%!PS-Adobe-2.0
%%Creator: dvips(k) 5.991 Copyright 2011 Radical Eye Software
%%Title: ex12p91.dvi
%%CreationDate: Mon Nov 11 22:09:30 2013
%%Pages: 1
%%PageOrder: Ascend
%%BoundingBox: 0 0 595 842
%%DocumentFonts: Utopia-Bold Utopia-Regular Fourier-Math-Letters
%%+ Fourier-Math-Symbols Utopia-Italic
%%DocumentPaperSizes: a4
%%EndComments
%DVIPSWebPage: (www.radicaleye.com)
%DVIPSCommandLine: dvips -o ex12p91.ps ex12p91.dvi
%DVIPSParameters: dpi=600
%DVIPSSource:  TeX output 2013.11.11:2209
%%BeginProcSet: tex.pro 0 0
%!
/TeXDict 300 dict def TeXDict begin/N{def}def/B{bind def}N/S{exch}N/X{S
N}B/A{dup}B/TR{translate}N/isls false N/vsize 11 72 mul N/hsize 8.5 72
mul N/landplus90{false}def/@rigin{isls{[0 landplus90{1 -1}{-1 1}ifelse 0
0 0]concat}if 72 Resolution div 72 VResolution div neg scale isls{
landplus90{VResolution 72 div vsize mul 0 exch}{Resolution -72 div hsize
mul 0}ifelse TR}if Resolution VResolution vsize -72 div 1 add mul TR[
matrix currentmatrix{A A round sub abs 0.00001 lt{round}if}forall round
exch round exch]setmatrix}N/@landscape{/isls true N}B/@manualfeed{
statusdict/manualfeed true put}B/@copies{/#copies X}B/FMat[1 0 0 -1 0 0]
N/FBB[0 0 0 0]N/nn 0 N/IEn 0 N/ctr 0 N/df-tail{/nn 8 dict N nn begin
/FontType 3 N/FontMatrix fntrx N/FontBBox FBB N string/base X array
/BitMaps X/BuildChar{CharBuilder}N/Encoding IEn N end A{/foo setfont}2
array copy cvx N load 0 nn put/ctr 0 N[}B/sf 0 N/df{/sf 1 N/fntrx FMat N
df-tail}B/dfs{div/sf X/fntrx[sf 0 0 sf neg 0 0]N df-tail}B/E{pop nn A
definefont setfont}B/Cw{Cd A length 5 sub get}B/Ch{Cd A length 4 sub get
}B/Cx{128 Cd A length 3 sub get sub}B/Cy{Cd A length 2 sub get 127 sub}
B/Cdx{Cd A length 1 sub get}B/Ci{Cd A type/stringtype ne{ctr get/ctr ctr
1 add N}if}B/CharBuilder{save 3 1 roll S A/base get 2 index get S
/BitMaps get S get/Cd X pop/ctr 0 N Cdx 0 Cx Cy Ch sub Cx Cw add Cy
setcachedevice Cw Ch true[1 0 0 -1 -.1 Cx sub Cy .1 sub]{Ci}imagemask
restore}B/D{/cc X A type/stringtype ne{]}if nn/base get cc ctr put nn
/BitMaps get S ctr S sf 1 ne{A A length 1 sub A 2 index S get sf div put
}if put/ctr ctr 1 add N}B/I{cc 1 add D}B/bop{userdict/bop-hook known{
bop-hook}if/SI save N @rigin 0 0 moveto/V matrix currentmatrix A 1 get A
mul exch 0 get A mul add .99 lt{/QV}{/RV}ifelse load def pop pop}N/eop{
SI restore userdict/eop-hook known{eop-hook}if showpage}N/@start{
userdict/start-hook known{start-hook}if pop/VResolution X/Resolution X
1000 div/DVImag X/IEn 256 array N 2 string 0 1 255{IEn S A 360 add 36 4
index cvrs cvn put}for pop 65781.76 div/vsize X 65781.76 div/hsize X}N
/p{show}N/RMat[1 0 0 -1 0 0]N/BDot 260 string N/Rx 0 N/Ry 0 N/V{}B/RV/v{
/Ry X/Rx X V}B statusdict begin/product where{pop false[(Display)(NeXT)
(LaserWriter 16/600)]{A length product length le{A length product exch 0
exch getinterval eq{pop true exit}if}{pop}ifelse}forall}{false}ifelse
end{{gsave TR -.1 .1 TR 1 1 scale Rx Ry false RMat{BDot}imagemask
grestore}}{{gsave TR -.1 .1 TR Rx Ry scale 1 1 false RMat{BDot}
imagemask grestore}}ifelse B/QV{gsave newpath transform round exch round
exch itransform moveto Rx 0 rlineto 0 Ry neg rlineto Rx neg 0 rlineto
fill grestore}B/a{moveto}B/delta 0 N/tail{A/delta X 0 rmoveto}B/M{S p
delta add tail}B/b{S p tail}B/c{-4 M}B/d{-3 M}B/e{-2 M}B/f{-1 M}B/g{0 M}
B/h{1 M}B/i{2 M}B/j{3 M}B/k{4 M}B/w{0 rmoveto}B/l{p -4 w}B/m{p -3 w}B/n{
p -2 w}B/o{p -1 w}B/q{p 1 w}B/r{p 2 w}B/s{p 3 w}B/t{p 4 w}B/x{0 S
rmoveto}B/y{3 2 roll p a}B/bos{/SS save N}B/eos{SS restore}B end

%%EndProcSet
%%BeginProcSet: pstricks.pro 0 0
% $Id: pstricks.pro 642 2012-02-09 15:00:52Z herbert $
%
%% PostScript prologue for pstricks.tex.
%% Version 1.10, 2012/02/09
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%
%
% Define the follwing gs-functions if not known, eg when using distiller
%
systemdict /.setopacityalpha known not {/.setopacityalpha { pop } def } if
systemdict /.setblendmode known not {/.setblendmode { pop } def } if
systemdict /.setshapealpha known not {/.setshapealpha { pop } def } if
%
/tx@Dict 200 dict def 				% the main PSTricks dictionary
tx@Dict begin
/ADict 25 dict def				% The arrow dictionaray
/CM { matrix currentmatrix } bind def
/SLW /setlinewidth load def
/CLW /currentlinewidth load def
/CP /currentpoint load def
/ED { exch def } bind def
/L /lineto load def
/T /translate load def
/TMatrix { } def
/RAngle { 0 } def
/Sqrt { dup 0 lt { pop 0 } { sqrt } ifelse } def  % return 0 for negative arguments 
/Atan { /atan load stopped { pop pop 0 } if } def % return 0 if atan not known
/ATAN1 {neg -1 atan 180 sub } def		% atan(x) (only one parameter)
/Div { dup 0 eq { pop } { div } ifelse } def  	% control the division
/tan { dup cos abs 1.e-10 lt 
  { pop 1.e10 } 				% return 1.e10 as infinit
  { dup sin exch cos div } ifelse 		% default sin/cos
} def
/Tan { dup sin exch cos Div } def 		% sin(x)/cos(x) x in degrees
/Acos {dup dup mul neg 1 add dup 0 lt {		% arc cos, returns 0 when negative root
  pop pop 0 }{ sqrt exch atan} ifelse } def
/NET { neg exch neg exch T } def	      	% change coordinate system to the negative one		
/Pyth { dup mul exch dup mul add sqrt } def   	% Pythagoras, expects 2 parameter
/Pyth2 {					% Pythagoras, xA yA xB yB
  3 -1 roll 		% xA xB yB yA
  sub			% xA xB yB-yA
  3 1 roll 		% yB-yA xA xB
  sub			% yB-yA xA-xB
  Pyth } def
/PtoC { 2 copy cos mul 3 1 roll sin mul } def 	% Polar to Cartesian
/Rand { rand 4294967295 div } def		% a real random number
%----------------- hv added 20050516 ---------------
/PiDiv2 1.57079632680 def
/Pi 3.14159265359 def 
/TwoPi 6.28318530718 def
/Euler 2.71828182846 def 
%/e Euler bind def
%
/RadtoDeg { 180 mul Pi div } bind def 		% convert from radian to degrees
/DegtoRad { Pi mul 180 div } bind def 		% viceversa
%----------------- hv end---------------------------
/PathLength@ { /z z y y1 sub x x1 sub Pyth add def /y1 y def /x1 x def } def
%
/PathLength { 
  flattenpath /z 0 def 
  { /y1 ED /x1 ED /y2 y1 def /x2 x1 def }
  { /y ED /x ED PathLength@ } 
  {} 
  { /y y2 def /x x2 def PathLength@ }
  /pathforall load stopped { pop pop pop pop } if 
  z 
} def
%
/STP { .996264 dup scale } def			% BP/PT scaling
/STV { SDict begin normalscale end STP  } def	% 
%
/DashLine {
    dup 0 gt
    { /a .5 def PathLength exch div }
    { pop /a 1 def PathLength } ifelse
    /b ED % pattern should fit evenly in b
    dup /X ED % pattern array
    0 get /y ED % length of first black segment
    /z 0 X {add} forall def % length of the full pattern
    %% Computation of the scaling factor as described by van Zandt:
    b a .5 sub 2 mul y mul sub z Div round
    z mul a .5 sub 2 mul y mul add b exch Div
    %%%% scaling factor on stack.
    /z ED %% now, z is the scaling factor
    false % for the length test below
    X { z mul } forall X astore %% modification TN 04-08-07
    %%% Checking whether at least one dash in X has positive length:
    {0 gt or} forall
    { X 1 a sub y mul }
    { [ 1 0 ] 0 }
    ifelse
    setdash stroke
} def
%
/DotLine { 
  /b PathLength def 
  /a ED /z ED /y CLW def 
  /z y z add def 
  a 0 gt { 
    /b b a div def 
  }{ 
    a 0 eq { 
      /b b y sub def 
    }{ a -3 eq { 
      /b b y add def } if 
    } ifelse 
  } ifelse 
  [ 0 b b z Div round Div dup 0 le { pop 1 } if ] 
  a 0 gt { 0 }{ y 2 div a -2 gt { neg }if } ifelse 
  setdash 1 setlinecap stroke 
} def
%
/SymbolLine {   % on stack [ x y x y ...
  counttomark 					% number of elements
  2 div cvi /n ED     				% n pairs
  /YA ED /XA ED					% the start point
  n 1 sub { 
    /YB ED /XB ED
    /XLength XB XA sub def
    /YLength YB YA sub def
    /PAngle YLength XLength Atan def
    /XYLength XLength YLength Pyth def
    /nSym XYLength SymStep div cvi def
    /Shift Symbol stringwidth pop 2 div def 
    /deltaX XLength nSym div def
    /deltaY YLength nSym div def
    XA Shift sub YA Shift sub moveto 
    nSym { 
      gsave rotateSymbol { PAngle 180 sub CorrAngle sub rotate } if
      Symbol show 
      grestore 
      deltaX deltaY rmoveto
    } repeat
    /YA YB def /XA XB def
  } repeat 
  XA Shift sub YA Shift sub moveto 
  gsave rotateSymbol { PAngle 180 sub CorrAngle sub rotate } if
  Symbol show grestore
  pop 				% delete the mark symbol
} def
%
/LineFill { % hv ------------ patch 7 -------------
  gsave 
  abs /hatchWidthInc ED
  abs /hatchSepInc ED
  abs CLW add /a ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform pathbbox 
  /y2 ED 
  a Div ceiling cvi /x2 ED /y1 ED 
  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clip 
  newpath 
  2 setlinecap 
  systemdict
  /setstrokeadjust known { true setstrokeadjust } if 
  x2 x1 sub 1 add { 
    x1 a mul y1 moveto 0 y2 rlineto stroke 
    /x1 x1 1 add 
      hatchWidthInc 0 gt { CLW add } if 
    def 
    hatchSepInc 0 gt hatchWidthInc 0 gt or { 
      /a a hatchSepInc add def
      CLW hatchWidthInc add SLW 
    } if
  } repeat 
  grestore 
  pop pop } def
%
/DotFill {%	 on stack: dot radius
  /dotRadius ED
  abs CLW add /a ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform 
  pathbbox % llx lly urx ury of smallest bounding box
  /y2 ED /x2 ED /y1 ED /x1 ED 
  y2 y1 sub a div 2 add cvi /Ny ED
  x2 x1 sub a div 2 add cvi /Nx ED
  clip 
  newpath 
  /yA y1 dotRadius add CLW add def
  /xA0 x1 dotRadius add CLW add def
  Ny {
     /xA xA0 def
     Nx { 
       newpath 
       xA yA dotRadius 0 360 arc 
       SolidDot { gsave fill grestore } if 
       stroke
       xA a add /xA ED
     } repeat
     yA a add /yA ED
  } repeat
  grestore
} def
%
/PenroseFill {%	 on stack: scaling factor
  dup dup scale
  1 exch div round /penroseFactor ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform pathbbox 
  /y2 ED 
  a Div ceiling cvi /x2 ED /y1 ED 
  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clip 
  newpath 
  systemdict
  /setstrokeadjust known { true setstrokeadjust } if 
  /I/S/L/W/G/+/Z/F/E/D[/def/exch/for{E D}/add{s E get mul}
 { Z -36.2001 1 33 }{25 E S rlineto}{/q Z dup q G E q 1 + G}{Z 2 2}]{cvx def}forall
  [0 72 1008 {dup sin E cos }F ]1 setlinejoin/s W{/a W{/b I 10{/i I 4{/m I moveto
  i m +/j I 10{/l Z b m l + G a l G sub s m get div .2 + floor .3 + 25
  mul j l + S rmoveto}F i L j L stroke }F}F}F}F 
  grestore 
  pop pop 
} def
%
/TruchetFill { %	 on stack: scaling factor
  10 dict begin
  dup dup scale
  1 exch div round /penroseFactor ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform pathbbox 
  /y2 ED 
  a Div ceiling cvi /x2 ED /y1 ED 
  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clip 
  newpath 
  systemdict
  /setstrokeadjust known { true setstrokeadjust } if 
  /ma a neg def
  /ha a 2 div def 
  /mha ha neg def
  /tile { 
    rand dup 2 idiv 2 mul eq { 90 rotate } if
    mha mha moveto ha mha lineto
    ha ha lineto mha ha lineto
%    closepath .1 setlinewidth stroke
    contents
  } def
  /contents{ 
    0 ha moveto ha 0 lineto
    0 mha moveto mha 0 lineto
%    1 setlinewidth stroke
  } def
  /dotiling {
    f ma mul a f a mul { 
      /i exch def
      f ma mul a f a mul { 
        /j exch def
        gsave i j translate
        tile stroke grestore
      } for
    } for
  } def
%
  /f 3 def 
  5 srand dotiling 
  end % local user dict
} def
%
/BeginArrow { 
  ADict begin 			% hold it local, for end see EndArrow
  /@mtrx CM def 
  gsave 
  2 copy T 
  2 index sub neg exch 
  3 index sub exch Atan 
  rotate newpath 
} def
%
/EndArrow { @mtrx setmatrix CP grestore end } def % end the ADict
%
/Arrow { 
  CLW mul add dup 
  2 div /w ED 
  mul dup /h ED 
  mul /a ED 
  { 0 h T 1 -1 scale } if 
  w neg h moveto 
  0 0 L w h L w neg a neg rlineto 
  gsave fill grestore 
} def
%
/ArrowD { % the sides are drawn as curves (hv 20071211)
  CLW mul add dup 
  2 div /w ED 
  mul dup /h ED 
  mul /Inset ED 
  { 0 h T 1 -1 scale } if % changes the direction
% we use y=w/h^2 * x^2 as equation for the control points
% for the coordinates the arrow is seen from top to bottom
% the bottom (tip) is (0;0)
  w neg h moveto % lower left of >
  w 9 div 4 mul neg h 3 div 2 mul
  w 9 div neg       h 3 div  
  0 0 curveto    % tip of >
  w 9 div        h 3 div  
  w 9 div 4 mul  h 3 div 2 mul
  w h curveto % upper left of >
  w neg Inset neg rlineto % move to x=0 and inset
  gsave fill grestore 
} def 
%
/Tbar { 
  CLW mul add /z ED 
  z -2 div CLW 2 div moveto 
  z 0 rlineto stroke 
  0 CLW moveto 
} def
%
/Bracket { 
  CLW mul add dup CLW sub 2 div 
  /x ED mul CLW add /y ED /z CLW 2 div def 
  x neg y moveto 
  x neg CLW 2 div L x CLW 2 div L x y L stroke 
  0 CLW moveto 
} def
%
/RoundBracket { 
  CLW mul add dup 2 div 
  /x ED mul /y ED /mtrx CM def 
  0 CLW 2 div T x y mul 0 ne { x y scale } if 
  1 1 moveto 
  .85 .5 .35 0 0 0 curveto 
  -.35 0 -.85 .5 -1 1 curveto 
  mtrx setmatrix stroke 0 CLW moveto 
} def
%
/SD { 0 360 arc fill } def
%
/EndDot { % DS is the dot size 
  { /z DS def } { /z 0 def } ifelse  	% outer or inner dimen 
  /b ED 				% the color definition
  0 z DS SD 
  b { 0 z DS CLW sub SD } if 
  0 DS z add CLW 4 div sub 
  moveto 
} def
%
/Shadow { [ { /moveto load } { /lineto load } { /curveto load } {
  /closepath load } /pathforall load stopped { pop pop pop pop CP /moveto
  load } if ] cvx newpath 3 1 roll T exec } def
%
/NArray { % holds the coordinates and on top of stack the showpoints boolean
  /showpoints ED 
  counttomark 2 div dup cvi /n ED  	% n 2 div on stack 
  n eq not { exch pop } if		% even numbers of points? delete one
  ] aload /Points ED 
  showpoints not { Points aload pop } if
%    { ] aload /Points ED } 
%    { n 2 mul 1 add -1 roll pop } ifelse	% delete the mark symbol 
} def
%
/Line { 
  NArray n 0 eq not 
    { n 1 eq { 0 0 /n 2 def } if ArrowA /n n 2 sub def 
      n { Lineto } repeat 
      CP 4 2 roll ArrowB L pop pop 
    } if 
} def
%
/LineToYAxis {
  /Ox ED		% Save the x origin value 
  NArray            % all x-y pairs on stack
  n { 2 copy moveto % go to current point
    Ox exch Lineto   % line to y-axis
    pop             % delete old x-value
  } repeat
} def
%
/LineToXAxis{
  /Oy ED		% Save the y origin value 
  NArray		% all x-y pairs on stack
  n 0 eq not
    { n 1 eq { 0 0 /n 2 def } if
      ArrowA
      /n n 2 sub def
      CP 2 copy moveto pop Oy Lineto
      n { 2 copy moveto pop Oy Lineto } repeat
      CP
      4 2 roll
      ArrowB
      2 copy moveto pop Oy
      L
      pop pop } if
} def
%
/Arcto { 
  /a [ 6 -2 roll ] cvx def 
  a r 
  /arcto load stopped { 5 } { 4 } ifelse { pop } repeat 
  a 
} def
%
/CheckClosed { 
  dup n 2 mul 1 sub index eq 2 index n 2 mul 1 add index eq
  and { pop pop /n n 1 sub def } if 
} def
%
/Polygon { 
  NArray n 2 eq { 0 0 /n 3 def } if 
  n 3 lt 
    { n { pop pop } repeat } 
    { n 3 gt { CheckClosed } if 
      n 2 mul -2 roll 
      /y0 ED /x0 ED /y1 ED /x1 ED  
      x1 y1 
      /x1 x0 x1 add 2 div def 
      /y1 y0 y1 add 2 div def 
      x1 y1 moveto 
      /n n 2 sub def 
      n { Lineto } repeat 
      x1 y1 x0 y0 6 4 roll Lineto
      Lineto pop pop closepath } ifelse 
} def
%
/SymbolPolygon {   % on stack [ x y x y ...
  counttomark 					% number of elements
  2 add /m ED
  2 copy m 2 roll				% copy last two
  m 2 div cvi /n ED    				% n pairs
  /YA ED /XA ED					% the start point
  n 1 sub { 
    /YB ED /XB ED
    /XLength XB XA sub def
    /YLength YB YA sub def
    /PAngle YLength XLength Atan def
    /XYLength XLength YLength Pyth def
    /nSym XYLength SymStep Div cvi def
    /Shift Symbol stringwidth pop 2 Div def 
    /deltaX XLength nSym Div def
    /deltaY YLength nSym Div def
    XA Shift sub YA Shift sub moveto 
    nSym { 
      gsave rotateSymbol { PAngle 180 sub CorrAngle sub rotate } if
      Symbol show 
      grestore 
      deltaX deltaY rmoveto
    } repeat
%    XB Shift sub YB Shift sub moveto Symbol show
    /YA YB def /XA XB def
  } repeat 
  pop	% delete the mark symbol
} def
%
/Diamond { 
  /mtrx CM def 
  T rotate 
  /h ED 
  /w ED 
  dup 0 eq { pop } { CLW mul neg 
    /d ED 
    /a w h Atan def 
    /h d a sin Div h add def 
    /w d a cos Div w add def } ifelse 
  mark w 2 div h 2 div w 0 0 h neg w neg 0 0 h w 2 div h 2 div 
  /ArrowA { moveto } def 
  /ArrowB { } def 
  false Line 
  closepath mtrx setmatrix } def
%
/Triangle { 
  /mtrx CM def 
  translate 
  rotate /h ED 2 div /w ED 
  dup CLW mul /d ED 
  /h h d w h Atan sin Div sub def 
  /w w d h w Atan 2 div dup cos exch sin Div mul sub def 
  mark 
  0 d w neg d 0 h w d 0 d 
  /ArrowA { moveto } def 
  /ArrowB { } def 
  false 
  Line 
  closepath 
  mtrx
% DG/SR modification begin - Jun.  1, 1998 - Patch 3 (from Michael Vulis)
% setmatrix } def
  setmatrix pop 
} def
% DG/SR modification end
%
/CCA { 
  /y ED /x ED 
  2 copy y sub /dy1 ED 
  x sub /dx1 ED 
  /l1 dx1 dy1 Pyth def 
} def
%
/CC { 
  /l0 l1 def 
  /x1 x dx sub def 
  /y1 y dy sub def 
  /dx0 dx1 def 
  /dy0 dy1 def 
  CCA 
  /dx dx0 l1 c exp mul dx1 l0 c exp mul add def 
  /dy dy0 l1 c exp mul dy1 l0 c exp mul add def 
  /m dx0 dy0 Atan dx1 dy1 Atan sub 2 div cos abs b exp a mul dx dy Pyth Div 2 div def 
  /x2 x l0 dx mul m mul sub def
  /y2 y l0 dy mul m mul sub def 
  /dx l1 dx mul m mul neg def 
  /dy l1 dy mul m mul neg def 
} def
%
/IC { 
  /c c 1 add def 
  c 0 lt { /c 0 def } { c 3 gt { /c 3 def } if } ifelse 
  /a a 2 mul 3 div 45 cos b exp div def 
  CCA 
  /dx 0 def 
  /dy 0 def 
} def
%
/BOC { IC CC x2 y2 x1 y1 ArrowA CP 4 2 roll x y curveto } def
/NC { CC x1 y1 x2 y2 x y curveto } def
/EOC { x dx sub y dy sub 4 2 roll ArrowB 2 copy curveto } def
/BAC { IC CC x y moveto CC x1 y1 CP ArrowA } def
/NAC { x2 y2 x y curveto CC x1 y1 } def
/EAC { x2 y2 x y ArrowB curveto pop pop } def
%
/OpenCurve { 
  NArray n 3 lt 
    { n { pop pop } repeat } 
    { BOC /n n 3 sub def n { NC } repeat EOC } ifelse 
} def
%
/CurvePath { 
  %% for negative SymStep we calculate the distance 
  SymStep 0 lt { gsave PathLength SymStep div abs /SymStep ED grestore } if
  0.5 setflat
  flattenpath /z 0 def /z0 0 def
  { /y1 ED /x1 ED /y2 y1 def /x2 x1 def 
    x1 Shift sub y1 Shift sub moveto 
    gsave 
    curveticks 
      { x1 y1 translate startAngle rotate 
        0 5 moveto 0 -5 lineto stroke      
      }
      { startAngle rotate Symbol show }
    ifelse 
    grestore /z0 z def }
  { /y ED /x ED PathLength@ z z0 sub SymStep ge {
      x Shift sub y Shift sub moveto 
      gsave 
      curveticks 
        { y yOld sub x xOld sub Atan 180 sub CorrAngle sub /rotAngle ED  
          x y translate rotAngle rotate 
          0 5 moveto 0 -5 lineto stroke
        }
        { 
          rotateSymbol { y yOld sub x xOld sub Atan 180 sub CorrAngle sub rotate } if        
          Symbol show 
        }
      ifelse 
      grestore /z0 z def } if 
    /yOld y def /xOld x def } 
  {} %% the lineto part
  { /y y2 def /x x2 def PathLength@ 
    x Shift sub y Shift sub moveto 
    gsave
    curveticks 
      { y yOld sub x xOld sub Atan 180 sub /rotAngle ED  
        x y translate rotAngle rotate 
        0 5 moveto 0 -5 lineto stroke
      }
      { 
        x Shift sub y Shift sub moveto 
        rotateSymbol { y yOld sub x xOld sub Atan 180 sub CorrAngle sub rotate } if        
        Symbol show 
      }
    ifelse 
    grestore
  }
  pathforall 
  curveticks 
   { gsave 
     x y translate rotAngle rotate 
     0 5 moveto 0 -5 lineto stroke grestore
   } if
  z 
} def
%
/OpenSymbolCurve { 
  OpenCurve
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/AltCurve { 
  { false NArray n 2 mul 2 roll 
    [ n 2 mul 3 sub 1 roll ] aload
    /Points ED 
    n 2 mul -2 roll } 
  { false NArray } ifelse 
  n 4 lt { n { pop pop } repeat } { BAC /n n 4 sub def n { NAC } repeat EAC } ifelse 
} def
%
/AltOpenSymbolCurve { 
  AltCurve
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/ClosedCurve { 
  NArray n 3 lt 
    { n { pop pop } repeat } 
    { n 3 gt { CheckClosed } if 
      6 copy n 2 mul 6 add 6 roll 
      IC CC x y moveto n { NC } repeat 
      closepath pop pop 
    } ifelse 
} def
%
/ClosedSymbolCurve { 
  ClosedCurve
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/SQ { /r ED r r moveto r r neg L r neg r neg L r neg r L fill } def
/ST { /y ED /x ED x y moveto x neg y L 0 x L fill } def
/SP { /r ED gsave 0 r moveto 4 { 72 rotate 0 r L } repeat fill grestore } def
%
/FontDot { 
  DS 2 mul dup 
  matrix scale matrix concatmatrix exch matrix
  rotate matrix concatmatrix exch 
  findfont exch makefont setfont 
} def
%
/Rect { 
  x1 y1 y2 add 2 div moveto 
  x1 y2 lineto 
  x2 y2 lineto 
  x2 y1 lineto
  x1 y1 lineto 
  closepath 
} def
%
/OvalFrame { 
  x1 x2 eq y1 y2 eq or 
    { pop pop x1 y1 moveto x2 y2 L } 
    { y1 y2 sub abs x1 x2 sub abs 2 copy gt 
      { exch pop } { pop } ifelse 
      2 div exch { dup 3 1 roll mul exch } if 
      2 copy lt { pop } { exch pop } ifelse
      /b ED 
      x1 y1 y2 add 2 div moveto 
      x1 y2 x2 y2 b arcto 
      x2 y2 x2 y1 b arcto
      x2 y1 x1 y1 b arcto 
      x1 y1 x1 y2 b arcto 
      16 { pop } repeat 
      closepath 
    } ifelse 
} def
%
/Frame { 
  CLW mul /a ED 
  3 -1 roll 
  2 copy gt { exch } if 
  a sub /y2 ED 
  a add /y1 ED 
  2 copy gt { exch } if 
  a sub /x2 ED 
  a add /x1 ED 
  1 index 0 eq { pop pop Rect } { OvalFrame } ifelse 
} def
%
/BezierNArray { 
  /f ED 
  counttomark 2 div dup cvi /n ED 
  n eq not { exch pop } if 
  n 1 sub neg 3 mod 3 add 3 mod { 0 0 /n n 1 add def } repeat 
  f { ] aload /Points ED } { n 2 mul 1 add -1 roll pop } ifelse 
} def
%
/OpenBezier { 
  BezierNArray 
  n 1 eq 
    { pop pop } 
    { ArrowA n 4 sub 3 idiv 
      { 6 2 roll 4 2 roll curveto } repeat 
      6 2 roll 4 2 roll ArrowB curveto } ifelse 
} def
%
/OpenSymbolBezier { 
  OpenBezier
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/ClosedBezier { 
  BezierNArray 
  n 1 eq 
    { pop pop } 
    { moveto n 1 sub 3 idiv 
      { 6 2 roll 4 2 roll curveto } repeat 
      closepath } ifelse 
} def
%
/ClosedSymbolBezier { 
  /f ED				 % save showpoints value 
  2 copy /yEnd ED /xEnd ED
  counttomark -2 roll 2 copy /yStart ED /xStart ED
  counttomark 2 roll
  f
  ClosedBezier
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
  [ xEnd yEnd xStart yStart SymbolLine 
} def
%
/BezierShowPoints { 
  gsave 
  Points aload length 2 div cvi /n ED 
  moveto 
  n 1 sub { lineto } repeat 
  CLW 2 div SLW [ 4 4 ] 0 setdash stroke 
  grestore 
} def
%
/Parab { 
  /y0 ED /x0 ED /y1 ED /x1 ED 
  /dx x0 x1 sub 3 div def 
  /dy y0 y1 sub 3 div def 
  x0 dx sub y0 dy add x1 y1 ArrowA
  x0 dx add y0 dy add x0 2 mul x1 sub y1 ArrowB 
  curveto 
  /Points [ x1 y1 x0 y0 x0 2 mul x1 sub y1 ] def 
} def
%
/Parab1 { % 1 end  |  0 SP
  /ySP ED /xSP ED /y1 ED /x1 ED 
  /dx xSP x1 sub 3 div def 
  /dy ySP y1 sub 3 div def 
  newpath x1 y1 moveto xSP y1 lineto xSP ySP lineto 
                       x1 ySP lineto closepath clip 
  currentpoint
  newpath moveto
  xSP dx sub ySP dy add x1 y1 ArrowA
  xSP dx add ySP dy add xSP 2 mul x1 sub y1 ArrowB 
  curveto 
  /Points [ x1 y1 xSP ySP xSP 2 mul x1 sub y1 ] def 
} def
%
/Grid { 
  newpath 
  /a 4 string def 
  /b ED % 				psk@gridlabels in pt
  /c ED % 				{ \pst@usecolor\psgridlabelcolor }
  /n ED % 				psk@griddots
  cvi dup 1 lt { pop 1 } if 
  /s ED % 				\psk@subgriddiv
  s div dup 0 eq { pop 1 } if 
  /dy ED s div dup 0 eq { pop 1 } if %	\pst@number\psyunit abs
  /dx ED dy div round dy mul %		\pst@number\psxunit abs
  /y0 ED dx div round dx mul 
  /x0 ED dy div round cvi 
  /y2 ED dx div round cvi 
  /x2 ED dy div round cvi 
  /y1 ED dx div round cvi 
  /x1 ED 
  /h y2 y1 sub 0 gt { 1 } { -1 } ifelse def 
  /w x2 x1 sub 0 gt { 1 } { -1 } ifelse def 
  b 0 gt { 
    /z1 b 4 div CLW 2 div add def
%    /Helvetica findfont b scalefont setfont 
    /b b .95 mul CLW 2 div add def } if 
  systemdict /setstrokeadjust known 
    { true setstrokeadjust /t { } def }
    { /t { transform 0.25 sub round 0.25 add exch 0.25 sub round 0.25 add
       exch itransform } bind def } ifelse 
  gsave n 0 gt { 1 setlinecap [ 0 dy n div ] dy n div 2 div setdash } { 2 setlinecap } ifelse 
  /i x1 def 
  /f y1 dy mul n 0 gt { dy n div 2 div h mul sub } if def 
  /g y2 dy mul n 0 gt { dy n div 2 div h mul add } if def 
  x2 x1 sub w mul 1 add dup 1000 gt { pop 1000 } if 
  { i dx mul dup y0 moveto 
    b 0 gt 
      { gsave c i a cvs dup stringwidth pop 
        /z2 ED w 0 gt {z1} {z1 z2 add neg} ifelse 
	h 0 gt {b neg}{z1} ifelse 
        rmoveto show grestore } if 
    dup t f moveto 
    g t L stroke 
    /i i w add def 
  } repeat 
  grestore 
  gsave 
  n 0 gt
  % DG/SR modification begin - Nov. 7, 1997 - Patch 1
  %{ 1 setlinecap [ 0 dx n div ] dy n div 2 div setdash }
    { 1 setlinecap [ 0 dx n div ] dx n div 2 div setdash }
  % DG/SR modification end
    { 2 setlinecap } ifelse 
  /i y1 def 
  /f x1 dx mul n 0 gt { dx n div 2 div w mul sub } if def 
  /g x2 dx mul n 0 gt { dx n div 2 div w mul add } if def 
  y2 y1 sub h mul 1 add dup 1000 gt { pop 1000 } if 
  { newpath i dy mul dup x0 exch moveto 
    b 0 gt { gsave c i a cvs dup stringwidth pop 
      /z2 ED 
      w 0 gt {z1 z2 add neg} {z1} ifelse 
      h 0 gt {z1} {b neg} ifelse 
      rmoveto show grestore } if 
    dup f exch t moveto 
    g exch t L stroke 
    /i i h add def 
  } repeat 
  grestore 
} def
%
/ArcArrow { 
  /d ED /b ED /a ED 
  gsave 
  newpath 0 -1000 moveto clip 
  newpath 
  0 1 0 0 b 
  grestore 
  c mul 
  /e ED 
  pop pop pop r a e d PtoC y add exch x add
  exch r a PtoC y add exch x add exch b pop pop pop pop a e d CLW 8 div c
  mul neg d 
} def
%
/Ellipse { 
  /rotAngle ED
  /mtrx CM def 
  T 
  rotAngle rotate
  scale 0 0 1 5 3 roll arc 
  mtrx setmatrix 
} def
%
/ArcAdjust { %%%% Vincent Guirardel
% given a target length (targetLength) and an initial angle (angle0) [in the stack],
% let  M(angle0)=(rx*cos(angle0),ry*sin(angle0))=(x0,y0).
% This computes an angle t such that (x0,y0) is at distance 
% targetLength from the point M(t)=(rx*cos(t),ry*sin(t)).
% NOTE: this an absolute angle, it does not have to be added or substracted to angle0
% contrary to TvZ's code.
% To achieve, this, one iterates the following process: start with some angle t,
% compute the point M' at distance targetLength of (x0,y0) on the semi-line [(x0,y0) M(t)].
% Now take t' (= new angle) so that (0,0) M(t') and M' are aligned.
%
% Another difference with TvZ's code is that we need d (=add/sub) to be defined.
% the value of d = add/sub is used to know on which side we have to move.
% It is only used in the initialisation of the angle before the iteration.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Input stack:  1: target length 2: initial angle
% variables used : rx, ry, d (=add/sub)
%
  /targetLength ED /angle0 ED
  /x0 rx angle0 cos mul def
  /y0 ry angle0 sin mul def
% we are looking for an angle t such that (x0,y0) is at distance targetLength 
% from the point M(t)=(rx*cos(t),ry*sin(t)))
%initialisation of angle (using 1st order approx = TvZ's code)
  targetLength 57.2958 mul
  angle0 sin rx mul dup mul
  angle0 cos ry mul dup mul
  add sqrt div 
% if initialisation angle is two large (more than 90 degrees) set it to 90 degrees
% (if the ellipse is very curved at the point where we draw the arrow, %
% the value can be much more than 360 degrees !)
% this should avoid going on the wrong side (more than 180 degrees) or go near
% a bad attractive point (at 180 degrees)
  dup 90 ge { pop 90 } if 
  angle0 exch d % add or sub
% maximum number of times to iterate the iterative procedure:
% iterative procedure: takes an angle t on top of stack, computes a 
% better angle (and put it on top of stack)
  30 { dup
% compute distance D between (x0,y0) and M(t)
    dup cos rx mul x0 sub dup mul exch sin ry mul y0 sub dup mul add sqrt
% if D almost equals targetLength, we stop
    dup targetLength sub abs 1e-5 le { pop exit } if
% stack now contains D t
% compute the point M(t') at distance targetLength of (x0,y0) on the semi-line [(x0,y0) M(t)]:
% M(t')= ( (x(t)-x0)*targetLength/d+x0 , (y(t)-y0)*targetLength/d+y0 )
    exch dup cos rx mul x0 sub  exch sin ry mul y0 sub
% stack contains:  y(t)-y0, x(t)-x0, d
    2 index Div targetLength mul y0 add ry Div exch
    2 index Div targetLength mul x0 add rx Div
% stack contains x(t')/rx , y(t')/ry , d
% now compute t', and remove D from stack
    atan exch pop
  } repeat
% we don't look at what happened... in particular, if targetLength is greater 
% than the diameter of the ellipse...
% the final angle will be around /angle0 + 180. maybe we should treat this pathological case...
% after iteration, stack contains an angle t such that M(t) is the tail of the arrow
% to give back the result as a an angle relative to angle0 we could add the following line:
% angle0 sub 0 exch d
%
% begin bug fix 2006-01-11
% we want to adjust the new angle t' by a multiple of 360 so that  | t'-angle0 | <= 180
%(we don't want to make the ellipse turn more or less than it should)...
dup angle0 sub dup abs 180 gt { 180 add 360 div floor 360 mul sub } { pop } ifelse
% end bug fix
} def
%
/EllipticArcArrow {
  /d ED      % is add or sub
  /b ED      % arrow procedure
  /a1 ED     % angle
  gsave
  newpath
  0 -1000 moveto
  clip                  % Set clippath far from arrow.
  newpath
  0 1 0 0 b             % Draw arrow to determine length.
  grestore
% Length of arrow is on top of stack. Next 3 numbers are junk.
%
  a1 exch ArcAdjust   % Angular position of base of arrow.
  /a2 ED
  pop pop pop
  a2 cos rx mul xOrig add % hv 2007-08-29   x->xOrig
  a2 sin ry mul yOrig add % hv 2007-08-29   y->yOrig
  a1 cos rx mul xOrig add % 
  a1 sin ry mul yOrig add % 
% Now arrow tip coor and base coor are on stack.
  b pop pop pop pop       % Draw arrow, and discard coordinates.
  a2 CLW 8 div
% change value of d (test it by looking if  `` 1 1 d '' gives 2 or not )
  1 1 d 2 eq { /d { sub } def } { /d { add } def } ifelse
  ArcAdjust
% resets original value of d
  1 1 d 2 eq { /d { sub } def } { /d { add } def } ifelse  % Adjust angle to give overlap.
} def
%%------------------ tvz/DG/hv (2004-05-10) end -------------------%%
%
/Rot { CP CP translate 3 -1 roll neg rotate NET  } def
%
/RotBegin { 
  tx@Dict /TMatrix known not { /TMatrix { } def /RAngle { 0 } def } if 
  /TMatrix [ TMatrix CM ] cvx def 
  /a ED 
  a Rot /RAngle [ RAngle dup a add ] cvx def 
} def
%
/RotEnd { 
  /TMatrix [ TMatrix setmatrix ] cvx def 
  /RAngle [ RAngle pop ] cvx def 
} def
%
/PutCoor { gsave CP T CM STV exch exec moveto setmatrix CP grestore } def
/PutBegin { /TMatrix [ TMatrix CM ] cvx def CP 4 2 roll T moveto } def
/PutEnd { CP /TMatrix [ TMatrix setmatrix ] cvx def moveto } def
%
/Uput { 
  /a ED 
  add 2 div /h ED 2 
  div /w ED 
  /s a sin def 
  /c a cos def 
  /b s abs c abs 2 copy gt dup 
    /q ED 
    { pop } { exch pop } ifelse def 
  /w1 c b div w mul def 
  /h1 s b div h mul def 
  q { w1 abs w sub dup c mul abs }{ h1 abs h sub dup s mul abs } ifelse 
} def
%
/UUput { 
  /z ED 
  abs /y ED 
  /x ED 
  q { x s div c mul abs y gt }{ x c div s mul abs y gt } ifelse 
    { x x mul y y mul sub z z mul add sqrt z add } 
    { q { x s div } { x c div } ifelse abs 
    } ifelse 
  a PtoC 
  h1 add exch 
  w1 add exch 
} def
%
/BeginOL { 
  dup (all) eq exch TheOL eq or 
    { IfVisible not { Visible /IfVisible true def } if } 
    { IfVisible { Invisible /IfVisible false def } if } ifelse 
} def
%
/InitOL { 
  /OLUnit [ 3000 3000 matrix defaultmatrix dtransform ] cvx def
  /Visible { CP OLUnit idtransform T moveto } def 
  /Invisible { CP OLUnit neg exch neg exch idtransform T moveto } def 
  /BOL { BeginOL } def
  /IfVisible true def 
} def
%
%%%%%%%%%%%%%%%%% tools %%%%%%%%%%%%%%%%%%%%%%%%%
%%%%% ### bubblesort ###
%% syntax : array bubblesort --> array2 trie par ordre croissant
%% code de Bill Casselman
%% http://www.math.ubc.ca/people/faculty/cass/graphics/text/www/
/bubblesort {
4 dict begin
   /a exch def
   /n a length 1 sub def
   n 0 gt {
      % at this point only the n+1 items in the bottom of a remain to
      % the sorted largest item in that blocks is to be moved up into
      % position n
      n {
         0 1 n 1 sub {
            /i exch def
            a i get a i 1 add get gt {
               % if a[i] > a[i+1] swap a[i] and a[i+1]
               a i 1 add
               a i get
               a i a i 1 add get
               % set new a[i] = old a[i+1]
               put
               % set new a[i+1] = old a[i]
               put
            } if
         } for
         /n n 1 sub def
      } repeat
   } if
   a
end
} def
%
%
/concatstringarray{  %  [(a) (b) ... (z)] --> (ab...z)  20100422
  0 1 index { length add } forall 
  string     
  0 3 2 roll      
  { 3 copy putinterval length add }forall 
  pop  
} bind def
%
/dot2comma {% on stack a string (...) 
  2 dict begin
  /Output exch def
  0 1 Output length 1 sub { 
    /Index exch def 
    Output Index get 46 eq { Output Index 44 put } if 
  } for
  Output
  end
} def
%
end
%-----------------------------------------------------------------------------%
%
% END pstricks.pro

%%EndProcSet
%%BeginProcSet: pst-algparser.pro 0 0
% $Id: pst-algparser.pro 594 2011-10-31 18:13:18Z herbert $
%%
%% PostScript prologue for PSTricks algorithm parser
%% Version 0.04, 2011/10/21
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%%
%%-----------------------------------------------------------------------------%
%
/AlgParser { tx@AlgToPs begin AlgToPs end } def  % Dominique Rodriguez
%
/tx@CoreAnalyzerDict 100 dict def tx@CoreAnalyzerDict begin
%
% PS ANALYZER FOR ALGEBRAIC EXPRESSION V1.13
%
% 09/2011 DR factorial with ! added
%
% E->T|E+T
% T->FS|T*FS
% FS -> F | +FS | -FS
% F->P|F^SF|P!
% P->(E)|literal
% literal->number|var|var[E]|func(params)
% params->E|E,param
% number->TOBEFINISHED
%
%% E expression, T term, SF signed factor, F factor, P power
%
%% parser
%
%% str
%
%% C->E<condition_operators>E
%% STR index -> STR index+lenExpr
/AnalyzeCond { AnalyzeExpr ReadCondOp AnalyzeExpr EvalCondOp  } def
%
%% analyze Expression List (separator , or | )
%% STR index -> STR index+lenExpr
%% /AnalyzeListOfE {
%%   { NextNonBlankChar pop AnalyzeExpr%%dup Strlen eq { exit } if NextNonBlankChar
%%     NextNonBlankChar dup 0 eq { pop exit } if
%%     dup 44 ne 1 index 124 ne and { dup 41 ne { PROBLEMCONTACTBILLOU } { pop exit } ifelse } if
%%     pop NextNonBlankChar dup 0 eq { exit } if 124 ne { PROBLEMCONTACTBILLOU } if 1 add NextNonBlankChar 0 eq {toto} if } loop
%%   AnalyzeListOfEPostHook
%% } def
/AnalyzeListOfE {
  /NotFirst false def
  { NextNonBlankChar pop AnalyzeExpr
    NotFirst { EvalListOfExpr } { /NotFirst true def } ifelse
    dup Strlen eq { exit } if NextNonBlankChar
    dup 44 ne 1 index 124 ne and
    { dup 41 ne { PROBLEMCONTACTBILLOU } { pop exit } ifelse }
    if  pop 1 add } loop
  AnalyzeListOfEPostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% E->T|E+T
%% STR index -> STR index+lenExpr
/AnalyzeExpr {
  AnalyzePreHook AnalyzeTerm IsEndingExpr
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { RollOp 1 add NextNonBlankChar pop AnalyzeTerm PreEvalHook EvalAddSub IsEndingExpr { pop exit } if } loop }
  ifelse
  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% T->FS|T*FS
%% STR index
/AnalyzeTerm {
  AnalyzePreHook AnalyzeSignedFactor IsEndingTerm
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { RollOp 1 add NextNonBlankChar pop AnalyzeSignedFactor PreEvalHook EvalMulDiv IsEndingTerm { pop exit } if} loop }
  ifelse
  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% FS -> F | +FS | -FS
%% STR index
/AnalyzeSignedFactor {
  AnalyzePreHook 2 copy get dup IsUnaryOp
  { RollOp 1 add NextNonBlankChar pop AnalyzeSignedFactor EvalUnaryOp }
  { pop AnalyzeFactor }
  ifelse AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% F->P|F^P|P!
%% STR index
/AnalyzeFactor {
  AnalyzePreHook AnalyzePower IsEndingFactor
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { dup 33 eq%% is there a ! DR 09/2011
      { pop 1 add NextNonBlankChar pop EvalFactorial }
      { RollOp 1 add NextNonBlankChar pop AnalyzePower PreEvalHook EvalPower }
      ifelse
      IsEndingFactor { pop exit } if } loop }
  ifelse  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% P->(E)|literal
%% STR index
/AnalyzePower {
  %% depending of first char either a number, or a literal
  2 copy get dup 40 eq%%an open par
  { pop 1 add NextNonBlankChar pop AnalyzeExpr 1 add NextNonBlankChar pop }
  { AnalyzeLiteral }
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index STR[index] -> STR index
%/AnalyzeLiteral { IsNumber { EvalNumber } { EvalLiteral } ifelse } def
/AnalyzeLiteral { dup IsUnaryOp exch IsNumber or { EvalNumber } { EvalLiteral } ifelse } def%%dr 09102006
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% recognize + or -
%% chr -> T/F
/IsUnaryOp { dup 43 eq exch 45 eq or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a number can contain only : 0123456789.
%% chr -> T/F
/IsNumber { dup 48 ge exch dup 57 le 3 -1 roll and exch 46 eq or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index number
%% a number can be of the form [0-9]*.[0-9]*\([eE][+-]?[0-9]+\)?
%% STR index -> STR index' number
/ReadNumber {
  exch dup 3 -1 roll dup 3 1 roll
  %%read mantissa
  { 1 add  2 copy dup Strlen eq { pop pop 0 exit } if get dup IsNumber not { exit } if pop } loop
  dup 101 eq exch 69 eq or
  %%% there is a "e" or "E" -> read exponant
  { 1 add 2 copy get dup IsUnaryOp
    { pop 1 add 2 copy get } if
    { IsNumber not { exit } if 1 add 2 copy get } loop }
  if
  dup 4 1 roll
  3 -1 roll exch 1 index sub getinterval
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a number can contain only : 0123456789.
%% chr -> T/F
/IsCondOp { dup 30 eq exch dup 60 ge exch 62 le and or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index number
%% a number can be of the form [0-9]*.[0-9]*\([eE][+-]?[0-9]+\)?
%% STR index -> STR index' number
/ReadCondOp {
  NextNonBlankChar 1 index 4 1 roll
  { IsCondOp not { exit } if 1 add  2 copy get } loop
  2 copy 5 -1 roll
  exch 1 index sub getinterval 3 1 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a literal can contain only : 0123456789.
%% chr -> T/F
/IsLiteral {%
  dup 48 ge exch dup  57 le 3 -1 roll and exch
  dup 65 ge exch dup  90 le 3 -1 roll and 3 -1 roll or exch
  dup 97 ge exch     122 le and or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a literal can be of the form [a-zA-Z][a-zA-Z0-9]*\(\((Expression)\)|\(\[Expression\]\)\)?
%% STR index -> literal STR index' nextchr
/ReadLiteral {
  exch dup 3 -1 roll dup 3 1 roll
  %%read literal core
  { 2 copy dup Strlen eq { pop pop 0 exit } if get dup IsLiteral not { exit } if pop 1 add } loop
  4 1 roll dup 5 1 roll 3 -1 roll exch 1 index sub getinterval 4 1 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or a clpar
%% STR index -> STR index STR[index] T/F
/IsEndingExpr {%
  2 copy dup Strlen eq
  %% if end of str is reached -> end !
  { pop pop 0 true }
  %% ending chr -> clpar, comma, |, <, >, =, !,
  {get dup  dup  41 eq
       exch dup 124 eq
       exch dup  93 eq
       exch dup  44 eq
       exch dup  30 eq
       exch dup  60 ge exch 62 le and or or or or or}
  ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or a +-
%% STR index -> STR index STR[index] T/F
/IsEndingTerm { IsEndingExpr { true } { dup dup 43 eq exch 45 eq or } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or */
%% STR index -> STR index STR[index] T/F
/IsEndingFactor { IsEndingTerm { true } { dup dup 42 eq exch 47 eq or } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or ^
%% STR index -> STR index STR[index] T/F
/IsEndingPower { IsEndingFactor { true } { dup 94 eq } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index STR[index]
/NextNonBlankChar { { dup Strlen eq { 0 exit } if 2 copy get dup neBlkChar { exit } if pop 1 add } loop } bind def
/neBlkChar { dup 32 ne exch dup 10 ne exch 9 ne and and } bind def
%%%%%%%%%%%%%%%%%%%%%%%%
%% DEBUG
/BRK {false} def
/BRKtrue {/BRK true def} def
/BRKStop {BRK {BRKtoto} if } def
/BRKEvalStop {BRK exch if } def
/BRKBRK2true {BRK {BRK2true} if } def
/BRK2 {false} def
/BRK2true {/BRK2 true def} def
/BRK2Stop {BRK2 {BRK2toto} if } def/BRK {false} def
end
%
%-------------------------------------------------------------------------------%
%
/tx@AlgToPs 12 dict def tx@AlgToPs begin
%
%% algExpr -> PSVector
/AlgToPs { tx@CoreAnalyzerDict begin InitParser AnalyzeListOfE pop pop EndingSequence end } def
/EndingSequence { ExpressionVector aload length /end cvx exch 1 add array astore } def
/InitParser { /ExpressionVector [ /tx@AddMathFunc cvx /begin cvx ] def dup length /Strlen exch def 0 } def
/Strlen 0 def
/EvalListOfExpr {} def%
/EvalNumber {%
    ReadNumber  cvr /ExpressionVector ExpressionVector aload length dup 3 add -1 roll cvx
    exch 1 add array astore def NextNonBlankChar pop } def
/EvalAddSub {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  43 eq { /add } { /sub } ifelse cvx exch 1 add array astore def
} def
/EvalMulDiv {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  42 eq { /mul } { /div } ifelse cvx exch 1 add array astore def
} def
/EvalPower {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  pop /exp cvx exch 1 add array astore def
} def
/EvalFactorial {% DR 09/2011
  /ExpressionVector ExpressionVector aload length
  /fact cvx exch 1 add array astore def
} def
/EvalLiteral {%
  ReadLiteral
  dup 40 eq%%% there is an open par -> function call
  { pop 2 index
    dup (Sum) eq { EvalSum }
    { dup (IfTE) eq { EvalCond }
      { dup (Derive) eq { pop EvalDerive }
	{ pop 1 add NextNonBlankChar pop AnalyzeListOfE 2 index TrigoFunc
          /ExpressionVector ExpressionVector aload length dup 5 add -1 roll cvn cvx
	  exch 1 add array astore def 1 add NextNonBlankChar pop } ifelse } ifelse} ifelse }
  { /ExpressionVector ExpressionVector aload length dup 6 add -1 roll cvn cvx exch 1 add array astore def
    dup 91 eq%%% there is an open bracket -> vector element
    { pop 1 add NextNonBlankChar pop AnalyzeExpr
      /ExpressionVector ExpressionVector aload length /cvi cvx exch /get cvx exch 2 add array astore def 1 add }
    { pop NextNonBlankChar pop }
    ifelse}
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% the derive function : Derive(n,f(x))
%% firstparindex lastparindex ->
/EvalDerive {
  %% manage the function descripiton
  1 add ReadNumber 3 1 roll NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  1 add NextNonBlankChar pop
  3 -1 roll cvi
  dup 0 eq
  { pop AnalyzeExpr 3 -1 roll pop 1 add }
  { 1 sub 3 1 roll (x)  exch tx@Derive begin DeriveIndexed end 4 -1 roll
    { (x) tx@Derive begin Derive end } repeat
    ExpressionVector exch /ExpressionVector [] def
    AlgToPs aload length
    /ExpressionVector 1 index 3 add -1 roll aload length dup 3 add -1 roll  /l2 exch def /l1 exch def
    l1 l2 add 1 add l2 neg roll l1 l2 add array astore def 3 -1 roll pop 1 add
    1 index length /Strlen exch def } ifelse
} def
/EvalSum {%
  pop 1 add NextNonBlankChar pop
  %% read the variable name
  ReadLiteral pop NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_Sum } if
  %% read the initial value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the increment value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the limit value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  /ExpressionVector ExpressionVector aload length dup 7 add -3 roll 0 4 1 roll
  5 -1 roll 4 add array astore def
  %% keep ExpressionVector for later and create a new one for internal Sum computation
  ExpressionVector 3 1 roll /ExpressionVector [ 6 -1 roll cvn /exch cvx /def cvx ] def
  1 add NextNonBlankChar pop AnalyzeExpr
  %% add each term
  /ExpressionVector ExpressionVector aload length 1 add /add cvx exch array astore def
  /ExpressionVector 4 -1 roll aload length ExpressionVector cvx /for cvx 3 -1 roll 2 add
  array astore def 3 -1 roll pop 1 add
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Convert to radians if trigo function call
%% (name) ->
/TrigoFunc {
  dup (cos) eq 1 index (sin) eq or exch (tan) eq or
  { /ExpressionVector ExpressionVector aload length Pi /div cvx 180 /mul cvx 5 -1 roll 4 add
    array astore def
  } if
} def
/EvalCond {%
  pop 1 add AnalyzeCond NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_IfTE } if
  ExpressionVector 3 1 roll /ExpressionVector [] def
  1 add AnalyzeExpr ExpressionVector 3 1 roll /ExpressionVector [] def
  NextNonBlankChar 44 ne { ANALYZER_ERROR_missing_second_comma_in_IfTE } if
  1 add AnalyzeExpr
  NextNonBlankChar 41 ne { ANALYZER_ERROR_missing_ending parenthesis_in_IfTE } if
  ExpressionVector
  /ExpressionVector 6 -1 roll aload length dup
  6 add -1 roll cvx exch dup 4 add -1 roll cvx /ifelse cvx 3 -1 roll 3 add array astore def
  1 add 3 -1 roll pop
} def
%% CondOp STR index
/EvalCondOp {%
  3 -1 roll
  dup (=) eq  { /eq } {%
  dup (<) eq  { /lt } {%
  dup (>) eq  { /gt } {%
  dup (>=) eq { /ge } {%
  dup (<=) eq { /ge } {%
  dup (!=) eq { /ne } { ERROR_non_valid_conditional_operator }
  ifelse } ifelse } ifelse } ifelse } ifelse } ifelse
  cvx exch pop
  /ExpressionVector ExpressionVector aload length dup 3 add -1 roll exch 1 add array astore def } def
/EvalUnaryOp {
  3 -1 roll 45 eq { /ExpressionVector ExpressionVector aload length /neg cvx exch 1 add array astore def } if
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% H O O K S
/AnalyzePreHook {} bind def
/PreEvalHook {} bind def
/AnalyzeListOfEPostHook {} bind def
/AnalyzePostHook {} def
/RollOp { 3 1 roll } bind def
end   %tx@CoreAnalyzerDict
%
%--------------------------------------------------------------------%
%
/tx@Derive 41 dict def tx@Derive begin
%%increase ^^ for each function added
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% algExpr variable -> PSVector
/Derive {%
  10240 string 3 1 roll 0 3 1 roll
  /Variable exch def
  tx@CoreAnalyzerDict begin InitParser AnalyzeListOfE end
} def
/Strlen 0 def
/InitParser { dup length /Strlen exch def 0 } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% algExpr variable index -> PSVector
/DeriveIndexed {%
  3 1 roll 10240 string 3 1 roll 0 3 1 roll
  /Variable exch def
  tx@CoreAnalyzerDict begin InitParser pop 4 -1 roll AnalyzeExpr 4 -2 roll pop pop 4 -2 roll exch pop end
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u,v)'=-(u',v')
/EvalListOfExpr {%
  4 2 roll 2 copy 9 -1 roll dup length 4 1 roll putinterval add AddPipe
           2 copy 7 -1 roll dup length 4 1 roll putinterval add
  6 -2 roll pop pop
  2 copy pop 0 6 2 roll GetIntervalNewStr 5 1 roll 2 copy 0 exch getinterval 6 1 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (-u)'=-(u')
/EvalUnaryOp {
  4 -2 roll 4 index (0) eq
  { (0) StrConcat 7 -1 roll pop }
  { 7 -1 roll 45 eq
    { AddSub AddOpPar true } { false } ifelse
    3 1 roll 5 index StrConcat 3 -1 roll { AddClPar } if } ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  7 -2 roll pop pop 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (number)'=0
/EvalNumber { ReadNumber (0) 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u+v)'=u'+v'
/EvalAddSub {%
  7 index dup (0) eq
  { pop true }%% du=0 nothing added
  { dup length exch 5 index 5 index 3 -1 roll putinterval 4 -1 roll add 3 1 roll false }
  ifelse
  5 index dup (0) eq
  { pop { (0) } { 4 -2 roll 2 copy pop 0  6 2 roll GetIntervalNewStr } ifelse }%%dv=0
  { exch
    { 5 -2 roll 7 index 45 eq { AddSub } if false } %%nothing yet added
    { 5 -2 roll 7 index 43 eq%%something yet added
      { AddAdd false } { AddSub AddOpPar true } ifelse }
    ifelse 11 1 roll
    3 -1 roll StrConcat 10 -1 roll { AddClPar } if
    2 copy pop 0 6 2 roll GetIntervalNewStr }
  ifelse
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u*v)' or (u/v)'
/EvalMulDiv { 6 index 42 eq {EvalMul} {EvalDiv} ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u*v)'=u'*v+u*v'
/EvalMul {%
  4 -2 roll 7 index dup (0) eq
  { pop false }%%du=0
  { (1) eq%%du=1
    { false }
    { AddOpPar 7 index StrConcat AddClPar AddMul AddOpPar true } ifelse
    3 1 roll 6 index StrConcat 3 -1 roll { AddClPar } if
    true }%%du!=0
  ifelse
  5 1 roll 5 index (0) eq
  { 5 -1 roll not { (0) StrConcat } if }%%dv=0
  { 5 -1 roll { AddAdd } if
    4 index (1) eq
    { 8 index StrConcat }
    { AddOpPar 8 index StrConcat AddClPar AddMul AddOpPar 4 index StrConcat AddClPar }
    ifelse
  }%%dv!=0
  ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u/v)'=(u'*v-u*v')/v^2
/EvalDiv {%
  4 -2 roll
  4 index (0) eq%%dv=0 -> u'/v
  { 7 index (0) eq { (0) StrConcat } { AddOpPar 7 index StrConcat AddClPar AddDiv 5 index StrConcat } ifelse }
  { 7 index dup (0) eq
    { pop }%%du=0
    { (1) eq%%du=1
      { false }
      { AddOpPar 7 index StrConcat AddClPar AddMul AddOpPar true } ifelse
      3 1 roll 6 index StrConcat 3 -1 roll { AddClPar } if}%%du!=0
    ifelse
      AddSub
      4 index (1) eq
      { 8 index StrConcat }
      { AddOpPar 8 index StrConcat AddClPar AddMul AddOpPar 4 index StrConcat AddClPar }
      ifelse
    %}%%dv!=0
    2 copy GetIntervalNewStr 3 1 roll pop 0 AddOpPar 3 -1 roll StrConcat AddClPar
    AddDiv AddOpPar 5 index StrConcat AddClPar 2 copy (^2) putinterval 2 add }
  ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% str1 index str2 -> str1 index
/StrConcat { dup length 4 2 roll 2 copy 6 -1 roll putinterval 3 -1 roll add } bind def
/GetIntervalNewStr { 0 exch getinterval dup length string copy } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u^v)'=(u^v)'=u'vu^(v-1)+v'u^(v)ln(u)
/EvalPower {%
  4 -2 roll 7 index (0) eq
  {%%if du=0 then (u^v)'=v'ln(u)u^v
    4 index (0) eq
    { (0) StrConcat }%%if dv=0 then (u^v)'=0
    { 4 index (1) ne { AddOpPar 4 index StrConcat (\)*) StrConcat } if
      8 index (e) ne { (ln\() StrConcat 8 index StrConcat (\)*) StrConcat } if
      AddOpPar 8 index StrConcat (\)^\() StrConcat 5 index StrConcat AddClPar } ifelse
  }
  {%%du!=0
    4 index (0) eq
    {%%if dv=0 then (u^v)'=vu'u^(v-1)
      5 index dup IsStrNumber
      { dup (0) eq
        { StrConcat }
        { dup dup (1) eq exch (1.0) eq or
          { StrConcat  }
	  { StrConcat
	    7 index dup (1) ne exch (1.0) ne and%%%dr 09102006 insert du if <> 1
	    { (*\() StrConcat 7 index StrConcat (\)) StrConcat } if%%%dr 09102006
            (*\() StrConcat 8 index StrConcat (\)) StrConcat
            5 index  dup dup (2) eq exch (2.0) eq or
	    { pop } { cvr 1 sub 20 string cvs 3 1 roll (^) StrConcat 3 -1 roll StrConcat } ifelse } ifelse } ifelse }
      { pop AddOpPar 5 index StrConcat (\)*\() StrConcat 8 index StrConcat (\)^\() StrConcat
        5 index StrConcat (-1\)) StrConcat } ifelse
    }
    {%%if dv!=0 and du!=0 then (u^v)'=u'vu^(v-1)+v'u^(v)ln(u)
      7 index (1) ne { AddOpPar 7 index StrConcat (\)*) StrConcat } if
      AddOpPar 5 index StrConcat (\)*\() StrConcat
      8 index StrConcat (\)^\() StrConcat
      5 index StrConcat (-1\)+\() StrConcat
      4 index (1) ne { 4 index StrConcat (\)*\() StrConcat } if
      8 index StrConcat (\)^\() StrConcat
      5 index StrConcat (\)*ln\() StrConcat
      8 index StrConcat AddClPar
    } ifelse
  } ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% No derivative for factorial ! only cst => null derivative
/EvalFactorial {% DR 09/2011
  4 index (0) eq
  { (0) mark 8 -2 roll  cleartomark 2 index 7 index dup 4 index exch sub getinterval exch 6 2 roll }
  { DERIVATIVE_ENGINE_ERROR_no_variable_in_factorial } ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% str -> true/false
/IsStrNumber {%
  true exch
  { dup 48 lt exch dup 57 gt 3 -1 roll or
    exch dup 46 ne%%.
    exch dup 43 ne%%+
    exch 45 ne%%-
    and and and { pop false } if } forall
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalLiteral {%
  ReadLiteral dup 40 eq%%% there is an open par -> function call
  { pop (EvalFunc_             ) 9 4 index StrConcat 0 exch getinterval cvn cvx exec }
  { dup 91 eq%%% there is an open bracket -> vector element
    { DERIVATIVE_ENGINE_ERROR_vector_not_yet_implemented }
    { pop EvalVariable }
    ifelse }
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% first last parpos Expr[first:parpos-1] ->
/EvalVariable { 2 index Variable eq { (1) } { (0) } ifelse 4 -1 roll exch 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (f(u))'=u'f'(u)
/EvalFunc {
  4 2 roll 4 index (1) ne
  { AddOpPar 4 index StrConcat (\)*) StrConcat } if
  (Eval             ) 4 8 index StrConcat 0 exch getinterval cvn cvx exec
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Func derivative -> Eval<func>
/EvalFunc_sin {%
  PreCommonFunc
  { (cos\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_cos {%
  PreCommonFunc
  { (\(-sin\() StrConcat 5 index StrConcat (\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_tan {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse  (/cos\() StrConcat 5 index StrConcat (\)^2) StrConcat } if
  PostCommonFunc } def
/EvalFunc_asin {%
  PreCommonFunc
  { (1/sqrt\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_acos {%
  PreCommonFunc
  { (-1/sqrt\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_atg {%
  PreCommonFunc
  { (1/\(1+\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_ln {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse (/\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_exp {%
  PreCommonFunc
  {  (exp\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_EXP {%
  PreCommonFunc
  {  (EXP\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_sqrt {%
  PreCommonFunc
  { dup 0 eq { (1) StrConcat } { 1 sub } ifelse (/\(2*sqrt\() StrConcat 5 index StrConcat (\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Fact {%
  PreCommonFunc { DERIVATIVE_ENGINE_ERROR_no_variable_expression_in_Fact } if
  PostCommonFunc } def
/EvalFunc_sh {%
  PreCommonFunc
  { (ch\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_ch {%
  PreCommonFunc
  { (sh\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_th {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse  (/ch\() StrConcat 5 index StrConcat (\)^2) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argsh {%
  PreCommonFunc
  { (1/sqrt\(1+\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argch {%
  PreCommonFunc
  { (1/sqrt\(\() StrConcat 5 index StrConcat (\)^2-1\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argth {%
  PreCommonFunc
  { (1/\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/PreCommonFunc {
  1 add NextNonBlankChar pop 3 -1 roll 5 1 roll AnalyzeExpr 1 add NextNonBlankChar pop
  4 2 roll 4 index (0) eq
  { (0) StrConcat false }
  { 4 index (1)  ne { AddOpPar 4 index StrConcat (\)*) StrConcat } if true } ifelse
} def
/PostCommonFunc {
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
/EvalFunc_Derive {%
  1 add ReadNumber cvi 1 add dup cvr log 1 add cvi string cvs
  4 -1 roll pop 5 1 roll 1 add NextNonBlankChar pop AnalyzeExpr 1 add
  4 -2 roll (Derive\() StrConcat 7 -1 roll StrConcat (,) StrConcat 6 -1 roll StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr 6 -1 roll pop 2 index 6 index dup 4 index exch sub getinterval
  exch 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalFunc_Sum {%
  1 add NextNonBlankChar pop
  %% read the variable name
  ReadLiteral pop 3 -1 roll pop NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_Sum } if
  %% read the initial value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the increment value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_third_comma_in_Sum } if
  %% read the limit value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_fourth_comma_in_Sum } if
  1 add NextNonBlankChar pop dup 6 1 roll 3 -1 roll pop AnalyzeExpr 1 add NextNonBlankChar pop
  4 -2 roll 3 index 8 index dup 9 index exch sub getinterval StrConcat
  4 index StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalFunc_IfTE {%
  3 -1 roll pop 1 add NextNonBlankChar pop SkipCond
  NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_IfTE } if
  1 add NextNonBlankChar pop dup 5 1 roll
  AnalyzeExpr NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_second_comma_in_IfTE } if
  1 add NextNonBlankChar pop
  AnalyzeExpr 1 add NextNonBlankChar pop
  4 -2 roll 3 index 10 index dup 11 index exch sub getinterval StrConcat
  6 index StrConcat (,) StrConcat 4 index StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% advance in str until a comma is found (no error detection!)
%% str index -> str index'
/SkipCond { { 1 add 2 copy get 44 eq {exit } if } loop } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Convert to radians if trigo function call
%% (name) ->
/TrigoFunc {
  dup (cos) eq 1 index (sin) eq or exch (tan) eq or
  { /ExpressionVector ExpressionVector aload length Pi /div cvx 180 /mul cvx 5 -1 roll 4 add
    array astore def
  } if
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% No derivative for condition....
/EvalCondOp { 3 -1 roll pop } bind def
/PutIntervalOneAdd {putinterval 1 add} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddOpPar {2 copy (\() PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add close parenthesis in string at the given index
%% str index -> str index+1
/AddClPar {2 copy (\)) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add 0 in string at the given index
%% str index -> str index+1
/AddZero {2 copy (0) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddMul {2 copy (*) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddDiv {2 copy (/) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a plus sign in string at the given index
%% str index -> str index+1
/AddAdd {2 copy (+) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a minus sign in string at the given index
%% str index -> str index+1
/AddSub {2 copy (-) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a pipe sign in string at the given index
%% str index -> str index+1
/AddPipe {2 copy (|) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% H O O K S
/AnalyzePreHook { dup 5 1 roll } bind def
/PreEvalHook {} def
/AnalyzePostHook { 7 -1 roll pop } bind def
/AnalyzeListOfEPostHook { 6 -1 roll mark 6 1 roll cleartomark } bind def
/RollOp { 5 1 roll } bind def
end%%%tx@CoreAnalyzerDict
/tx@AddMathFunc 12 dict def tx@AddMathFunc begin
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% NEW FUNC
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% function arcsine in radians asin(x)=atan(x/sqrt(1-x^2))
%% x -> theta
/asin {%
  dup abs 1 gt { EQDFasinrangeerror  } if
  dup dup dup mul 1 exch sub sqrt atan exch 0 lt { 360 sub } if DegtoRad
} def
%% function arccosine in radians acos(x)=atan(sqrt(1-x^2)/x)
%% x -> theta
/acos {%
  dup abs 1 gt { EQDFacosrangeerror  } if
  dup dup mul 1 exch sub sqrt exch atan DegtoRad
} def
%% function arctangent in radians
%% x -> theta
/atg { 1 atan dup 90 gt { 360 sub } if DegtoRad } bind def
%% HYPERBOLIC FUNCTIONS
/sh { dup Ex exch neg Ex sub 2 div } def
/ch { dup Ex exch neg Ex add 2 div } def
/th { dup sh exch ch div } def
/Argsh { dup dup mul 1 add sqrt add ln } def
/Argch { dup dup mul 1 sub sqrt add ln } def
/Argth { dup 1 add exch 1 exch sub div ln 2 div } def
%% modified exponential funtion for 0
%% x n -> x^n
/Exp { dup 0 eq { pop pop 1 } { exp } ifelse } bind def
%% modified exponential funtion for 0
%% x -> e^x
/Ex { Euler exch exp } bind def
%%
%% factorial function
%% n -> n!
/Fact { 1 exch 2 exch 1 exch { mul } for } bind def
/fact { Fact } bind def
/! { Fact } bind def
end
%
% END pst-algparser.pro

%%EndProcSet
%%BeginProcSet: pst-tools.pro 0 0
% $Id: pst-tools.pro 622 2012-01-01 15:36:14Z herbert $
%
%% PostScript tools prologue for pstricks.tex.
%% Version 0.02, 2012/01/01
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%
%
/Pi2 1.57079632679489661925640 def
/factorial { % n on stack, returns n! 
  dup 0 eq { 1 }{ 
    dup 1 gt { dup 1 sub factorial mul } if }
  ifelse } def 
%
/MoverN { % m n on stack, returns the binomial coefficient m over n
  2 dict begin
  /n exch def /m exch def
  n 0 eq { 1 }{
    m n eq { 1 }{
      m factorial n factorial m n sub factorial mul div } ifelse } ifelse 
  end
} def
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% subroutines for complex numbers, given as an array [a b] 
% which is a+bi = Real+i Imag
%
/cxadd {		% [a1 b1] [a2 b2] = [a1+a2 b1+b2]
  dup 0 get		% [a1 b1] [a2 b2] a2
  3 -1 roll		% [a2 b2] a2 [a1 b1]
  dup 0 get		% [a2 b2] a2 [a1 b1] a1
  3 -1 roll		% [a2 b2] [a1 b1] a1 a2
  add			% [a2 b2] [a1 b1] a1+a2
  3 1 roll		% a1+a2 [a2 b2] [a1 b1]
  1 get			% a1+a2 [a2 b2] b1
  exch 1 get		% a1+a2 b1 b2
  add 2 array astore
} def
%
/cxneg {		% [a b]
  dup 1 get		% [a b] b
  exch 0 get		% b a
  neg exch neg		% -a -b
  2 array astore
} def
%
/cxsub { cxneg cxadd } def  % same as negative addition
%
% [a1 b1][a2 b2] = [a1a2-b1b2 a1b2+b1a2] = [a3 b3]
/cxmul {		% [a1 b1] [a2 b2]
  dup 0 get		% [a1 b1] [a2 b2] a2
  exch 1 get		% [a1 b1] a2 b2
  3 -1 roll		% a2 b2 [a1 b1]
  dup 0 get		% a2 b2 [a1 b1] a1
  exch 1 get		% a2 b2 a1 b1
  dup			% a2 b2 a1 b1 b1
  5 -1 roll dup		% b2 a1 b1 b1 a2 a2
  3 1 roll mul		% b2 a1 b1 a2 b1a2
  5 -2 roll dup		% b1 a2 b1a2 b2 a1 a1
  3 -1 roll dup		% b1 a2 b1a2 a1 a1 b2 b2
  3 1 roll mul		% b1 a2 b1a2 a1 b2 a1b2
  4 -1 roll add		% b1 a2 a1 b2 b3
  4 2 roll mul		% b1 b2 b3 a1a2
  4 2 roll mul sub	% b3 a3
  exch 2 array astore
} def
%
% [a b]^2 = [a^2-b^2 2ab] = [a2 b2]
/cxsqr {		% [a b]   square root
  dup 0 get exch 1 get	% a b
  dup dup mul		% a b b^2
  3 -1 roll		% b b^2 a
  dup dup mul 		% b b^2 a a^2
  3 -1 roll sub		% b a a2
  3 1 roll mul 2 mul	% a2 b2	
  2 array astore
} def
%
/cxsqrt {		% [a b]
%  dup cxnorm sqrt /r exch def
%  cxarg 2 div RadtoDeg dup cos r mul exch sin r mul cxmake2 
  cxlog 		% log[a b]
  2 cxrdiv 		% log[a b]/2
  aload pop exch	% b a
  2.781 exch exp	% b exp(a)
  exch cxconv exch	% [Re +iIm] exp(a)
  cxrmul		%
} def
%
/cxarg { 		% [a b] 
  aload pop 		% a b
  exch atan 		% arctan b/a
  DegtoRad 		% arg(z)=atan(b/a)
} def
%
% log[a b] = [a^2-b^2 2ab] = [a2 b2]
/cxlog {		% [a b]
  dup 			% [a b][a b]
  cxnorm 		% [a b] |z|
  log 			% [a b] log|z|
  exch 			% log|z|[a b]
  cxarg 		% log|z| Theta
  cxmake2 		% [log|z| Theta]
} def
%
% square of magnitude of complex number
/cxnorm2 {		% [a b]
  dup 0 get exch 1 get	% a b
  dup mul			% a b^2
  exch dup mul add	% a^2+b^2
} def
%
/cxnorm {		% [a b]
  cxnorm2 sqrt
} def
%
/cxconj {		% conjugent complex
  dup 0 get exch 1 get	% a b
  neg 2 array astore	% [a -b]
} def
%
/cxre { 0 get } def	% real value
/cxim { 1 get } def	% imag value
%
% 1/[a b] = ([a -b]/(a^2+b^2)
/cxrecip {		% [a b]
  dup cxnorm2 exch	% n2 [a b]
  dup 0 get exch 1 get	% n2 a b
  3 -1 roll		% a b n2
  dup			% a b n2 n2
  4 -1 roll exch div	% b n2 a/n2
  3 1 roll div		% a/n2 b/n2
  neg 2 array astore
} def
%
/cxmake1 { 0 2 array astore } def % make a complex number, real given
/cxmake2 { 2 array astore } def	  % dito, both given
%
/cxdiv { cxrecip cxmul } def
%
% multiplikation by a real number
/cxrmul {		% [a b] r
  exch aload pop	% r a b
  3 -1 roll dup		% a b r r
  3 1 roll mul		% a r b*r
  3 1 roll mul		% b*r a*r
  exch 2 array astore   % [a*r b*r]
} def
%
% division by a real number
/cxrdiv {		% [a b] r
  1 exch div		% [a b] 1/r
  cxrmul
} def
%
% exp(i theta) = cos(theta)+i sin(theta) polar<->cartesian
/cxconv {		% theta
  RadtoDeg dup sin exch cos cxmake2
} def

%%%%% ### bubblesort ###
%% syntax : array bubblesort --> array2 trie par ordre croissant
%% code de Bill Casselman
%% http://www.math.ubc.ca/people/faculty/cass/graphics/text/www/
/bubblesort { % on stack must be an array [ ... ]
4 dict begin
   /a exch def
   /n a length 1 sub def
   n 0 gt {
      % at this point only the n+1 items in the bottom of a remain to
      % the sorted largest item in that blocks is to be moved up into
      % position n
      n {
         0 1 n 1 sub {
            /i exch def
            a i get a i 1 add get gt {
               % if a[i] > a[i+1] swap a[i] and a[i+1]
               a i 1 add
               a i get
               a i a i 1 add get
               % set new a[i] = old a[i+1]
               put
               % set new a[i+1] = old a[i]
               put
            } if
         } for
         /n n 1 sub def
      } repeat
   } if
   a % return the sorted array
end
} def
%
/concatstringarray{  %  [(a) (b) ... (z)] --> (ab...z)  20100422
  0 1 index { length add } forall 
  string     
  0 3 2 roll      
  { 3 copy putinterval length add }forall 
  pop  
} bind def
%
/dot2comma {% on stack a string (...) 
  2 dict begin
  /Output exch def
  0 1 Output length 1 sub { 
    /Index exch def 
    Output Index get 46 eq { Output Index 44 put } if 
  } for
  Output
  end
} def
%
%-----------------------------------------------------------------------------%
% END pst-tools.pro

%%EndProcSet
%%BeginProcSet: pst-dots.pro 0 0
% $Id: pst-dots.pro 130 2009-08-27 08:55:03Z herbert $
%
%% PostScript prologue for pstricks.tex.
%% Version 2.02,  2009/06/16
%%
%% For distribution, see pstricks.tex.
%%
%% Timothy Van Zandt <tvz@Princeton.EDU>
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%%
%% Modified by Etienne Riga  - Dec. 16, 1999
%% Modified by Etienne Riga  - 2005/01/01 (er)
%% to add /Diamond, /SolidDiamond and /BoldDiamond
%% Modified by Herbert Voss (hv) - 2008/04/17 
%
10 dict dup begin			% hold local
  /FontType 3 def
  /FontMatrix [.001 0 0 .001 0 0] def
%  /FontBBox [-571.5 -742.5 571.5 742.5] def % changed to next line 20060616 hv
  /FontBBox [-1000 -1000 1000 1000] def  % See end of file in /BuildGlyph
  /Encoding 256 array def
  0 1 255 {Encoding exch /.notdef put} for % fill the array with /.notdef
  Encoding				   % replace with given dot names
    dup (b) 0 get /Bullet put		   % get the numerical position of b in ASCII
%					   % and save /Bullet at this place in Encoding 
    dup (c) 0 get /Circle put
    dup (C) 0 get /BoldCircle put	% 67
    dup (u) 0 get /SolidTriangle put
    dup (t) 0 get /Triangle put
    dup (T) 0 get /BoldTriangle put
    dup (r) 0 get /SolidSquare put
    dup (s) 0 get /Square put
    dup (S) 0 get /BoldSquare put
    dup (q) 0 get /SolidPentagon put
    dup (p) 0 get /Pentagon put
    dup (P) 0 get /BoldPentagon put
%%%		  
    dup (k) 0 get /Asterisk put
    dup (K) 0 get /BoldAsterisk put
    dup (J) 0 get /SolidAsterisk put
    dup (h) 0 get /Hexagon put
    dup (H) 0 get /BoldHexagon put
    dup (G) 0 get /SolidHexagon put
    dup (f) 0 get /Octogon put		% 2008-04-18 hv
    dup (F) 0 get /BoldOctogon put	% 2008-04-18 hv
    dup (g) 0 get /SolidOctogon put	% 2008-04-18 hv
    dup (a) 0 get /Add put
    dup (A) 0 get /BoldAdd put 		% 65
    dup (x) 0 get /Mul put
    dup (X) 0 get /BoldMul put
    dup (m) 0 get /Oplus put
    dup (M) 0 get /BOplus put
    dup (e) 0 get /SolidOplus put
    dup (n) 0 get /Otimes put
    dup (N) 0 get /BOtimes put
    dup (E) 0 get /SolidOtimes put
    dup (i) 0 get /Bar put
    dup (I) 0 get /BoldBar put
    dup (l) 0 get /SolidDiamond put
    dup (d) 0 get /Diamond put
        (D) 0 get /BoldDiamond put
%%%  
/CharProcs 47 dict def
CharProcs begin
  /CirclePath {0 0 500 0 360 arc closepath} def
  /Bullet {CirclePath fill} def
  /Circle {CirclePath .9 .9 scale CirclePath eofill} def
  /BoldCircle {CirclePath .8 .8 scale CirclePath eofill} def
  /TrianglePath {0 660 moveto -571.5 -330 lineto 571.5 -330 lineto closepath} def
  /SolidTriangle {TrianglePath fill} def
  /Triangle {TrianglePath .85 .85 scale TrianglePath eofill} def
  /BoldTriangle {TrianglePath .7 .7 scale TrianglePath eofill} def
  /SquarePath {-450 450 moveto 450 450 lineto 450 -450 lineto -450 -450 lineto closepath} def
  /SolidSquare {SquarePath fill} def
  /Square {SquarePath .89 .89 scale SquarePath eofill} def
  /BoldSquare {SquarePath .78 .78 scale SquarePath eofill} def
  /PentagonPath {
    -337.8 -465 moveto 337.8 -465 lineto 546.6 177.6 lineto
    0 574.7 lineto -546.6 177.6 lineto closepath
  } def
  /SolidPentagon {PentagonPath fill} def
  /Pentagon {PentagonPath .89 .89 scale PentagonPath eofill} def
  /BoldPentagon {PentagonPath .78 .78 scale PentagonPath eofill} def
%-------------- hv begin 2004/07/25   from: er 2003/03/24
  /HexagonPath {
    0 550 moveto -476 275 lineto -476 -275 lineto
    0 -550 lineto 476 -275 lineto 476 275 lineto closepath
  } def
  /SolidHexagon {HexagonPath fill} def
  /Hexagon {HexagonPath .89 .89 scale HexagonPath eofill} def
  /BoldHexagon {HexagonPath .79 .79 scale HexagonPath eofill} def
%					2008-04-18 hv
  /OctogonPath { 
     550 dup 22.5 tan mul dup neg dup add /xMove exch def 
     exch moveto 7 { xMove 0 rlineto 45 rotate } repeat closepath } def 
  /SolidOctogon { OctogonPath fill                             } def
  /Octogon {      OctogonPath .89 .89 scale OctogonPath eofill } def
  /BoldOctogon {  OctogonPath .79 .79 scale OctogonPath eofill } def
%
  /AsteriskPath {
    20 0 moveto 10 250 180 500 0 500 curveto
    -180 500 -10 250 -20 0 curveto closepath
  } def
  /Asterisk {
    AsteriskPath 60 rotate AsteriskPath 60 rotate AsteriskPath
    60 rotate AsteriskPath 60 rotate AsteriskPath 60 rotate AsteriskPath fill
  } def
%
  /Basterp {50 250 220 500 0 500 curveto -220 500 -50 250 -50 30 cos 100 mul curveto} def
  /BoldAsteriskPath {
    50 30 cos 100 mul moveto  Basterp
    60 rotate Basterp 60 rotate Basterp
    60 rotate Basterp 60 rotate Basterp
    60 rotate Basterp closepath
  } def
  /BoldAsterisk {BoldAsteriskPath fill} def
  /SolidAsterisk {CirclePath .9 .9 scale BoldAsteriskPath eofill} def
  /CrossPath {
    40 550 moveto -40 550 lineto -40 40 lineto -550 40 lineto
    -550 -40 lineto -40 -40 lineto -40 -550 lineto 40 -550 lineto 
    40 -40 lineto 550 -40 lineto 550 40 lineto 40 40 lineto closepath
  } def
  /BoldCrossPath {80 550 moveto -80 550 lineto -80 80 lineto -550 80 lineto
    -550 -80 lineto -80 -80 lineto -80 -550 lineto 80 -550 lineto 
    80 -80 lineto 550 -80 lineto 550 80 lineto 80 80 lineto closepath
  } def
  /Add {CrossPath fill} def
  /Mul {45 rotate CrossPath fill} def
  /BoldAdd {BoldCrossPath fill} def
  /BoldMul {45 rotate BoldCrossPath fill} def
  /Oplus {CirclePath .9 .9 scale CirclePath eofill .775 .775 scale CrossPath fill } def 
  /SolidOplus {CirclePath .775 .775 scale BoldCrossPath eofill} def 
  /BOplus {CirclePath .8 .8 scale CirclePath eofill .775 .775 scale BoldCrossPath fill} def 
  /Otimes {CirclePath .9 .9 scale CirclePath eofill 45 rotate .775 .775 scale CrossPath fill} def 
  /BOtimes {CirclePath .8 .8 scale CirclePath eofill 45 rotate .775 .775 scale BoldCrossPath fill } def 
  /SolidOtimes {CirclePath 45 rotate .775 .775 scale BoldCrossPath eofill} def 
  /BarPath {40 660 moveto -40 660 lineto -40 -660 lineto 40 -660 lineto closepath} def
  /Bar {BarPath fill} def
  /BoldBarPath {80 660 moveto -80 660 lineto -80 -660 lineto 80 -660 lineto closepath} def
  /BoldBar {BoldBarPath fill} def
  /DiamondPath {0 742.5 moveto -428.5 0 lineto 0 -742.5 lineto 428.5 0 lineto closepath} def
  /SolidDiamond {DiamondPath fill} def
  /Diamond {DiamondPath .865 .865 scale DiamondPath eofill} def
  /BoldDiamond {DiamondPath .73 .73 scale DiamondPath eofill} def
%%%
  /.notdef { } def
end
%
/BuildGlyph {
  exch
  begin 		
%  Metrics 1 index get exec 0
    0 0
%      BBoxes 3 index get exec
    -1000 -1000 1000 1000
%     -571.5 -742.5 571.5 742.5
    setcachedevice
    CharProcs begin load exec end
  end
} def
%
/BuildChar {
  1 index /Encoding get exch get
  1 index /BuildGlyph get exec
} bind def
%
end
/PSTricksDotFont exch definefont pop
%
%% end

%%EndProcSet
%%BeginProcSet: pst-grad.pro 0 0
%!
% PostScript prologue for pst-grad.tex.
% Version 1.05, 2006/11/04 
% prepared by Herbert Voss
% For copying restrictions, see pstricks.tex.
%
% For the PSTricks gradient fillstyle.%
% Based on some EPS files by leeweyr!bill@nuchat.sccsi.com (W. R. Lee).%
% Syntax:% D.G. modification begin - Apr.  9, %1998
%%%%%% R0 G0 B0 R1 G1 B1 NumLines MidPoint Angle GradientFill
%   ifGradientCircle GradientScale %GradientPosX GradientPosY
%     R0 G0 B0 R1 G1 B1 NumLines MidPoint %Angle GradientFill
% D.G. modification end
%
/tx@GradientDict 40 dict def
tx@GradientDict begin
/GradientFill {
 /ifCMYK exch def   % do we have rgb or cmyk? hv 1.06
 rotate
 /MidPoint ED
 /NumLines ED
 ifCMYK {
    /LastBlack ED	% 1.06
    /LastYellow ED	% 1.06
    /LastMagenta ED	% 1.06
    /LastCyan ED	% 1.06
    /FirstBlack ED	% 1.06
    /FirstYellow ED	% 1.06
    /FirstMagenta ED	% 1.06
    /FirstCyan ED	% 1.06
 }{ /LastBlue ED
    /LastGreen ED
    /LastRed ED
    /FirstBlue ED
    /FirstGreen ED
    /FirstRed ED
 } ifelse
 /GradientPosY ED
 /GradientPosX ED
 /GradientScale ED
 /ifGradientCircle ED
 % This avoids gaps due to rounding errors:
 clip
 pathbbox           %leave llx,lly,urx,ury on stack
 4 copy /ury ED /urx ED /lly ED /llx ED
 /y ED /x ED
 ifGradientCircle
   { 0 GradientPosX eq { 0 GradientPosX eq {2 copy translate} if } if }
   {2 copy translate} ifelse
 y sub neg /y ED
 x sub neg /x ED  % This avoids gaps due to rounding errors:
 ifCMYK {				% 1.06
    LastCyan FirstCyan add 2 div	% 1.06
    LastMagenta FirstMagenta add 2 div	% 1.06
    LastYellow FirstYellow add 2 div	% 1.06
    LastBlack FirstBlack add 2 div	% 1.06
    setcmykcolor			% 1.06
  }{
    LastRed FirstRed add 2 div
    LastGreen FirstGreen add 2 div
    LastBlue FirstBlue add 2 div
    setrgbcolor
  } ifelse
 ifGradientCircle
   { /YSizePerLine y NumLines div def
     /CurrentY y 2 div def
     /MidLine NumLines 2 div 1 MidPoint sub mul abs cvi def
   }{
     fill
     /YSizePerLine y NumLines div def
     /CurrentY 0 def
     /MidLine NumLines 1 MidPoint sub mul abs cvi def
   } ifelse
 MidLine NumLines 2 sub gt 
   { /MidLine NumLines def }
   { MidLine 2 lt { /MidLine 0 def } if } ifelse
 MidLine 0 gt {
  ifCMYK {
    /Cyan FirstCyan def
    /Magenta FirstMagenta def
    /Yellow FirstYellow def
    /Black FirstBlack def
    /CyanIncrement LastCyan FirstCyan sub MidLine 1 sub div def
    /MagentaIncrement LastMagenta FirstMagenta sub MidLine 1 sub div def
    /YellowIncrement LastYellow FirstYellow sub MidLine 1 sub div def
    /BlackIncrement LastBlack FirstBlack sub MidLine 1 sub div def
  }{
    /Red FirstRed def
    /Green FirstGreen def
    /Blue FirstBlue def
    /RedIncrement LastRed FirstRed sub MidLine 1 sub div def
    /GreenIncrement LastGreen FirstGreen sub MidLine 1 sub div def
    /BlueIncrement LastBlue FirstBlue sub MidLine 1 sub div def
  } ifelse
  MidLine { GradientLoop } repeat
 } if
 MidLine NumLines lt {
  ifCMYK {
    /Cyan LastCyan def
    /Magenta LastMagenta def
    /Yellow LastYellow def
    /Black LastBlack def
    /CyanIncrement FirstCyan LastCyan sub NumLines MidLine sub 1 sub div def
    /MagentaIncrement FirstMagenta LastMagenta sub NumLines MidLine sub 1 sub div def
    /YellowIncrement FirstYellow LastYellow sub NumLines MidLine sub 1 sub div def
    /BlackIncrement FirstBlack LastBlack sub NumLines MidLine sub 1 sub div def
  }{
    /Red LastRed def
    /Green LastGreen def
    /Blue LastBlue def
    /RedIncrement FirstRed LastRed sub NumLines MidLine sub 1 sub div def
    /GreenIncrement FirstGreen LastGreen sub NumLines MidLine sub 1 sub div def
    /BlueIncrement FirstBlue LastBlue sub NumLines MidLine sub 1 sub div def
  } ifelse
  NumLines MidLine sub { GradientLoop } repeat  
 } if
} def/GradientLoop {
% D.G. modification begin - Jul. 23, 1997 / Apr.  9, 1998
  ifGradientCircle
   {CurrentY 0 gt {
% The default center used is the center of the bounding box of the object
      0 GradientPosX eq        {0 GradientPosX eq
           {/GradientPosX urx llx sub 2 div def
            /GradientPosY ury lly sub 2 div def} if} if
      GradientPosX GradientPosY CurrentY GradientScale mul 0 360 arc
      ifCMYK { Cyan Magenta Yellow Black setcmykcolor }
           { Red Green Blue setrgbcolor } ifelse 
      fill
      /CurrentY CurrentY YSizePerLine sub def
      ifCMYK {
        /Cyan Cyan CyanIncrement add def
        /Magenta Magenta MagentaIncrement add def
        /Yellow Yellow YellowIncrement add def
        /Black Black BlackIncrement add def
      }{	
        /Blue Blue BlueIncrement add def
        /Green Green GreenIncrement add def
        /Red Red RedIncrement add def
      } ifelse
  } if }   { 0 CurrentY moveto    x 0 rlineto
    0 YSizePerLine rlineto    x neg 0 rlineto    closepath
      ifCMYK { Cyan Magenta Yellow Black setcmykcolor }
           { Red Green Blue setrgbcolor } ifelse 
      fill    
      /CurrentY CurrentY YSizePerLine add def
      ifCMYK {
        /Cyan Cyan CyanIncrement add def
        /Magenta Magenta MagentaIncrement add def
        /Yellow Yellow YellowIncrement add def
        /Black Black BlackIncrement add def
      }{	
        /Blue Blue BlueIncrement add def
        /Green Green GreenIncrement add def
        /Red Red RedIncrement add def
      } ifelse
      } ifelse% D.G. modification end
    }def
%
/GradientFillHSB { %	hv 2006-11-04
  rotate
  /MidPoint ED
  /NumLines ED
  /LastBrightness ED
  /LastSaturation ED
  /LastHue ED
  /FirstBrightness ED
  /FirstSaturation ED
  /FirstHue ED
  % This avoids gaps due to rounding errors:
  clip
  pathbbox           %leave llx,lly,urx,ury on stack
  /y ED /x ED
  2 copy translate
  y sub neg /y ED
  x sub neg /x ED
  % This avoids gaps due to rounding errors:
  LastHue FirstHue add 2 div
  LastSaturation FirstSaturation add 2 div
  LastBrightness FirstBrightness add 2 div
  sethsbcolor
  fill
  /YSizePerLine y NumLines div def
  /CurrentY 0 def
  /MidLine NumLines 1 MidPoint sub mul abs cvi def
  MidLine NumLines 2 sub gt
  { /MidLine NumLines def }
  { MidLine 2 lt { /MidLine 0 def } if }
  ifelse
  MidLine 0 gt
  {
    /Hue FirstHue def
    /Saturation FirstSaturation def
    /Brightness FirstBrightness def
    /HueIncrement LastHue FirstHue sub MidLine 1 sub div def
    /SaturationIncrement LastSaturation FirstSaturation sub MidLine 1 sub
                         div def
    /BrightnessIncrement LastBrightness FirstBrightness sub MidLine 1 sub
                         div def
    MidLine { GradientLoopHSB } repeat
  } if
  MidLine NumLines lt
  {
    /Hue LastHue def
    /Saturation LastSaturation def
    /Brightness LastBrightness def
    /HueIncrement FirstHue LastHue sub NumLines MidLine sub 1 sub div def
    /SaturationIncrement FirstSaturation LastSaturation sub
                         NumLines MidLine sub 1 sub div def
    /BrightnessIncrement FirstBrightness LastBrightness sub
                         NumLines MidLine sub 1 sub div def
    NumLines MidLine sub { GradientLoopHSB } repeat
  } if
} def
/GradientLoopHSB {
  0 CurrentY moveto
  x 0 rlineto
  0 YSizePerLine rlineto
  x neg 0 rlineto
  closepath
  Hue Saturation Brightness sethsbcolor fill
  /CurrentY CurrentY YSizePerLine add def
  /Brightness Brightness BrightnessIncrement add def
  /Saturation Saturation SaturationIncrement add def
  /Hue Hue HueIncrement add def
} def
%
end
%
% END pst-grad.pro

%%EndProcSet
%%BeginProcSet: pst-node.pro 0 0
% $Id: pst-node.pro 645 2012-02-12 09:09:51Z herbert $
%%
%% PostScript prologue for pst-node.tex.
%% Version 1.13, 2011/11/21.
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%
/tx@NodeDict 400 dict def tx@NodeDict begin
tx@Dict begin 			% from main pstricks dict
 /T /translate load def 
 /CP /currentpoint load def 
end
/NewNode { % on stack: { x y } boolean N@name type InitXnode 
  gsave 
  NodeScale                     % a bugfix for xelatex, it's empty for dvips
  /next exch def 		% { x y } boolean N@name type  
  dict dup 			% { x y } boolean N@name dict dict
  3 1 roll def 			% { x y } boolean dict N@name dict def
  exch { dup 3 1 roll def } if  % { x y } dict boolean
  begin 			% { x y } dict begin
  tx@Dict begin 
    STV CP T exec 		% set scaling
  end 
  /NodeMtrx CM def 		% save CM
  next 				% InitXNode
  end
  grestore 
} def
%
/InitPnode { 
  /Y ED /X ED 
  /NodePos { NodeSep Cos mul NodeSep Sin mul } def
} def
%
/InitCnode { 
  /r ED /Y ED /X ED 
  /NodePos { NodeSep r add dup Cos mul exch Sin mul } def 
} def
%
/GetRnodePos { 
  Cos 0 gt { /dx r NodeSep add def } { /dx l NodeSep sub def } ifelse 
  Sin 0 gt { /dy u NodeSep add def } { /dy d NodeSep sub def } ifelse 
  dx Sin mul abs dy 
  Cos mul abs gt { dy Cos mul Sin div dy } { dx dup Sin mul Cos Div } ifelse 
} def
%
/InitRnode { 
  /Y ED /X ED X sub /r ED /l X neg def Y add neg /d ED Y sub /u ED 
  /NodePos { GetRnodePos } def 
} def
%
/DiaNodePos { 
  w h mul w Sin mul abs h Cos mul abs add Div NodeSep add dup
  Cos mul exch Sin mul 
} def
%
/TriNodePos { 
  Sin s lt 
    { d NodeSep sub dup Cos mul Sin Div exch } 
    { w h mul w Sin mul h Cos abs mul add Div 
      NodeSep add dup Cos mul exch Sin mul 
    } ifelse 
} def
%
/InitTriNode { 
  sub 2 div exch 
  2 div exch 
  2 copy T 
  2 copy 4 index index /d ED 
  pop pop pop pop 
  -90 mul rotate 
  /NodeMtrx CM def 
  /X 0 def /Y 0 def 
  d sub abs neg /d ED 
  d add /h ED 
  2 div h mul h d sub Div /w ED 
  /s d w Atan sin def 
  /NodePos { TriNodePos } def 
} def
%
/OvalNodePos { 
  /ww w NodeSep add def 
  /hh h NodeSep add def 
  Sin ww mul Cos hh mul Atan dup cos ww mul exch sin hh mul 
} def
%
/GetCenter { begin X Y NodeMtrx transform CM itransform end } def
%
/XYPos { 
  dup sin exch cos Do 
  /Cos ED /Sin ED /Dist ED 
  Cos 0 gt 
    { Dist Dist Sin mul Cos div }
    { Cos 0 lt 
      { Dist neg Dist Sin mul Cos div neg }
      { 0 Dist Sin mul } ifelse 
    } ifelse 
  Do 
} def
%
/GetEdge {
  dup 0 eq 
    { pop begin 1 0 NodeMtrx dtransform 
      CM idtransform 
      exch atan sub 
      dup 
      sin /Sin ED 
      cos /Cos ED 
      /NodeSep ED 
      NodePos NodeMtrx dtransform CM idtransform end }
    { 1 eq {{exch}} {{}} ifelse /Do ED pop XYPos } ifelse 
} def
%
/AddOffset { 
  1 index 0 eq 
    { pop pop } 
    { 2 copy 5 2 roll cos mul add 4 1 roll sin mul sub exch } ifelse 
} def
%
/GetEdgeA { 
  NodeSepA AngleA NodeA NodeSepTypeA GetEdge 
  OffsetA AngleA AddOffset 
  yA add /yA1 ED 
  xA add /xA1 ED 
} def
%
/GetEdgeB { 
  NodeSepB AngleB NodeB NodeSepTypeB GetEdge 
  OffsetB AngleB AddOffset 
  yB add /yB1 ED 
  xB add /xB1 ED 
} def
%
/GetArmA { 
  ArmTypeA 0 eq 
    { /xA2 ArmA AngleA cos mul xA1 add def 
      /yA2 ArmA AngleA sin mul yA1 add def } 
    { ArmTypeA 1 eq {{exch}} {{}} ifelse 
      /Do ED 
      ArmA AngleA XYPos OffsetA AngleA AddOffset 
      yA add /yA2 ED 
      xA add /xA2 ED } ifelse 
} def
%
/GetArmB { 
  ArmTypeB 0 eq 
    { /xB2 ArmB AngleB cos mul xB1 add def 
      /yB2 ArmB AngleB sin mul yB1 add def } 
    { ArmTypeB 1 eq {{exch}} {{}} ifelse 
      /Do ED
      ArmB AngleB XYPos OffsetB AngleB AddOffset 
      yB add /yB2 ED 
      xB add /xB2 ED } ifelse 
} def
%
/InitNC { 
  /b ED /a ED % second and first node
  /NodeSepTypeB ED /NodeSepTypeA ED 
  /NodeSepB ED /NodeSepA ED 
  /OffsetB ED /OffsetA ED 
  tx@NodeDict a known tx@NodeDict b known and dup { 
    /NodeA a load def 
    /NodeB b load def 
    NodeA GetCenter /yA ED /xA ED 
    NodeB GetCenter /yB ED /xB ED } if 
} def
%
/LPutLine { 
  4 copy 
  3 -1 roll sub neg 3 1 roll sub Atan /NAngle ED 
  1 t sub mul 
  3 1 roll 1 t sub mul 
  4 1 roll t mul add /Y ED 
  t mul add /X ED 
} def
%
/LPutLines { 
  mark LPutVar counttomark 2 div 1 sub /n ED 
%  t floor dup n gt 
  t floor dup n ge 		% to allow npos<= hv 2008-08-14
  { pop n 1 sub /t 1 def } { dup t sub neg /t ED } ifelse 
  cvi 2 mul { pop } repeat 
  LPutLine 
  cleartomark 
} def
%
/BezierMidpoint { 
  /y3 ED /x3 ED /y2 ED /x2 ED /y1 ED /x1 ED /y0 ED /x0 ED /t ED 
  /cx x1 x0 sub 3 mul def 
  /cy y1 y0 sub 3 mul def 
  /bx x2 x1 sub 3 mul cx sub def 
  /by y2 y1 sub 3 mul cy sub def 
  /ax x3 x0 sub cx sub bx sub def 
  /ay y3 y0 sub cy sub by sub def 
  ax t 3 exp mul bx t t mul mul add 
  cx t mul add x0 add ay t 3 exp mul 
  by t t mul mul add cy t mul add
  y0 add 3 ay t t mul mul mul 2 
  by t mul mul add cy add 3 ax t t mul mul mul 
  2 bx t mul mul add cx add atan /NAngle ED 
  /Y ED /X ED 
} def
%
/HPosBegin { yB yA ge { /t 1 t sub def } if /Y yB yA sub t mul yA add def
} def
/HPosEnd { /X Y yyA sub yyB yyA sub Div xxB xxA sub mul xxA add def
/NAngle yyB yyA sub xxB xxA sub Atan def } def
/HPutLine { HPosBegin /yyA ED /xxA ED /yyB ED /xxB ED HPosEnd  } def
/HPutLines { HPosBegin yB yA ge { /check { le } def } { /check { ge } def
} ifelse /xxA xA def /yyA yA def mark xB yB LPutVar { dup Y check { exit
} { /yyA ED /xxA ED } ifelse } loop /yyB ED /xxB ED cleartomark HPosEnd 
} def
/VPosBegin { xB xA lt { /t 1 t sub def } if /X xB xA sub t mul xA add def
} def
/VPosEnd { /Y X xxA sub xxB xxA sub Div yyB yyA sub mul yyA add def
/NAngle yyB yyA sub xxB xxA sub Atan def } def
/VPutLine { VPosBegin /yyA ED /xxA ED /yyB ED /xxB ED VPosEnd  } def
/VPutLines { VPosBegin xB xA ge { /check { le } def } { /check { ge } def
} ifelse /xxA xA def /yyA yA def mark xB yB LPutVar { 1 index X check {
exit } { /yyA ED /xxA ED } ifelse } loop /yyB ED /xxB ED cleartomark
VPosEnd  } def
/HPutCurve { gsave newpath /SaveLPutVar /LPutVar load def LPutVar 8 -2
roll moveto curveto flattenpath /LPutVar [ {} {} {} {} pathforall ] cvx
def grestore exec /LPutVar /SaveLPutVar load def } def
/NCCoor { /AngleA yB yA sub xB xA sub Atan def /AngleB AngleA 180 add def
GetEdgeA GetEdgeB /LPutVar [ xB1 yB1 xA1 yA1 ] cvx def /LPutPos {
LPutVar LPutLine } def /HPutPos { LPutVar HPutLine } def /VPutPos {
LPutVar VPutLine } def LPutVar } def
%
/NCLine { 
  NCCoor 
  tx@Dict begin 
  ArrowA CP 4 2 roll 
  ArrowB 
  lineto pop pop
  end 
} def
%
/NCLines { 
  false NArray 
  n 0 eq 
    { NCLine } 
    { 2 copy yA sub exch xA sub Atan /AngleA ED 
      n 2 mul dup index exch index yB sub exch xB sub 
      Atan /AngleB ED 
      GetEdgeA GetEdgeB 
      /LPutVar [ xB1 yB1 n 2 mul 4 add 4 roll xA1 yA1 ] cvx def 
      mark LPutVar 
      tx@Dict begin false Line end 
      /LPutPos { LPutLines } def 
      /HPutPos { HPutLines } def 
      /VPutPos { VPutLines } def 
    } ifelse 
} def
%
/NCCurve { 
  GetEdgeA 
  GetEdgeB 
  xA1 xB1 sub yA1 yB1 sub Pyth 2 div dup 3 -1
roll mul /ArmA ED mul /ArmB ED /ArmTypeA 0 def /ArmTypeB 0 def GetArmA
GetArmB xA2 yA2 xA1 yA1 tx@Dict begin ArrowA end xB2 yB2 xB1 yB1 tx@Dict
begin ArrowB end curveto /LPutVar [ xA1 yA1 xA2 yA2 xB2 yB2 xB1 yB1 ]
cvx def /LPutPos { t LPutVar BezierMidpoint } def /HPutPos { { HPutLines
} HPutCurve } def /VPutPos { { VPutLines } HPutCurve } def } def
%
/NCAngles { 
  GetEdgeA GetEdgeB GetArmA GetArmB 
  /mtrx AngleA matrix rotate def 
  xA2 yA2 mtrx transform pop 
  xB2 yB2 mtrx transform exch pop 
  mtrx itransform 
  /y0 ED /x0 ED 
  mark ArmB 0 ne { xB1 yB1 } if 
  xB2 yB2 x0 y0 xA2 yA2 
  ArmA 0 ne { xA1 yA1 } if 
  tx@Dict begin false Line end 
  /LPutVar [ xB1 yB1 xB2 yB2 x0 y0 xA2 yA2 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def } def
%
/NCAngle { 
  GetEdgeA GetEdgeB GetArmB 
  /mtrx AngleA matrix rotate def 
  xB2 yB2 mtrx itransform pop xA1 yA1 mtrx itransform exch pop mtrx transform
  /y0 ED /x0 ED 
  mark 
  ArmB 0 ne { xB1 yB1 } if 
  xB2 yB2 x0 y0 xA1 yA1
  tx@Dict begin false Line end 
  /LPutVar [ xB1 yB1 xB2 yB2 x0 y0 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def 
} def
%
/NCBar { 
  GetEdgeA GetEdgeB GetArmA GetArmB 
  /mtrx AngleA matrix rotate def
  xA2 yA2 mtrx itransform pop 
  xB2 yB2 mtrx itransform pop 
  sub dup 0 mtrx transform 
  3 -1 roll 0 gt 
    { /yB2 exch yB2 add def /xB2 exch xB2 add def }
    { /yA2 exch neg yA2 add def /xA2 exch neg xA2 add def } ifelse 
  mark 
  ArmB 0 ne { xB1 yB1 } if 
  xB2 yB2 xA2 yA2 ArmA 0 ne { xA1 yA1 } if 
  tx@Dict begin false Line end 
  /LPutVar [ xB1 yB1 xB2 yB2 xA2 yA2 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def 
} def
%
/NCDiag { 
  /lineAngle ED
  GetEdgeA GetEdgeB GetArmA GetArmB mark
  lineAngle abs 0 gt {
    /xTemp xA2 10 add def
    /yTemp yA2 lineAngle dup sin exch cos div 10 mul add def
    /dY1 yTemp yA2 sub def
    /dX1 xTemp xA2 sub def
    /dY2 yB2 yB1 sub def
    /dX2 xB2 xB1 sub def
    dX1 abs 0.01 lt {
      /m2 dY2 dX2 div def
      /xB2 xA2 def
      /yB2 xA2 xB1 sub m2 mul yB1 add def
    }{
      dX2 abs 0.01 lt {
        /m1 dY1 dX1 div def
        /xB2 xB1 def
        /yB2 xB1 xA2 sub m1 mul yA2 add def
      }{%
        /m1 dY1 dX1 div def
        /m2 dY2 dX2 div def
        /xB2 m1 xA2 mul m2 xB1 mul sub yA2 sub yB1 add m1 m2 sub div def
        /yB2 xB2 xA2 sub m1 mul yA2 add def
      } ifelse
    } ifelse
  } if
  ArmB 0 ne { xB1 yB1 } if
  xB2 yB2 xA2 yA2 
  ArmA 0 ne { xA1 yA1 } if 
  tx@Dict begin false Line end
  /LPutVar [ xB1 yB1 xB2 yB2 xA2 yA2 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def 
%
%  GetEdgeA GetEdgeB GetArmA GetArmB mark 
%  ArmB 0 ne { xB1 yB1 } if
%  xB2 yB2 xA2 yA2 
%  ArmA 0 ne { xA1 yA1 } if 
%  tx@Dict begin false Line end
%  /LPutVar [ xB1 yB1 xB2 yB2 xA2 yA2 xA1 yA1 ] cvx def 
%  /LPutPos { LPutLines } def 
%  /HPutPos { HPutLines } def 
%  /VPutPos { VPutLines } def 
} def
%
/NCDiagg { 
  /lineAngle ED
  GetEdgeA GetArmA 
  lineAngle abs 0 gt 
    { lineAngle }
    { yB yA2 sub xB xA2 sub Atan 180 add } ifelse 
  /AngleB ED
  GetEdgeB mark
  lineAngle abs 0 gt {
    /dY2 yA2 yA1 sub def
    /dX2 xA2 xA1 sub def
    lineAngle abs 90 eq {
      /m2 dY2 dX2 div def
      /yA2 xB xA2 sub m2 mul yA2 add def
      /xA2 xB def
    }{
      /m1 lineAngle dup sin exch cos div def % tan alpha
      dX2 abs 0.01 lt {
        /yA2 xA1 xB sub m1 mul yB add def
        /xA2 xA1 def
      }{%
        /m2 dY2 dX2 div def
        /xA2 m1 xB mul m2 xA2 mul sub yA2 add yB sub m1 m2 sub div def
        /yA2 xA2 xB sub m1 mul yB add def
      } ifelse
    } ifelse
  } if
  xB1 yB1 xA2 yA2
  ArmA 0 ne { xA1 yA1 } if
  tx@Dict begin false Line end
  /LPutVar [ xB1 yB1 xA2 yA2 xA1 yA1 ] cvx def
  /LPutPos { LPutLines } def
  /HPutPos { HPutLines } def
  /VPutPos { VPutLines } def
%
%  GetEdgeA GetArmA 
%  yB yA2 sub xB xA2 sub Atan 180 add /AngleB ED
%  GetEdgeB 
%  mark 
%  xB1 yB1 xA2 yA2 
%  ArmA 0 ne { xA1 yA1 } if 
%  tx@Dict begin false Line end 
%  /LPutVar [ xB1 yB1 xA2 yA2 xA1 yA1 ] cvx def 
%  /LPutPos { LPutLines } def 
%  /HPutPos { HPutLines } def 
%  /VPutPos { VPutLines } def 
} def
%
/NCLoop { 
  GetEdgeA GetEdgeB GetArmA GetArmB 
  /mtrx AngleA matrix rotate def 
  xA2 yA2 mtrx transform loopsize add /yA3 ED /xA3 ED 
  /xB3 xB2 yB2 mtrx transform pop def 
  xB3 yA3 mtrx itransform /yB3 ED /xB3 ED 
  xA3 yA3 mtrx itransform /yA3 ED /xA3 ED 
  mark ArmB 0 ne { xB1 yB1 } if 
  xB2 yB2 xB3 yB3 xA3 yA3 xA2 yA2 ArmA 0 ne { xA1 yA1 } if 
  tx@Dict begin false Line end 
  /LPutVar [ xB1 yB1 xB2 yB2 xB3 yB3 xA3 yA3 xA2 yA2 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def 
} def
%
% DG/SR modification begin - May 9, 1997 - Patch 1
%/NCCircle { 0 0 NodesepA nodeA \tx@GetEdge pop xA sub 2 div dup 2 exp r
%r mul sub abs sqrt atan 2 mul /a ED r AngleA 90 add PtoC yA add exch xA add
%exch 2 copy /LPutVar [ 4 2 roll r AngleA ] cvx def /LPutPos { LPutVar t 360
%mul add dup 5 1 roll 90 sub \tx@PtoC 3 -1 roll add /Y ED add /X ED /NAngle ED
%
/NCCircle { 
  NodeSepA 0 NodeA 0 GetEdge pop 
  2 div dup 2 exp r r mul sub abs sqrt 
  atan 2 mul /a ED 
  r AngleA 90 add PtoC yA add exch xA add 
  exch 2 copy 
  /LPutVar [ 4 2 roll r AngleA ] cvx def 
  /LPutPos { 
    LPutVar t 360 mul add dup 5 1 roll 90 sub PtoC 
    3 -1 roll add 
    /Y ED add /X ED /NAngle ED
% DG/SR modification end
  } def 
  /HPutPos { LPutPos } def 
  /VPutPos { LPutPos } def 
  r AngleA 90 sub a add AngleA 270 add a sub 
  tx@Dict begin 
  /angleB ED /angleA ED /r ED 
  /c 57.2957 r Div def 
  /y ED /x ED 
} def
%
/NCBox { 
  /d ED /h ED 
  /AngleB yB yA sub xB xA sub Atan def 
  /AngleA AngleB 180 add def 
  GetEdgeA GetEdgeB 
  /dx d AngleB sin mul def 
  /dy d AngleB cos mul neg def 
  /hx h AngleB sin mul neg def 
  /hy h AngleB cos mul def 
  /LPutVar [ 
    xA1 hx add yA1 hy add xB1 hx add yB1 hy add 
    xB1 dx add yB1 dy add xA1 dx add yA1 dy add ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { xB yB xA yA LPutLine } def 
  /VPutPos { HPutPos } def 
  mark 
  LPutVar tx@Dict begin false Polygon end 
} def
%
/NCArcBox { 
  /l ED neg /d ED /h ED /a ED 
  /AngleA yB yA sub xB xA sub Atan def 
  /AngleB AngleA 180 add def 
  /tA AngleA a sub 90 add def 
  /tB tA a 2 mul add def 
  /r xB xA sub tA cos tB cos sub Div dup 0 eq { pop 1 } if def
  /x0 xA r tA cos mul add def 
  /y0 yA r tA sin mul add def 
  /c 57.2958 r div def 
  /AngleA AngleA a sub 180 add def 
  /AngleB AngleB a add 180 add def
  GetEdgeA GetEdgeB 
  /AngleA tA 180 add yA yA1 sub xA xA1 sub Pyth c mul sub def 
  /AngleB tB 180 add yB yB1 sub xB xB1 sub Pyth c mul add def 
  l 0 eq { 
    x0 y0 r h add AngleA AngleB arc x0 y0 r d add AngleB AngleA arcn 
  }{ 
    x0 y0 translate 
    /tA AngleA l c mul add def 
    /tB AngleB l c mul sub def
    0 0 r h add tA tB arc r h add 
    AngleB PtoC r d add 
    AngleB PtoC 2 copy 
    6 2 roll l arcto 4 { pop } repeat 
    r d add tB PtoC l arcto 4 { pop } repeat 
    0 0 r d add tB tA arcn r d add 
    AngleA PtoC r h add 
    AngleA PtoC 2 copy 6 2 roll 
    l arcto 4 { pop } repeat 
    r h add tA PtoC l arcto 4 { pop } repeat 
  } ifelse 
  closepath 
  /LPutVar [ x0 y0 r AngleA AngleB h d ] cvx def 
  /LPutPos { 
    LPutVar /d ED /h ED 
    /AngleB ED /AngleA ED 
    /r ED /y0 ED /x0 ED 
    t 1 le { 
      r h add AngleA 1 t sub mul AngleB t mul add dup 90 add /NAngle ED PtoC 
    }{t 2 lt { 
        /NAngle AngleB 180 add def r 2 t sub 
        h mul t 1 sub d mul add add AngleB PtoC 
      }{ 
        t 3 lt { 
          r d add AngleB 3 t sub mul AngleA 2 t sub
          mul add dup 90 sub /NAngle ED PtoC 
        }{ 
          /NAngle AngleA 180 add def 
          r 4 t sub d mul t 3 sub h mul add add AngleA PtoC 
        } ifelse 
      } ifelse 
    } ifelse
    y0 add /Y ED x0 add /X ED 
  } def 
  /HPutPos { LPutPos } def 
  /VPutPos { LPutPos } def 
} def
%
/Tfan { /AngleA yB yA sub xB xA sub Atan def GetEdgeA w xA1 xB sub yA1 yB
sub Pyth Pyth w Div CLW 2 div mul 2 div dup AngleA sin mul yA1 add /yA1
ED AngleA cos mul xA1 add /xA1 ED /LPutVar [ xA1 yA1 m { xB w add yB xB
w sub yB } { xB yB w sub xB yB w add } ifelse xA1 yA1 ] cvx def /LPutPos
{ LPutLines } def /VPutPos@ { LPutVar flag { 8 4 roll pop pop pop pop }
{ pop pop pop pop 4 2 roll } ifelse } def /VPutPos { VPutPos@ VPutLine }
def /HPutPos { VPutPos@ HPutLine } def mark LPutVar tx@Dict begin
/ArrowA { moveto } def /ArrowB { } def false Line closepath end } def
%
/LPutCoor { 
  NAngle 
  tx@Dict begin /NAngle ED end 
  gsave 
  CM STV 
  CP Y sub neg exch X sub neg exch moveto 
  setmatrix CP 
  grestore 
} def
%
/LPut { 
  tx@NodeDict /LPutPos known 
    { LPutPos } { CP /Y ED /X ED /NAngle 0 def } ifelse 
  LPutCoor  
} def
%
/HPutAdjust { 
  Sin Cos mul 0 eq 
    { 0 } 
    { d Cos mul Sin div flag not { neg } if 
      h Cos mul Sin div flag { neg } if 
      2 copy gt { pop } { exch pop } ifelse 
    } ifelse 
  s add flag { r add neg }{ l add } ifelse 
  X add /X ED 
} def
%
/VPutAdjust { 
  Sin Cos mul 
  0 eq 
    { 0 }
    { l Sin mul Cos div flag { neg } if
      r Sin mul Cos div flag not { neg } if 
      2 copy gt { pop } { exch pop } ifelse 
    } ifelse 
  s add flag { d add } { h add neg } ifelse 
  Y add /Y ED 
} def
%
%
end
%
% END pst-node.pro

%%EndProcSet
%%BeginProcSet: pst-coil.pro 0 0
%!ps
% PostScript prologue for pst-coil.tex.
% Version 1.06, 2011/09/18
% For distribution, see pstricks.tex.
%
/tx@CoilDict 40 dict def tx@CoilDict begin
/CoilLoop { 
  /t ED 
  t sin AspectSin mul t 180 div AspectCos mul add t cos lineto } def
/Coil { 
  /Inc ED 
  dup sin /AspectSin ED 
  cos /AspectCos ED 
  /ArmB ED 
  /ArmA ED
  /h ED /w ED /y1 ED /x1 ED /y0 ED /x0 ED 
  x0 y0 translate y1 y0 sub x1 x0 sub 2 copy Pyth 
  /TotalLength ED 
  Atan rotate 
  /BeginAngle ArmA AspectCos Div w h mul Div 360 mul def 
  /EndAngle TotalLength ArmB sub AspectCos Div
    w h mul Div 360 mul def 
  1 0 0 0 ArrowA ArmA 0 lineto 
  /mtrx CM def 
  w h mul 2 Div w 2 Div scale BeginAngle Inc 
  EndAngle { CoilLoop } for
  EndAngle CoilLoop mtrx setmatrix TotalLength ArmB sub 0 lineto CP
% DG/SR modification begin - Jun.  2, 1998 - Patch 1 (from Michael Vulis)
% TotalLength 0 ArrowB lineto } def
  TotalLength 0 ArrowB lineto
  pop pop pop pop } def
% DG/SR modification end
%
/Sin { 
  /Func ED
  /PointsPerPeriod ED
  /ArmB ED 
  /ArmA ED
  /Amplitude ED 
  /roundValue ED
  /relativePeriod ED 
  /Periods ED 
  /y1 ED /x1 ED /y0 ED /x0 ED 
  x0 y0 translate y1 y0 sub x1 x0 sub 2 copy Pyth 
  dup /TotalLength ED
  ArmA sub ArmB sub /SinLength ED 
  Atan rotate 
  1 0 0 0 ArrowA ArmA 0 lineto 
  /mtrx CM def 
  relativePeriod 
    {} 
    { SinLength Periods div 
      roundValue dup 0 eq { pop cvi } { 1 eq { round } if } ifelse
      /Periods ED } ifelse
  /dxStep SinLength 360 div def         % the default step for x pos
  /xStep 360 PointsPerPeriod div def    % the step for the for loop
  1 xStep 360 {                         % PointsPerPeriod times
    dup dxStep mul ArmA add exch        % x pos and value for the func
    Periods mul Func Amplitude mul lineto
  } for
  mtrx setmatrix TotalLength ArmB sub 0 lineto CP
  TotalLength 0 ArrowB lineto
  pop pop pop pop 
} def
%
/AltCoil { 
  /Inc ED 
  dup sin /AspectSin ED 
  cos /AspectCos ED /h ED /w ED /EndAngle ED /BeginAngle ED 
  /mtrx CM def 
  w h mul 2 Div w 2 Div scale BeginAngle sin AspectSin mul 
  BeginAngle 180 div AspectCos mul add BeginAngle cos 
  /lineto load stopped { moveto } if 
  BeginAngle Inc EndAngle { CoilLoop } for 
  EndAngle CoilLoop mtrx setmatrix } def
/ZigZag { 15 dict begin 
  /ArmB ED /ArmA ED 
  2 div /w ED 
  w mul /h ED /y1 ED /x1 ED /y0 ED /x0 ED 
  x1 y1 translate y0 y1 sub x0 x1 sub 2 copy Pyth 
  /TotalLength ED
  Atan rotate TotalLength ArmA sub ArmB sub dup h div cvi /n ED n h mul
  sub 2 div dup ArmA add 
  /ArmA ED ArmB add 
  /ArmB ED 
  /x ArmB h 2 div add def 
  mark 0 0 ArmB 0 
  n { x w /w w neg def /x x h add def } repeat
  TotalLength ArmA sub 0 TotalLength 0 
  end } def
%
 /ZigZagCirc { % x0 y0 x1 y1 bow h w ArmA ArmB on stack
  /bow ED 
  /ArmB ED /ArmA ED 
  2 div /w ED 
  w mul /h ED /y1 ED /x1 ED /y0 ED /x0 ED 
  x1 y1 translate %
  y0 y1 sub x0 x1 sub 2 copy Pyth 2 div 
  /HalfLength ED
  Atan /ang ED %angle of A relative to B
  %rotate % so end B is origin and BA is horizontal, A to right
  /theta bow abs HalfLength Atan 2 mul def %halfangular sector for arc
  /theta2 theta 2 mul def % full arc
  %/psi ang 90 sub theta sub def % angle of B from center if bow>0
  /rho HalfLength theta sin div def % radius of circle
  bow 0 gt { /direc 1 def /thetaB ang 90 sub theta sub def } % travel B to A in pos drn
  { /direc -1 def /thetaB ang 90 add theta add def } ifelse % travel B to A in neg drn
  %thetaB=angle from center to B
  rho thetaB 180 add PtoC translate % origin now at center
  /h h rho div RadtoDeg def
  /ArmA ArmA rho div RadtoDeg def /ArmB ArmB rho div RadtoDeg def
  theta2 ArmA sub ArmB sub dup h div cvi /n ED n h mul
  %HalfLength 2 mul ArmA sub ArmB sub dup h div cvi /n ED n h mul
  sub 2 div dup ArmA add 
  /ArmA ED ArmB add /ArmB ED 
  /h h direc mul def % h is now angle increment for half-period
  /rhoo rho w add def /rhoi rho w sub def % outer and inner radii
  /arg thetaB ArmB direc mul add def % argument for 2nd point
%  thetaB = direc = bow = HalfLength = theta = rho = arg = h = n =
  mark rho thetaB  PtoC  rho arg PtoC /arg arg h 2 div add def
  n { w 0 gt { rhoo }{ rhoi } ifelse arg PtoC /w w neg def /arg arg h add def } repeat
  rho thetaB theta2 ArmA sub direc mul add  PtoC rho thetaB theta2 direc mul add PtoC  
  } def 
%
end
% END pst-coil.pro

%%EndProcSet
%%BeginProcSet: pst-text.pro 0 0
%!
% PostScript header file pst-text.pro
% Version 1.0, 2005-11-29 (hv)
% For distribution, see pstricks.tex.

/tx@TextPathDict 40 dict def
tx@TextPathDict begin

% Syntax:  <dist> PathPosition -
% Function: Searches for position of currentpath distance <dist> from
%           beginning. Sets (X,Y)=position, and Angle=tangent.
/PathPosition
{ /targetdist exch def
  /pathdist 0 def
  /continue true def
  /X { newx } def /Y { newy } def /Angle 0 def
  gsave
    flattenpath
    { movetoproc }  { linetoproc } { } { firstx firsty linetoproc }
    /pathforall load stopped { pop pop pop pop /X 0 def /Y 0 def } if
  grestore
} def

/movetoproc { continue { @movetoproc } { pop pop } ifelse } def

/@movetoproc
{ /newy exch def /newx exch def
  /firstx newx def /firsty newy def
} def

/linetoproc { continue { @linetoproc } { pop pop } ifelse } def

/@linetoproc {
  /oldx newx def /oldy newy def
  /newy exch def /newx exch def
  /dx newx oldx sub def
  /dy newy oldy sub def
  /dist dx dup mul dy dup mul add sqrt def
  /pathdist pathdist dist add def
  pathdist targetdist ge
  { pathdist targetdist sub dist div dup
    dy mul neg newy add /Y exch def
    dx mul neg newx add /X exch def
    /Angle dy dx atan def
    /continue false def
  } if
} def

/TextPathShow { 
  /String exch def
  /CharCount 0 def
% hv begin 2005-11-29   1.00
%   String length
%   { String CharCount 1 getinterval ShowChar
%     /CharCount CharCount 1 add def
   /CharSize 1 def
   currentfont /FontType get 0 eq
   { currentfont /FMapType get dup 2 eq exch dup 5 eq exch 9 eq or or
     { /CharSize 2 def} if
   } if
   String length CharSize idiv
   { String CharCount CharSize getinterval ShowChar
     /CharCount CharCount CharSize add def
% hv end 2005-11-29   1.00
  } repeat
} def

% Syntax: <pathlength> <position> InitTextPath -
/InitTextPath
{ gsave
    currentpoint /Y exch def /X exch def
    exch X Hoffset sub sub mul
    Voffset Hoffset sub add
    neg X add /Hoffset exch def
    /Voffset Y def
  grestore
} def

/Transform
{ PathPosition
  dup
  Angle cos mul Y add exch
  Angle sin mul neg X add exch
  translate
  Angle rotate
} def

/ShowChar { 
  /Char exch def
  gsave
    Char end stringwidth
    tx@TextPathDict begin
    2 div /Sy exch def 2 div /Sx exch def

%%%  MV 10-09-99 00:36
    /sc?currentpoint where {pop sc?currentpoint} {currentpoint} ifelse
%   currentpoint

    Voffset sub Sy add exch
    Hoffset sub Sx add
    Transform
    Sx neg Sy neg moveto
    Char end tx@TextPathSavedShow
    tx@TextPathDict begin
  grestore
  Sx 2 mul Sy 2 mul rmoveto
} def
%
end
% END pst-text.pro

%%EndProcSet
%%BeginProcSet: pst-3d.pro 0 0
%% $Id: pst-3d.pro 247 2010-01-04 22:45:42Z herbert $
% PostScript prologue for pst-3d.tex.
% Version 0.01, 2010/01/01 
%
/tx@3Ddict 300 dict def 
tx@3Ddict begin
%
/SetMatrixThreeD {
  dup sin /e ED cos /f ED
  /p3 ED /p2 ED /p1 ED
  p1 0 eq
  { /a 0 def /b p2 0 le { 1 } { -1 } ifelse def
    p3 p2 abs
  }
  { p2 0 eq
    { /a p1 0 lt { -1 } { 1 } ifelse def /b 0 def
      p3 p1 abs
    }
    { p1 dup mul p2 dup mul add sqrt dup
      p1 exch div /a ED
      p2 exch div neg /b ED
      p3 p1 a div
    }
    ifelse
  }
  ifelse
  atan dup sin /c ED cos /d ED
  /Matrix3D
  [
    b f mul c a mul e mul sub
    a f mul c b mul e mul add
    d e mul
    b e mul neg c a mul f mul sub
    a e mul neg c b mul f mul add
    d f mul
  ] def
} def
%
/ProjThreeD {
  /z ED /y ED /x ED
  Matrix3D aload pop
  z mul exch y mul add exch x mul add
  4 1 roll
  z mul exch y mul add exch x mul add
  exch
} def
%
/SetMatrixEmbed {
  SetMatrixThreeD
  Matrix3D aload pop
  /z3 ED /z2 ED /z1 ED /x3 ED /x2 ED /x1 ED
  SetMatrixThreeD
  [
  Matrix3D aload pop
  z3 mul exch z2 mul add exch z1 mul add 4 1 roll
  z3 mul exch z2 mul add exch z1 mul add
  Matrix3D aload pop
  x3 mul exch x2 mul add exch x1 mul add 4 1 roll
  x3 mul exch x2 mul add exch x1 mul add
  3 -1 roll 3 -1 roll 4 -1 roll 8 -3 roll 3 copy
  x3 mul exch x2 mul add exch x1 mul add 4 1 roll
  z3 mul exch z2 mul add exch z1 mul add
  ]
  concat
} def
%
/TMSave {
  tx@Dict /TMatrix known not { /TMatrix { } def /RAngle { 0 } def } if 
  /TMatrix [ TMatrix CM ] cvx def 
} def
%
/TMRestore { CP /TMatrix [ TMatrix setmatrix ] cvx def moveto } def
%
/TMChange {
  TMSave
  /cp [ currentpoint ] cvx def % ??? Check this later.
  CM
  CP T STV
  CM matrix invertmatrix    % Inv(M')
  matrix concatmatrix       % M Inv(M')
  exch exec
  concat cp moveto
} def
%
end % of tx@3Ddict
%%
%% End of file `pst-3d.pro'.

%%EndProcSet
%%BeginProcSet: pst-math.pro 0 0
%                           -*- Mode: Postscript -*-
% pst-math.pro --- PostScript header file pst-math.pro
%
% Author          : Christophe JORSSEN 
% Author          : Herbert Vo <hvoss@tug.org>
% Created the     : Sat 20 March 2004
% Last Mod        : $Date: 2010/10/02 $
% Version         : 0.62 $
%
/PI 3.14159265359 def
/ENeperian 2.71828182846 def
%
/DegToRad {PI mul 180 div} bind def
/RadToDeg {180 mul PI div} bind def
%
/COS {RadToDeg cos} bind def
/SIN {RadToDeg sin} bind def
/TAN {dup SIN exch COS Div} bind def
/tan {dup sin exch cos Div} bind def
/ATAN {neg -1 atan 180 sub DegToRad} bind def
/ACOS {dup dup mul neg 1 add sqrt exch atan DegToRad} bind def
/acos {dup dup mul neg 1 add sqrt exch atan} bind def
/ASIN {neg dup dup mul neg 1 add sqrt neg atan 180 sub DegToRad} bind def
/asin {neg dup dup mul neg 1 add sqrt neg atan 180 sub} bind def
%
/EXP {ENeperian exch exp} bind def
%
/COSH {dup EXP exch neg EXP add 2 div} bind def
/SINH {dup EXP exch neg EXP sub 2 div} bind def
/TANH {dup SINH exch COSH div} bind def
/ACOSH {dup dup mul 1 sub sqrt add ln} bind def
/ASINH {dup dup mul 1 add sqrt add ln} bind def
/ATANH {dup 1 add exch neg 1 add Div ln 2 div} bind def
%
%/SINC {dup SIN exch Div} bind def
/SINC { dup 0 eq { pop 1 } { dup SIN exch div } ifelse } bind def

/GAUSS {dup mul 2 mul dup 4 -2 roll sub dup mul exch div neg EXP exch PI mul sqrt div} bind def
%
/GAMMA { 2 dict begin				% hv 2007-08-30
  /z exch def
  1.000000000190015				% p(0)
  0 1 5 {					% on stack is 0 1 2 3 4 5 
    dup 					% n-1 n-1
    [ 76.18009172947146 
     -86.50532032941677 
      24.0140982483091 
      -1.231739572450155
       0.1208650973866179E-2 
      -0.5395239384953E-5      ] exch get exch 	% p(n) n-1
      1 add z add div			     	% p(n)/(z+n)
      add					% build the sum
    } for
    Pi 2 mul sqrt z div mul
    z 5.5 add z 0.5 add exp mul ENeperian z 5.5 add neg exp mul 
  end } bind def
%    
/GAMMALN {dup dup dup 5.5 add dup ln 3 -1 roll .5 add mul sub neg 1.000000000190015
    0 1 5 {
    [76.18009172947146 -86.50532032941677 24.0140982483091 -1.231739572450155
    .1208650973866179E-2 -.5395239384953E-5 2.5066282746310005] exch get
    4 -1 roll 1 add dup 5 1 roll div add} for
    4 -1 roll div 2.5066282746310005 mul ln add exch pop} bind def
/BETA {2 copy add GAMMALN neg exch GAMMALN 3 -1 roll GAMMALN EXP} bind def
%
/HORNER {aload length
    dup 2 add -1 roll
    exch 1 sub {
        dup 4 1 roll
        mul add exch
    } repeat
    pop
} bind def
%
/BESSEL_J0 {dup abs 8 lt {
    dup mul dup [57568490574 -13362590354 651619640.7 -11214424.18 77392.33017 -184.9052456] HORNER
    exch [57568490411 1029532985 9494680.718 59272.64853 267.8532712 1] HORNER
    Div}
    {abs dup .636619772 exch div sqrt exch dup .785398164 sub exch 8 exch div dup dup mul dup 
    [1 -1.098628627E-2 .2734510407E-4 -.2073370639E-5 .2093887211E-6] HORNER
    3 index COS mul
    exch [-.1562499995E-1 .1430488765E-3 -.6911147651E-5 .7621095161E-6 -.934945152E-7] HORNER
    4 -1 roll SIN mul 3 -1 roll mul neg add mul} 
    ifelse} bind def
%
/BESSEL_Y0 {dup 8 lt {
    dup dup mul dup [-2957821389 7062834065 -512359803.6 10879881.29 -86327.92757 228.4622733] HORNER
    exch [40076544269 745249964.8 7189466.438 47447.26470 226.1030244 1] HORNER
    Div exch dup ln exch BESSEL_J0 .636619772 mul mul add}
    {dup .636619772 exch div sqrt exch dup .785398164 sub exch 8 exch div dup dup mul dup 
    [1 -.1098628627E-2 .2734510407E-4 -.2073370639E-5 .2093887211E-6] HORNER
    3 index SIN mul
    exch [-.1562499995E-1 .1430488765E-3 -.6911147651E-5 .7621095161E-6 -.934945152E-7] HORNER
    4 -1 roll COS mul 3 -1 roll mul add mul} 
    ifelse} bind def
%
/BESSEL_J1 {dup abs 8 lt {
    dup dup mul dup 3 -2 roll [72362614232 -7895059235 242396853.1 -2972611.439 15704.48260 -30.16036606] HORNER mul
    exch [144725228442 2300535178 18583304.74 99447.43394 376.9991397 1] HORNER
    Div}
    {dup abs dup .636619772 exch div sqrt exch dup 2.356194491 sub exch 8 exch div dup dup mul dup 
    [1 .183105E-2 -.3516396496E-4 .2457520174E-5 -.240337019E-6] HORNER
    3 index COS mul
    exch [.04687499995 6.2002690873E-3 .8449199096E-5 -.88228987E-6 .105787412E-6] HORNER
    4 -1 roll SIN mul 3 -1 roll mul neg add mul exch dup abs Div mul} 
    ifelse} bind def
%
/BESSEL_Y1 {dup 8 lt {
    dup dup dup mul dup [-.4900604943E13 .1275274390E13 -.5153428139E11 .7349264551E9 -.4237922726E7 .8511937935E4] HORNER
    exch [.2499580570E14 .4244419664E12 .3733650367E10 .2245904002E8 .1020426050E6 .3549632885E3 1] HORNER
    Div mul exch dup dup ln exch BESSEL_J1 mul exch 1 exch div sub .636619772 mul add}
    {dup .636619772 exch div sqrt exch dup 2.356194491 sub exch 8 exch div dup dup mul dup 
    [1 .183105E-2 -.3516396496E-4 .2457520174E-5 -.240337019E-6] HORNER
    3 index SIN mul
    exch [.04687499995 -.2002690873E-3 .8449199096E-5 6.88228987E-6 .105787412E-6] HORNER
    4 -1 roll COS mul 3 -1 roll mul add mul} 
    ifelse} bind def
%
% En cours...
/BESSEL_Yn {dup 0 eq {pop BESSEL_Y0}{dup 1 eq {pop BESSEL_Y1}{
    exch dup BESSEL_Y0 exch dup BESSEL_Y1 exch 2 exch Div {
        mul 3 -1 roll mul 2 index sub pstack} for
    } ifelse } ifelse } bind def
%
/SIMPSON { 1 dict begin  %% on stack a b var f ierr  Dominik Rodriguez
  3 index 5 index sub                                % compute h
  1                                                  % a b var f ierr h n
  4 index 7 index def 3 index exec                   % a b var f ierr h n f(a)
  5 index 7 index def 4 index exec add               % a b var f ierr h n f(a)+f(b)
  5 index 8 index 4 index 2 div add def 4 index exec % a b var f ierr h n f(a)+f(b) f(a+h/2)
  exch 1 index 4 mul add 0  % a b var f ierr h n old=f(a+h/2) Estim=f(a)+f(b)+4f(a+h/2) NbLoop
    {                                                % a b var f ierr h n old Estim NbLoop
      5 -1 roll 2 div dup 6 1 roll              % h<-h/2
      5 -1 roll 2 mul 5 1 roll                  % n<-2n
                                                % a b var f ierr h n old Estim NbLoop h
      2 div 10 index add 0                      % a b var f ierr h n old Estim NbLoop a+h/2 Cumul
      5 index { 
        1 index 10 index exch def 8 index exec add exch 6 index add exch 
      } repeat                                  % a b var f ierr h n old Estim NbLoop a+nh/2 Cumul
      exch pop                                  % a b var f ierr h n old Estim NbLoop New
      2 index 1 index 4 mul 6 -1 roll 2 mul sub sub % a b var f ierr h n Estim NbLoop New Diff
      4 -1 roll 2 mul 1 index sub 4 1 roll          % a b var f ierr h n Estim NbLoop New Diff
      exch 4 1 roll                             % a b var f ierr h n old Estim NbLoop Diff
      5 index 6 div mul abs 6 index lt { exit } if
      1 add dup 9 eq { exit } if
  } loop                                        % a b var f ierr h n old Estim NbLoop
  exch 5 -1 roll 6 div mul mark 10 2 roll cleartomark
end 
} def
% ------------------------------------ math stuff ----------------------------------
%
% Matrix A in arrays of rows A[[row1][row2]...]
% with [row1]=[a11 a12 ... b1]
% returns on stack solution vector X=[x1 x2 ... xn]
/SolveLinEqSystem { 				% on stack matrix M=[A,b] (A*x=b)
  10 dict begin					% hold all ocal
    /A exch def
    /Rows A length def         			% Rows = number of rows
    /Cols A 0 get length def   			% Cols = number of columns
    /Index [ 0 1 Rows 1 sub { } for ] def	% Index = [0 1 2 ... Rows-1]
    /col 0 def
    /row  0 def
    /PR Rows array def 				% PR[c] = pivot row for row row
  { 						% starts the loop, find pivot entry in row r
    col Cols ge row  Rows ge or { exit } if	% col < Cols and row < Rows else exit
    /pRow row def  				% pRow = pivot row		
    /max A row  get col get abs def		% get A[row[col]], first A[0,0] 
    row 1 add 1 Rows 1 sub { 			% starts for loop 1 1 Rows-1
      /j exch def				% index counter
      /x A j get col get abs def		% get A[j[r]]
      x max gt {				% x>max, then save position
        /pRow j def
        /max x def
      } if
    } for					% now we have the row with biggest A[0,1]
						% with pRow = the pivot row
    max 0 gt {					% swap entries pRow and row  in i 
      /tmp Index row  get def
      Index row  Index pRow get put
      Index pRow tmp put			% and columns pRow and row  in A
      /tmp A row get def
      A row  A pRow get put
      A pRow tmp put   				% pivot
      /row0  A row  get def 			% the pivoting row
      /p0 row0  col get def 			% the pivot value
      row 1 add 1 Rows 1 sub { 			% start for loop
        /j exch def
        /c1 A j get def
        /p c1 col get p0 div def
        c1 col p put				% subtract (p1/p0)*row[i] from row[j]
        col 1 add 1 Cols 1 sub {		% start for loop
          /i exch def
          c1 dup i exch 			% c1 i c1
          i get row0 i get p mul sub put
        } for
      } for
      PR row col put
      /col col 1 add def
      /row row 1 add def
    }{						% all zero entries
      /row row 1 add def			% continue loop with same row
    } ifelse
  } loop
  /X A def					% solution vector
  A Rows 1 sub get dup
  Cols 1 sub get exch
  Cols 2 sub get div
  X Rows 1 sub 3 -1 roll put  			% X[n]
  Rows 2 sub -1 0 {				% for loop to calculate X[i]
    /xi exch def				% current index
    A xi get 					% i-th row
    /Axi exch def
    /sum 0 def
    Cols 2 sub -1 xi 1 add { 
      /n exch def
      /sum sum Axi n get X n get mul add def 
    } for
    Axi Cols 1 sub get 				% b=Axi[Cols-1]
    sum sub 					% b-sum
    Axi xi get div				% b-sum / Axi[xi]
    X xi 3 -1 roll put  			% X[xi]
  } for
  X
  end 
} def
%
/c@_0 2.515517 def 
/c@_1 0.802853 def 
/c@_2 0.010328 def 
/d@_1 1.432788 def 
/d@_2 0.189269 def 
/d@_3 0.001308 def 
/norminv {
  5 dict begin
  neg 1 add 1 exch div ln 2 mul sqrt 
  /t exch def 
  /t2 t dup mul def 
  /t3 t2 t mul def 
  c@_0 c@_1 t mul add c@_2 t2 mul add 1 d@_1 t mul add 
  d@_2 t2 mul add d@_3 t3 mul add div neg t add 
  end
} def 
%end{norminv Michael Sharpe}
%
%
% END pst-math.pro

%%EndProcSet
%%BeginProcSet: pstricks-add.pro 0 0
%% $Id: pstricks-add.pro 328 2010-05-24 15:56:43Z herbert $
% PostScript prologue for pstricks-add.tex.
% Version 0.23, 2009/12/17 
%
/tx@addDict 410 dict def tx@addDict begin
%%
realtime srand % set random generator
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/GTriangle {
  gsave
  /mtrx CM def
  /colorA ED /colorB ED /colorC ED 	% save the colors
  /yA ED /xA ED               		% save the origin
  xA yA translate
  rotate       		        	% \psk@gangle
  /yB ED /xB ED /yC ED /xC ED   	% save other coordinates
  /ds [                % save data in a array
     0 0 0 colorA aload pop     	% fd x y xr xg xb
     0 xB xA sub yB yA sub colorB aload pop
     0 xC xA sub yC yA sub colorC aload pop
%     1 xC xB add yB colorA aload pop  	% for use with 4 points ABCD
  ] def
  newpath
  <<
  /ShadingType 4           % single Gouraud
  /ColorSpace [ /DeviceRGB ]
  /DataSource ds
  >> 
  shfill
  closepath
  mtrx
  setmatrix grestore} def
%
/RGBtoCMYK {    % on stack r g b -> C M Y K
  3 dict begin
  /Blue ED /Green ED /Red ED
  1 Red sub     % Cyan
  1 Green sub   % Magenta
  1 Blue sub    % Yellow
  0   		% Black  
  end
} def
%
/CMYKtoGRAY { % on stack c m y k -> gray
  exch 0.11 mul add
  exch 0.59 mul add
  exch 0.3 mul add
  dup 1 gt { pop 1 }  if 
  neg 1 add 
} def
%
/RGBtoGRAY { % on stack r g b -> gray
  0.11 mul
  exch 0.59 mul add
  exch 0.3 mul add 
} def
%
/HSBtoGRAY { 
  6 dict begin
  /b exch def 
  /s exch def 6 mul dup cvi dup 
  /i exch def sub 
  /f exch def
  /F [[0 1 f sub 1][f 0 1][1 0 1 f sub][1 f 0][1 f sub 1 0][0 1 f][0 1 1]] def
  F i get { s mul neg 1 add b mul} forall
  0.11 mul
  exch 0.59 mul add
  exch 0.3 mul add 
  end
} def
%
%% convertisseur longueur d'onde ->R,G,B       Manuel Luque
%% lambda max=780 nanometres
%% lambda min=380 nanometres
%% adaptation de :
%% http://www.physics.sfasu.edu/astro/color.html
%% www.efg2.com/lab
%
/Gamma 0.8 def
/calculateRGB {
  lambda 379 le {/Red 0 def /Green 0 def /Blue 0 def} if
  lambda 781 ge {/Red 0 def /Green 0 def /Blue 0 def} if
  lambda 380 ge {lambda 439 le {
    /R {lambda 440 sub neg 440 380 sub div} def
    /Red R factor mul Gamma exp def
    /G 0 def
    /Green G factor mul Gamma exp def
    /B 1 def
    /Blue B factor mul Gamma exp def} if
  } if
  lambda 440 ge { lambda 489 le {
    /G {lambda 440 sub 490 440 sub div} def
    /Green G factor mul Gamma exp def
    /R 0 def /Red 0 def
    /B 1 def
    /Blue B factor mul Gamma exp def } if
  } if
  lambda 490 ge {lambda 509 le {
    /B {lambda 510 sub neg 510 490 sub div} def
    /Blue B factor mul Gamma exp def
    /R 0 def /Red 0 def
    /G 1 def
    /Green G factor mul Gamma exp def } if
  } if
  lambda 510 ge {lambda 579 le {
    /R {lambda 510 sub 580 510 sub div } def
    /Red R factor mul Gamma exp def
    /Blue 0 def
    /G 1 def
    /Green G factor mul Gamma exp def } if
  } if
  lambda 580 ge {lambda 644 le {
    /G {lambda 645 sub neg 645 580 sub div } def
    /Green G factor mul Gamma exp def
    /Blue 0 def
    /R 1 def
    /Red R factor mul Gamma exp def } if
  } if
  lambda 645 ge { lambda 780 le {
    /Red 1 factor mul Gamma exp def
    /Blue 0 def
    /Green 0 def } if
  } if
} def
%
/factor {
  lambda 380 ge {lambda 419 le { 0.3 0.7 lambda 380 sub mul 420 380 sub div add} if } if
  lambda 420 ge {lambda 700 le { 1 } if } if
  lambda 701 ge {lambda 780 le { 0.3 0.7 780 lambda sub mul 780 700 sub div add} if } if
} def
%
/wavelengthToRGB { % the wavelength in nm must be on top of the stack
  cvi /lambda exch def % no floating point here
  calculateRGB
} def %  now the colors are saved in Red Green Blue
%
/wavelengthToGRAY { % the wavelength in nm must be on top of the stack
  cvi /lambda exch def % no floating point here
  calculateRGB
  Red Green Blue RGBtoGRAY
} def %  now the gray color is on the stack
%
/wavelengthToCMYK { % the wavelength in nm must be on top of the stack
  cvi /lambda exch def % no floating point here
  gsave
  calculateRGB Red Green Blue RGBtoCMYK 
  /Black ED /Yellow ED /Magenta ED /Cyan ED
  grestore
} def %  now the colors are saved in Cyan Magenta Yellow Black
%
/axfill {
    8 dict begin
    /xw exch def /nl exch def
    /C1 exch def /y1 exch def/x1 exch def
    /C0 exch def /y0 exch def/x0 exch def
    <<  /ShadingType 2
        /ColorSpace /DeviceRGB
        /Coords [ x0 y0 x1 y1 ]
        /EmulatorHints [ xw 2 div dup ]
        /Function <<
            /FunctionType 2
            /Domain [0 1]
            /C0 C0
            /C1 C1
            /N      1
        >>
    >> shfill
    end
} bind def
%
%/amplHand {.8} def 
%/dtHand 2 def
/varHand { rand sin amplHand mul add } def
/MovetoByHand { moveto } def 
%/MovetoByHand { /y0 ED /x0 ED x0 y0 moveto } def 
/LinetoByHand { 4 dict begin
  /y1 ED /x1 ED 
  currentpoint /y0 ED /x0 ED
  x0 x1 sub dup mul y0 y1 sub dup mul add sqrt /dEnd ED
  0 dtHand dEnd { dup
    x1 x0 sub mul dEnd div x0 add varHand exch  
    y1 y0 sub mul dEnd div y0 add varHand lineto
  } for
%  /x0 x1 def /y0 y1 def
  end
} def  
%
end
%
% END pstricks-add.pro

%%EndProcSet
%%BeginProcSet: pst-eucl.pro 0 0
%!
% PostScript prologue for pst-eucl.tex.
% Version 1.00 2011/08/04
% For distribution, see pstricks.tex.
%
/tx@EcldDict 40 dict def tx@EcldDict begin
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Pi
/Pi 3.14159265359 def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% e
/E 2.718281828459045 def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% x -> true (if |x| < 1E-6)
/ZeroEq { abs 1E-6 lt } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% x1 y1 x2 y2 -> a b c (ax-by+c=0 with a^2+b^2=1)
/EqDr {
  4 copy 3 -1 roll sub 7 1 roll exch sub 5 1 roll 4 -1 roll
  mul 3 1 roll mul exch sub
  2 index dup mul 2 index dup mul add sqrt
  4 -1 roll 1 index div exch
  4 -1 roll 1 index div exch
  4 -1 roll 1 index div exch pop
} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% orthogonal projection of M1 onto (OM2)
%% x1 y1 x2 y2 -> x3 y3
/Project {
  2 copy dup mul exch dup mul add 5 1 roll 2 copy 5 -1 roll mul exch
  5 -1 roll mul add 4 -1 roll div dup 4 -1 roll mul exch 3 -1 roll mul
} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a b c (ax2+bx+c=0) -> x1 y1
/SolvTrin {
  /c exch def /b exch def /a exch def
  b dup mul a c mul 4 mul sub dup 0 lt
  { pop 0 0 } %% no solutions
  {sqrt dup b neg add a 2 mul div exch b add neg 2 a mul div }
  ifelse } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% x1 y1 x2 y2 -> Dist
/ABDist { 3 -1 roll sub dup mul 3 1 roll sub dup mul add sqrt } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% x1 y1 x2 y2 -> x1-x2  y1-y2
/ABVect { 3 -1 roll exch sub 3 1 roll sub exch } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% x1 y1 x2 y2 x3 y3 x4 y4 -> x y
/InterLines {
  EqDr /D1c exch def /D1b exch def /D1a exch def
  EqDr /D2c exch def /D2b exch def /D2a exch def
  D1a D2b mul D1b D2a mul sub dup ZeroEq
%   { pop pop pop 0 0 } %% parallel lines  % --- hv 20110714
   { pop 0 0 } %% parallel lines             --- hv 20110714
   {
    /Det exch def
    D1b D2c mul D1c D2b mul sub Det div
    D1a D2c mul D2a D1c mul sub Det div
   } ifelse  } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a b c R -> x1 y1 x2 y2
/InterLineCircle {
  /CR exch def /Dc exch def neg /Db exch def /Da exch def
  ABVect /Vy exch def /Vx exch def
  %% Dc==0 then O belong to the line
  %% First project O on the line -> M (-ca;-cb)
  %% l'abscisse de M sur (OM) divise par R donne le cosinus
  %Dc neg dup Db mul exch Da mul 2 copy 0 0
  %ABDist dup CR gt { pop pop pop 0 0 0 0 }
  %{ ZeroEq { pop pop Db Da } if Atan /alpha exch def
  Dc abs CR gt { 0 0 0 0 } 
  { Db neg Da neg Atan /alpha exch def
  Dc CR div dup dup mul 1 exch sub sqrt exch Atan /beta exch def
  alpha beta add dup cos CR mul exch sin CR mul
  alpha beta sub dup cos CR mul exch sin CR mul
  4 copy ABVect Vy mul 0 le exch Vx mul 0 le and
  { 4 2 roll } if } ifelse
 } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% R R' OO' -> x1 y1 x2 y2
/InterCircles {
  /OOP exch def /CRP exch def /CR exch def
  OOP dup mul CRP dup mul sub CR dup mul add OOP div 2 div
  dup dup mul CR dup mul exch sub dup
  0 lt { pop pop 0 0 0 0 } { sqrt 2 copy neg } ifelse
} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% x y theta -> x' y' (rotation of theta)
/Rotate {
  dup sin /sintheta exch def cos /costheta exch def /y exch def /x exch def
  x costheta mul y sintheta mul sub
  y costheta mul x sintheta mul add
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% N -> x y
/GetNode {
  tx@NodeDict begin
    tx@NodeDict 1 index known { load GetCenter } { pop 0 0 } ifelse
  end
} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% x -> ch(x)
/ch { dup Ex exch neg Ex add 2 div } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% x -> sh(x)
/sh { dup Ex exch neg Ex sub 2 div } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% x -> e^(x)
/Ex { E exch exp } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% x f g -> x y n
/NewtonSolving {
  /g exch def /f exch def 0
  { %%% STACK: x0 n
    1 add exch %% one more loop
    dup ZeroEq
    { dup 0.0005 add fgeval
      1 index 0.0005 sub fgeval sub .001 div }
    { dup 1.0005 mul fgeval
      1 index 0.9995 mul fgeval sub .001 2 index mul div } ifelse  %%% STACK: n x0 fg'(x0)
    %%% compute x1=x0-fg(x0)/fg'(x0)
    1 index fgeval exch div dup 4 1 roll sub exch %% stack: dx x0 n
    3 -1 roll ZeroEq              %% exit if root found
    1 index 100 eq or { exit } if %% or looping for more than 100 times
  } loop
  dup 100 lt { exch dup /x exch def f } { pop 0 0 } ifelse
  3 -1 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/fgeval { /x exch def f g sub } bind def
end
% END ps-euclide.pro

%%EndProcSet
%%BeginProcSet: pst-barcode.pro 0 0
%!PS-Adobe-2.0
%%Creator: Terry Burton
%%DocumentPaperSizes: a4
%%EndComments

% Barcode Writer in Pure PostScript - Version 2011-03-09
% http://www.terryburton.co.uk/barcodewriter/
%
% Copyright (c) 2004-2011 Terry Burton
%
% Permission is hereby granted, free of charge, to any
% person obtaining a copy of this software and associated
% documentation files (the "Software"), to deal in the
% Software without restriction, including without
% limitation the rights to use, copy, modify, merge,
% publish, distribute, sublicense, and/or sell copies of
% the Software, and to permit persons to whom the Software
% is furnished to do so, subject to the following
% conditions:
%
% The above copyright notice and this permission notice
% shall be included in all copies or substantial portions
% of the Software.
%
% THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY
% KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO
% THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
% PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
% THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
% DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
% CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
% CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
% IN THE SOFTWARE.

% Uncomment this next line to allow these named resource
% definitions to remain resident within a printer's
% PostScript virtual machine so that the barcode generation
% capability persists between jobs.

% serverdict begin 0 exitserver 

% --BEGIN TEMPLATE--

% --BEGIN PREAMBLE--
currentglobal
true setglobal
/Generic /Category findresource
dup length 1 add dict copy
dup /InstanceType /packedarraytype put
/uk.co.terryburton.bwipp exch /Category defineresource pop
setglobal
% --END PREAMBLE--

% --BEGIN RENDERER renlinear--
/setpacking where {pop currentpacking true setpacking} if
1 dict
begin
/renlinear {

    20 dict begin          % Confine variables to local scope

    /args exch def   % We are given some arguments

    % Default options
    /sbs [] def
    /bhs [] def
    /bbs [] def
    /txt [] def
    /barcolor (unset) def
    /includetext false def
    /textcolor (unset) def
    /textxalign (unset) def
    /textyalign (unset) def
    /textfont (Courier) def
    /textsize 10 def
    /textxoffset 0 def
    /textyoffset 0 def
    /textgaps 0 def
    /alttext () def
    /bordercolor (unset) def
    /backgroundcolor (unset) def
    /inkspread 0.15 def
    /width 0 def
    /barratio 1 def
    /spaceratio 1 def
    /showborder false def
    /borderleft 10 def
    /borderright 10 def
    /bordertop 1 def
    /borderbottom 1 def
    /borderwidth 0.5 def
    /guardwhitespace false def
    /guardleftpos 0 def
    /guardleftypos 0 def
    /guardrightpos 0 def
    /guardrightypos 0 def
    /guardwidth 6 def
    /guardheight 7 def
    
    % Apply the renderer options and the user options
    args {def} forall
    opt {def} forall 

    /barcolor barcolor cvlit def
    /textcolor textcolor cvlit def
    /textxalign textxalign cvlit def
    /textyalign textyalign cvlit def
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textxoffset textxoffset cvr def
    /textyoffset textyoffset cvr def
    /textgaps textgaps cvr def
    /alttext alttext cvlit def
    /bordercolor bordercolor cvlit def
    /backgroundcolor backgroundcolor cvlit def
    /inkspread inkspread cvr def
    /width width cvr def
    /barratio barratio cvr def
    /spaceratio spaceratio cvr def
    /borderleft borderleft cvr def
    /borderright borderright cvr def
    /bordertop bordertop cvr def
    /borderbottom borderbottom cvr def
    /borderwidth borderwidth cvr def
    /guardleftpos guardleftpos cvr def
    /guardleftypos guardleftypos cvr def
    /guardrightpos guardrightpos cvr def
    /guardrightypos guardrightypos cvr def
    /guardwidth guardwidth cvr def
    /guardheight guardheight cvr def
    
    % Create bar elements and put them into the bars array
    /bars sbs length 1 add 2 idiv array def
    /x 0.00 def /maxh 0 def
    0 1 sbs length 1 add 2 idiv 2 mul 2 sub {
        /i exch def
        i 2 mod 0 eq {           % i is even
            /d sbs i get barratio mul barratio sub 1 add def  % d=digit*r-r+1
            sbs i get 0 ne {
                /h bhs i 2 idiv get 72 mul def  % Height from bhs
                /c d 2 div x add def            % Centre of the bar = x + d/2
                /y bbs i 2 idiv get 72 mul def  % Baseline from bbs
                /w d inkspread sub def          % bar width = digit - inkspread
                bars i 2 idiv [h c y w] put     % Add the bar entry
                h y add maxh gt {/maxh h y add def} if
            } {
                bars i 2 idiv -1 put            % Dummy entry
            } ifelse
        } {
            /d sbs i get spaceratio mul spaceratio sub 1 add def  % d=digit*r-r+1 
        } ifelse
        /x x d add def  % x+=d
    } for

    gsave

    currentpoint translate

    % Force symbol to given width
    width 0 ne {
        width 72 mul x div 1 scale
    } if

    % Set RGB or CMYK color depending on length of given hex string
    /setanycolor {
        /anycolor exch def
        anycolor length 6 eq {
            (<      >) 8 string copy dup 1 anycolor putinterval cvx exec {255 div} forall setrgbcolor
        } if
        anycolor length 8 eq {
            (<        >) 10 string copy dup 1 anycolor putinterval cvx exec {255 div} forall setcmykcolor
        } if
    } bind def

    % Display the border and background
    newpath
    borderleft neg borderbottom neg moveto
    x borderleft add borderright add 0 rlineto
    0 maxh borderbottom add bordertop add rlineto
    x borderleft add borderright add neg 0 rlineto
    0 maxh borderbottom add bordertop add neg rlineto    
    closepath
    backgroundcolor (unset) ne { gsave backgroundcolor setanycolor fill grestore } if     
    showborder {
        gsave
        bordercolor (unset) ne { bordercolor setanycolor } if
        borderwidth setlinewidth stroke
        grestore
    } if    
   
    % Display the bars for elements in the bars array
    gsave
    0 setlinecap
    barcolor (unset) ne { barcolor setanycolor } if
    bars {
        dup -1 ne {
            aload pop newpath setlinewidth moveto 0 exch rlineto stroke
        } {
            pop
        } ifelse
    } forall
    grestore
    
    % Display the text for elements in the text array
    textcolor (unset) ne { textcolor setanycolor } if
    includetext {
        textxalign (unset) eq textyalign (unset) eq and alttext () eq and {
            /s 0 def /f () def
            txt {
                {} forall
                2 copy s ne exch f ne or {
                    2 copy /s exch def /f exch def            
                    exch findfont exch scalefont setfont          
                } {
                    pop pop
                } ifelse
                moveto show
            } forall
        } {
            textfont findfont textsize scalefont setfont
            alttext () eq {
                /txt [ txt { 0 get {} forall } forall ] def
                /tstr txt length string def
                0 1 txt length 1 sub { dup txt exch get tstr 3 1 roll put } for
            } {
                /tstr alttext def
            } ifelse

            % Find true ascent of font
            tstr length 0 eq {
                0
            } {
                gsave
                newpath 0 0 moveto (0) false charpath pathbbox
                4 1 roll pop pop pop
                grestore
                currentfont /PaintType known {currentfont /PaintType get 2 eq} {false} ifelse
                currentfont /StrokeWidth known and {
                    currentfont /StrokeWidth get 2 div 0 exch
                    currentfont /FontMatrix get dtransform
                    dup mul exch dup mul add sqrt
                    add
                } if
            } ifelse
            /textascent exch def
            /textwidth tstr stringwidth pop tstr length 1 sub textgaps mul add def

            /textxpos textxoffset x textwidth sub 2 div add def
            textxalign (left) eq { /textxpos textxoffset def } if
            textxalign (right) eq { /textxpos x textxoffset sub textwidth sub def } if
            textxalign (offleft) eq { /textxpos textwidth textxoffset add neg def } if
            textxalign (offright) eq { /textxpos x textxoffset add def } if
            textxalign (justify) eq textwidth x lt and {
                /textxpos 0 def
                /textgaps x textwidth sub tstr length 1 sub div def
            } if
            /textypos textyoffset textascent add 1 add neg def
            textyalign (above) eq { /textypos textyoffset maxh add 1 add def } if
            textyalign (center) eq { /textypos textyoffset maxh textascent sub 2 div add def } if
            textxpos textypos moveto textgaps 0 tstr ashow
        } ifelse
    } if    

    % Display the guard elements
    guardwhitespace {
        0.75 setlinewidth
        guardleftpos 0 ne {
            newpath
            guardleftpos neg guardwidth add guardleftypos guardwidth 2 div add moveto
            guardwidth neg guardheight -2 div rlineto
            guardwidth guardheight -2 div rlineto
            stroke            
        } if
        guardrightpos 0 ne {
            newpath
            guardrightpos x add guardwidth sub guardrightypos guardheight 2 div add moveto
            guardwidth guardheight -2 div rlineto
            guardwidth neg guardheight -2 div rlineto
            stroke            
        } if
    } if
    
    grestore
    
    end

} bind def
/renlinear dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END RENDERER renlinear--

% --BEGIN RENDERER renmatrix--
/setpacking where {pop currentpacking true setpacking} if
1 dict
begin
/renmatrix {

    20 dict begin

    /args exch def

    % Default options
    /width 1 def
    /height 1 def
    /color (unset) def
    /backgroundcolor (unset) def

    % Apply the renderer options and the user options
    args {def} forall
    opt {def} forall

    /width width cvr def
    /height height cvr def
    /color color cvlit def
    /backgroundcolor backgroundcolor cvlit def

    % Extend bitmap horizontally to an 8-bit boundary
    /pixx8 pixx 8 div ceiling cvi 8 mul def
    /pixs8 [ pixx8 pixy mul {0} repeat ] def
    0 1 pixy 1 sub {
        /i exch def
        pixs8 pixx8 i mul pixs pixx i mul pixx getinterval putinterval
    } for
    /pixs pixs8 def

    % Convert bitmap into 8-bit sample string
    /imgstr pixs length 8 idiv string def
    0 1 pixs length 1 sub {
        /i exch def
        imgstr i 8 idiv 2 copy get 2 7 i 8 mod sub exp cvi pixs i get mul add put
    } for

    % Set RGB or CMYK color depending on length of given hex string
    /setanycolor {
        /anycolor exch def
        anycolor length 6 eq {
            (<      >) 8 string copy dup 1 anycolor putinterval cvx exec {255 div} forall setrgbcolor
        } if
        anycolor length 8 eq {
            (<        >) 10 string copy dup 1 anycolor putinterval cvx exec {255 div} forall setcmykcolor
        } if
    } bind def

    % Draw the image
    gsave
    currentpoint translate
    72 width mul 72 height mul scale
    .0001 .0001 moveto .9999 .0001 lineto .9999 .9999 lineto .0001 .9999 lineto closepath
    backgroundcolor (unset) ne { gsave backgroundcolor setanycolor fill grestore } if 
    color (unset) ne { color setanycolor } if
    pixx pixy true [ pixx 0 0 pixy neg 0 pixy ] {imgstr} imagemask
    grestore

    end

} bind def
/renmatrix dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END RENDERER renmatrix--

% --BEGIN RENDERER renmaximatrix--
/setpacking where {pop currentpacking true setpacking} if
1 dict
begin
/renmaximatrix {

    20 dict begin

    /args exch def   % We are given some arguments

    % Apply the renderer options and the user options
    args {def} forall
    opt {def} forall
 
    gsave

    currentpoint translate

    2.4945 dup scale  % from 1pt to 1.88mm
    0.5 0.5774 translate

    pixs {
        dup 
        /x exch 30 mod def 
        /y exch 30 idiv def
        y 2 mod 0 eq {x} {x 0.5 add} ifelse
        32 y sub 0.8661 mul
        moveto
        0     0.5774 rmoveto
        -0.5 -0.2887 rlineto
        0    -0.5774 rlineto
        0.5  -0.2887 rlineto
        0.5   0.2887 rlineto
        0     0.5774 rlineto
        -0.5  0.2887 rlineto
        closepath fill
    } forall

    % Plot the locator symbol
    newpath 14 13.8576 0.5774 0 360 arc closepath
    14 13.8576 1.3359 360 0 arcn closepath fill
    newpath 14 13.8576 2.1058 0 360 arc closepath
    14 13.8576 2.8644 360 0 arcn closepath fill
    newpath 14 13.8576 3.6229 0 360 arc closepath
    14 13.8576 4.3814 360 0 arcn closepath fill

    grestore

    end

} bind def
/renmaximatrix dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END RENDERER renmaximatrix--

% --BEGIN ENCODER ean5--
% --DESC: EAN-5 (5 digit addon)
% --EXAM: 90200
% --EXOP: includetext guardwhitespace
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/ean5 {

    20 dict begin

    /options exch def                   % We are given an option string
    /barcode exch def                   % We are given a barcode string

    /dontdraw false def
    /includetext false def              % Enable/disable text
    /textfont /Helvetica def
    /textsize 12 def
    /textxoffset 0 def
    /textyoffset (unset) def
    /height 0.7 def    
    
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall   
 
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /height height cvr def
    /textxoffset textxoffset cvr def
    textyoffset (unset) eq {
        /textyoffset height 72 mul 1 add def
    } {
        /textyoffset textyoffset cvr def
    } ifelse
    
    % Create an array containing the character mappings
    /encs
    [ (3211) (2221) (2122) (1411) (1132)
      (1231) (1114) (1312) (1213) (3112)
      (112) (11)
    ] def

    % Create a string of the available characters
    /barchars (0123456789) def

    % Determine the mirror map based on mod 10 checksum
    /mirrormaps
    [ (11000) (10100) (10010) (10001) (01100)
      (00110) (00011) (01010) (01001) (00101)
    ] def
    /checksum 0 def
    0 1 4 {
        /i exch def
        /barchar barcode i get 48 sub def
        i 2 mod 0 eq {
            /checksum barchar 3 mul checksum add def
        } {
            /checksum barchar 9 mul checksum add def
        } ifelse
    } for
    /checksum checksum 10 mod def
    /mirrormap mirrormaps checksum get def

    /sbs 31 string def
    /txt 5 array def
   
    0 1 4 {
        /i exch def

        % Prefix with either a start character or separator character
        i 0 eq {
            sbs 0 encs 10 get putinterval
        } {
            sbs i 1 sub 6 mul 7 add encs 11 get putinterval
        } ifelse

        % Lookup the encoding for the barcode character
        barcode i 1 getinterval barchars exch search
        pop                     % Discard true leaving pre
        length /indx exch def   % indx is the length of pre
        pop pop                 % Discard seek and post
        /enc encs indx get def  % Get the indxth encoding
        mirrormap i get 49 eq { % Reverse enc if 1 in this position in mirrormap
            /enclen enc length def
            /revenc enclen string def
            0 1 enclen 1 sub {
                /j exch def
                /char enc j get def
                revenc enclen j sub 1 sub char put
            } for
            /enc revenc def
        } if
        sbs i 6 mul 3 add enc putinterval   % Put encoded digit into sbs
        txt i [barcode i 1 getinterval i 1 sub 9 mul 13 add textxoffset add textyoffset textfont textsize] put
    } for

    % Return the arguments
    <<
    /ren //renlinear
    /sbs [sbs {48 sub} forall]
    /bhs [16{height}repeat]
    /bbs [16{0}repeat]
    includetext {
        /txt txt
    } if
    /opt options
    /guardrightpos 10
    /guardrightypos textyoffset 4 add
    /bordertop 10
    >>

    dontdraw not //renlinear if

    end

} bind def
/ean5 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER ean5--

% --BEGIN ENCODER ean2--
% --DESC: EAN-2 (2 digit addon)
% --EXAM: 05
% --EXOP: includetext guardwhitespace
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/ean2 {

    20 dict begin

    /options exch def                   % We are given an options string
    /barcode exch def                   % We are given a barcode string

    /dontdraw false def
    /includetext false def               % Enable/disable text
    /textfont /Helvetica def
    /textsize 12 def
    /textxoffset 0 def
    /textyoffset (unset) def
    /height 0.7 def
    
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
 
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /height height cvr def
    /textxoffset textxoffset cvr def
    textyoffset (unset) eq {
        /textyoffset height 72 mul 1 add def
    } {
        /textyoffset textyoffset cvr def
    } ifelse
    
    % Create an array containing the character mappings
    /encs
    [ (3211) (2221) (2122) (1411) (1132)
      (1231) (1114) (1312) (1213) (3112)
      (112) (11)
    ] def

    % Create a string of the available characters
    /barchars (0123456789) def

    % Determine the mirror map based on mod 4 checksum
    /mirrormap [(00) (01) (10) (11)] barcode 0 2 getinterval cvi 4 mod get def

    /sbs 13 string def
    /txt 2 array def
    
    0 1 1 {
        /i exch def

        % Prefix with either a start character or separator character
        i 0 eq {
            sbs 0 encs 10 get putinterval
        } {
            sbs i 1 sub 6 mul 7 add encs 11 get putinterval
        } ifelse

        % Lookup the encoding for the barcode character
        barcode i 1 getinterval barchars exch search
        pop                     % Discard true leaving pre
        length /indx exch def   % indx is the length of pre
        pop pop                 % Discard seek and post
        /enc encs indx get def  % Get the indxth encoding
        mirrormap i get 49 eq { % Reverse enc if 1 in this position in mirrormap    
            /enclen enc length def
            /revenc enclen string def
            0 1 enclen 1 sub {
                /j exch def
                /char enc j get def
                revenc enclen j sub 1 sub char put
            } for
            /enc revenc def
        } if
        sbs i 6 mul 3 add enc putinterval   % Put encoded digit into sbs
        txt i [barcode i 1 getinterval i 1 sub 9 mul 13 add textxoffset add textyoffset textfont textsize] put
    } for

    % Return the arguments
    <<
    /ren //renlinear
    /sbs [sbs {48 sub} forall]
    /bhs [12{height}repeat]
    /bbs [12{0}repeat]
    includetext {
        /txt txt
    } if
    /opt options
    /guardrightpos 10
    /guardrightypos textyoffset 4 add
    /bordertop 10
    >>

    dontdraw not //renlinear if

    end

} bind def
/ean2 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER ean2--

% --BEGIN ENCODER ean13--
% --SUGGESTS ean5 ean2--
% --DESC: EAN-13
% --EXAM: 977147396801
% --EXOP: includetext guardwhitespace
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /ean2 dup /uk.co.terryburton.bwipp findresource put
dup /ean5 dup /uk.co.terryburton.bwipp findresource put
begin
/ean13 {

    20 dict begin

    /options exch def                  % We are given an option string
    /barcode exch def                  % We are given a barcode string

    /dontdraw false def
    /includetext false def             % Enable/disable text
    /textfont /Helvetica def
    /textsize 12 def
    /textyoffset -4 def
    /height 1 def
    /addongap 12 def

    % Parse the input options, either a string or a dict
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def
    /addongap addongap cvr def   

    % Split off the addon
    barcode ( ) search {
        /barcode exch def
        pop
        /addon exch def
    } {
        pop
        /addon () def
    } ifelse
 
    % Add checksum digit
    /pad 13 string def
    /checksum 0 def
    0 1 11 {
        /i exch def
        /barchar barcode i get 48 sub def
        i 2 mod 0 eq {
            /checksum barchar checksum add def
        } {
            /checksum barchar 3 mul checksum add def
        } ifelse
    } for
    /checksum 10 checksum 10 mod sub 10 mod def
    pad 0 barcode putinterval       % Add barcode to the start of the pad
    pad 12 checksum 48 add put      % Put ascii for checksum at end of pad
    /barcode pad def

    % Create an array containing the character mappings
    /encs
    [ (3211) (2221) (2122) (1411) (1132)
      (1231) (1114) (1312) (1213) (3112)
      (111) (11111) (111)
    ] def

    % Create a string of the available characters
    /barchars (0123456789) def

    % Digits to mirror on left side
    /mirrormaps
    [ (000000) (001011) (001101) (001110) (010011)
      (011001) (011100) (010101) (010110) (011010)
    ] def

    /sbs 59 string def
    /txt 13 array def
  
    % Put the start character
    sbs 0 encs 10 get putinterval

    % First digit - determine mirrormap by this and show before guard bars
    /mirrormap mirrormaps barcode 0 get 48 sub get def
    txt 0 [barcode 0 1 getinterval -10 textyoffset textfont textsize] put

    % Left side - performs mirroring
    1 1 6 {
        % Lookup the encoding for the each barcode character
        /i exch def
        barcode i 1 getinterval barchars exch search
        pop                            % Discard true leaving pre
        length /indx exch def          % indx is the length of pre
        pop pop                        % Discard seek and post
        /enc encs indx get def         % Get the indxth encoding
        mirrormap i 1 sub get 49 eq {   % Reverse enc if 1 in this position in mirrormap
            /enclen enc length def
            /revenc enclen string def
            0 1 enclen 1 sub {
                /j exch def
                /char enc j get def
                revenc enclen j sub 1 sub char put
            } for
            /enc revenc def
        } if
        sbs i 1 sub 4 mul 3 add enc putinterval   % Put encoded digit into sbs
        txt i [barcode i 1 getinterval i 1 sub 7 mul 4 add textyoffset textfont textsize] put
    } for

    % Put the middle character
    sbs 7 1 sub 4 mul 3 add encs 11 get putinterval

    % Right side
    7 1 12 {
        % Lookup the encoding for the each barcode character
        /i exch def
        barcode i 1 getinterval barchars exch search
        pop                            % Discard true leaving pre
        length /indx exch def          % indx is the length of pre
        pop pop                        % Discard seek and post
        /enc encs indx get def         % Get the indxth encoding
        sbs i 1 sub 4 mul 8 add enc putinterval  % Put encoded digit into sbs
        txt i [barcode i 1 getinterval i 1 sub 7 mul 8 add textyoffset textfont textsize] put
    } for

    % Put the end character
    sbs 56 encs 12 get putinterval

    /sbs [sbs {48 sub} forall] def
    includetext {
        /bhs [height height 12{height .075 sub}repeat height height 12{height .075 sub}repeat height height] def
        /bbs [0 0 12{.075}repeat 0 0 12{.075}repeat 0 0] def
    } {
        /bhs [30{height}repeat] def
        /bbs [30{0}repeat] def
        /txt [] def
    } ifelse
    /guardrightypos 0 def

    % Append the addon
    addon () ne {
        /addopts <<
            /dontdraw true
            /includetext true
            /height height 0.15 sub
            /textxoffset 95 addongap add
            /textsize textsize
            /textfont textfont
        >> def
        addon length 2 eq {addon addopts //ean2 exec} if
        addon length 5 eq {addon addopts //ean5 exec} if
        /addcode exch def
        /sbs [sbs aload pop addongap addcode (sbs) get aload pop] def
        /bhs [bhs aload pop addcode (bhs) get {.075 sub} forall] def
        /bbs [bbs aload pop addcode (bbs) get {.075 add} forall] def
        /txt [txt aload pop addcode (txt) get aload pop] def
        /guardrightypos height 72 mul 6 sub def
    } if 
   
    % Return the arguments
    <<
    /ren //renlinear
    /sbs sbs
    /bhs bhs
    /bbs bbs
    /txt txt
    /opt options
    /guardrightpos 10
    /guardrightypos guardrightypos
    /borderbottom 5
    >>

    dontdraw not //renlinear if

    end

} bind def
/ean13 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER ean13--

% --BEGIN ENCODER ean8--
% --SUGGESTS ean5 ean2--
% --DESC: EAN-8
% --EXAM: 01335583
% --EXOP: includetext guardwhitespace height=0.5
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /ean2 dup /uk.co.terryburton.bwipp findresource put
dup /ean5 dup /uk.co.terryburton.bwipp findresource put
begin
/ean8 {

    20 dict begin

    /options exch def                  % We are given an option string
    /barcode exch def                  % We are given a barcode string

    /dontdraw false def
    /includetext false def              % Enable/disable text
    /textfont /Helvetica def
    /textsize 12 def
    /textyoffset -4 def
    /height 1 def
    /addongap 12 def
    
    % Parse the input options, either a string or a dict
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
   
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def
    /addongap addongap cvr def   

    % Split off the addon
    barcode ( ) search {
        /barcode exch def
        pop
        /addon exch def
    } {
        pop
        /addon () def
    } ifelse

    % Add checksum digit
    /pad 8 string def
    /checksum 0 def
    0 1 6 {
        /i exch def
        /barchar barcode i get 48 sub def
        i 2 mod 0 ne {
            /checksum barchar checksum add def
        } {
            /checksum barchar 3 mul checksum add def
        } ifelse
    } for
    /checksum 10 checksum 10 mod sub 10 mod def
    pad 0 barcode putinterval      % Add barcode to the start of the pad
    pad 7 checksum 48 add put      % Put ascii for checksum at end of pad
    /barcode pad def
 
    % Create an array containing the character mappings
    /encs
    [ (3211) (2221) (2122) (1411) (1132)
      (1231) (1114) (1312) (1213) (3112)
      (111) (11111) (111)
    ] def

    % Create a string of the available characters
    /barchars (0123456789) def

    /sbs 43 string def
    /txt 8 array def
    
    % Put the start character
    sbs 0 encs 10 get putinterval

    % Left side
    0 1 3 {
        % Lookup the encoding for the each barcode character
        /i exch def
        barcode i 1 getinterval barchars exch search
        pop                                % Discard true leaving pre
        length /indx exch def              % indx is the length of pre
        pop pop                            % Discard seek and post
        /enc encs indx get def             % Get the indxth encoding
        sbs i 4 mul 3 add enc putinterval  % Put encoded digit into sbs
        txt i [barcode i 1 getinterval i 7 mul 4 add textyoffset textfont textsize] put
    } for

    % Put the middle character
    sbs 4 4 mul 3 add encs 11 get putinterval

    % Right side
    4 1 7 {
        % Lookup the encoding for the each barcode character
        /i exch def
        barcode i 1 getinterval barchars exch search
        pop                                % Discard true leaving pre
        length /indx exch def              % indx is the length of pre
        pop pop                            % Discard seek and post
        /enc encs indx get def             % Get the indxth encoding
        sbs i 4 mul 8 add enc putinterval  % Put encoded digit into sbs
        txt i [barcode i 1 getinterval i 7 mul 8 add textyoffset textfont textsize] put
    } for

    % Put the end character
    sbs 40 encs 12 get putinterval

    /sbs [sbs {48 sub} forall] def
    includetext {
        /bhs [height height 8{height .075 sub}repeat height height 8{height .075 sub}repeat height height] def
        /bbs [0 0 8{.075}repeat 0 0 8{.075}repeat 0 0] def
    } {
        /bhs [22{height}repeat] def
        /bbs [22{0}repeat] def
        /txt [] def
    } ifelse
    /guardrightypos 0 def

    % Append the addon
    addon () ne {
        /addopts <<
            /dontdraw true
            /includetext true
            /height height 0.15 sub
            /textxoffset 67 addongap add
            /textsize textsize
            /textfont textfont
        >> def
        addon length 2 eq {addon addopts //ean2 exec} if
        addon length 5 eq {addon addopts //ean5 exec} if
        /addcode exch def
        /sbs [sbs aload pop addongap addcode (sbs) get aload pop] def
        /bhs [bhs aload pop addcode (bhs) get {.075 sub} forall] def
        /bbs [bbs aload pop addcode (bbs) get {.075 add} forall] def
        /txt [txt aload pop addcode (txt) get aload pop] def
        /guardrightypos height 72 mul 6 sub def
    } if 

    % Return the arguments
    <<
    /ren //renlinear
    /sbs sbs
    /bhs bhs
    /bbs bbs
    /txt txt
    /opt options
    /guardleftpos 10
    /guardrightpos 10
    /guardrightypos guardrightypos
    /borderbottom 5
    >>

    dontdraw not //renlinear if

    end

} bind def
/ean8 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER ean8--

% --BEGIN ENCODER upca--
% --SUGGESTS ean5 ean2--
% --DESC: UPC-A
% --EXAM: 78858101497
% --EXOP: includetext
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /ean2 dup /uk.co.terryburton.bwipp findresource put
dup /ean5 dup /uk.co.terryburton.bwipp findresource put
begin
/upca {

    20 dict begin

    /options exch def
    /barcode exch def             % We are given a barcode string

    /dontdraw false def
    /includetext false def         % Enable/disable text
    /textfont /Helvetica def
    /textsize 12 def
    /textyoffset -4 def
    /height 1 def 
    /addongap 12 def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall    

    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def
    /addongap addongap cvr def
   
    % Split off the addon
    barcode ( ) search {
        /barcode exch def
        pop
        /addon exch def
    } {
        pop
        /addon () def
    } ifelse
 
    % Add checksum digit to barcode
    /pad 12 string def   % Create pad one bigger than barcode
    /checksum 0 def
    0 1 10 {
        /i exch def
        /barchar barcode i get 48 sub def
        i 2 mod 0 ne {
            /checksum checksum barchar add def
        } {
            /checksum checksum barchar 3 mul add def
        } ifelse
    } for
    /checksum 10 checksum 10 mod sub 10 mod def
    pad 0 barcode putinterval       % Add barcode to the start of the pad
    pad 11 checksum 48 add put      % Put ascii for checksum at end of pad
    /barcode pad def

    % Create an array containing the character mappings
    /encs
    [ (3211) (2221) (2122) (1411) (1132)
      (1231) (1114) (1312) (1213) (3112)
      (111) (11111) (111)
    ] def

    % Create a string of the available characters
    /barchars (0123456789) def

    /sbs 59 string def
    /txt 12 array def

    % Put the start character
    sbs 0 encs 10 get putinterval

    % Left side
    0 1 5 {
        % Lookup the encoding for the each barcode character
        /i exch def
        barcode i 1 getinterval barchars exch search
        pop                                % Discard true leaving pre
        length /indx exch def              % indx is the length of pre
        pop pop                            % Discard seek and post
        /enc encs indx get def             % Get the indxth encoding
        sbs i 4 mul 3 add enc putinterval  % Put encoded digit into sbs
        i 0 eq {      % First digit is before the guard bars
            txt 0 [barcode 0 1 getinterval -7 textyoffset textfont textsize 2 sub] put
        } {
            txt i [barcode i 1 getinterval i 7 mul 4 add textyoffset textfont textsize] put
        } ifelse
    } for

    % Put the middle character
    sbs 6 4 mul 3 add encs 11 get putinterval

    % Right side
    6 1 11 {
        % Lookup the encoding for the each barcode character
        /i exch def
        barcode i 1 getinterval barchars exch search
        pop                                % Discard true leaving pre
        length /indx exch def              % indx is the length of pre
        pop pop                            % Discard seek and post
        /enc encs indx get def             % Get the indxth encoding
        sbs i 4 mul 8 add enc putinterval  % Put encoded digit into sbs
        i 11 eq {       % Last digit is after guard bars
            txt 11 [barcode 11 1 getinterval 96 textyoffset textfont textsize 2 sub] put
        } {
            txt i [barcode i 1 getinterval i 7 mul 8 add textyoffset textfont textsize] put
        } ifelse
    } for

    % Put the end character
    sbs 56 encs 12 get putinterval

    /sbs [sbs {48 sub} forall] def
    includetext {
        /bhs [4{height}repeat 10{height .075 sub}repeat height height 10{height .075 sub}repeat 4{height}repeat] def
        /bbs [0 0 0 0 10{.075}repeat 0 0 10{.075}repeat 0 0 0 0] def
    } {
        /bhs [30{height}repeat] def
        /bbs [30{0}repeat] def
        /txt [] def
    } ifelse
    /guardrightypos 0 def

    % Append the addon
    addon () ne {
        /addopts <<
            /dontdraw true
            /includetext true
            /height height 0.15 sub
            /textxoffset 95 addongap add
            /textsize textsize
            /textfont textfont
        >> def
        addon length 2 eq {addon addopts //ean2 exec} if
        addon length 5 eq {addon addopts //ean5 exec} if
        /addcode exch def
        /sbs [sbs aload pop addongap addcode (sbs) get aload pop] def
        /bhs [bhs aload pop addcode (bhs) get {.075 sub} forall] def
        /bbs [bbs aload pop addcode (bbs) get {.075 add} forall] def
        /txt [txt aload pop addcode (txt) get aload pop] def
        /guardrightypos height 72 mul 6 sub def
    } if 

    % Return the arguments
    <<
    /ren //renlinear
    /sbs sbs
    /bhs bhs
    /bbs bbs
    /txt txt
    /opt options
    /guardrightpos 10
    /guardrightypos guardrightypos
    /borderbottom 5
    >>

    dontdraw not //renlinear if

    end

} bind def
/upca dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER upca--

% --BEGIN ENCODER upce--
% --SUGGESTS ean5 ean2--
% --DESC: UPC-E
% --EXAM: 0123456
% --EXOP: includetext height=0.4
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /ean2 dup /uk.co.terryburton.bwipp findresource put
dup /ean5 dup /uk.co.terryburton.bwipp findresource put
begin
/upce {

    20 dict begin

    /options exch def                   % We are given an option string
    /barcode exch def                   % We are given a barcode string

    /dontdraw false def
    /includetext false def               % Enable/disable text
    /textfont /Helvetica def
    /textsize 12 def
    /textyoffset -4 def
    /height 1 def
    /addongap 12 def   
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
 
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def
    /addongap addongap cvr def    

    % Ensure 0 or 1 number systems
    barcode 0 get dup 48 ne exch 49 ne and {
        /barcode () def
    } if

    % Split off the addon
    barcode ( ) search {
        /barcode exch def
        pop
        /addon exch def
    } {
        pop
        /addon () def
    } ifelse

    % Create an array containing the character mappings
    /encs
    [ (3211) (2221) (2122) (1411) (1132)
      (1231) (1114) (1312) (1213) (3112)
      (111) (111111)
    ] def

    % Create a string of the available characters
    /barchars (0123456789) def

    /mirrormaps
    [ (000111) (001011) (001101) (001110) (010011)
      (011001) (011100) (010101) (010110) (011010)
    ] def

    % Derive the equivalent UPC-A for its checksum
    /upcacode (00000000000) 11 string copy def
    upcacode 0 barcode 0 get put
    barcode 6 get 48 sub 2 le {
        upcacode 1 barcode 1 2 getinterval putinterval
        upcacode 3 barcode 6 1 getinterval putinterval
        upcacode 8 barcode 3 3 getinterval putinterval
    } if
    barcode 6 get 48 sub 3 eq {
        upcacode 1 barcode 1 3 getinterval putinterval
        upcacode 9 barcode 4 2 getinterval putinterval
    } if
    barcode 6 get 48 sub 4 eq {
        upcacode 1 barcode 1 4 getinterval putinterval
        upcacode 10 barcode 5 1 getinterval putinterval
    } if
    barcode 6 get 48 sub 5 ge {
        upcacode 1 barcode 1 5 getinterval putinterval
        upcacode 10 barcode 6 1 getinterval putinterval
    } if
    /checksum 0 def
    0 1 10 {
       /i exch def
       /barchar upcacode i get 48 sub def
       i 2 mod 0 ne {
           /checksum checksum barchar add def
       } {
           /checksum checksum barchar 3 mul add def
       } ifelse
    } for
    /checksum 10 checksum 10 mod sub 10 mod def
    /pad 8 string def
    pad 0 barcode putinterval       % Add barcode to the start of the pad
    pad 7 checksum 48 add put       % Put ascii for checksum at end of pad
    /barcode pad def
    /txt 8 array def
    txt 0 [barcode 0 1 getinterval -7 textyoffset textfont textsize 2 sub] put

    % Determine the mirror map based on checksum
    /mirrormap mirrormaps checksum get def

    % Invert the mirrormap if we are using a non-zero number system
    barcode 0 get 48 eq {
        /invt mirrormap length string def
        0 1 mirrormap length 1 sub {
            /i exch def
            mirrormap i get 48 eq {
                invt i 49 put
            } {
                invt i 48 put
            } ifelse
        } for
        /mirrormap invt def
    } if

    /sbs 33 string def

    % Put the start character
    sbs 0 encs 10 get putinterval

    1 1 6 {
        /i exch def
        % Lookup the encoding for the each barcode character
        barcode i 1 getinterval barchars exch search
        pop                            % Discard true leaving pre
        length /indx exch def          % indx is the length of pre
        pop pop                        % Discard seek and post
        /enc encs indx get def         % Get the indxth encoding
        mirrormap i 1 sub get 49 eq {  % Reverse enc if 1 in this position in mirrormap        
            /enclen enc length def
            /revenc enclen string def
            0 1 enclen 1 sub {
                /j exch def
                /char enc j get def
                revenc enclen j sub 1 sub char put
            } for
            /enc revenc def
        } if
        sbs i 1 sub 4 mul 3 add enc putinterval   % Put encoded digit into sbs
        txt i [barcode i 1 getinterval i 1 sub 7 mul 4 add textyoffset textfont textsize] put
    } for

    txt 7 [barcode 7 1 getinterval 6 7 mul 11 add textyoffset textfont textsize 2 sub] put

    % Put the end character
    sbs 27 encs 11 get putinterval

    /sbs [sbs {48 sub} forall] def
    includetext {
        /bhs [height height 12{height .075 sub}repeat height height height] def
        /bbs [0 0 12{.075}repeat 0 0 0] def
    } {
        /bhs [17{height}repeat] def
        /bbs [17{0}repeat] def
        /txt [] def
    } ifelse
    /guardrightypos 0 def

    % Append the addon
    addon () ne {
        /addopts <<
            /dontdraw true
            /includetext true
            /height height 0.15 sub
            /textxoffset 51 addongap add
            /textsize textsize
            /textfont textfont
        >> def
        addon length 2 eq {addon addopts //ean2 exec} if
        addon length 5 eq {addon addopts //ean5 exec} if
        /addcode exch def
        /sbs [sbs aload pop addongap addcode (sbs) get aload pop] def
        /bhs [bhs aload pop addcode (bhs) get {.075 sub} forall] def
        /bbs [bbs aload pop addcode (bbs) get {.075 add} forall] def
        /txt [txt aload pop addcode (txt) get aload pop] def
        /guardrightypos height 72 mul 6 sub def
    } if

    % Return the arguments
    <<
    /ren //renlinear
    /sbs sbs
    /bhs bhs
    /bbs bbs
    /txt txt
    /opt options
    /guardrightpos 10
    /guardrightypos guardrightypos
    /borderbottom 5
    >>

    dontdraw not //renlinear if

    end

} bind def
/upce dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER upce--

% --BEGIN ENCODER isbn--
% --REQUIRES ean13--
% --SUGGESTS ean5 ean2--
% --DESC: ISBN
% --EXAM: 978-1-56592-479 54495
% --EXOP: includetext guardwhitespace
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /ean13 dup /uk.co.terryburton.bwipp findresource put
begin
/isbn {

    20 dict begin

    /options exch def      % We are given an options string
    /isbntxt exch def      % We are given the isbn text with dashes

    /dontdraw false def
    /includetext false def  % Enable/disable ISBN text
    /isbnfont /Courier def
    /isbnsize 9 def
    /isbnpos (unset) def
    /height 1 def
    /addongap 12 def   
    /legacy false def
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
    
    /isbnfont isbnfont cvlit def
    /isbnsize isbnsize cvr def
    /height height cvr def
    /addongap addongap cvr def
    isbnpos (unset) eq {
        /isbnpos height 72 mul 3 add def
    } {
        /isbnpos isbnpos cvr def
    } ifelse

    % Split off the addon
    isbntxt ( ) search {
        /isbntxt exch def
        pop
        /addon exch def
    } {
        pop
        /addon () def
    } ifelse
 
    % Convert ISBN-10 to ISBN-13
    legacy not isbntxt length 13 le and {
        /pad isbntxt length 4 add string def
        pad 0 (978-) putinterval
        pad 4 isbntxt putinterval
        /isbntxt pad def
    } if

    % Read the digits from isbntxt and calculate checksums
    /isbn 13 string def
    /checksum10 0 def
    /checksum13 0 def
    /i 0 def /n 0 def
    { % loop
        /isbnchar isbntxt i get 48 sub def
        isbnchar -3 ne {     % Ignore dashes
            isbn n isbnchar 48 add put
            n 9 lt {
                /checksum10 checksum10 10 n sub isbnchar mul add def
            } if
            n 12 lt {
                n 2 mod 0 eq {
                    /checksum13 isbnchar checksum13 add def
                } {
                    /checksum13 isbnchar 3 mul checksum13 add def
                } ifelse
            } if
            /n n 1 add def
        } if
        /i i 1 add def
        i isbntxt length eq {exit} if
    } loop

    % Add the ISBN header to the isbntxt
    n 9 eq n 10 eq or {
        /checksum 11 checksum10 11 mod sub 11 mod def
        /isbn isbn 0 9 getinterval def
        /pad 18 string def
    } {
        /checksum 10 checksum13 10 mod sub 10 mod def
        /isbn isbn 0 12 getinterval def
        /pad 22 string def
    } ifelse
    pad 0 (ISBN ) putinterval
    pad 5 isbntxt putinterval  % Add isbntxt to the pad

    % Add checksum digit
    pad pad length 2 sub 45 put  % Put a dash
    checksum 10 eq {
        pad pad length 1 sub checksum 78 add put  % Check digit for 10 is X
    } {
        pad pad length 1 sub checksum 48 add put  % Put check digit
    } ifelse
    /isbntxt pad def

    % Convert ISBN digits to EAN-13
    /barcode 12 string def
    isbn length 9 eq {        
        barcode 0 (978) putinterval
        barcode 3 isbn putinterval
    } {
        barcode 0 isbn putinterval
    } ifelse

    % Append the addon
    addon () ne {
        12 addon length add 1 add string 
        dup 0 barcode putinterval
        dup 12 ( ) putinterval
        dup 13 addon putinterval
        /barcode exch def
    } if

    % Get the result of encoding with ean13
    options (dontdraw) true put
    options (addongap) addongap put 
    /args barcode options //ean13 exec def

    % Add the ISBN text
    includetext {
        isbn length 9 eq {
            /isbnxpos -1 def
        } {
            /isbnxpos -12 def
        } ifelse
        args (txt) known {
            /txt args (txt) get def
            /newtxt txt length 1 add array def
            newtxt 0 txt putinterval
            newtxt newtxt length 1 sub [isbntxt isbnxpos isbnpos isbnfont isbnsize] put
            args (txt) newtxt put
        } {
            args (txt) [ [isbntxt isbnxpos isbnpos isbnfont isbnsize] ] put
        } ifelse
    } if

    args (opt) options put
    args

    dontdraw not //renlinear if

    end
 
} bind def
/isbn dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER isbn--

% --BEGIN ENCODER ismn--
% --REQUIRES ean13--
% --SUGGESTS ean5 ean2--
% --DESC: ISMN
% --EXAM: 979-0-2600-0043
% --EXOP: includetext guardwhitespace
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /ean13 dup /uk.co.terryburton.bwipp findresource put
begin
/ismn {

    20 dict begin

    /options exch def      % We are given an options string
    /ismntxt exch def      % We are given the ismn text with dashes

    /dontdraw false def
    /includetext false def  % Enable/disable ISMN text
    /ismnfont /Courier def
    /ismnsize 9 def
    /ismnpos (unset) def
    /height 1 def
    /addongap 12 def   
    /legacy false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
    
    /ismnfont ismnfont cvlit def
    /ismnsize ismnsize cvr def
    /height height cvr def
    /addongap addongap cvr def
    ismnpos (unset) eq {
        /ismnpos height 72 mul 3 add def
    } {
        /ismnpos ismnpos cvr def
    } ifelse
   
    % Split off the addon
    ismntxt ( ) search {
        /ismntxt exch def
        pop
        /addon exch def
    } {
        pop
        /addon () def
    } ifelse

    % Convert old ISMN to ISMN-13
    /legacytxt () def
    ismntxt 0 1 getinterval (M) eq ismntxt length 13 le and {
        /legacytxt ismntxt def
        /pad ismntxt length 4 add string def
        pad 0 (979-0-) putinterval
        pad 6 ismntxt 2 ismntxt length 2 sub getinterval putinterval
        /ismntxt pad def
    } if

    % Read the digits from ismntxt and calculate checksums
    /ismn 13 string def
    /checksum 0 def
    /i 0 def /n 0 def
    { % loop
        /ismnchar ismntxt i get 48 sub def
        ismnchar -3 ne {           % Ignore dashes
            ismn n ismnchar 48 add put
            n 12 lt {
                n 2 mod 0 eq {
                    /checksum ismnchar checksum add def
                } {
                    /checksum ismnchar 3 mul checksum add def
                } ifelse
            } if
            /n n 1 add def
        } if
        /i i 1 add def
        i ismntxt length eq {exit} if
    } loop
    /checksum 10 checksum 10 mod sub 10 mod def

    % Add the ISMN header to the ismntxt
    legacy legacytxt () ne and {
        /ismntxt legacytxt def
        /pad 18 string def
    } {
        /pad 22 string def
    } ifelse
    pad 0 (ISMN ) putinterval
    pad 5 ismntxt putinterval  % Add ismntxt to the pad

    % Add checksum digit
    pad pad length 2 sub 45 put  % Put a dash
    pad pad length 1 sub checksum 48 add put  % Put check digit
    /ismntxt pad def

    % Convert ISMN digits to EAN-13
    /barcode ismn 0 12 getinterval def 

    % Append the addon
    addon () ne {
        12 addon length add 1 add string 
        dup 0 barcode putinterval
        dup 12 ( ) putinterval
        dup 13 addon putinterval
        /barcode exch def
    } if

    % Get the result of encoding with ean13
    options (dontdraw) true put
    options (addongap) addongap put 
    /args barcode options //ean13 exec def

    % Add the ISMN text
    includetext {
        ismntxt length 18 eq {
            /ismnxpos -1 def
        } {
            /ismnxpos -12 def
        } ifelse
        args (txt) known {
            /txt args (txt) get def
            /newtxt txt length 1 add array def
            newtxt 0 txt putinterval
            newtxt newtxt length 1 sub [ismntxt ismnxpos ismnpos ismnfont ismnsize] put
            args (txt) newtxt put
        } {
            args (txt) [ [ismntxt ismnxpos ismnpos ismnfont ismnsize] ] put
        } ifelse
    } if

    args (opt) options put
    args

    dontdraw not //renlinear if

    end
 
} bind def
/ismn dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER ismn--

% --BEGIN ENCODER issn--
% --REQUIRES ean13--
% --SUGGESTS ean2 ean5--
% --DESC: ISSN
% --EXAM: 0317-8471 00 05
% --EXOP: includetext guardwhitespace
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /ean13 dup /uk.co.terryburton.bwipp findresource put
begin
/issn {

    20 dict begin

    /options exch def      % We are given an options string
    /issntxt exch def      % We are given the issn text with dashes

    /dontdraw false def
    /includetext false def  % Enable/disable ISSN text
    /issnfont /Courier def
    /issnsize 9 def
    /issnpos (unset) def
    /height 1 def
    /addongap 12 def   

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
    
    /issnfont issnfont cvlit def
    /issnsize issnsize cvr def
    /height height cvr def
    /addongap addongap cvr def
    issnpos (unset) eq {
        /issnpos height 72 mul 3 add def
    } {
        /issnpos issnpos cvr def
    } ifelse
   
    % Split off the ISSN
    issntxt ( ) search {
        /issntxt exch def
        pop
        /seqvar exch def
    } if

    % Split off the sequence variant and 2 digit addon
    seqvar ( ) search {
        /seqvar exch def
        pop
        2 string dup exch 0 4 -1 roll putinterval /addon exch def
    } {
        pop
        /addon () def
    } ifelse

    % Read the digits from issntxt and calculate checksums
    /issn 8 string def
    /checksum 0 def
    /i 0 def /n 0 def
    { % loop
        /issnchar issntxt i get 48 sub def
        issnchar -3 ne {           % Ignore dashes
            issn n issnchar 48 add put
            n 7 lt {
                /checksum checksum issnchar 8 n sub mul add def
            } if
            /n n 1 add def
        } if
        /i i 1 add def
        i issntxt length eq {exit} if
    } loop
    /checksum 11 checksum 11 mod sub 11 mod def

    % Add the ISSN header to the issntxt
    /pad 14 string def
    pad 0 (ISSN ) putinterval
    pad 5 issntxt putinterval  % Add issntxt to the pad

    % Add checksum digit
    pad 13 checksum 48 add dup 58 eq {pop 88} if put  % Put check digit
    /issntxt pad def

    % Convert ISSN digits to EAN-13
    /barcode issn 0 7 getinterval def 

    % Append the sequence variant
    /barcode 12 string def
    barcode 0 (977) putinterval
    barcode 3 issn putinterval
    barcode 10 seqvar putinterval

    % Append the addon
    addon () ne {
        12 addon length add 1 add string 
        dup 0 barcode putinterval
        dup 12 ( ) putinterval
        dup 13 addon putinterval
        /barcode exch def
    } if

    % Get the result of encoding with ean13
    options (dontdraw) true put
    options (addongap) addongap put 
    /args barcode options //ean13 exec def

    % Add the ISSN text
    includetext {
        /issnxpos 10 def
        args (txt) known {
            /txt args (txt) get def
            /newtxt txt length 1 add array def
            newtxt 0 txt putinterval
            newtxt newtxt length 1 sub [issntxt issnxpos issnpos issnfont issnsize] put
            args (txt) newtxt put
        } {
            args (txt) [ [issntxt issnxpos issnpos issnfont issnsize] ] put
        } ifelse
    } if

    args (opt) options put
    args

    dontdraw not //renlinear if

    end
 
} bind def
/issn dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER issn--

% --BEGIN ENCODER code128--
% --DESC: Code 128
% --EXAM: Count01234567^FNC2!
% --EXOP: includetext parsefnc
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/code128 {

    20 dict begin                  % Confine variables to local scope

    /options exch def        % We are given an option string
    /barcode exch def        % We are given a barcode string

    /dontdraw false def
    /includetext false def    % Enable/disable text
    /textfont /Courier def
    /textsize 10 def
    /textxoffset 0 def
    /textyoffset -7 def
    /height 1 def
    /encoding (auto) def
    /raw false def
    /parse false def
    /parsefnc false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textxoffset textxoffset cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def

    % Parse ordinals of the form ^NNN to ASCII
    parse {
        /msg barcode length string def
        /j 0 def
        barcode
        { % loop
            (^) search {
                dup msg exch j exch putinterval
                length j add 1 add /j exch def
                pop
                dup 0 3 getinterval cvi msg exch j 1 sub exch put
                dup length 3 sub 3 exch getinterval
            } {
                dup msg exch j exch putinterval
                length j add /j exch def
                /barcode msg 0 j getinterval def
                exit
            } ifelse 
        } loop
    } if

    /barlen barcode length def

    % Special function characters
    /sta  -1 def  /stb  -2 def  /stc  -3 def 
    /swa  -4 def  /swb  -5 def  /swc  -6 def 
    /fn1  -7 def  /fn2  -8 def  /fn3  -9 def 
    /fn4 -10 def  /sft -11 def  /stp -12 def
    /lka -13 def  /lkc -14 def  % CC-A/B and CC-C linkage

    % Character maps for each state
    /charmaps [
      %  A    B    C         A    B    C         A    B    C
      [  32   32  (00) ]  [ (!)  (!)  (01) ]  [ (")  (")  (02) ]  % 0-2 
      [ (#)  (#)  (03) ]  [ ($)  ($)  (04) ]  [ (%)  (%)  (05) ]  % 3-5
      [ (&)  (&)  (06) ]  [ (')  (')  (07) ]  [  40   40  (08) ]  % 6-8
      [  41   41  (09) ]  [ (*)  (*)  (10) ]  [ (+)  (+)  (11) ]  % 9-11
      [ (,)  (,)  (12) ]  [ (-)  (-)  (13) ]  [ (.)  (.)  (14) ]  % 12-14
      [ (/)  (/)  (15) ]  [ (0)  (0)  (16) ]  [ (1)  (1)  (17) ]  % 15-17
      [ (2)  (2)  (18) ]  [ (3)  (3)  (19) ]  [ (4)  (4)  (20) ]  % 18-20
      [ (5)  (5)  (21) ]  [ (6)  (6)  (22) ]  [ (7)  (7)  (23) ]  % 21-23
      [ (8)  (8)  (24) ]  [ (9)  (9)  (25) ]  [ (:)  (:)  (26) ]  % 24-26
      [ (;)  (;)  (27) ]  [ (<)  (<)  (28) ]  [ (=)  (=)  (29) ]  % 27-29
      [ (>)  (>)  (30) ]  [ (?)  (?)  (31) ]  [ (@)  (@)  (32) ]  % 30-32
      [ (A)  (A)  (33) ]  [ (B)  (B)  (34) ]  [ (C)  (C)  (35) ]  % 33-35
      [ (D)  (D)  (36) ]  [ (E)  (E)  (37) ]  [ (F)  (F)  (38) ]  % 36-38
      [ (G)  (G)  (39) ]  [ (H)  (H)  (40) ]  [ (I)  (I)  (41) ]  % 39-41
      [ (J)  (J)  (42) ]  [ (K)  (K)  (43) ]  [ (L)  (L)  (44) ]  % 42-44
      [ (M)  (M)  (45) ]  [ (N)  (N)  (46) ]  [ (O)  (O)  (47) ]  % 45-47
      [ (P)  (P)  (48) ]  [ (Q)  (Q)  (49) ]  [ (R)  (R)  (50) ]  % 48-50
      [ (S)  (S)  (51) ]  [ (T)  (T)  (52) ]  [ (U)  (U)  (53) ]  % 51-53
      [ (V)  (V)  (54) ]  [ (W)  (W)  (55) ]  [ (X)  (X)  (56) ]  % 54-56
      [ (Y)  (Y)  (57) ]  [ (Z)  (Z)  (58) ]  [ ([)  ([)  (59) ]  % 57-59
      [  92   92  (60) ]  [ (])  (])  (61) ]  [ (^)  (^)  (62) ]  % 60-62
      [ (_)  (_)  (63) ]  [   0  (`)  (64) ]  [   1  (a)  (65) ]  % 63-65
      [   2  (b)  (66) ]  [   3  (c)  (67) ]  [   4  (d)  (68) ]  % 66-68
      [   5  (e)  (69) ]  [   6  (f)  (70) ]  [   7  (g)  (71) ]  % 69-71
      [   8  (h)  (72) ]  [   9  (i)  (73) ]  [  10  (j)  (74) ]  % 72-74
      [  11  (k)  (75) ]  [  12  (l)  (76) ]  [  13  (m)  (77) ]  % 75-77
      [  14  (n)  (78) ]  [  15  (o)  (79) ]  [  16  (p)  (80) ]  % 78-80
      [  17  (q)  (81) ]  [  18  (r)  (82) ]  [  19  (s)  (83) ]  % 81-83
      [  20  (t)  (84) ]  [  21  (u)  (85) ]  [  22  (v)  (86) ]  % 84-86
      [  23  (w)  (87) ]  [  24  (x)  (88) ]  [  25  (y)  (89) ]  % 87-89
      [  26  (z)  (90) ]  [  27  ({)  (91) ]  [  28  (|)  (92) ]  % 90-92
      [  29  (})  (93) ]  [  30  (~)  (94) ]  [  31  127  (95) ]  % 93-95
      [ fn3  fn3  (96) ]  [ fn2  fn2  (97) ]  [ sft  sft  (98) ]  % 96-98
      [ swc  swc  (99) ]  [ swb  fn4  swb  ]  [ fn4  swa  swa  ]  % 99-101
      [ fn1  fn1  fn1  ]  [ sta  sta  sta  ]  [ stb  stb  stb  ]  % 102-104
      [ stc  stc  stc  ]  [ stp  stp  stp  ]                      % 105-106
    ] def 
    
    % Invert charmaps to give character to value maps for each state
    /charvals [ 109 dict 109 dict 109 dict ] def
    0 1 charmaps length 1 sub {
        /i exch def
        /encs charmaps i get def
        0 1 2 {
            /j exch def
            encs j get dup type /stringtype eq {0 get} if  % convert string to ASCII if required
            charvals j get exch i put 
        } for
    } for
    /seta charvals 0 get def
    /setb charvals 1 get def
    /setc charvals 2 get def

    % Include pseudo characters for GS1-128 Composite linkage identifiers
    seta lka seta swb get put  seta lkc seta swc get put
    setb lka setb swc get put  setb lkc setb swa get put
    setc lka setc swa get put  setc lkc setc swb get put

    raw {/encoding (raw) def} if

    encoding (raw) eq {
        /cws barlen array def
        /i 0 def /j 0 def
        { % loop
            i barlen eq {exit} if
            /cw barcode i 1 add 3 getinterval cvi def
            cws j cw put
            /i i 4 add def
            /j j 1 add def
        } loop
        /cws cws 0 j getinterval def
        /text () def
    } if

    encoding (auto) eq { 

        /fncvals <<
            (FNC1) fn1
            (FNC2) fn2
            (FNC3) fn3
            (FNC4) fn4
            (LNKA) lka
            (LNKC) lkc
        >> def

        % Convert input into bytes accounting for FNC and LNK characters 
        /msg barlen array def
        /text barlen string def
        /i 0 def /j 0 def {
            i barlen eq {exit} if
            /char barcode i get def
            text j char put
            parsefnc char 94 eq and i barlen 4 sub lt and {
                barcode i 1 add get 94 ne {
                    /char fncvals barcode i 1 add 4 getinterval get def
                    text j ( ) putinterval
                    /i i 4 add def
                } {
                    /i i 1 add def
                } ifelse
            } if
            msg j char put
            /i i 1 add def
            /j j 1 add def
        } loop
        /msg msg 0 j getinterval def
        /msglen msg length def
        /text text 0 j getinterval def

        % Determine digit runlength and characters from given position
        /numsscr {
            /n 0 def /s 0 def
            /p exch def {
                p msglen ge {exit} if
                msg p get
                dup setc exch known not {pop exit} if
                fn1 eq {
                    % FNC1 in odd position of run like two digits
                    s 2 mod 0 eq {/s s 1 add def} {exit} ifelse
                } if
                /n n 1 add def
                /s s 1 add def
                /p p 1 add def
            } loop
            n s
        } bind def

        % Encoding for each alphabet
        /enca {
            seta exch get cws exch j exch put
            /j j 1 add def
        } bind def
        /encb {
            setb exch get cws exch j exch put
            /j j 1 add def
        } bind def
        /encc {
            dup type /arraytype ne {
                setc exch get
            } {
                aload pop 48 sub exch 48 sub 10 mul add
            } ifelse
            cws exch j exch put
            /j j 1 add def
        } bind def

        % Character exclusively in either alphabet A or B
        /anotb {dup seta exch known exch setb exch known not and} bind def
        /bnota {dup setb exch known exch seta exch known not and} bind def

        % Pre-compute relative position of next anotb and next bnota characters
        /nextanotb [ msg length {0} repeat 9999 ] def
        /nextbnota [ msg length {0} repeat 9999 ] def
        msg length 1 sub -1 0 {
            /i exch def
            msg i get anotb {
                nextanotb i 0 put
            } {
                nextanotb i nextanotb i 1 add get 1 add put
            } ifelse
            msg i get bnota {
                nextbnota i 0 put
            } {
                nextbnota i nextbnota i 1 add get 1 add put
            } ifelse
        } for

        % Does a-only come before b-only after given position and vice versa
        /abeforeb {dup nextanotb exch get exch nextbnota exch get lt} bind def
        /bbeforea {dup nextbnota exch get exch nextanotb exch get lt} bind def
        
        /cws barcode length 2 mul 3 add array def

        % Select start character
        /j 0 def
        msglen 0 gt {0 numsscr} {-1 -1} ifelse /nums exch def /nchars exch def
        {  % common exit
            msglen 0 eq {
                stb enca
                /cset (setb) def
                exit
            } if
            msglen 2 eq nums 2 eq and {
                stc enca
                /cset (setc) def
                exit
            } if
            nums 4 ge {
                stc enca
                /cset (setc) def
                exit
            } if
            0 abeforeb { 
                sta enca
                /cset (seta) def
                exit 
            } if 
            stb enca
            /cset (setb) def
            exit
        } loop

        % Main encoding loop
        /i 0 def {  
            i msglen eq {exit} if
        
            i numsscr /nums exch def /nchars exch def
        
            % Determine switches and shifts
            {  % common exit
                cset (seta) eq cset (setb) eq or nums 4 ge and 
                msg i get fn1 ne and {
                    nums 2 mod 0 eq {
                        swc cset (seta) eq {enca} {encb} ifelse
                        /cset (setc) def
                        exit
                    } {
                        msg i get cset (seta) eq {enca} {encb} ifelse
                        /i i 1 add def
                        swc cset (seta) eq {enca} {encb} ifelse
                        /cset (setc) def
                        exit
                    } ifelse
                } if
                cset (setb) eq msg i get anotb and { 
                    i msglen 1 sub lt {
                        i 1 add bbeforea { 
                            sft encb
                            msg i get enca
                            /i i 1 add def
                            exit
                        } if
                    } if
                    swa encb
                    /cset (seta) def
                    exit
                } if
                cset (seta) eq msg i get bnota and {
                    i msglen 1 sub lt {
                        i 1 add abeforeb {
                            sft enca
                            msg i get encb
                            /i i 1 add def
                            exit
                        } if
                    } if
                    swb enca
                    /cset (setb) def
                    exit
                } if
                cset (setc) eq nums 2 lt and {
                    i abeforeb {
                        swa encc
                        /cset (seta) def
                        exit
                    } if
                    swb encc
                    /cset (setb) def
                    exit
                } if
        
                % No switches or latches so encode
                cset (seta) eq {
                    msg i get enca
                    /i i 1 add def
                    exit
                } if
                cset (setb) eq {
                    msg i get encb
                    /i i 1 add def
                    exit
                } if
                cset (setc) eq {
                    msg i get fn1 eq {
                        fn1 encc
                        /i i 1 add def
                    } {
                        msg i 2 getinterval encc
                        /i i 2 add def 
                    } ifelse
                    exit
                } if
         
                exit
            } loop
        
        } loop
        /cws cws 0 j getinterval def
    } if  % auto encoding

    % Derive checksum and place stop character
    /cws j 2 add array dup 0 cws putinterval def
    /csum cws 0 get def
    1 1 j 1 sub {
        /i exch def
        /csum csum cws i get i mul add def
    } for
    /csum csum 103 mod def
    cws j csum put
    cws j 1 add seta stp get put

    % Create an array containing the character mappings
    /encs
    [ (212222) (222122) (222221) (121223) (121322) (131222) (122213)
      (122312) (132212) (221213) (221312) (231212) (112232) (122132)
      (122231) (113222) (123122) (123221) (223211) (221132) (221231)
      (213212) (223112) (312131) (311222) (321122) (321221) (312212)
      (322112) (322211) (212123) (212321) (232121) (111323) (131123)
      (131321) (112313) (132113) (132311) (211313) (231113) (231311)
      (112133) (112331) (132131) (113123) (113321) (133121) (313121)
      (211331) (231131) (213113) (213311) (213131) (311123) (311321)
      (331121) (312113) (312311) (332111) (314111) (221411) (431111)
      (111224) (111422) (121124) (121421) (141122) (141221) (112214)
      (112412) (122114) (122411) (142112) (142211) (241211) (221114)
      (413111) (241112) (134111) (111242) (121142) (121241) (114212)
      (124112) (124211) (411212) (421112) (421211) (212141) (214121)
      (412121) (111143) (111341) (131141) (114113) (114311) (411113)
      (411311) (113141) (114131) (311141) (411131) (211412) (211214)
      (211232) (2331112)
    ] def

    % Derive space bar succession
    /sbs cws length 6 mul 1 add string def
    0 1 cws length 1 sub {
        /i exch def
        sbs i 6 mul encs cws i get get putinterval
    } for

    % Return the arguments
    <<
    /ren //renlinear
    /sbs [sbs {48 sub} forall]
    /bhs [sbs length 1 add 2 idiv {height} repeat]
    /bbs [sbs length 1 add 2 idiv {0} repeat]
    /txt [ [text textxoffset textyoffset textfont textsize] ]
    /textxalign (center)
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/code128 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER code128--

% --BEGIN ENCODER gs1-128--
% --REQUIRES code128--
% --DESC: GS1-128
% --EXAM: (01)95012345678903(3103)000123
% --EXOP: includetext
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /code128 dup /uk.co.terryburton.bwipp findresource put
begin
/gs1-128 {

    20 dict begin            % Confine variables to local scope

    /options exch def  % We are given an option string
    /barcode exch def  % We are given a barcode string

    /dontdraw false def
    /includetext false def    % Enable/disable text
    /textfont /Courier def
    /textsize 10 def
    /textxoffset 0 def
    /textyoffset -7 def
    /height 0.5 def
    /linkagea false def
    /linkagec false def
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textxoffset textxoffset cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def 
   
    /text barcode def
 
    % Expand ordinals of the form ^NNN to ASCII
    /expand {
        /in exch def
        /out in length string def
        /j 0 def
        in
        { % loop
            (^) search {
                dup out exch j exch putinterval
                length j add 1 add /j exch def
                pop
                dup 0 3 getinterval cvi out exch j 1 sub exch put
                dup length 3 sub 3 exch getinterval
            } {
                dup out exch j exch putinterval
                length j add /j exch def
                out 0 j getinterval exit
            } ifelse 
        } loop
    } bind def
    
    % Parse out AIs
    /ais [] def
    /aival 2 dict def
    barcode dup length 1 sub 1 exch getinterval
    {  % loop
        dup () eq {exit} if
        (\)) search pop
        exch pop
        exch (\() search {
            exch pop exch 3 1 roll 
        } { 
            () 3 1 roll
        } ifelse
        [ ais aload pop counttomark 2 add index ] /ais exch def
        aival 3 1 roll expand put
    } loop
    pop

    % Pre-defined fixed length data field AIs
    % any AI whose prefix is not included in this table must be
    % terminated with "FNC1", even if it's fixed length
    /aifixed 23 dict def
    [
        0 1 4 {} for
    ] {
        (00) 2 string copy dup dup 1 5 -1 roll 48 add put aifixed 3 1 roll put
    } forall
    [
        11 1 20 {} for
        23
        31 1 36 {} for
        41
    ] {
        10 2 string cvrs dup aifixed 3 1 roll put
    } forall

    % Create the code128 data 
    /fnc1 -1 def
    /c128 [ fnc1 ] def
    0 1 ais length 1 sub {
        /i exch def
        /ai ais i get def
        /val aival ai get def
        c128 length ai length add val length add array
        dup 0 c128 putinterval
        dup c128 length ai [ exch {} forall ] putinterval
        dup c128 length ai length add val [ exch {} forall ] putinterval
        /c128 exch def
        i ais length 1 sub ne aifixed ai 0 2 getinterval known not and {  % Append FNC1
            c128 length 1 add array
            dup 0 c128 putinterval
            dup c128 length fnc1 put
            /c128 exch def
        } if
    } for

    % Compose input to code128
    /barcode c128 length 1 add 5 mul string def
    /i 0 def /j 0 def {
        i c128 length eq {exit} if
        c128 i get dup fnc1 eq {
            pop barcode j (^FNC1) putinterval
            /j j 4 add def
        } {
            barcode exch j exch put
        } ifelse
        /i i 1 add def
        /j j 1 add def
    } loop
    linkagea linkagec or {
        barcode j linkagea {(^LNKA)} {(^LNKC)} ifelse putinterval
        /j j 5 add def
    } if
    /barcode barcode 0 j getinterval def

    % Get the result of encoding with code128
    options (height) height put
    options (dontdraw) true put
    options (parsefnc) true put
    /args barcode options //code128 exec def

    args (txt) [ [text textxoffset textyoffset textfont textsize] ] put
    args (textxalign) (center) put
    args (opt) options put
    args
 
    dontdraw not //renlinear if
 
    end

} bind def
/gs1-128 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER gs1-128--

% --BEGIN ENCODER ean14--
% --REQUIRES code128--
% --DESC: GS1-14
% --EXAM: (01)04601234567893
% --EXOP: includetext
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /code128 dup /uk.co.terryburton.bwipp findresource put
begin
/ean14 {

    20 dict begin            % Confine variables to local scope

    /options exch def  % We are given an option string
    /barcode exch def  % We are given a barcode string

    /dontdraw false def
    /includetext false def    % Enable/disable text
    /textfont /Courier def
    /textsize 10 def
    /textxoffset 0 def
    /textyoffset -7 def
    /height 1 def
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textxoffset textxoffset cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def 

    % Calculate EAN checksum and add to end of barcode
    barcode length dup 17 eq exch 18 eq or 
    barcode 0 4 getinterval (\(01\)) eq and {
        /checksum 0 def
        0 1 12 {
            /i exch def
            /checksum checksum barcode i 4 add get 48 sub i 2 mod 0 eq {3 mul} if add def
        } for 
        /checksum 10 checksum 10 mod sub 10 mod def
        18 string
        dup 0 barcode 0 17 getinterval putinterval
        dup 17 checksum 48 add put
        /barcode exch def
        /gtin barcode 4 14 getinterval def
    } if

    % Compose input to code128
    /text barcode def
    /barcode 21 string def
    barcode 0 (^FNC101) putinterval
    barcode 7 gtin putinterval

    % Get the result of encoding with code128
    options (dontdraw) true put
    options (parsefnc) true put
    /args barcode options //code128 exec def

    args (txt) [ [text textxoffset textyoffset textfont textsize] ] put
    args (textxalign) (center) put
    args (opt) options put
    args
 
    dontdraw not //renlinear if
 
    end

} bind def
/ean14 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER ean14--

% --BEGIN ENCODER sscc18--
% --REQUIRES code128--
% --DESC: SSCC-18
% --EXAM: (00)006141411234567890
% --EXOP: includetext
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /code128 dup /uk.co.terryburton.bwipp findresource put
begin
/sscc18 {

    20 dict begin            % Confine variables to local scope

    /options exch def  % We are given an option string
    /barcode exch def  % We are given a barcode string

    /dontdraw false def
    /includetext false def    % Enable/disable text
    /textfont /Courier def
    /textsize 10 def
    /textxoffset 0 def
    /textyoffset -7 def
    /height 1 def
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textxoffset textxoffset cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def 

    % Calculate EAN checksum and add to end of barcode
    barcode length dup 21 eq exch 22 eq or 
    barcode 0 4 getinterval (\(00\)) eq and {
        /checksum 0 def
        0 1 16 {
            /i exch def
            /checksum checksum barcode i 4 add get 48 sub i 2 mod 0 eq {3 mul} if add def
        } for 
        /checksum 10 checksum 10 mod sub 10 mod def
        22 string
        dup 0 barcode 0 21 getinterval putinterval
        dup 21 checksum 48 add put
        /barcode exch def
        /sscc barcode 4 18 getinterval def
    } if

    % Compose input to code128
    /text barcode def
    /barcode 25 string def
    barcode 0 (^FNC100) putinterval
    barcode 7 sscc putinterval

    % Get the result of encoding with code128
    options (dontdraw) true put
    options (parsefnc) true put
    /args barcode options //code128 exec def

    args (txt) [ [text textxoffset textyoffset textfont textsize] ] put
    args (textxalign) (center) put
    args (opt) options put
    args
 
    dontdraw not //renlinear if
 
    end

} bind def
/sscc18 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER sscc18--

% --BEGIN ENCODER code39--
% --DESC: Code 39
% --EXAM: THIS IS CODE 39
% --EXOP: includetext includecheck includecheckintext
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/code39 {

    20 dict begin                 % Confine variables to local scope

    /options exch def       % We are given an option string
    /barcode exch def       % We are given a barcode string

    /dontdraw false def
    /includecheck false def  % Enable/disable checkdigit
    /includetext false def
    /includecheckintext false def
    /hidestars false def
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /height 1 def
    
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
 
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def
    
    % Create an array containing the character mappings
    /encs
    [ (1113313111) (3113111131) (1133111131) (3133111111) (1113311131)
      (3113311111) (1133311111) (1113113131) (3113113111) (1133113111)
      (3111131131) (1131131131) (3131131111) (1111331131) (3111331111)
      (1131331111) (1111133131) (3111133111) (1131133111) (1111333111)
      (3111111331) (1131111331) (3131111311) (1111311331) (3111311311)
      (1131311311) (1111113331) (3111113311) (1131113311) (1111313311)
      (3311111131) (1331111131) (3331111111) (1311311131) (3311311111)
      (1331311111) (1311113131) (3311113111) (1331113111) (1313131111)
      (1313111311) (1311131311) (1113131311) (1311313111)
    ] def

    % Create a string of the available characters
    /barchars (0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%*) def

    /barlen barcode length def  % Length of the code

    includecheck {
        /sbs barlen 10 mul 30 add string def
        /txt barlen 3 add array def
    } {
        /sbs barlen 10 mul 20 add string def
        /txt barlen 2 add array def
    } ifelse

    /checksum 0 def

    % Put the start character
    sbs 0 encs 43 get putinterval
    hidestars not {
        txt 0 [(*) 0 textyoffset textfont textsize] put
    } {
        txt 0 [() 0 textyoffset textfont textsize] put
    } ifelse

    0 1 barlen 1 sub {
        /i exch def
        % Lookup the encoding for the each barcode character
        barcode i 1 getinterval barchars exch search
        pop                                  % Discard true leaving pre
        length /indx exch def                % indx is the length of pre
        pop pop                              % Discard seek and post
        /enc encs indx get def               % Get the indxth encoding
        sbs i 10 mul 10 add enc putinterval  % Put encoded digit into sbs
        txt i 1 add [barcode i 1 getinterval i 1 add 16 mul textyoffset textfont textsize] put
        /checksum checksum indx add def
    } for

    % Put the checksum and end characters
    includecheck {
        /checksum checksum 43 mod def
        sbs barlen 10 mul 10 add encs checksum get putinterval
        includecheckintext {
            txt barlen 1 add [barchars checksum 1 getinterval barlen 1 add 16 mul textyoffset textfont textsize] put
        } {
            txt barlen 1 add [() barlen 1 add 16 mul textyoffset textfont textsize] put
        } ifelse
        sbs barlen 10 mul 20 add encs 43 get putinterval
        hidestars not {
            txt barlen 2 add [(*) barlen 2 add 16 mul textyoffset textfont textsize] put
        } {
            txt barlen 2 add [() barlen 2 add 16 mul textyoffset textfont textsize] put
        } ifelse
    } {
        sbs barlen 10 mul 10 add encs 43 get putinterval
        hidestars not {
            txt barlen 1 add [(*) barlen 1 add 16 mul textyoffset textfont textsize] put
        } {
            txt barlen 1 add [() barlen 1 add 16 mul textyoffset textfont textsize] put
        } ifelse
    } ifelse
    
    % Return the arguments
    <<
    /ren //renlinear
    /sbs [sbs {48 sub} forall]
    /bhs [sbs length 1 add 2 idiv {height} repeat]
    /bbs [sbs length 1 add 2 idiv {0} repeat]
    includetext {
        /txt txt
    } if
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/code39 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER code39--

% --BEGIN ENCODER code39ext--
% --REQUIRES code39--
% --DESC: Code 39 Extended
% --EXAM: Code39 Ext!
% --EXOP: includetext includecheck includecheckintext
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /code39 dup /uk.co.terryburton.bwipp findresource put
begin
/code39ext {

    20 dict begin

    /options exch def      % We are given an options string
    /barcode exch def      % We are given the code39extended text

    /dontdraw false def
    /includetext false def
    /parse false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    % Parse ordinals of the form ^NNN to ASCII
    parse {
        /msg barcode length string def
        /j 0 def
        barcode
        { % loop
            (^) search {
                dup msg exch j exch putinterval
                length j add 1 add /j exch def
                pop
                dup 0 3 getinterval cvi msg exch j 1 sub exch put
                dup length 3 sub 3 exch getinterval
            } {
                dup msg exch j exch putinterval
                length j add /j exch def
                /barcode msg 0 j getinterval def
                exit
            } ifelse 
        } loop
    } if

    /barlen barcode length def

    % Extended alphabet to non-extended alphabet
    /extencs
    [ (%U) ($A) ($B) ($C) ($D) ($E) ($F) ($G) ($H) ($I) ($J) ($K) ($L) ($M) ($N) ($O)
      ($P) ($Q) ($R) ($S) ($T) ($U) ($V) ($W) ($X) ($Y) ($Z) (%A) (%B) (%C) (%D) (%E)
      ( )  (/A) (/B) (/C) (/D) (/E) (/F) (/G) (/H) (/I) (/J) (/K) (/L) (-)  (.)  (/O)
      (0)  (1)  (2)  (3)  (4)  (5)  (6)  (7)  (8)  (9)  (/Z) (%F) (%G) (%H) (%I) (%J)
      (%V) (A)  (B)  (C)  (D)  (E)  (F)  (G)  (H)  (I)  (J)  (K)  (L)  (M)  (N)  (O)
      (P)  (Q)  (R)  (S)  (T)  (U)  (V)  (W)  (X)  (Y)  (Z)  (%K) (%L) (%M) (%N) (%O)
      (%W) (+A) (+B) (+C) (+D) (+E) (+F) (+G) (+H) (+I) (+J) (+K) (+L) (+M) (+N) (+O)
      (+P) (+Q) (+R) (+S) (+T) (+U) (+V) (+W) (+X) (+Y) (+Z) (%P) (%Q) (%R) (%S) (%T)
    ] def

    /newcode barlen 2 mul string def
    /newtext barlen 2 mul string def
    /j 0 def
    0 1 barlen 1 sub {
        /i exch def
        /extchar extencs barcode i get get def
        newcode j extchar putinterval
        newtext j barcode i get put
        extchar length 1 ne {newtext j 1 add ( ) putinterval} if
        /j j extchar length add def
    } for
    /newcode newcode 0 j getinterval def
    /newtext newtext 0 j getinterval def

    % Get the result of encoding with code39
    options (dontdraw) true put
    /args newcode options //code39 exec def

    % Replace chars in /txt with chars in newtext
    includetext {
        /txt args (txt) get def
        0 1 newtext length 1 sub {
            /i exch def
            /txtentry txt i 1 add get def
            txtentry 0 newtext i 1 getinterval put
            txt i 1 add txtentry put
        } for
        args (txt) txt put
    } if
    args (opt) options put
    args

    dontdraw not //renlinear if

    end

} bind def
/code39ext dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER code39ext--

% --BEGIN ENCODER code32--
% --REQUIRES code39--
% --DESC: Italian PharmaCode
% --EXAM: 01234567
% --EXOP: includetext
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /code39 dup /uk.co.terryburton.bwipp findresource put
begin
/code32 {

    20 dict begin

    /options exch def      % We are given an options string
    /barcode exch def      % We are given a barcode string

    /dontdraw false def
    /includetext false def  % Enable/disable code32 text
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /textxoffset 0 def
    /height 1 def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def

    /text 10 string def
    text 0 barcode 0 8 getinterval putinterval

    % calculate check digit
    text 8 0
    0 1 7 {
        dup text exch get 48 sub exch 1 and 1 add mul dup 9 gt {9 sub} if add
    } for
    10 mod 48 add put

    % convert number from base10 to base32
    /val text cvi 32 barcode cvrs def
    /barcode 6 string def
    0 1 5 {barcode exch 48 put} for
    barcode 6 val length sub val putinterval

    % convert base32 number to specified character set
    0 1 5 {
        dup barcode exch get
        dup (AEIO) {ge {1 add} if dup} forall pop
        barcode 3 1 roll put
    } for

    % format HRI
    text 1 text 0 9 getinterval putinterval
    text 0 65 put

    % Get the result of encoding with code39
    options (dontdraw) true put
    /args barcode options //code39 exec def

    args (txt) [ [text textxoffset textyoffset textfont textsize] ] put
    args (textxalign) (center) put
    args (opt) options put
    args

    dontdraw not //renlinear if

    end

} bind def
/code32 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER code32--

% --BEGIN ENCODER pzn--
% --REQUIRES code39--
% --DESC: Pharmazentralnummer (PZN)
% --EXAM: 123456
% --EXOP: includetext
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /code39 dup /uk.co.terryburton.bwipp findresource put
begin
/pzn {

    20 dict begin
 
    /options exch def      % We are given an options string
    /barcode exch def      % We are given a barcode string
 
    /dontdraw false def
    /includetext false def  % Enable/disable code32 text
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /textxoffset 0 def
    /height 1 def
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
 
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /textxoffset textxoffset cvr def
    /height height cvr def
 
    /text 13 string def
    text 0 barcode 0 6 getinterval putinterval
 
    % calculate check digit
    text 6 0
    0 1 5 {
        dup text exch get 48 sub exch 2 add mul add
    } for
    11 mod 48 add put
 
    /barcode 8 string def
    barcode 1 text 0 7 getinterval putinterval
    barcode 0 45 put
 
    % Get the result of encoding with code39
    options (dontdraw) true put
    /args barcode options //code39 exec def
 
    % format HRI
    text 6 text 0 7 getinterval putinterval
    text 0 (PZN - ) putinterval
 
    args (txt) [ [text textxoffset textyoffset textfont textsize] ] put
    args (textxalign) (center) put
    args (opt) options put
    args
 
    dontdraw not //renlinear if
 
    end
 
} bind def
/pzn dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER pzn--

% --BEGIN ENCODER code93--
% --DESC: Code 93
% --EXAM: THIS IS CODE 93
% --EXOP: includetext includecheck
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/code93 {

    20 dict begin                 % Confine variables to local scope

    /options exch def       % We are given an option string
    /barcode exch def       % We are given a barcode string

    /dontdraw false def
    /includecheck false def  % Enable/disable checkdigit
    /includetext false def   % Enable/disable text
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /height 1 def
    /parsefnc false def   
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
 
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def
    
    /encs
    [ (131112) (111213) (111312) (111411) (121113)
      (121212) (121311) (111114) (131211) (141111)
      (211113) (211212) (211311) (221112) (221211)
      (231111) (112113) (112212) (112311) (122112)
      (132111) (111123) (111222) (111321) (121122)
      (131121) (212112) (212211) (211122) (211221)
      (221121) (222111) (112122) (112221) (122121)
      (123111) (121131) (311112) (311211) (321111)
      (112131) (113121) (211131) (121221) (312111)
      (311121) (122211) (111141) (1111411)
    ] def

    % Create a string of the available characters
    /barchars (0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%) def

    /barlen barcode length def

    % Special function characters
    /sft1 -1 def  /sft2 -2 def  /sft3 -3 def  /sft4 -4 def
    /fncvals <<
        (SFT$) sft1
        (SFT%) sft2
        (SFT/) sft3
        (SFT+) sft4
    >> def

    % Convert input into bytes accounting for shift characters 
    /msg barlen array def
    /i 0 def /j 0 def {
        i barlen eq {exit} if
        /char barcode i get def
        parsefnc char 94 eq and i barlen 4 sub lt and {
            barcode i 1 add get 94 ne {
                /char fncvals barcode i 1 add 4 getinterval get def
                /i i 4 add def
            } {
                /i i 1 add def
            } ifelse
        } if
        msg j char put
        /i i 1 add def
        /j j 1 add def
    } loop
    /msg msg 0 j getinterval def
    /msglen msg length def

    includecheck {
        /sbs msglen 6 mul 25 add string def
    } {
        /sbs msglen 6 mul 13 add string def
    } ifelse
    /txt msglen array def

    % Put the start character
    sbs 0 encs 47 get putinterval
    
    /checksum1 0 def /checksum2 0 def
    0 1 msglen 1 sub {
        /i exch def
        % Lookup the encoding for the each barcode character
        msg i get dup 0 lt { 
            42 exch sub /indx exch def
            /char ( ) def
        } {
            1 string dup 0 4 -1 roll put /char exch def
            barchars char search
            pop                                  % Discard true leaving pre
            length /indx exch def                % indx is the length of pre
            pop pop                              % Discard seek and post
        } ifelse
        /enc encs indx get def                   % Get the indxth encoding
        sbs i 6 mul 6 add enc putinterval        % Put encoded digit into sbs
        txt i [char i 9 mul 9 add textyoffset textfont textsize] put
        /checksum1 checksum1 msglen i sub 1 sub 20 mod 1 add indx mul add def
        /checksum2 checksum2 msglen i sub 15 mod 1 add indx mul add def
    } for

    includecheck {
        % Put the first checksum character
        /checksum1 checksum1 47 mod def
        /checksum2 checksum2 checksum1 add 47 mod def
        sbs msglen 6 mul 6 add encs checksum1 get putinterval
        sbs msglen 6 mul 12 add encs checksum2 get putinterval
        % Put the end character
        sbs msglen 6 mul 18 add encs 48 get putinterval
    } {
        % Put the end character
        sbs msglen 6 mul 6 add encs 48 get putinterval      
    } ifelse

    % Return the arguments
    <<
    /ren //renlinear
    /sbs [sbs {48 sub} forall]
    /bhs [sbs length 1 add 2 idiv {height} repeat]
    /bbs [sbs length 1 add 2 idiv {0} repeat]
    includetext {
        /txt txt
    } if
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/code93 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER code93--

% --BEGIN ENCODER code93ext--
% --REQUIRES code93--
% --DESC: Code 93 Extended
% --EXAM: Code93 Ext!
% --EXOP: includetext includecheck
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /code93 dup /uk.co.terryburton.bwipp findresource put
begin
/code93ext {

    20 dict begin

    /options exch def      % We are given an options string
    /barcode exch def      % We are given the code39extended text

    /dontdraw false def
    /includetext false def
    /parse false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    % Parse ordinals of the form ^NNN to ASCII
    parse {
        /msg barcode length string def
        /j 0 def
        barcode
        { % loop
            (^) search {
                dup msg exch j exch putinterval
                length j add 1 add /j exch def
                pop
                dup 0 3 getinterval cvi msg exch j 1 sub exch put
                dup length 3 sub 3 exch getinterval
            } {
                dup msg exch j exch putinterval
                length j add /j exch def
                /barcode msg 0 j getinterval def
                exit
            } ifelse 
        } loop
    } if

    /barlen barcode length def

    % Extended alphabet to non-extended alphabet
    /extencs
    [ (^SFT%U) (^SFT$A) (^SFT$B) (^SFT$C) (^SFT$D) (^SFT$E) (^SFT$F) (^SFT$G) 
      (^SFT$H) (^SFT$I) (^SFT$J) (^SFT$K) (^SFT$L) (^SFT$M) (^SFT$N) (^SFT$O)
      (^SFT$P) (^SFT$Q) (^SFT$R) (^SFT$S) (^SFT$T) (^SFT$U) (^SFT$V) (^SFT$W)
      (^SFT$X) (^SFT$Y) (^SFT$Z) (^SFT%A) (^SFT%B) (^SFT%C) (^SFT%D) (^SFT%E)
      ( )      (^SFT/A) (^SFT/B) (^SFT/C) (^SFT/D) (^SFT/E) (^SFT/F) (^SFT/G)
      (^SFT/H) (^SFT/I) (^SFT/J) (^SFT/K) (^SFT/L) (-)      (.)      (^SFT/O)
      (0)      (1)      (2)      (3)      (4)      (5)      (6)      (7)
      (8)      (9)      (^SFT/Z) (^SFT%F) (^SFT%G) (^SFT%H) (^SFT%I) (^SFT%J)
      (^SFT%V) (A)      (B)      (C)      (D)      (E)      (F)      (G)
      (H)      (I)      (J)      (K)      (L)      (M)      (N)      (O)
      (P)      (Q)      (R)      (S)      (T)      (U)      (V)      (W)
      (X)      (Y)      (Z)      (^SFT%K) (^SFT%L) (^SFT%M) (^SFT%N) (^SFT%O)
      (^SFT%W) (^SFT+A) (^SFT+B) (^SFT+C) (^SFT+D) (^SFT+E) (^SFT+F) (^SFT+G)
      (^SFT+H) (^SFT+I) (^SFT+J) (^SFT+K) (^SFT+L) (^SFT+M) (^SFT+N) (^SFT+O)
      (^SFT+P) (^SFT+Q) (^SFT+R) (^SFT+S) (^SFT+T) (^SFT+U) (^SFT+V) (^SFT+W)
      (^SFT+X) (^SFT+Y) (^SFT+Z) (^SFT%P) (^SFT%Q) (^SFT%R) (^SFT%S) (^SFT%T)
    ] def

    /newcode barlen 6 mul string def
    /newtext barlen 6 mul string def
    /j 0 def /k 0 def
    0 1 barlen 1 sub {
        /i exch def
        /extchar extencs barcode i get get def
        /extlen extchar length def
        newcode j extchar putinterval
        newtext k barcode i get put
        extlen 1 ne {newtext k 1 add ( ) putinterval} if
        /j j extlen add def
        /k k extlen 1 eq {1} {2} ifelse add def
    } for
    /newcode newcode 0 j getinterval def
    /newtext newtext 0 k getinterval def

    % Get the result of encoding with code93
    options (dontdraw) true put
    options (parsefnc) true put
    /args newcode options //code93 exec def

    % Replace chars in /txt with chars in newtext
    includetext {
        /txt args (txt) get def
        0 1 newtext length 1 sub {
            /i exch def
            /txtentry txt i get def
            txtentry 0 newtext i 1 getinterval put
            txt i txtentry put
        } for
        args (txt) txt put
    } if
    args (opt) options put
    args

    dontdraw not //renlinear if

    end

} bind def
/code93ext dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER code93ext--

% --BEGIN ENCODER interleaved2of5--
% --DESC: Interleaved 2 of 5 (ITF)
% --EXAM: 2401234567
% --EXOP: height=0.5 includecheck includetext includecheckintext
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/interleaved2of5 {

    20 dict begin         % Confine variables to local scope

    /options exch def               % We are given an option string
    /barcode exch def               % We are given a barcode string

    /dontdraw false def
    /includecheck false def         % Enable/disable checkdigit
    /includetext false def          % Enable/disable text
    /includecheckintext false def
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /height 1 def
    
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
    
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def
    
    /barlen barcode length def      % Length of the code

    % Prefix 0 to barcode if length is even and including checkdigit
    % or length is odd and not including checkdigit
    barlen 2 mod 0 eq includecheck and          % even & includecheck
    barlen 2 mod 0 ne includecheck not and or { % odd  & !includecheck
        /pad barlen 1 add string def  % Create pad one bigger than barcode
        pad 0 48 put                  % Put ascii 0 at start of pad
        pad 1 barcode putinterval     % Add barcode to the end of pad
        /barcode pad def              % barcode=pad
        /barlen barlen 1 add def      % barlen++
    } if

    % Add checksum to end of barcode
    includecheck {
        /checksum 0 def
        0 1 barlen 1 sub {
            /i exch def
            i 2 mod 0 eq {
                /checksum checksum barcode i get 48 sub 3 mul add def
            } {
                /checksum checksum barcode i get 48 sub add def
            } ifelse
        } for
        /checksum 10 checksum 10 mod sub 10 mod def
        /pad barlen 1 add string def    % Create pad one bigger than barcode
        pad 0 barcode putinterval       % Add barcode to the start of pad
        pad barlen checksum 48 add put  % Add checksum to end of pad
        /barcode pad def                % barcode=pad
        /barlen barlen 1 add def        % barlen++
    } if

    % Create an array containing the character mappings
    /encs
    [ (11221) (21112) (12112) (22111) (11212)
      (21211) (12211) (11122) (21121) (12121)
      (1111)  (2111)
    ] def

    % Create a string of the available characters
    /barchars (0123456789) def
    /sbs barlen 5 mul 8 add string def
    /txt barlen array def

    % Put the start character
    sbs 0 encs 10 get putinterval

    0 2 barlen 1 sub {
    /i exch def
        % Lookup the encodings for two consecutive barcode characters
        barcode i 1 getinterval barchars exch search
        pop                           % Discard true leaving pre
        length /indx exch def         % indx is the length of pre
        pop pop                       % Discard seek and post
        /enca encs indx get def       % Get the indxth encoding

        barcode i 1 add 1 getinterval barchars exch search
        pop                           % Discard true leaving pre
        length /indx exch def         % indx is the length of pre
        pop pop                       % Discard seek and post
        /encb encs indx get def       % Get the indxth encoding

        % Interleave the two character encodings
        /intl enca length 2 mul string def
        0 1 enca length 1 sub {
            /j exch def
            /achar enca j get def
            /bchar encb j get def
            intl j 2 mul achar put
            intl j 2 mul 1 add bchar put
        } for

        sbs i 5 mul 4 add intl putinterval   % Put encoded digit into sbs
        txt i [barcode i 1 getinterval i 9 mul 4 add textyoffset textfont textsize] put
        includecheck includecheckintext not and barlen 2 sub i eq and {
            txt i 1 add [( ) i 1 add 9 mul 4 add textyoffset textfont textsize] put
        } {
            txt i 1 add [barcode i 1 add 1 getinterval i 1 add 9 mul 4 add textyoffset textfont textsize] put
        } ifelse
    } for

    % Put the end character
    sbs barlen 5 mul 4 add encs 11 get putinterval

    % Return the arguments
    <<
    /ren //renlinear
    /sbs [sbs {48 sub} forall]
    /bhs [sbs length 1 add 2 idiv {height} repeat]
    /bbs [sbs length 1 add 2 idiv {0} repeat]
    includetext {
        /txt txt
    } if
    /barratio 2
    /spaceratio 2
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/interleaved2of5 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER interleaved2of5--

% --BEGIN ENCODER itf14--
% --REQUIRES interleaved2of5--
% --DESC: ITF-14
% --EXAM: 04601234567893
% --EXOP: includetext
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /interleaved2of5 dup /uk.co.terryburton.bwipp findresource put
begin
/itf14 {

    20 dict begin            % Confine variables to local scope

    /options exch def  % We are given an option string
    /barcode exch def  % We are given a barcode string

    /dontdraw false def
    /includetext false def    % Enable/disable text
    /textfont /Courier def
    /textsize 10 def
    /textxoffset 0 def
    /textyoffset -7 def
    /height 1 def
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textxoffset textxoffset cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def 

    % Calculate EAN checksum and add to end of barcode
    barcode length dup 13 eq exch 14 eq or {
        /gtin barcode 0 13 getinterval def
    } if

    % Get the result of encoding with interleaved2of5
    options (dontdraw) true put
    options (showborder) true put
    options (borderwidth) 4 put
    options (borderleft) 15 put
    options (borderright) 15 put
    options (height) 0.5 put
    options (includecheck) true put
    options (includecheckintext) true put
    options (textyoffset) -10 put
    /args gtin options //interleaved2of5 exec def

    args (opt) options put
    args
 
    dontdraw not //renlinear if
 
    end

} bind def
/itf14 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER itf14--

% --BEGIN ENCODER identcode-- 
% --REQUIRES interleaved2of5--
% --DESC: Deutsche Post Identcode
% --EXAM: 563102430313
% --EXOP: includetext
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /interleaved2of5 dup /uk.co.terryburton.bwipp findresource put
begin
/identcode {

    20 dict begin            % Confine variables to local scope

    /options exch def  % We are given an option string
    /barcode exch def  % We are given a barcode string

    /dontdraw false def
    /includetext false def    % Enable/disable text
    /textfont /Courier def
    /textsize 10 def
    /textxoffset 0 def
    /textyoffset -7 def
    /height 1 def
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textxoffset textxoffset cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def 

    % Calculate checksum and add to end of barcode
    barcode length dup 11 eq exch 12 eq or {
        /checksum 0 def
        0 1 10 {
            /i exch def
            /checksum checksum barcode i get 48 sub i 2 mod 0 eq {4 mul} {9 mul} ifelse add def
        } for 
        /checksum 10 checksum 10 mod sub 10 mod def
        12 string
        dup 0 barcode 0 11 getinterval putinterval
        dup 11 checksum 48 add put
        /pad exch def
    } if
    /barcode pad def

    % Compose the human readable text
    /text (  .       .     ) 16 string copy def
    text  0 barcode  0 2 getinterval putinterval
    text  3 barcode  2 3 getinterval putinterval
    text  7 barcode  5 3 getinterval putinterval
    text 11 barcode  8 3 getinterval putinterval
    text 15 barcode 11 1 getinterval putinterval

    % Get the result of encoding with interleaved2of5
    options (dontdraw) true put
    options (includecheck) false put
    /args barcode options //interleaved2of5 exec def

    args (txt) [ [text textxoffset textyoffset textfont textsize] ] put
    args (textxalign) (center) put
    args (opt) options put
    args
 
    dontdraw not //renlinear if
 
    end

} bind def
/identcode dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER identcode--

% --BEGIN ENCODER leitcode-- 
% --REQUIRES interleaved2of5--
% --DESC: Deutsche Post Leitcode
% --EXAM: 21348075016401
% --EXOP: includetext
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /interleaved2of5 dup /uk.co.terryburton.bwipp findresource put
begin
/leitcode {

    20 dict begin            % Confine variables to local scope

    /options exch def  % We are given an option string
    /barcode exch def  % We are given a barcode string

    /dontdraw false def
    /includetext false def    % Enable/disable text
    /textfont /Courier def
    /textsize 10 def
    /textxoffset 0 def
    /textyoffset -7 def
    /height 1 def
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textxoffset textxoffset cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def 

    % Calculate checksum and add to end of barcode
    barcode length dup 13 eq exch 14 eq or {
        /checksum 0 def
        0 1 12 {
            /i exch def
            /checksum checksum barcode i get 48 sub i 2 mod 0 eq {4 mul} {9 mul} ifelse add def
        } for 
        /checksum 10 checksum 10 mod sub 10 mod def
        14 string
        dup 0 barcode 0 13 getinterval putinterval
        dup 13 checksum 48 add put
        /pad exch def
    } if
    /barcode pad def

    % Compose the human readable text
    /text (     .   .   .    ) 18 string copy def
    text  0 barcode  0 5 getinterval putinterval
    text  6 barcode  5 3 getinterval putinterval
    text 10 barcode  8 3 getinterval putinterval
    text 14 barcode 11 2 getinterval putinterval
    text 17 barcode 13 1 getinterval putinterval

    % Get the result of encoding with interleaved2of5
    options (dontdraw) true put
    options (includecheck) false put
    /args barcode options //interleaved2of5 exec def

    args (txt) [ [text textxoffset textyoffset textfont textsize] ] put
    args (textxalign) (center) put
    args (opt) options put
    args
 
    dontdraw not //renlinear if
 
    end

} bind def
/leitcode dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER leitcode--

% --BEGIN ENCODER databaromni--
% --DESC: GS1 DataBar Omnidirectional
% --EXAM: (01)24012345678905
% --EXOP:
% --RNDR: renlinear renmatrix
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/databaromni {

    20 dict begin            % Confine variables to local scope

    /options exch def  % We are given an option string
    /barcode exch def  % We are given a barcode string

    /dontdraw false def
    /height 33 72 div def
    /linkage false def
    /format (omni) def
    
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
  
    format (truncated) eq {/height 13 72 div def} if
    /height height cvr def

    % Strip the AI and optional check digit
    barcode length dup 17 eq exch 18 eq or {
        barcode 0 4 getinterval (\(01\)) eq {
            /binval [ 
                linkage {1} {0} ifelse
                barcode 4 13 getinterval {48 sub} forall
            ] def
        } if
    } if

    % Calculate EAN checksum and add to end of barcode
    /checksum 0 def
    0 1 12 {
        /i exch def
        /checksum checksum barcode i 4 add get 48 sub i 2 mod 0 eq {3 mul} if add def
    } for 
    /checksum 10 checksum 10 mod sub 10 mod def
    18 string
    dup 0 barcode 0 17 getinterval putinterval
    dup 17 checksum 48 add put
    /barcode exch def

    % Create the human readable text
    /txt barcode length array def
    0 1 barcode length 1 sub {
        /i exch def
        txt i [barcode i 1 getinterval 0 0 () 0] put
    } for

    /ncr {  % n r
        2 copy sub 2 copy lt {exch} if  % n r maxd mind
        1 1 5 3 roll  % mind j=1 v=1 n maxd
        1 add -1 exch {  % mind j v  n -1 maxd+1
            mul  % mind j v*i
            1 index 3 index le {
                1 index idiv exch 1 add exch
            } if
        } for
        {  % mind j v
            1 index 3 index gt {exit} if
            1 index idiv exch 1 add exch
        } loop
        exch pop exch pop
    } bind def
     
    /getRSSwidths {
        /oe exch def
        /el exch def
        /mw exch def
        /nm exch def
        /val exch def
        /out el array def
        /mask 0 def
        0 1 el 2 sub {
            /bar exch def
            /ew 1 def 
            /mask mask 1 bar bitshift or def {
                /sval nm ew sub 1 sub el bar sub 2 sub ncr def
                oe mask 0 eq and nm ew sub el 2 mul sub bar 2 mul add -2 ge and {
                    /sval sval nm ew sub el sub bar add el bar sub 2 sub ncr sub def
                } if
                el bar sub 2 gt {
                    /lval 0 def
                    nm ew sub el sub bar add 2 add -1 mw 1 add {
                        nm exch sub ew sub 1 sub el bar sub 3 sub ncr
                        /lval exch lval add def
                    } for
                    /sval sval lval el bar sub 1 sub mul sub def
                } {
                    nm ew sub mw gt {/sval sval 1 sub def} if
                } ifelse
                /val val sval sub def
                val 0 lt {exit} if
                /ew ew 1 add def
                /mask mask 1 bar bitshift not and def
            } loop  
            /val val sval add def
            /nm nm ew sub def
            out bar ew put 
        } for
        out el 1 sub nm put
        out
    } bind def
   
    0 1 12 {
        /i exch def
        binval i 1 add 2 copy get binval i get 4537077 mod 10 mul add put
        binval i binval i get 4537077 idiv put
    } for
    /right binval 13 get 4537077 mod def
    binval 13 2 copy get 4537077 idiv put

    /left 0 def
    /i true def
    0 1 13 {
        /j exch def
        binval j get
        dup 0 eq i and {
            pop
        } {
            /i false def
            /left left 3 -1 roll 10 13 j sub exp cvi mul add def
        } ifelse
    } for
    
    /d1 left 1597 idiv def
    /d2 left 1597 mod def
    /d3 right 1597 idiv def
    /d4 right 1597 mod def

    /tab164 [
        160   0     12 4   8 1  161   1
        960   161   10 6   6 3  80   10
        2014  961   8  8   4 5  31   34
        2714  2015  6  10  3 6  10   70
        2840  2715  4  12  1 8  1    126
    ] def

    /tab154 [
        335   0     5  10  2 7  4   84
        1035  336   7  8   4 5  20  35
        1515  1036  9  6   6 3  48  10
        1596  1516  11 4   8 1  81  1
    ] def

    /i 0 def {
        d1 tab164 i get le {
            tab164 i 1 add 7 getinterval {} forall
            /d1te exch def /d1to exch def
            /d1mwe exch def /d1mwo exch def
            /d1ele exch def /d1elo exch def
            /d1gs exch def
            exit
        } if
        /i i 8 add def
    } loop

    /i 0 def {
        d2 tab154 i get le {
            tab154 i 1 add 7 getinterval {} forall
            /d2te exch def /d2to exch def
            /d2mwe exch def /d2mwo exch def
            /d2ele exch def /d2elo exch def
            /d2gs exch def
            exit
        } if
        /i i 8 add def
    } loop

    /i 0 def {
        d3 tab164 i get le {
            tab164 i 1 add 7 getinterval {} forall
            /d3te exch def /d3to exch def
            /d3mwe exch def /d3mwo exch def
            /d3ele exch def /d3elo exch def
            /d3gs exch def
            exit
        } if
        /i i 8 add def
    } loop

    /i 0 def {
        d4 tab154 i get le {
            tab154 i 1 add 7 getinterval {} forall
            /d4te exch def /d4to exch def
            /d4mwe exch def /d4mwo exch def
            /d4ele exch def /d4elo exch def
            /d4gs exch def
            exit
        } if
        /i i 8 add def
    } loop
    
    /d1wo d1 d1gs sub d1te idiv d1elo d1mwo 4 false getRSSwidths def
    /d1we d1 d1gs sub d1te mod  d1ele d1mwe 4 true  getRSSwidths def
    /d2wo d2 d2gs sub d2to mod  d2elo d2mwo 4 true  getRSSwidths def
    /d2we d2 d2gs sub d2to idiv d2ele d2mwe 4 false getRSSwidths def
    /d3wo d3 d3gs sub d3te idiv d3elo d3mwo 4 false getRSSwidths def
    /d3we d3 d3gs sub d3te mod  d3ele d3mwe 4 true  getRSSwidths def
    /d4wo d4 d4gs sub d4to mod  d4elo d4mwo 4 true  getRSSwidths def
    /d4we d4 d4gs sub d4to idiv d4ele d4mwe 4 false getRSSwidths def

    /d1w 8 array def
    0 1 3 {
        /i exch def
        d1w i 2 mul d1wo i get put
        d1w i 2 mul 1 add d1we i get put
    } for

    /d2w 8 array def
    0 1 3 {
        /i exch def
        d2w 7 i 2 mul sub d2wo i get put
        d2w 6 i 2 mul sub d2we i get put
    } for
    
    /d3w 8 array def
    0 1 3 {
        /i exch def
        d3w 7 i 2 mul sub d3wo i get put
        d3w 6 i 2 mul sub d3we i get put
    } for
    
    /d4w 8 array def
    0 1 3 {
        /i exch def
        d4w i 2 mul d4wo i get put
        d4w i 2 mul 1 add d4we i get put
    } for

    /widths [
        d1w {} forall
        d2w {} forall
        d3w {} forall
        d4w {} forall
    ] def
    
    /checkweights [
        1   3   9   27  2   6   18  54
        58  72  24  8   29  36  12  4
        74  51  17  32  37  65  48  16
        64  34  23  69  49  68  46  59
    ] def

    /checkwidths [
        3 8 2 1 1   3 5 5 1 1   3 3 7 1 1
        3 1 9 1 1   2 7 4 1 1   2 5 6 1 1
        2 3 8 1 1   1 5 7 1 1   1 3 9 1 1
    ] def
    
    /checksum 0 def
    0 1 31 {
        /i exch def
        /checksum checksum widths i get checkweights i get mul add def 
    } for
    /checksum checksum 79 mod def    
    checksum 8 ge {/checksum checksum 1 add def} if
    checksum 72 ge {/checksum checksum 1 add def} if
    /checklt checkwidths checksum 9 idiv 5 mul 5 getinterval def
    /checkrtrev checkwidths checksum 9 mod 5 mul 5 getinterval def
    /checkrt 5 array def
    0 1 4 {
        /i exch def
        checkrt i checkrtrev 4 i sub get put
    } for

    % Stacked format
    format (omni) eq format (truncated) eq or {  % linear

        /sbs [
            1 d1w {} forall checklt {} forall d2w {} forall 
            d4w {} forall checkrt {} forall d3w {} forall 1 1
        ] def
        
        <<
        /ren //renlinear
        /sbs sbs
        /bhs [sbs length 1 add 2 idiv {height} repeat]
        /bbs [sbs length 1 add 2 idiv {0} repeat]
        /txt txt
        /textxalign (center)
        /opt options
        >>
    
        dontdraw not //renlinear if

    } {  % 2D - stacked or stackedomni

        /top [ 1 1 d1w {} forall checklt {} forall d2w {} forall 1 1 0 ] def
        /bot [ 1 1 d4w {} forall checkrt {} forall d3w {} forall 1 1 0 ] def 
        0 2 24 {
            /i exch def
            top i get {0} repeat
            top i 1 add get {1} repeat
        } for
        50 array astore /top exch def 
        0 2 24 {
            /i exch def
            bot i get {1} repeat
            bot i 1 add get {0} repeat
        } for
        50 array astore /bot exch def

        % Stacked
        format (stacked) eq {
            /sep [ 50 {0} repeat ] def
            4 1 45 {
                /i exch def
                top i get bot i get eq {
                    sep i 1 top i get sub put
                } {
                    sep i 1 sep i 1 sub get sub put
                } ifelse
            } for
            /pixs [
                5 {top aload pop} repeat
                sep aload pop
                7 {bot aload pop} repeat
            ] def
            /pixy pixs length 50 idiv def
        } if
    
        % Stacked omnidirectional
        format (stackedomni) eq {
            /sep1 [ top {1 exch sub} forall ] def
            sep1 0  [ 0 0 0 0 ] putinterval
            sep1 46 [ 0 0 0 0 ] putinterval
            18 1 30 {
                /i exch def
                top i get 0 eq {
                    top i 1 sub get 1 eq {
                        1
                    } {
                        sep1 i 1 sub get 0 eq {1} {0} ifelse
                    } ifelse
                } {
                    0
                } ifelse
                sep1 exch i exch put
            } for
            /sep2 [ 0 0 0 0 21 { 0 1 } repeat 0 0 0 0 ] def
            /sep3 [ bot {1 exch sub} forall ] def
            sep3 0  [ 0 0 0 0 ] putinterval
            sep3 46 [ 0 0 0 0 ] putinterval
            19 1 31 {
                /i exch def
                bot i get 0 eq {
                    bot i 1 sub get 1 eq {
                        1
                    } {
                        sep3 i 1 sub get 0 eq {1} {0} ifelse
                    } ifelse
                } {
                    0
                } ifelse
                sep3 exch i exch put
            } for
            /f3 [1 1 1 1 1 1 1 1 1 0 1 1 1] def
            true 0 1 12 {dup bot exch 19 add get exch f3 exch get eq and} for {
                % Right shifted module for value 3 finder
                sep3 19 [ 0 0 0 0 0 0 0 0 0 0 1 0 0 ] putinterval
            } if
            /pixs [
                33 {top aload pop} repeat
                sep1 aload pop
                sep2 aload pop
                sep3 aload pop
                33 {bot aload pop} repeat
            ] def
            /pixy pixs length 50 idiv def
        } if
    
        % Return the arguments
        <<
        /ren //renmatrix
        /pixs pixs
        /pixx 50
        /pixy pixy
        /height pixy 72 div
        /width 50 72 div
        /opt options
        >>
    
        dontdraw not //renmatrix if
     
    } ifelse
    
    end

} bind def
/databaromni dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER databaromni--

% --BEGIN ENCODER databarstacked--
% --REQUIRES databaromni--
% --DESC: GS1 DataBar Stacked
% --EXAM: (01)24012345678905
% --EXOP:
% --RNDR: renmatrix renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
dup /databaromni dup /uk.co.terryburton.bwipp findresource put
begin
/databarstacked {

    20 dict begin                 % Confine variables to local scope

    /options exch def       % We are given an option string
    /barcode exch def       % We are given a barcode string

    /dontdraw false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    % Get the result of encoding with databaromni with format=stacked
    options (dontdraw) true put
    options (format) (stacked) put

    /args barcode options //databaromni exec def

    args (opt) options put
    args
 
    dontdraw not //renmatrix if

    end

} bind def
/databarstacked dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER databarstacked--

% --BEGIN ENCODER databarstackedomni--
% --REQUIRES databaromni--
% --DESC: GS1 DataBar Stacked Omnidirectional
% --EXAM: (01)24012345678905
% --EXOP:
% --RNDR: renmatrix renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
dup /databaromni dup /uk.co.terryburton.bwipp findresource put
begin
/databarstackedomni {

    20 dict begin                 % Confine variables to local scope

    /options exch def       % We are given an option string
    /barcode exch def       % We are given a barcode string

    /dontdraw false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    % Get the result of encoding with databaromni with format=stackedomni
    options (dontdraw) true put
    options (format) (stackedomni) put

    /args barcode options //databaromni exec def

    args (opt) options put
    args
 
    dontdraw not //renmatrix if

    end

} bind def
/databarstackedomni dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER databarstackedomni--

% --BEGIN ENCODER databartruncated--
% --REQUIRES databaromni--
% --DESC: GS1 DataBar Truncated
% --EXAM: (01)24012345678905
% --EXOP:
% --RNDR: renlinear renmatrix
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /databaromni dup /uk.co.terryburton.bwipp findresource put
begin
/databartruncated {

    20 dict begin                 % Confine variables to local scope

    /options exch def       % We are given an option string
    /barcode exch def       % We are given a barcode string

    /dontdraw false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    % Get the result of encoding with databaromni with format=truncated
    options (dontdraw) true put
    options (format) (truncated) put

    /args barcode options //databaromni exec def

    args (opt) options put
    args
 
    dontdraw not //renlinear if

    end

} bind def
/databartruncated dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER databartruncated--

% --BEGIN ENCODER databarlimited--
% --DESC: GS1 DataBar Limited
% --EXAM: (01)15012345678907
% --EXOP:
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/databarlimited {

    20 dict begin            % Confine variables to local scope

    /options exch def  % We are given an option string
    /barcode exch def  % We are given a barcode string

    /dontdraw false def
    /height 10 72 div def
    /linkage false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
   
    /height height cvr def

    % Strip the AI and optional check digit
    barcode length dup 17 eq exch 18 eq or {
        barcode 0 5 getinterval dup (\(01\)0) eq exch (\(01\)1) eq or {
            /binval [ 
                barcode 4 13 getinterval {48 sub} forall
            ] def
            linkage {
                /linkval [ 2 0 1 5 1 3 3 5 3 1 0 9 6 ] def
                0 1 binval length 1 sub {
                    /i exch def
                    binval i binval i get linkval i get add put
                } for
            } if 
        } if
    } if

    % Calculate EAN checksum and add to end of barcode
    /checksum 0 def
    0 1 12 {
        /i exch def
        /checksum checksum barcode i 4 add get 48 sub i 2 mod 0 eq {3 mul} if add def
    } for 
    /checksum 10 checksum 10 mod sub 10 mod def
    18 string
    dup 0 barcode 0 17 getinterval putinterval
    dup 17 checksum 48 add put
    /barcode exch def

    % Create the human readable text
    /txt barcode length array def
    0 1 barcode length 1 sub {
        /i exch def
        txt i [barcode i 1 getinterval 0 0 () 0] put
    } for

    /ncr {  % n r
        2 copy sub 2 copy lt {exch} if  % n r maxd mind
        1 1 5 3 roll  % mind j=1 v=1 n maxd
        1 add -1 exch {  % mind j v  n -1 maxd+1
            mul  % mind j v*i
            1 index 3 index le {
                1 index idiv exch 1 add exch
            } if
        } for
        {  % mind j v
            1 index 3 index gt {exit} if
            1 index idiv exch 1 add exch
        } loop
        exch pop exch pop
    } bind def
    
    /getRSSwidths {
        /oe exch def
        /el exch def
        /mw exch def
        /nm exch def
        /val exch def
        /out el array def
        /mask 0 def
        0 1 el 2 sub {
            /bar exch def
            /ew 1 def 
            /mask mask 1 bar bitshift or def {
                /sval nm ew sub 1 sub el bar sub 2 sub ncr def
                oe mask 0 eq and nm ew sub el 2 mul sub bar 2 mul add -2 ge and {
                    /sval sval nm ew sub el sub bar add el bar sub 2 sub ncr sub def
                } if
                el bar sub 2 gt {
                    /lval 0 def
                    nm ew sub el sub bar add 2 add -1 mw 1 add {
                        nm exch sub ew sub 1 sub el bar sub 3 sub ncr
                        /lval exch lval add def
                    } for
                    /sval sval lval el bar sub 1 sub mul sub def
                } {
                    nm ew sub mw gt {/sval sval 1 sub def} if
                } ifelse
                /val val sval sub def
                val 0 lt {exit} if
                /ew ew 1 add def
                /mask mask 1 bar bitshift not and def
            } loop  
            /val val sval add def
            /nm nm ew sub def
            out bar ew put 
        } for
        out el 1 sub nm put
        out
    } bind def
   
    0 1 11 {
        /i exch def
        binval i 1 add 2 copy get binval i get 2013571 mod 10 mul add put
        binval i binval i get 2013571 idiv put
    } for
    /d2 binval 12 get 2013571 mod def
    binval 12 2 copy get 2013571 idiv put

    /d1 0 def
    /i true def
    0 1 12 {
        /j exch def
        binval j get
        dup 0 eq i and {
            pop
        } {
            /i false def
            /d1 d1 3 -1 roll 10 12 j sub exp cvi mul add def
        } ifelse
    } for
    
    /tab267 [
        183063   0        17 9   6 3  6538   28
        820063   183064   13 13  5 4  875    728
        1000775  820064   9  17  3 6  28     6454
        1491020  1000776  15 11  5 4  2415   203
        1979844  1491021  11 15  4 5  203    2408
        1996938  1979845  19 7   8 1  17094  1
        2013570  1996939  7  19  1 8  1      16632
    ] def

    /i 0 def {
        d1 tab267 i get le {
            tab267 i 1 add 7 getinterval {} forall
            /d1te exch def /d1to exch def
            /d1mwe exch def /d1mwo exch def
            /d1ele exch def /d1elo exch def
            /d1gs exch def
            exit
        } if
        /i i 8 add def
    } loop

    /i 0 def {
        d2 tab267 i get le {
            tab267 i 1 add 7 getinterval {} forall
            /d2te exch def /d2to exch def
            /d2mwe exch def /d2mwo exch def
            /d2ele exch def /d2elo exch def
            /d2gs exch def
            exit
        } if
        /i i 8 add def
    } loop

    /d1wo d1 d1gs sub d1te idiv d1elo d1mwo 7 false getRSSwidths def    
    /d1we d1 d1gs sub d1te mod  d1ele d1mwe 7 true  getRSSwidths def
    /d2wo d2 d2gs sub d2te idiv d2elo d2mwo 7 false getRSSwidths def    
    /d2we d2 d2gs sub d2te mod  d2ele d2mwe 7 true  getRSSwidths def

    /d1w 14 array def
    0 1 6 {
        /i exch def
        d1w i 2 mul d1wo i get put
        d1w i 2 mul 1 add d1we i get put
    } for

    /d2w 14 array def
    0 1 6 {
        /i exch def
        d2w i 2 mul d2wo i get put
        d2w i 2 mul 1 add d2we i get put
    } for

    /widths [
        d1w {} forall
        d2w {} forall
    ] def
    
    /checkweights [
        1  3  9  27 81 65 17 51 64 14 42 37 22 66
        20 60 2  6  18 54 73 41 34 13 39 28 84 74
    ] def

    /checkseq [
        0 1 43 {} for
        45 52 57
        63 1 66 {} for
        73 1 79 {} for
        82
        126 1 130 {} for
        132
        141 1 146 {} for
        210 1 217 {} for
        220
        316 1 320 {} for
        322 323
        326 337
    ] def
   
    /checksum 0 def
    0 1 27 {
        /i exch def
        /checksum checksum widths i get checkweights i get mul add def
    } for
    /checksum checksum 89 mod def
    /seq checkseq checksum get def
    /swidths seq 21 idiv 8 3 6 false getRSSwidths def
    /bwidths seq 21 mod  8 3 6 false getRSSwidths def

    /checkwidths [0 0 0 0 0 0 0 0 0 0 0 0 1 1] def
    0 1 5 {
        /i exch def
        checkwidths i 2 mul swidths i get put
        checkwidths i 2 mul 1 add bwidths i get put
    } for
    
    /sbs [
        1 d1w {} forall checkwidths {} forall d2w {} forall 1 1
    ] def
    
    % Return the arguments
    <<
    /ren //renlinear
    /sbs sbs
    /bhs [sbs length 1 add 2 idiv {height} repeat]
    /bbs [sbs length 1 add 2 idiv {0} repeat]
    /txt txt
    /textxalign (center)
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/databarlimited dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER databarlimited--

% --BEGIN ENCODER databarexpanded--
% --DESC: GS1 DataBar Expanded
% --EXAM: (01)95012345678903(3103)000123
% --EXOP:
% --RNDR: renlinear renmatrix
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/databarexpanded {

    20 dict begin            % Confine variables to local scope

    /options exch def  % We are given an option string
    /barcode exch def  % We are given a barcode string

    /dontdraw false def
    /height 34 72 div def
    /format (expanded) def
    /segments -1 def
    /linkage false def   
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
 
    /height height cvr def
    /segments segments cvi def

    segments -1 eq {
        /segments format (expandedstacked) eq {4} {22} ifelse def
    } if

    % Expand ordinals of the form ^NNN to ASCII
    /expand {
        /in exch def
        /out in length string def
        /j 0 def
        in
        { % loop
            (^) search {
                dup out exch j exch putinterval
                length j add 1 add /j exch def
                pop
                dup 0 3 getinterval cvi out exch j 1 sub exch put
                dup length 3 sub 3 exch getinterval
            } {
                dup out exch j exch putinterval
                length j add /j exch def
                out 0 j getinterval exit
            } ifelse 
        } loop
    } bind def
    
    % Parse out AIs
    /ais [] def
    /aival 2 dict def
    barcode dup length 1 sub 1 exch getinterval
    {  % loop
        dup () eq {exit} if
        (\)) search pop
        exch pop
        exch (\() search {
            exch pop exch 3 1 roll 
        } { 
            () 3 1 roll
        }  ifelse
        [ ais aload pop counttomark 2 add index ] /ais exch def
        aival 3 1 roll expand put
    } loop
    pop
    
    % Method selection
    {  % common exit
    
        % (01)9...(3103)...
        ais length 2 eq {
            ais 0 get (01) eq ais 1 get (3103) eq and { 
                aival (01) get 0 1 getinterval (9) eq aival (3103) get cvi 32767 le and {
                   (0100) false exit 
                } if
            } if
        } if
    
        % (01)9...(3202)...
        ais length 2 eq {
            ais 0 get (01) eq ais 1 get (3202) eq and {
                aival (01) get 0 1 getinterval (9) eq aival (3202) get cvi 9999 le and {
                    (0101) false exit
                } if
            } if
        } if
    
        % (01)9...(3203)...
        ais length 2 eq {
            ais 0 get (01) eq ais 1 get (3203) eq and {
                aival (01) get 0 1 getinterval (9) eq aival (3203) get cvi 22767 le and {
                    (0101) false exit
                } if
            } if
        } if
    
        % (01)9...(310x/320x)...[(11/13/15/17)...]
        ais length dup 2 eq exch 3 eq or {
           /ai310x false 3100 1 3109 {10 4 string cvrs ais 1 get eq or} for def
           /ai320x false 3200 1 3209 {10 4 string cvrs ais 1 get eq or} for def
           ais length 3 eq {
               /aibad true [ (11) (13) (15) (17) ] {ais 2 get ne and} forall def
           } {
               /aibad false def
           } ifelse
           ais 0 get (01) eq ai310x ai320x or and aibad not and {
               ais length 3 eq {
                   aival (01) get 0 1 getinterval (9) eq 
                   aival ais 1 get get cvi 99999 le and 
                   aival ais 2 get get cvi 999999 le and {
                       ai310x ais 2 get (11) eq and { (0111000) false exit } if
                       ai320x ais 2 get (11) eq and { (0111001) false exit } if
                       ai310x ais 2 get (13) eq and { (0111010) false exit } if
                       ai320x ais 2 get (13) eq and { (0111011) false exit } if
                       ai310x ais 2 get (15) eq and { (0111100) false exit } if
                       ai320x ais 2 get (15) eq and { (0111101) false exit } if
                       ai310x ais 2 get (17) eq and { (0111110) false exit } if
                       ai320x ais 2 get (17) eq and { (0111111) false exit } if
                   } if
               } {
                   aival (01) get 0 1 getinterval (9) eq 
                   aival ais 1 get get cvi 99999 le and {
                       ai310x { (0111000) false exit } if
                       ai320x { (0111001) false exit } if
                   } if
               } ifelse
           } if
        } if
    
        % (01)9...(392x)...
        ais length 2 ge {
            /ai392x false 3920 1 3923 {10 4 string cvrs ais 1 get eq or} for def
            ais 0 get (01) eq ai392x and {
                aival (01) get 0 1 getinterval (9) eq { (01100) true exit } if
            } if
        } if
    
        % (01)9...(393x)...
        ais length 2 ge {
            /ai393x false 3930 1 3933 {10 4 string cvrs ais 1 get eq or} for def
            ais 0 get (01) eq ai393x and {
                aival (01) get 0 1 getinterval (9) eq { (01101) true exit } if
            } if
        } if
    
        % (01)...
        ais 0 get (01) eq { (1) true exit } if
    
        % Freeform
        (00) true exit
    
    } loop
    /gpfallow exch def
    /method exch def
   
    /conv12to40 {
        (0000000000000000000000000000000000000000) 40 string copy
        2 copy  0 10 getinterval exch 0 3 getinterval cvi 2 10 string cvrs dup length 10 exch sub exch putinterval
        2 copy 10 10 getinterval exch 3 3 getinterval cvi 2 10 string cvrs dup length 10 exch sub exch putinterval
        2 copy 20 10 getinterval exch 6 3 getinterval cvi 2 10 string cvrs dup length 10 exch sub exch putinterval
        2 copy 30 10 getinterval exch 9 3 getinterval cvi 2 10 string cvrs dup length 10 exch sub exch putinterval
        exch pop
    } bind def
    
    /conv13to44 {
        (00000000000000000000000000000000000000000000) 44 string copy
        2 copy 0 4 getinterval exch 0 1 getinterval cvi 2 4 string cvrs dup length 4 exch sub exch putinterval
        dup 3 -1 roll 1 12 getinterval conv12to40 4 exch putinterval
    } bind def
    
    /tobin {
        string dup length 1 sub 0 exch 1 exch {1 index exch 48 put} for
        dup 3 -1 roll 2 2 index length string cvrs dup length 2 index length exch sub exch putinterval 
    } bind def
    
    method (00) eq {
        /cdf [] def
        /gpf [] def
    } if
    
    method (1) eq {
        /cdf aival (01) get 0 13 getinterval conv13to44 def
        /cdf [ cdf {48 sub} forall ] def
        /gpf [] def
        /ais ais 1 ais length 1 sub getinterval def
    } if
    
    method (0100) eq {
        /cdf 55 string def
        cdf 0 aival (01) get 1 12 getinterval conv12to40 putinterval
        cdf 40 aival (3103) get cvi 15 tobin putinterval
        /cdf [ cdf {48 sub} forall ] def
        /gpf [] def
        /ais [] def
    } if
    
    method (0101) eq {
        /cdf 55 string def
        cdf 0 aival (01) get 1 12 getinterval conv12to40 putinterval
        ais 1 get (3202) eq {
            aival (3202) get cvi 15 tobin
        } {
            aival (3203) get cvi 10000 add 15 tobin
        } ifelse
        cdf exch 40 exch putinterval
        /cdf [ cdf {48 sub} forall ] def
        /gpf [] def
        /ais [] def
    } if
    
    method length 7 eq {
        /cdf 76 string def
        cdf 0 aival (01) get 1 12 getinterval conv12to40 putinterval
        6 string dup 0 ais 1 get 3 1 getinterval putinterval
        dup aival ais 1 get get 1 5 getinterval 1 exch putinterval cvi 20 tobin
        cdf exch 40 exch putinterval
        ais length 3 eq {
            aival ais 2 get get
            dup 0 2 getinterval cvi 384 mul exch
            dup 2 2 getinterval cvi 1 sub 32 mul exch
            4 2 getinterval cvi add add 
        } {
            38400
        } ifelse
        16 tobin cdf exch 60 exch putinterval
        /cdf [ cdf {48 sub} forall ] def
        /gpf [] def
        /ais [] def
    } if
    
    method (01100) eq {
        /cdf 42 string def
        cdf 0 aival (01) get 1 12 getinterval conv12to40 putinterval
        cdf 40 ais 1 get 3 1 getinterval cvi 2 tobin putinterval
        /cdf [ cdf {48 sub} forall ] def
        /gpf [ aival ais 1 get get {} forall ] def
        /ais ais 2 ais length 2 sub getinterval def
    } if
    
    method (01101) eq {
        /cdf 52 string def
        cdf 0 aival (01) get 1 12 getinterval conv12to40 putinterval
        cdf 40 ais 1 get 3 1 getinterval cvi 2 tobin putinterval
        cdf 42 aival ais 1 get get 0 3 getinterval cvi 10 tobin putinterval
        /cdf [ cdf {48 sub} forall ] def
        /gpf [ aival ais 1 get get dup length 3 sub 3 exch getinterval {} forall ] def
        /ais ais 2 ais length 2 sub getinterval def
    } if
    
    % Variable length symbol field
    gpfallow {
        /vlf 2 array def
    } {
        /vlf [] def
    } ifelse
    
    % Pre-defined fixed length data field AIs
    % any AI whose prefix is not included in this table must be
    % terminated with "FNC1", even if it's fixed length
    /aifixed 23 dict def
    [
        0 1 4 {} for
    ] {
        (00) 2 string copy dup dup 1 5 -1 roll 48 add put aifixed 3 1 roll put
    } forall
    [
        11 1 20 {} for
        23
        31 1 36 {} for
        41
    ] {
        10 2 string cvrs dup aifixed 3 1 roll put
    } forall

    /fnc1 -1 def /lnumeric -2 def /lalphanumeric -3 def /liso646 -4 def
    
    /numeric <<
        0 1 119 {
            dup (00) 2 string copy dup 3 -1 roll 11 2 string cvrs
            dup length 2 exch sub exch putinterval 
            dup 0 get 65 eq {dup 0 94 put} if 
            dup 1 get 65 eq {dup 1 94 put} if 
            exch 8 add
            (0000000) 7 string copy dup 3 -1 roll 2 7 string cvrs 
            dup length 7 exch sub exch putinterval
        } for
        lalphanumeric (0000)
    >> def
    
    /alphanumeric <<
        48 1 57 {dup 43 sub 5 tobin} for
        fnc1 (01111)
        65 1 90 {dup 33 sub 6 tobin} for
        42 (111010)
        44 1 47 {dup 15 add 6 tobin} for
        lnumeric (000)
        liso646 (00100)
    >> def
    
    /iso646 <<
        48 1 57 {dup 43 sub 5 tobin} for
        fnc1 (01111)
        65 1 90 {dup 1 sub 7 tobin} for
        97 1 122 {dup 7 sub 7 tobin} for
        33 (11101000)
        34 (11101001)
        37 1 47 {dup 197 add 8 tobin} for
        58 1 63 {dup 187 add 8 tobin} for
        95 (11111011)
        32 (11111100)
        lnumeric (000)
        lalphanumeric (00100)
    >> def
    
    % Append the remaining AI data
    0 1 ais length 1 sub {
        /i exch def
        /ai ais i get def
        /val aival ai get def
        gpf length ai length add val length add array
        dup 0 gpf putinterval
        dup gpf length ai [ exch {} forall ] putinterval
        dup gpf length ai length add val [ exch {} forall ] putinterval
        /gpf exch def
        i ais length 1 sub ne aifixed ai 0 2 getinterval known not and {  % Append FNC1
            gpf length 1 add array
            dup 0 gpf putinterval
            dup gpf length fnc1 put
            /gpf exch def
        } if
    } for
    
    % Calculate the number of bits remaining to the next valid symbol size
    /rembits {
        dup
        12 div ceiling cvi 12 mul            % Round up to multiple of 12 
        48 2 copy lt {exch} if pop           % At least 4 symbols
        dup 12 idiv dup segments mod 1 eq {  % At least 2 symbols on last row of stacked symbol
            1 add 12 mul exch pop
        } {
            pop
        } ifelse 
        exch sub
    } bind def
    
    /encode {
        dup /raw ne {exch get} {pop} ifelse
        [ exch {48 sub} forall ]
        dup length exch
        gpfenc exch j exch putinterval
        /j exch j add def
    } bind def
   
    % Pre-compute alphanumeric and numeric runlengths and position of next ISO646-only characters
    /numericruns [ gpf length {0} repeat 0 -1 ] def
    /alphanumericruns [ gpf length {0} repeat 0 ] def
    /nextiso646only [ gpf length {0} repeat 9999 ] def
    gpf length 1 sub -1 0 {
        /i exch def
        gpf i get
        (00) 2 string copy
        dup 0 gpf i get dup fnc1 eq {pop 94} if put 
        i gpf length 1 sub lt {dup 1 gpf i 1 add get dup fnc1 eq {pop 94} if put} if
        numeric exch known {
            numericruns i numericruns i 2 add get 2 add put
        } {
            numericruns i 0 put
        } ifelse
        dup alphanumeric exch known {
            alphanumericruns i alphanumericruns i 1 add get 1 add put
        } {
            alphanumericruns i 0 put
        } ifelse
        dup iso646 exch known exch alphanumeric exch known not and {
            nextiso646only i 0 put
        } {
            nextiso646only i nextiso646only i 1 add get 1 add put
        } ifelse
    } for
   
    % Encode the general purpose field
    /gpfenc 252 array def
    /i 0 def /j 0 def /mode (numeric) def
    {  % loop
        i gpf length eq {exit} if
        {  % not a loop but common exit point
    
            mode (numeric) eq {
                i gpf length 2 sub le {
                    2 string 
                    dup 0 gpf i get dup fnc1 eq {pop 94} if put
                    dup 1 gpf i 1 add get dup fnc1 eq {pop 94} if put
                    dup numeric exch known {
                        numeric encode
                        /i i 2 add def
                        exit
                    } if
                    pop
                    lalphanumeric numeric encode 
                    /mode (alphanumeric) def
                    exit
                } {
                    gpf i get dup 48 lt exch 57 gt or {
                        lalphanumeric numeric encode
                        /mode (alphanumeric) def
                        exit
                    } if
                    /rem 12 1 add method length add vlf length add cdf length add j add rembits def
                    rem 4 ge rem 6 le and {  % C1 + 1 into 4 to 6 bits
                        (000000) 6 string copy 0 rem getinterval
                        dup gpf i get 47 sub 2 4 string cvrs
                        dup length 4 exch sub exch putinterval /raw encode
                        /i i 1 add def
                        exit
                    } {  % C1.FNC1
                        2 string dup 0 gpf i get put dup 1 94 put numeric encode 
                        /i i 1 add def
                        exit
                    } ifelse
                } ifelse
            } if
    
            mode (alphanumeric) eq {
                gpf i get fnc1 eq {
                    fnc1 alphanumeric encode
                    /i i 1 add def
                    exit
                } if
                gpf i get dup iso646 exch known exch alphanumeric exch known not and {
                     liso646 alphanumeric encode
                     /mode (iso646) def
                     exit
                } if
                numericruns i get 6 ge {
                    lnumeric alphanumeric encode
                    /mode (numeric) def
                    exit
                } if
                numericruns i get dup 4 ge exch i add gpf length eq and {
                    lnumeric alphanumeric encode
                    /mode (numeric) def
                    exit
                } if
                gpf i get alphanumeric encode
                /i i 1 add def
                exit
            } if
    
            mode (iso646) eq {
                gpf i get fnc1 eq {
                    fnc1 iso646 encode
                    /i i 1 add def
                    exit
                } if
                numericruns i get 4 ge nextiso646only i get 10 ge and {
                    lnumeric iso646 encode
                    /mode (numeric) def
                    exit
                } if
                alphanumericruns i get 5 ge nextiso646only i get 10 ge and {
                    lalphanumeric iso646 encode
                    /mode (alphanumeric) def
                    exit
                } if
                gpf i get iso646 encode
                /i i 1 add def
                exit
            } if
    
        } loop
    } loop
    /gpf gpfenc 0 j getinterval def
   
    % Complete the variable length field and create pad
    1 12 add method length add vlf length add cdf length add gpf length add 
    dup rembits dup array /pad exch def
    vlf length 0 ne {
        add 12 idiv
        dup 2 mod vlf exch 0 exch put
        14 le {0} {1} ifelse vlf exch 1 exch put
    } {
        pop pop
    } ifelse
    pad length 0 gt {
        0 5 pad length 1 sub {  % Fill with 00100
            /i exch def
            pad i [ 0 0 1 0 0 ] 0 pad length i sub 5 2 copy gt {exch} if pop getinterval putinterval 
        } for 
        mode (numeric) eq {  % Prefix shift from numeric to ASCII
            /pad [ 0 0 0 0 pad aload pop ] 0 pad length getinterval def
        } if
    } if
   
    % Concatinate fields
    /binval [
        linkage {1} {0} ifelse 
        method {48 sub} forall
        vlf aload pop
        cdf aload pop
        gpf aload pop
        pad aload pop
    ] def
    /datalen binval length 12 idiv def
    
    /ncr {  % n r
        2 copy sub 2 copy lt {exch} if  % n r maxd mind
        1 1 5 3 roll  % mind j=1 v=1 n maxd
        1 add -1 exch {  % mind j v  n -1 maxd+1
            mul  % mind j v*i
            1 index 3 index le {
                1 index idiv exch 1 add exch
            } if
        } for
        {  % mind j v
            1 index 3 index gt {exit} if
            1 index idiv exch 1 add exch
        } loop
        exch pop exch pop
    } bind def
    
    /getRSSwidths {
        /oe exch def
        /el exch def
        /mw exch def
        /nm exch def
        /val exch def
        /out el array def
        /mask 0 def
        0 1 el 2 sub {
            /bar exch def
            /ew 1 def 
            /mask mask 1 bar bitshift or def {
                /sval nm ew sub 1 sub el bar sub 2 sub ncr def
                oe mask 0 eq and nm ew sub el 2 mul sub bar 2 mul add -2 ge and {
                    /sval sval nm ew sub el sub bar add el bar sub 2 sub ncr sub def
                } if
                el bar sub 2 gt {
                    /lval 0 def
                    nm ew sub el sub bar add 2 add -1 mw 1 add {
                        nm exch sub ew sub 1 sub el bar sub 3 sub ncr
                        /lval exch lval add def
                    } for
                    /sval sval lval el bar sub 1 sub mul sub def
                } {
                    nm ew sub mw gt {/sval sval 1 sub def} if
                } ifelse
                /val val sval sub def
                val 0 lt {exit} if
                /ew ew 1 add def
                /mask mask 1 bar bitshift not and def
            } loop  
            /val val sval add def
            /nm nm ew sub def
            out bar ew put 
        } for
        out el 1 sub nm put
        out
    } bind def

    /tab174 [
        347   0     12 5   7 2  87  4
        1387  348   10 7   5 4  52  20
        2947  1388  8  9   4 5  30  52
        3987  2948  6  11  3 6  10  104
        4191  3988  4  13  1 8  1   204
    ] def

    /dxw datalen array def
    
    0 1 datalen 1 sub {

        /x exch def

        /d binval x 12 mul 12 getinterval def
        /d 0 0 1 11 {/j exch def 2 11 j sub exp cvi d j get mul add} for def

        /j 0 def {
            d tab174 j get le {
                tab174 j 1 add 7 getinterval {} forall
                /dte exch def /dto exch def
                /dmwe exch def /dmwo exch def
                /dele exch def /delo exch def
                /dgs exch def
                exit
            } if
            /j j 8 add def
        } loop

        /dwo d dgs sub dte idiv delo dmwo 4 true  getRSSwidths def
        /dwe d dgs sub dte mod  dele dmwe 4 false getRSSwidths def

        /dw 8 array def        
        x 2 mod 0 eq {                    
            0 1 3 {
                /j exch def
                dw 7 j 2 mul sub dwo j get put
                dw 6 j 2 mul sub dwe j get put
            } for
        } {           
            0 1 3 {
                /j exch def
                dw j 2 mul dwo j get put
                dw j 2 mul 1 add dwe j get put
            } for
        } ifelse

        dxw x dw put

    } for
    
    /finderwidths [
        1 8 4 1 1    1 1 4 8 1
        3 6 4 1 1    1 1 4 6 3
        3 4 6 1 1    1 1 6 4 3
        3 2 8 1 1    1 1 8 2 3
        2 6 5 1 1    1 1 5 6 2
        2 2 9 1 1    1 1 9 2 2
    ] def

    /finderseq [
        [0 1]
        [0 3 2]
        [0 5 2 7]
        [0 9 2 7 4]
        [0 9 2 7 6 11]
        [0 9 2 7 8 11 10]
        [0 1 2 3 4 5 6 7]
        [0 1 2 3 4 5 6 9 8]
        [0 1 2 3 4 5 6 9 10 11]
        [0 1 2 3 4 7 6 9 8 11 10]
    ] def

    /seq finderseq datalen 2 sub 2 idiv get def
    /fxw seq length array def
    0 1 seq length 1 sub {
        /x exch def
        fxw x finderwidths seq x get 5 mul 5 getinterval put
    } for

    /checkweights [
        -1   -1   -1   -1   -1   -1   -1   -1   % A1L
        77   96   32   81   27   9    3    1    % A1R
        20   60   180  118  143  7    21   63   % A2L
        205  209  140  117  39   13   145  189  % A2R
        193  157  49   147  19   57   171  91   % B1L 
        132  44   85   169  197  136  186  62   % B1R
        185  133  188  142  4    12   36   108  % B2L
        50   87   29   80   97   173  128  113  % B2R
        150  28   84   41   123  158  52   156  % C1L
        166  196  206  139  187  203  138  46   % C1R
        76   17   51   153  37   111  122  155  % C2L
        146  119  110  107  106  176  129  43   % C2R
        16   48   144  10   30   90   59   177  % D1L
        164  125  112  178  200  137  116  109  % D1R
        70   210  208  202  184  130  179  115  % D2L
        190  204  68   93   31   151  191  134  % D2R
        148  22   66   198  172  94   71   2    % E1L
        40   154  192  64   162  54   18   6    % E1R
        120  149  25   75   14   42   126  167  % E2L
        175  199  207  69   23   78   26   79   % E2R
        103  98   83   38   114  131  182  124  % F1L
        159  53   88   170  127  183  61   161  % F1R
        55   165  73   8    24   72   5    15   % F2L
        89   100  174  58   160  194  135  45   % F2R
    ] def

    /checkweightseq [
       seq {16 mul checkweights exch 16 getinterval aload pop} forall
    ] dup length 8 sub 8 exch getinterval def

    /widths [
        dxw {{} forall} forall
    ] def
   
    /checksum 0 def
    0 1 widths length 1 sub {
        /i exch def
        /checksum checksum widths i get checkweightseq i get mul add def 
    } for
    /checksum checksum 211 mod datalen 3 sub 211 mul add def

    /i 0 def {
        checksum tab174 i get le {
            tab174 i 1 add 7 getinterval {} forall
            /cte exch def /cto exch def
            /cmwe exch def /cmwo exch def
            /cele exch def /celo exch def
            /cgs exch def
            exit
        } if
        /i i 8 add def
    } loop

    /cwo checksum cgs sub cte idiv celo cmwo 4 true  getRSSwidths def
    /cwe checksum cgs sub cte mod  cele cmwe 4 false getRSSwidths def

    /cw 8 array def        
    0 1 3 {
        /i exch def
        cw i 2 mul cwo i get put
        cw i 2 mul 1 add cwe i get put
    } for

    22 array dup dup
    0 cw put 1 dxw putinterval 0 datalen 1 add getinterval
    /dxw exch def
    /datalen dxw length def

    % Encode row runlengths
    /rows datalen segments div ceiling cvi array def
    /numrows rows length def
    0 1 numrows 1 sub {
        /r exch def
        mark
        segments 4 mod 0 ne r 2 mod 1 eq and {0} if
        1 1
        0 1 segments 1 sub {
            /pos exch r segments mul add def
            pos datalen lt {
                dxw pos get {} forall                 
                pos 2 mod 0 eq {fxw pos 2 idiv get {} forall} if
            } if
        } for
        1 1
        counttomark array astore rows exch r exch put pop
    } for

    format (expandedstacked) ne {  % Linear

        % Remove leading space
        /sbs rows 0 get dup length 1 sub 1 exch getinterval def

        /sbs [
            1
            0 1 datalen 1 sub {
                /i exch def
                dxw i get {} forall
                i 2 mod 0 eq {fxw i 2 idiv get {} forall} if
            } for
            1 1
        ] def

        <<
        /ren //renlinear
        /sbs sbs
        /bhs [sbs length 1 add 2 idiv {height} repeat]
        /bbs [sbs length 1 add 2 idiv {0} repeat]
        /opt options
        >>

        dontdraw not //renlinear if

    } {  % expandedstacked

        /seps numrows array def
        0 1 numrows 1 sub {

            /r exch def
            /row rows r get def

            % Sample runlengths into bitmap
            mark
            0 2 row length 1 sub {
                /i exch def
                row i get {0} repeat
                i row length 1 sub lt {row i 1 add get {1} repeat} if
            } for
            counttomark array astore /row exch def pop

            % Derive the separator pattern
            /sep [ row {1 exch sub} forall ] def
            sep 0 [ 0 0 0 0 ] putinterval
            sep row length 4 sub [ 0 0 0 0 ] putinterval
            /finderpos [  % Finder pattern module positions
                19 98 row length 13 sub {} for
                68 98 row length 13 sub {} for
            ] def 
            finderpos {
                dup 14 add 1 exch {
                    /i exch def
                    row i get 0 eq {
                        row i 1 sub get 1 eq {
                            1
                        } {
                            sep i 1 sub get 0 eq {1} {0} ifelse
                        } ifelse
                    } {
                        0
                    } ifelse
                    sep exch i exch put
                } for
            } forall

            % For even segment-pair symbols reverse alternate rows
            segments 4 mod 0 eq r 2 mod 1 eq and {
                rows r get length rows 0 get length ne  % Except partial width last row
                finderpos length 2 mod 1 eq and {       % with odd finders
                    /row [ 0 row aload pop ] def
                    /sep [ 0 sep aload pop ] def
                } {
                    row length 1 sub -1 0 {row exch get} for
                    row astore pop
                    sep length 1 sub -1 0 {sep exch get} for
                    sep astore pop
                } ifelse
            } if

            rows r row put
            seps r sep put

        } for

        % Extend last row and separator to fill width of symbol
        /pixx rows 0 get length def
        [ pixx {0} repeat ] dup 0 rows numrows 1 sub get putinterval
        rows exch numrows 1 sub exch put 
        [ pixx {0} repeat ] dup 0 seps numrows 1 sub get putinterval
        seps exch numrows 1 sub exch put 

        % Middle separator pattern
        /sep [ pixx 2 idiv 1 add { 0 1 } repeat ] 0 pixx getinterval def
        sep 0 [0 0 0 0] putinterval
        sep pixx 4 sub [0 0 0 0] putinterval

        % Compose the symbol
        /pixs [
            0 1 numrows 1 sub {
                /r exch def
                r 0 ne {
                    seps r get aload pop
                } if
                34 {rows r get aload pop} repeat
                r numrows 1 sub ne {
                    seps r get aload pop
                    sep aload pop
                } if
            } for
        ] def

        <<
        /ren //renmatrix
        /pixs pixs
        /pixx pixx
        /pixy pixs length pixx idiv
        /height pixs length pixx idiv 72 div
        /width pixx 72 div
        /opt options
        >>

        dontdraw not //renmatrix if

    } ifelse

    end

} bind def
/databarexpanded dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER databarexpanded--

% --BEGIN ENCODER databarexpandedstacked--
% --REQUIRES databarexpanded--
% --DESC: GS1 DataBar Expanded Stacked
% --EXAM: (01)95012345678903(3103)000123
% --EXOP: segments=4
% --RNDR: renmatrix renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
dup /databarexpanded dup /uk.co.terryburton.bwipp findresource put
begin
/databarexpandedstacked {

    20 dict begin                 % Confine variables to local scope

    /options exch def       % We are given an option string
    /barcode exch def       % We are given a barcode string

    /dontdraw false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    % Get the result of encoding with databarexpanded with format=expandedstacked
    options (dontdraw) true put
    options (format) (expandedstacked) put

    /args barcode options //databarexpanded exec def

    args (opt) options put
    args
 
    dontdraw not //renmatrix if

    end

} bind def
/databarexpandedstacked dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER databarexpandedstacked--

% --BEGIN ENCODER pharmacode--
% --DESC: Pharmaceutical Binary Code
% --EXAM: 117480
% --EXOP: showborder
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/pharmacode {

    20 dict begin                 % Confine variables to local scope

    /options exch def       % We are given an option string
    /barcode exch def       % We are given a barcode string

    /dontdraw false def
    /height 8 2.835 mul 72 div def
    /nwidth 0.5 2.835 mul def
    /wwidth 1.5 2.835 mul def
    /swidth 1.0 2.835 mul def    

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
 
    /height height cvr def
    /nwidth nwidth cvr def
    /wwidth wwidth cvr def
    /swidth swidth cvr def

    % Create the human readable text
    /txt barcode length array def
    0 1 barcode length 1 sub {
        /i exch def
        txt i [barcode i 1 getinterval 0 0 () 0] put
    } for

    % Convert the integer into the paramacode string 
    /barcode barcode cvi 1 add 2 17 string cvrs def
    /barcode barcode 1 barcode length 1 sub getinterval def

    /barlen barcode length def  % Length of the code
    /sbs barlen 2 mul array def

    0 1 barlen 1 sub {
        /i exch def
        /enc barcode i 1 getinterval def
        enc (0) eq {
            sbs i 2 mul nwidth put
        } {
            sbs i 2 mul wwidth put
        } ifelse
        sbs i 2 mul 1 add swidth put
    } for

    % Return the arguments
    <<
    /ren //renlinear
    /sbs sbs
    /bhs [sbs length 1 add 2 idiv {height} repeat]
    /bbs [sbs length 1 add 2 idiv {0} repeat]
    /txt txt
    /textxalign (center)
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/pharmacode dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER pharmacode--

% --BEGIN ENCODER pharmacode2--
% --DESC: Two-track Pharmacode
% --EXAM: 117480
% --EXOP: includetext showborder
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/pharmacode2 {

    20 dict begin

    /options exch def           % We are given an option string
    /barcode exch def           % We are given a barcode string

    /dontdraw false def
    /includetext false def      % Enable/disable text
    /height 4 def               % Height of short bars in millimetres

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /height height cvr def

    % Create the human readable text
    /txt barcode length array def
    0 1 barcode length 1 sub {
        /i exch def
        txt i [barcode i 1 getinterval 0 0 () 0] put
    } for

    /encstr 16 string def
    /bhs 16 array def
    /bbs 16 array def
    /sbs 32 array def
    /bar 1 25.4 div height mul def     % bar height (mm)
    /spc 1 25.4 div 72 mul def         % bar width & spacing (1mm)
 
    % Convert number into a base3 representation
    /i 15 def
    /val barcode cvi def
    {  % loop
        val 0 eq {exit} if
        val 3 mod dup
        [3 1 2] exch get val exch sub 3 idiv /val exch def
        encstr i [2 0 1] 4 -1 roll get put
        /i i 1 sub def
    } loop
    /encstr encstr i 1 add 15 i sub getinterval def
 
    % Generate the bar pattern
    0 1 encstr length 1 sub {
        /i exch def
        encstr i get dup
        bhs i bar [1 1 2] 5 -1 roll get mul put
        bbs i [0 bar 0] 4 -1 roll get put
    } for
     
    % Return the arguments
    <<
    /ren //renlinear
    /bhs bhs
    /bbs bbs
    /sbs [encstr length 2 mul {spc} repeat]
    /txt txt
    /textxalign (center)
    /textyoffset 4
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/pharmacode2 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER pharmacode2--

% --BEGIN ENCODER code2of5--
% --DESC: Code 25
% --EXAM: 01234567
% --EXOP: version=iata includetext includecheck includecheckintext
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/code2of5 {

    20 dict begin                 % Confine variable to local scope

    /options exch def       % We are given an option string
    /barcode exch def       % We are given a barcode string

    /dontdraw false def
    /includecheck false def
    /includetext false def   % Enable/disable text
    /includecheckintext false def
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /height 1 def
    /version (industrial) def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def

    % Create an array containing the character mappings
    << 
    /industrial
        [ (1111313111) (3111111131) (1131111131) (3131111111)
          (1111311131) (3111311111) (1131311111) (1111113131)
          (3111113111) (1131113111) (313111)     (31113)
        ] 
    /iata
        [ (1111313111) (3111111131) (1131111131) (3131111111)
          (1111311131) (3111311111) (1131311111) (1111113131)
          (3111113111) (1131113111) (1111)       (311)
        ]
    /matrix
        [ (113311) (311131) (131131) (331111) (113131) (313111)
          (133111) (111331) (311311) (131311) (311111) (31111)
        ]
    /coop
        [ (331111) (111331) (113131) (113311) (131131) (131311)
          (133111) (311131) (311311) (313111) (3131)   (133)
        ]
    /datalogic
        [ (113311) (311131) (131131) (331111) (113131) (313111)
          (133111) (111331) (311311) (131311) (1111)   (311)
        ]
    >>
    version get /encs exch def
    /cs encs 0 get length def
    /cw 0 encs 0 get {48 sub add} forall def
    /ss encs dup length 2 sub get length def
    /sw 0 encs dup length 2 sub get {48 sub add} forall def

    % Create a string of the available characters
    /barchars (0123456789) def

    /barlen barcode length def            % Length of the code

    includecheck {
        /sbs barlen 1 add cs mul ss add ss add string def
        /txt barlen 1 add array def
    } {
        /sbs barlen cs mul ss add ss add string def
        /txt barlen array def
    } ifelse

    % Put the start character
    sbs 0 encs 10 get putinterval

    /checksum 0 def

    0 1 barlen 1 sub {
        /i exch def
        % Lookup the encoding for the each barcode character
        barcode i 1 getinterval barchars exch search
        pop                                 % Discard true leaving pre
        length /indx exch def               % indx is the length of pre
        pop pop                             % Discard seek and post
        /enc encs indx get def              % Get the indxth encoding
        sbs i cs mul ss add enc putinterval % Put encoded digit into sbs
        txt i [barcode i 1 getinterval i cw mul sw add textyoffset textfont textsize] put
        barlen i sub 2 mod 0 eq {
            /checksum checksum indx add def
        } {
            /checksum checksum indx 3 mul add def
        } ifelse
    } for

    % Put the checksum and end characters
    includecheck {
        /checksum 10 checksum 10 mod sub 10 mod def
        sbs barlen cs mul ss add encs checksum get putinterval
        sbs barlen cs mul cs add ss add encs 11 get putinterval
        includecheckintext {
            txt barlen [barchars checksum 1 getinterval barlen cw mul sw add textyoffset textfont textsize] put
        } {
            txt barlen [( ) barlen cw mul sw add textyoffset textfont textsize] put
        } ifelse
    } {
        sbs barlen cs mul ss add encs 11 get putinterval
    } ifelse

    % Return the arguments
    <<
    /ren //renlinear
    /sbs [sbs {48 sub} forall]
    /bhs [sbs length 1 add 2 idiv {height} repeat]
    /bbs [sbs length 1 add 2 idiv {0} repeat]
    includetext {
        /txt txt
    } if
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/code2of5 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER code2of5--

% --BEGIN ENCODER code11--
% --DESC: Code 11
% --EXAM: 0123456789
% --EXOP: includetext includecheck includecheckintext
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/code11 {

    20 dict begin            % Confine variables to local scope

    /options exch def  % We are given an option string
    /barcode exch def  % We are given a barcode string

    /dontdraw false def
    /includecheck false def
    /includetext false def
    /includecheckintext false def
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /height 1 def
    
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
 
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def
    
    % Create an array containing the character mappings
    /encs
    [ (111131) (311131) (131131) (331111) (113131)
      (313111) (133111) (111331) (311311) (311111)
      (113111) (113311)
    ] def

    % Create a string of the available characters
    /barchars (0123456789-) def

    /barlen barcode length def        % Length of the code

    includecheck {
        barlen 10 ge {
            /sbs barlen 6 mul 24 add string def
            /txt barlen 2 add array def
        } {
            /sbs barlen 6 mul 18 add string def
            /txt barlen 1 add array def
        } ifelse
    } {
        /sbs barlen 6 mul 12 add string def
        /txt barlen array def
    } ifelse

    % Put the start character
    sbs 0 encs 11 get putinterval

    /checksum1 0 def /checksum2 0 def
    
    /xpos 8 def
    0 1 barlen 1 sub {
        /i exch def
        % Lookup the encoding for the each barcode character
        barcode i 1 getinterval barchars exch search
        pop                                % Discard true leaving pre
        length /indx exch def              % indx is the length of pre
        pop pop                            % Discard seek and post
        /enc encs indx get def             % Get the indxth encoding
        sbs i 6 mul 6 add enc putinterval  % Put encoded digit into sbs
        txt i [barcode i 1 getinterval xpos textyoffset textfont textsize] put
        0 1 5 {       % xpos+=width of the character
            /xpos exch enc exch get 48 sub xpos add def
        } for
        /checksum1 checksum1 barlen i sub 1 sub 10 mod 1 add indx mul add def
        /checksum2 checksum2 barlen i sub 9 mod 1 add indx mul add def
    } for
   
    % Put the checksum and end characters
    includecheck {
        /checksum1 checksum1 11 mod def        
        barlen 10 ge {
            /checksum2 checksum2 checksum1 add 11 mod def
            sbs barlen 6 mul 6 add encs checksum1 get putinterval        
            sbs barlen 6 mul 12 add encs checksum2 get putinterval
            includecheckintext {
                txt barlen [barchars checksum1 1 getinterval xpos textyoffset textfont textsize] put
                /enc encs checksum1 get def   
                0 1 5 {       % xpos+=width of the character
                    /xpos exch enc exch get 48 sub xpos add def
                } for
                txt barlen 1 add [barchars checksum2 1 getinterval xpos textyoffset textfont textsize] put
            } {
                txt barlen [() xpos textyoffset textfont textsize] put
                txt barlen 1 add [() xpos textyoffset textfont textsize] put
            } ifelse
            sbs barlen 6 mul 18 add encs 11 get putinterval
        } {
            sbs barlen 6 mul 6 add encs checksum1 get putinterval          
            includecheckintext {
                txt barlen [barchars checksum1 1 getinterval xpos textyoffset textfont textsize] put
            } {
                txt barlen [() xpos textyoffset textfont textsize] put
            } ifelse
            sbs barlen 6 mul 12 add encs 11 get putinterval
        } ifelse
    } {
        sbs barlen 6 mul 6 add encs 11 get putinterval
    } ifelse

    % Return the arguments
    <<
    /ren //renlinear
    /sbs [sbs {48 sub} forall]
    /bhs [sbs length 1 add 2 idiv {height} repeat]
    /bbs [sbs length 1 add 2 idiv {0} repeat]
    includetext {
        /txt txt
    } if
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/code11 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER code11--

% --BEGIN ENCODER bc412--
% --DESC: BC412
% --EXAM: BC412
% --EXOP: semi includetext includecheckintext
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/bc412 {

    20 dict begin                 % Confine variables to local scope

    /options exch def       % We are given an option string
    /barcode exch def       % We are given a barcode string

    /dontdraw false def
    /includecheck false def  % Enable/disable checkdigit
    /includetext false def
    /includecheckintext false def
    /includestartstop false def
    /semi false def
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /height 1 def
    
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
 
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def
   
    semi {
        /includecheck true def
        /includestartstop true def
    } if
 
    % Create an array containing the character mappings
    /encs
    [ (11111115) (13111212) (11131113) (12111213) (12121311)
      (13131111) (12111312) (11131212) (11121411) (11151111)
      (15111111) (11111511) (12131211) (13121112) (13111212)
      (11111214) (12121113) (11111313) (13111113) (11121213)
      (11141112) (11121312) (11141211) (14121111) (12121212)
      (11131311) (13121211) (12111411) (14111211) (11111412)
      (12111114) (14111112) (12141111) (11121114) (12131112)
      (12) (111)
    ] def

    % Create a string of the available characters
    /barchars (0R9GLVHA8EZ4NTS1J2Q6C7DYKBUIX3FWP5M) def

    /barlen barcode length def  % Length of the code

    /sbs barlen 1 add 8 mul 5 add string def
    includecheck {
        /txt barlen 1 add array def
    } {
        /txt barlen array def
    } ifelse

    % Put the start character
    includestartstop {
        sbs 0 encs 35 get putinterval
        /pos 2 def
        /txtpos 3 def
    } {
        /pos 0 def
        /txtpos 0 def
    } ifelse

    /checksum 0 def
    0 1 barlen 1 sub {
        /i exch def
        % Lookup the encoding for the each barcode character
        barcode i 1 getinterval barchars exch search
        pop                                  % Discard true leaving pre
        length /indx exch def                % indx is the length of pre
        pop pop                              % Discard seek and post
        /enc encs indx get def               % Get the indxth encoding
        sbs pos enc putinterval  % Put encoded digit into sbs
        txt i [barcode i 1 getinterval i 12 mul txtpos add textyoffset textfont textsize] put
        /checksum checksum indx add def
        /pos pos 8 add def
    } for

    % Put the checksum
    includecheck {
        /checksum checksum 35 mod def
        sbs pos encs checksum get putinterval
        includecheckintext {
            txt barlen [barchars checksum 1 getinterval barlen 12 mul txtpos add textyoffset textfont textsize] put
        } {
            txt barlen [() barlen 12 mul txtpos add textyoffset textfont textsize] put
        } ifelse
        /pos pos 8 add def
    } if 

    % Put the stop character
    includestartstop { 
        sbs pos encs 36 get putinterval
        /pos pos 2 add def
    } if

    % Return the arguments
    /sbs sbs 0 pos getinterval def 
    <<
    /ren //renlinear
    /sbs [sbs {48 sub} forall]
    /bhs [sbs length 1 add 2 idiv {height} repeat]
    /bbs [sbs length 1 add 2 idiv {0} repeat]
    includetext {
        /txt txt
    } if
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/bc412 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER bc412--

% --BEGIN ENCODER rationalizedCodabar--
% --DESC: Rationalized Codabar
% --EXAM: A0123456789B
% --EXOP: includetext includecheck includecheckintext
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/rationalizedCodabar {

    20 dict begin                    % Confine variables to local scope

    /options exch def          % We are given an option string
    /barcode exch def          % We are given a barcode string

    /dontdraw false def
    /includecheck false def     % Enable/disable checkdigit
    /includetext false def      % Enable/disable text
    /includecheckintext false def
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /height 1 def
    
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
    
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def
    
    % Create an array containing the character mappings
    /encs
    [ (11111331) (11113311) (11131131) (33111111) (11311311)
      (31111311) (13111131) (13113111) (13311111) (31131111)
      (11133111) (11331111) (31113131) (31311131) (31313111)
      (11313131) (11331311) (13131131) (11131331) (11133311)
    ] def

    % Create a string of the available characters
    /barchars (0123456789-$:/.+ABCD) def

    /barlen barcode length def    % Length of the code

    includecheck {
        /sbs barlen 8 mul 8 add string def
        /txt barlen 1 add array def
    } {
        /sbs barlen 8 mul string def
        /txt barlen array def
    } ifelse

    /checksum 0 def
    /xpos 0 def
    0 1 barlen 2 sub {
        /i exch def
        % Lookup the encoding for the each barcode character
        barcode i 1 getinterval barchars exch search
        pop                          % Discard true leaving pre
        length /indx exch def        % indx is the length of pre
        pop pop                      % Discard seek and post
        /enc encs indx get def       % Get the indxth encoding
        sbs i 8 mul enc putinterval  % Put encoded digit into sbs
        txt i [barcode i 1 getinterval xpos textyoffset textfont textsize] put
        0 1 7 {       % xpos+=width of the character
            /xpos exch enc exch get 48 sub xpos add def
        } for
        /checksum checksum indx add def
    } for

    % Find index of last character
    barcode barlen 1 sub 1 getinterval barchars exch search
    pop                          % Discard true leaving pre
    length /indx exch def        % indx is the length of pre
    pop pop                      % Discard seek and post

    includecheck {
        % Put the checksum character
        /checksum checksum indx add def
        /checksum 16 checksum 16 mod sub 16 mod def
        sbs barlen 8 mul 8 sub encs checksum get putinterval
        includecheckintext {
            txt barlen 1 sub [barchars checksum 1 getinterval xpos textyoffset textfont textsize] put
        } {
            txt barlen 1 sub [( ) xpos textyoffset textfont textsize] put
        } ifelse
        0 1 7 {       % xpos+=width of the character
            /xpos exch encs checksum get exch get 48 sub xpos add def
        } for
        % Put the end character
        /enc encs indx get def            % Get the indxth encoding
        sbs barlen 8 mul enc putinterval  % Put encoded digit into sbs
        txt barlen [barcode barlen 1 sub 1 getinterval xpos textyoffset textfont textsize] put
    } {
        % Put the end character
        /enc encs indx get def                  % Get the indxth encoding
        sbs barlen 8 mul 8 sub enc putinterval  % Put encoded digit into sbs
        txt barlen 1 sub [barcode barlen 1 sub 1 getinterval xpos textyoffset textfont textsize] put
    } ifelse

    % Return the arguments
    <<
    /ren //renlinear
    /sbs [sbs {48 sub} forall]
    /bhs [sbs length 1 add 2 idiv {height} repeat]
    /bbs [sbs length 1 add 2 idiv {0} repeat]
    includetext {
        /txt txt
    } if
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/rationalizedCodabar dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER rationalizedCodabar--

% --BEGIN ENCODER onecode--
% --DESC: United States Postal Service Intelligent Mail
% --EXAM: 0123456709498765432101234567891
% --EXOP: barcolor=FF0000
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/onecode {

    20 dict begin

    /options exch def              % We are given an option string
    /barcode exch def              % We are given a barcode string

    /dontdraw false def
    /height 0.15 def
    
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
 
    /height height cvr def

    /barlen barcode length def
 
    % Create the human readable text
    /txtdict <<
        2 dup
        5 dup
        barcode 5 1 getinterval (9) eq {14} {11} ifelse dup
        20 dup
        25 dup
        29 dup
    >> def
    /txt barlen 6 add array def
    /spacecnt 0 def
    0 1 barlen 1 sub {
        /i exch def
        txtdict i known {
            txt i spacecnt add [( ) 0 0 () 0] put
            /spacecnt spacecnt 1 add def
        } if
        txt i spacecnt add [barcode i 1 getinterval 0 0 () 0] put
    } for
    /txt txt 0 barcode length spacecnt add getinterval def

    /normalize {
        /base exch def
        /num exch def
        num length 1 sub -1 1 {
            /i exch def        
            num i 1 sub 2 copy get num i get base idiv add put
            num i num i get base mod put
        } for
        { %loop - extend input as necessary
            num 0 get base lt {exit} if
            /num [0 num {} forall] def        
            num 0 num 0 get num 1 get base idiv add put
            num 1 num 1 get base mod put
        } loop
        % Trim leading zeros
        /num [/i true def num {dup 0 eq i and {pop} {/i false def} ifelse} forall] def   
        num length 0 eq {/num [0] def} if
        num
    } bind def

    /bigadd {
        2 copy length exch length
        2 copy sub abs /offset exch def
        lt {exch} if
        /a exch def /b exch def    
        0 1 b length 1 sub {
            dup a exch offset add 2 copy get b 5 -1 roll get add put
        } for
        a
    } bind def

    % Conversion of data fields into binary data
    barlen 20 eq {[0]} if
    barlen 25 eq {[1]} if
    barlen 29 eq {[1 0 0 0 0 1]} if
    barlen 31 eq {[1 0 0 0 1 0 0 0 0 1]} if
    /binval exch [barcode 20 barlen 20 sub getinterval {48 sub} forall] bigadd def
    /binval [binval {} forall barcode 0 get 48 sub] def
    /binval [binval {5 mul} forall] [barcode 1 get 48 sub] bigadd 10 normalize def
    /binval [binval {} forall barcode 2 18 getinterval {48 sub} forall] def

    % Conversion of binary data into byte array
    /bytes 13 array def
    /bintmp [binval {} forall] def
    12 -1 0 {
        /i exch def
        0 1 bintmp length 2 sub {
            /j exch def
            bintmp j 1 add 2 copy get bintmp j get 256 mod 10 mul add put
            bintmp j bintmp j get 256 idiv put
        } for
        bytes i bintmp bintmp length 1 sub get 256 mod put
        bintmp bintmp length 1 sub 2 copy get 256 idiv put    
    } for

    % Generation of 11-bit CRC on byte array
    /fcs 2047 def
    /dat bytes 0 get 5 bitshift def
    6 {
        fcs dat xor 1024 and 0 ne {
            /fcs fcs 1 bitshift 3893 xor def 
        } {
            /fcs fcs 1 bitshift def
        } ifelse
        /fcs fcs 2047 and def
        /dat dat 1 bitshift def
    } repeat
    1 1 12 {
        bytes exch get 3 bitshift /dat exch def    
        8 {        
            fcs dat xor 1024 and 0 ne {
                /fcs fcs 1 bitshift 3893 xor def 
            } {
                /fcs fcs 1 bitshift def
            } ifelse
            /fcs fcs 2047 and def
            /dat dat 1 bitshift def
        } repeat
    } for

    % Conversion from binary data to codewords
    /codewords 10 array def
    9 -1 0 {
        /i exch def
        i 9 eq {
            /b 636 def
        } {
            /b 1365 def
        } ifelse
        0 1 binval length 2 sub {
            /j exch def
            binval j 1 add 2 copy get binval j get b mod 10 mul add put
            binval j binval j get b idiv put
        } for   
        codewords i binval binval length 1 sub get b mod put
        binval binval length 1 sub 2 copy get b idiv put
    } for

    % Inserting additional information into codewords
    codewords 9 codewords 9 get 2 mul put
    fcs 1024 and 0 ne {
        codewords 0 codewords 0 get 659 add put
    } if

    % Conversion from codewords to characters
    /tab513 [
        31 7936   47 7808   55 7552   59 7040   61 6016   62 3968   79 7744   87 
      7488   91 6976   93 5952   94 3904  103 7360  107 6848  109 5824  110 3776 
       115 6592  117 5568  118 3520  121 5056  122 3008  124 1984  143 7712  151 
      7456  155 6944  157 5920  158 3872  167 7328  171 6816  173 5792  174 3744 
       179 6560  181 5536  182 3488  185 5024  186 2976  188 1952  199 7264  203 
      6752  205 5728  206 3680  211 6496  213 5472  214 3424  217 4960  218 2912 
       220 1888  227 6368  229 5344  230 3296  233 4832  234 2784  236 1760  241 
      4576  242 2528  244 1504  248  992  271 7696  279 7440  283 6928  285 5904 
       286 3856  295 7312  299 6800  301 5776  302 3728  307 6544  309 5520  310 
      3472  313 5008  314 2960  316 1936  327 7248  331 6736  333 5712  334 3664 
       339 6480  341 5456  342 3408  345 4944  346 2896  348 1872  355 6352  357 
      5328  358 3280  361 4816  362 2768  364 1744  369 4560  370 2512  372 1488 
       376  976  391 7216  395 6704  397 5680  398 3632  403 6448  405 5424  406 
      3376  409 4912  410 2864  412 1840  419 6320  421 5296  422 3248  425 4784 
       426 2736  428 1712  433 4528  434 2480  436 1456  440  944  451 6256  453 
      5232  454 3184  457 4720  458 2672  460 1648  465 4464  466 2416  468 1392 
       472  880  481 4336  482 2288  484 1264  488  752  527 7688  535 7432  539 
      6920  541 5896  542 3848  551 7304  555 6792  557 5768  558 3720  563 6536 
       565 5512  566 3464  569 5000  570 2952  572 1928  583 7240  587 6728  589 
      5704  590 3656  595 6472  597 5448  598 3400  601 4936  602 2888  604 1864 
       611 6344  613 5320  614 3272  617 4808  618 2760  620 1736  625 4552  626 
      2504  628 1480  632  968  647 7208  651 6696  653 5672  654 3624  659 6440 
       661 5416  662 3368  665 4904  666 2856  668 1832  675 6312  677 5288  678 
      3240  681 4776  682 2728  684 1704  689 4520  690 2472  692 1448  696  936 
       707 6248  709 5224  710 3176  713 4712  714 2664  716 1640  721 4456  722 
      2408  724 1384  728  872  737 4328  738 2280  740 1256  775 7192  779 6680 
       781 5656  782 3608  787 6424  789 5400  790 3352  793 4888  794 2840  796 
      1816  803 6296  805 5272  806 3224  809 4760  810 2712  812 1688  817 4504 
       818 2456  820 1432  824  920  835 6232  837 5208  838 3160  841 4696  842 
      2648  844 1624  849 4440  850 2392  852 1368  865 4312  866 2264  868 1240 
       899 6200  901 5176  902 3128  905 4664  906 2616  908 1592  913 4408  914 
      2360  916 1336  929 4280  930 2232  932 1208  961 4216  962 2168  964 1144 
      1039 7684 1047 7428 1051 6916 1053 5892 1054 3844 1063 7300 1067 6788 1069 
      5764 1070 3716 1075 6532 1077 5508 1078 3460 1081 4996 1082 2948 1084 1924 
      1095 7236 1099 6724 1101 5700 1102 3652 1107 6468 1109 5444 1110 3396 1113 
      4932 1114 2884 1116 1860 1123 6340 1125 5316 1126 3268 1129 4804 1130 2756 
      1132 1732 1137 4548 1138 2500 1140 1476 1159 7204 1163 6692 1165 5668 1166 
      3620 1171 6436 1173 5412 1174 3364 1177 4900 1178 2852 1180 1828 1187 6308 
      1189 5284 1190 3236 1193 4772 1194 2724 1196 1700 1201 4516 1202 2468 1204 
      1444 1219 6244 1221 5220 1222 3172 1225 4708 1226 2660 1228 1636 1233 4452 
      1234 2404 1236 1380 1249 4324 1250 2276 1287 7188 1291 6676 1293 5652 1294 
      3604 1299 6420 1301 5396 1302 3348 1305 4884 1306 2836 1308 1812 1315 6292 
      1317 5268 1318 3220 1321 4756 1322 2708 1324 1684 1329 4500 1330 2452 1332 
      1428 1347 6228 1349 5204 1350 3156 1353 4692 1354 2644 1356 1620 1361 4436 
      1362 2388 1377 4308 1378 2260 1411 6196 1413 5172 1414 3124 1417 4660 1418 
      2612 1420 1588 1425 4404 1426 2356 1441 4276 1442 2228 1473 4212 1474 2164 
      1543 7180 1547 6668 1549 5644 1550 3596 1555 6412 1557 5388 1558 3340 1561 
      4876 1562 2828 1564 1804 1571 6284 1573 5260 1574 3212 1577 4748 1578 2700 
      1580 1676 1585 4492 1586 2444 1603 6220 1605 5196 1606 3148 1609 4684 1610 
      2636 1617 4428 1618 2380 1633 4300 1634 2252 1667 6188 1669 5164 1670 3116 
      1673 4652 1674 2604 1681 4396 1682 2348 1697 4268 1698 2220 1729 4204 1730 
      2156 1795 6172 1797 5148 1798 3100 1801 4636 1802 2588 1809 4380 1810 2332 
      1825 4252 1826 2204 1857 4188 1858 2140 1921 4156 1922 2108 2063 7682 2071 
      7426 2075 6914 2077 5890 2078 3842 2087 7298 2091 6786 2093 5762 2094 3714 
      2099 6530 2101 5506 2102 3458 2105 4994 2106 2946 2119 7234 2123 6722 2125 
      5698 2126 3650 2131 6466 2133 5442 2134 3394 2137 4930 2138 2882 2147 6338 
      2149 5314 2150 3266 2153 4802 2154 2754 2161 4546 2162 2498 2183 7202 2187 
      6690 2189 5666 2190 3618 2195 6434 2197 5410 2198 3362 2201 4898 2202 2850 
      2211 6306 2213 5282 2214 3234 2217 4770 2218 2722 2225 4514 2226 2466 2243 
      6242 2245 5218 2246 3170 2249 4706 2250 2658 2257 4450 2258 2402 2273 4322 
      2311 7186 2315 6674 2317 5650 2318 3602 2323 6418 2325 5394 2326 3346 2329 
      4882 2330 2834 2339 6290 2341 5266 2342 3218 2345 4754 2346 2706 2353 4498 
      2354 2450 2371 6226 2373 5202 2374 3154 2377 4690 2378 2642 2385 4434 2401 
      4306 2435 6194 2437 5170 2438 3122 2441 4658 2442 2610 2449 4402 2465 4274 
      2497 4210 2567 7178 2571 6666 2573 5642 2574 3594 2579 6410 2581 5386 2582 
      3338 2585 4874 2586 2826 2595 6282 2597 5258 2598 3210 2601 4746 2602 2698 
      2609 4490 2627 6218 2629 5194 2630 3146 2633 4682 2641 4426 2657 4298 2691 
      6186 2693 5162 2694 3114 2697 4650 2705 4394 2721 4266 2753 4202 2819 6170 
      2821 5146 2822 3098 2825 4634 2833 4378 2849 4250 2881 4186 2945 4154 3079 
      7174 3083 6662 3085 5638 3086 3590 3091 6406 3093 5382 3094 3334 3097 4870 
      3107 6278 3109 5254 3110 3206 3113 4742 3121 4486 3139 6214 3141 5190 3145 
      4678 3153 4422 3169 4294 3203 6182 3205 5158 3209 4646 3217 4390 3233 4262 
      3265 4198 3331 6166 3333 5142 3337 4630 3345 4374 3361 4246 3393 4182 3457 
      4150 3587 6158 3589 5134 3593 4622 3601 4366 3617 4238 3649 4174 3713 4142 
      3841 4126 4111 7681 4119 7425 4123 6913 4125 5889 4135 7297 4139 6785 4141 
      5761 4147 6529 4149 5505 4153 4993 4167 7233 4171 6721 4173 5697 4179 6465 
      4181 5441 4185 4929 4195 6337 4197 5313 4201 4801 4209 4545 4231 7201 4235 
      6689 4237 5665 4243 6433 4245 5409 4249 4897 4259 6305 4261 5281 4265 4769 
      4273 4513 4291 6241 4293 5217 4297 4705 4305 4449 4359 7185 4363 6673 4365 
      5649 4371 6417 4373 5393 4377 4881 4387 6289 4389 5265 4393 4753 4401 4497 
      4419 6225 4421 5201 4425 4689 4483 6193 4485 5169 4489 4657 4615 7177 4619 
      6665 4621 5641 4627 6409 4629 5385 4633 4873 4643 6281 4645 5257 4649 4745 
      4675 6217 4677 5193 4739 6185 4741 5161 4867 6169 4869 5145 5127 7173 5131 
      6661 5133 5637 5139 6405 5141 5381 5155 6277 5157 5253 5187 6213 5251 6181 
      5379 6165 5635 6157 6151 7171 6155 6659 6163 6403 6179 6275 6211 5189 4681 
      4433 4321 3142 2634 2386 2274 1612 1364 1252  856  744  496 
    ] def

    /tab213 [
         3 6144    5 5120    6 3072    9 4608   10 2560   12 1536   17 4352   18 
      2304   20 1280   24  768   33 4224   34 2176   36 1152   40  640   48  384 
        65 4160   66 2112   68 1088   72  576   80  320   96  192  129 4128  130 
      2080  132 1056  136  544  144  288  257 4112  258 2064  260 1040  264  528 
       513 4104  514 2056  516 1032 1025 4100 1026 2052 2049 4098 4097 2050 1028 
       520  272  160
    ] def

    /chars 10 array def
    0 1 9 {
        /i exch def
        codewords i get dup 1286 le {
            tab513 exch get 
        } {
            tab213 exch 1287 sub get
        } ifelse
        chars i 3 -1 roll put
    } for

    9 -1 0 {
        /i exch def
        2 i exp cvi fcs and 0 ne {
            chars i chars i get 8191 xor put
        } if
    } for

    % Conversion from characters to the OneCode encoding
    /barmap [
        7 2 4 3    1 10 0 0   9 12 2 8   5 5 6 11   8 9 3 1
        0 1 5 12   2 5 1 8    4 4 9 11   6 3 8 10   3 9 7 6
        5 11 1 4   8 5 2 12   9 10 0 2   7 1 6 7    3 6 4 9
        0 3 8 6    6 4 2 7    1 1 9 9    7 10 5 2   4 0 3 8
        6 2 0 4    8 11 1 0   9 8 3 12   2 6 7 7    5 1 4 10
        1 12 6 9   7 3 8 0    5 8 9 7    4 6 2 10   3 4 0 5
        8 4 5 7    7 11 1 9   6 0 9 6    0 6 4 8    2 1 3 2
        5 9 8 12   4 11 6 1   9 5 7 4    3 3 1 2    0 7 2 0
        1 3 4 1    6 10 3 5   8 7 9 4    2 11 5 6   0 8 7 12
        4 2 8 1    5 10 3 0   9 3 0 9    6 5 2 4    7 8 1 7
        5 0 4 5    2 3 0 10   6 12 9 2   3 11 1 6   8 8 7 9
        5 4 0 11   1 5 2 2    9 1 4 12   8 3 6 6    7 0 3 7
        4 7 7 5    0 12 1 11  2 9 9 0    6 8 5 3    3 10 8 2
    ] def

    /bbs 65 array def    
    /bhs 65 array def
    0 1 64 {
        /i exch def
        /dec chars barmap i 4 mul get get 2 barmap i 4 mul 1 add get exp cvi and 0 ne def
        /asc chars barmap i 4 mul 2 add get get 2 barmap i 4 mul 3 add get exp cvi and 0 ne def
        dec not asc not and {
            bbs i 3 height mul 8 div put
            bhs i 2 height mul 8 div put
        } if
        dec not asc and {
            bbs i 3 height mul 8 div put
            bhs i 5 height mul 8 div put        
        } if
        dec asc not and {
            bbs i 0 height mul 8 div put
            bhs i 5 height mul 8 div put        
        } if
        dec asc and {
            bbs i 0 height mul 8 div put
            bhs i 8 height mul 8 div put        
        } if
    } for
    
    % Return the arguments
    <<
    /ren //renlinear
    /bbs bbs
    /bhs bhs
    /sbs [bhs length 1 sub {1.44 1.872} repeat 1.44]
    /txt txt
    /textxalign (left)
    /textfont /Helvetica
    /textyoffset 1
    /textxoffset -0.3
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/onecode dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER onecode--

% --BEGIN ENCODER postnet--
% --DESC: United States Postal Service POSTNET
% --EXAM: 01234
% --EXOP: includetext includecheckintext
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/postnet {

    20 dict begin

    /options exch def              % We are given an option string
    /barcode exch def              % We are given a barcode string

    /dontdraw false def
    /includetext false def          % Enable/disable text
    /includecheckintext false def
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /height 0.125 def
    
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
 
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def
    
    /barlen barcode length def

    % Ensure 5, 9 or 11 digits
    barlen 5 lt {
        /barlen -1 def  % Error
    } {
        barlen 11 ge {
            /barlen 11 def
        } if
        barlen 10 eq {
            /barlen 9 def
        } if
        barlen 8 le {
            /barlen 5 def
        } if
    } ifelse

    % Create an array containing the character mappings
    /encs
    [ (55222) (22255) (22525) (22552) (25225)
      (25252) (25522) (52225) (52252) (52522)
      (5) (5)
    ] def

    % Create a string of the available characters
    /barchars (0123456789) def

    /bhs barlen 5 mul 7 add array def
    /txt barlen 1 add array def

    % Put start character
    /enc encs 10 get def
    /heights enc length array def
    0 1 enc length 1 sub {
        /j exch def
        heights j enc j 1 getinterval cvi height mul 5 div put
    } for
    bhs 0 heights putinterval   % Put encoded digit into sbs

    /checksum 0 def
    0 1 barlen 1 sub {
        /i exch def
        % Lookup the encoding for the each barcode character
        barcode i 1 getinterval barchars exch search
        pop                                 % Discard true leaving pre
        length /indx exch def               % indx is the length of pre
        pop pop                             % Discard seek and post
        /enc encs indx get def              % Get the indxth encoding
        /heights enc length array def
        0 1 enc length 1 sub {
            /j exch def
            heights j enc j 1 getinterval cvi height mul 5 div put
        } for
        bhs i 5 mul 1 add heights putinterval   % Put encoded digit into sbs
        txt i [barcode i 1 getinterval i 5 mul 1 add 3.312 mul textyoffset textfont textsize] put
        /checksum checksum indx add def     % checksum+=indx
    } for

    % Put the checksum character
    /checksum 10 checksum 10 mod sub 10 mod def
    /enc encs checksum get def
    /heights enc length array def
    0 1 enc length 1 sub {
        /j exch def
        heights j enc j 1 getinterval cvi height mul 5 div put
    } for
    bhs barlen 5 mul 1 add heights putinterval  
    
    includecheckintext {
        txt barlen [barchars checksum 1 getinterval barlen 5 mul 1 add 3.312 mul textyoffset textfont textsize] put
    } {
        txt barlen [( ) barlen 5 mul 1 add 72 mul 25 div textyoffset textfont textsize] put
    } ifelse
    
    % Put end character
    /enc encs 11 get def
    /heights enc length array def
    0 1 enc length 1 sub {
        /j exch def
        heights j enc j 1 getinterval cvi height mul 5 div put
    } for
    bhs barlen 5 mul 6 add heights putinterval  

    % Return the arguments
    <<
    /ren //renlinear
    /bhs bhs
    /bbs [bhs length {0} repeat]
    /sbs [bhs length 1 sub {1.44 1.872} repeat 1.44]
    includetext {
        /txt txt
    } if
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/postnet dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER postnet--

% --BEGIN ENCODER planet--
% --DESC: United States Postal Service PLANET
% --EXAM: 01234567890
% --EXOP: includetext includecheckintext
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/planet {

    20 dict begin

    /options exch def              % We are given an option string
    /barcode exch def              % We are given a barcode string

    /dontdraw false def
    /includetext false def          % Enable/disable text
    /includecheckintext false def
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /height 0.125 def
    
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
 
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def
    
    /barlen barcode length def

    % Ensure 11 or 13 digits
    barlen 11 lt {
        /barlen -1 def  % Error
    } {
        barlen 13 ge {
            /barlen 13 def
        } {
            /barlen 11 def
        } ifelse
    } ifelse

    % Create an array containing the character mappings
    /encs
    [ (22555) (55522) (55252) (55225) (52552)
      (52525) (52255) (25552) (25525) (25255)
      (5) (5)
    ] def

    % Create a string of the available characters
    /barchars (0123456789) def

    /bhs barlen 5 mul 7 add array def
    /txt barlen 1 add array def

    % Put start character
    /enc encs 10 get def
    /heights enc length array def
    0 1 enc length 1 sub {
        /j exch def
        heights j enc j 1 getinterval cvi height mul 5 div put
    } for
    bhs 0 heights putinterval   % Put encoded digit into sbs

    /checksum 0 def
    0 1 barlen 1 sub {
        /i exch def
        % Lookup the encoding for the each barcode character
        barcode i 1 getinterval barchars exch search
        pop                                 % Discard true leaving pre
        length /indx exch def               % indx is the length of pre
        pop pop                             % Discard seek and post
        /enc encs indx get def              % Get the indxth encoding
        /heights enc length array def
        0 1 enc length 1 sub {
            /j exch def
            heights j enc j 1 getinterval cvi height mul 5 div put
        } for
        bhs i 5 mul 1 add heights putinterval   % Put encoded digit into sbs
        txt i [barcode i 1 getinterval i 5 mul 1 add 3.312 mul textyoffset textfont textsize] put
        /checksum checksum indx add def     % checksum+=indx
    } for

    % Put the checksum character
    /checksum 10 checksum 10 mod sub 10 mod def
    /enc encs checksum get def
    /heights enc length array def
    0 1 enc length 1 sub {
        /j exch def
        heights j enc j 1 getinterval cvi height mul 5 div put
    } for
    bhs barlen 5 mul 1 add heights putinterval  
    
    includecheckintext {
        txt barlen [barchars checksum 1 getinterval barlen 5 mul 1 add 3.312 mul textyoffset textfont textsize] put
    } {
        txt barlen [( ) barlen 5 mul 1 add 72 mul 25 div textyoffset textfont textsize] put
    } ifelse
    
    % Put end character
    /enc encs 11 get def
    /heights enc length array def
    0 1 enc length 1 sub {
        /j exch def
        heights j enc j 1 getinterval cvi height mul 5 div put
    } for
    bhs barlen 5 mul 6 add heights putinterval  

    % Return the arguments
    <<
    /ren //renlinear
    /bhs bhs
    /bbs [bhs length {0} repeat]
    /sbs [bhs length 1 sub {1.44 1.872} repeat 1.44]
    includetext {
        /txt txt
    } if
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/planet dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER planet--

% --BEGIN ENCODER royalmail--
% --DESC: Royal Mail 4 State Customer Code (RM4SCC)
% --EXAM: LE28HS9Z
% --EXOP: includetext includecheckintext barcolor=FF0000
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/royalmail {

    20 dict begin

    /options exch def              % We are given an option string
    /barcode exch def              % We are given a barcode string

    /dontdraw false def
    /includetext false def          % Enable/disable text
    /includecheckintext false def
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /height 0.175 def
    
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
 
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def
    
    % Create an array containing the character mappings
    /encs
    [ (3300) (2211) (2301) (2310) (3201) (3210) 
      (1122) (0033) (0123) (0132) (1023) (1032) 
      (1302) (0213) (0303) (0312) (1203) (1212) 
      (1320) (0231) (0321) (0330) (1221) (1230) 
      (3102) (2013) (2103) (2112) (3003) (3012) 
      (3120) (2031) (2121) (2130) (3021) (3030) 
      (2) (3)
    ] def

    % Create a string of the available characters
    /barchars (ZUVWXY501234B6789AHCDEFGNIJKLMTOPQRS) def

    /barlen barcode length def
    /encstr barlen 4 mul 6 add string def
    /txt barlen 1 add array def

    % Put start character
    encstr 0 encs 36 get putinterval
    
    /checksumrow 0 def
    /checksumcol 0 def
    0 1 barlen 1 sub {
        /i exch def
        % Lookup the encoding for the each barcode character
        barcode i 1 getinterval barchars exch search
        pop                                 % Discard true leaving pre
        length /indx exch def               % indx is the length of pre
        pop pop                             % Discard seek and post
        /enc encs indx get def              % Get the indxth encoding
        encstr i 4 mul 1 add enc putinterval
        txt i [barcode i 1 getinterval i 4 mul 1 add 3.312 mul textyoffset textfont textsize] put
        /checksumrow checksumrow indx 6 idiv add def
        /checksumcol checksumcol indx 6 mod add def 
    } for

    % Put the checksum character
    /checksum checksumrow 6 mod 6 mul checksumcol 6 mod add def
    /enc encs checksum get def
    encstr barlen 4 mul 1 add enc putinterval
    includecheckintext {
        txt barlen [barchars checksum 1 getinterval barlen 4 mul 1 add 3.312 mul textyoffset textfont textsize] put
    } {
        txt barlen [( ) barlen 4 mul 1 add 3.312 mul textyoffset textfont textsize] put
    } ifelse
    
    % Put end character
    encstr barlen 4 mul 5 add encs 37 get putinterval  

    /bbs encstr length array def    
    /bhs encstr length array def
    0 1 encstr length 1 sub {
        /i exch def
        /enc encstr i 1 getinterval def
        enc (0) eq {
            bbs i 3 height mul 8 div put
            bhs i 2 height mul 8 div put
        } if
        enc (1) eq {
            bbs i 0 height mul 8 div put
            bhs i 5 height mul 8 div put
        } if
        enc (2) eq {
            bbs i 3 height mul 8 div put
            bhs i 5 height mul 8 div put
        } if
        enc (3) eq {
            bbs i 0 height mul 8 div put
            bhs i 8 height mul 8 div put
        } if
    } for
    
    % Return the arguments
    <<
    /ren //renlinear
    /bbs bbs
    /bhs bhs
    /sbs [bhs length 1 sub {1.44 1.872} repeat 1.44]
    includetext {
        /txt txt
    } if
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/royalmail dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER royalmail--

% --BEGIN ENCODER auspost--
% --DESC: AusPost 4 State Customer Code
% --EXAM: 5956439111ABA 9
% --EXOP: includetext custinfoenc=character
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/auspost {

    20 dict begin

    /options exch def              % We are given an option string
    /barcode exch def              % We are given a barcode string

    /dontdraw false def
    /includetext false def         % Enable/disable text
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /height 0.175 def
    /custinfoenc (character) def
    
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
 
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def

    % Create an array containing the character mappings
    /encs
    [ (000) (001) (002) (010) (011) (012) (020) (021)
      (022) (100) (101) (102) (110) (111) (112) (120)
      (121) (122) (200) (201) (202) (210) (211) (212)
      (220) (221) (222) (300) (301) (302) (310) (311)
      (312) (320) (321) (322) (023) (030) (031) (032)
      (033) (103) (113) (123) (130) (131) (132) (133)
      (203) (213) (223) (230) (231) (232) (233) (303)
      (313) (323) (330) (331) (332) (333) (003) (013)
      (00) (01) (02) (10) (11) (12) (20) (21) (22) (30)
      (13) (3)
    ] def

    % Create a string of the available characters
    /barchars (ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz #) def
    
    /barlen barcode length def
    barcode 0 2 getinterval (11) eq {37} if
    barcode 0 2 getinterval (45) eq {37} if
    barcode 0 2 getinterval (59) eq {52} if
    barcode 0 2 getinterval (62) eq {67} if
    /encstr exch string def
    /txt barlen 2 sub array def

    % Put start character
    encstr 0 encs 74 get putinterval

    % Encode the FCC
    0 1 1 {
        /i exch def       
        encs barcode i 1 getinterval cvi 64 add get
        encstr i 2 mul 2 add 3 2 roll putinterval
    } for
    
    % Encode the DPID
    2 1 9 {
        /i exch def       
        encs barcode i 1 getinterval cvi 64 add get
        encstr i 2 mul 2 add 3 2 roll putinterval
        txt i 2 sub [barcode i 1 getinterval i 2 sub 2 mul 6 add 3.312 mul textyoffset textfont textsize] put
    } for
    
    % Encode the customer information   
    custinfoenc (numeric) eq {
        0 1 barlen 11 sub {
            /i exch def
            encs barcode i 10 add 1 getinterval cvi 64 add get
            encstr i 2 mul 22 add 3 2 roll putinterval
            txt i 8 add [barcode i 10 add 1 getinterval i 2 mul 22 add 3.312 mul textyoffset textfont textsize] put
        } for        
        /ciflen barlen 10 sub 2 mul def
    } {
        0 1 barlen 11 sub {
            /i exch def           
            barcode i 10 add 1 getinterval barchars exch search
            pop                                
            length /indx exch def           
            pop pop                            
            /enc encs indx get def          
            encstr i 3 mul 22 add enc putinterval
            txt i 8 add [barcode i 10 add 1 getinterval i 3 mul 22 add 3.312 mul textyoffset textfont textsize] put
        } for        
        /ciflen barlen 10 sub 3 mul def
    } ifelse

    % Add any filler characters
    22 ciflen add 1 encstr length 14 sub {        
        encstr exch encs 75 get putinterval
    } for
    
    % Create the 64x64 Reed-Solomon table
    /rstable 64 64 mul array def
    rstable 0 [ 64 {0} repeat ] putinterval
    rstable 64 [ 0 1 63 {} for ] putinterval
    /prev 1 def
    64 {       
        /next prev 1 bitshift def
        next 64 and 0 ne {
            /next next 67 xor def
        } if        
        0 1 63 {
            /j exch def
            /nextcell {rstable 64 next mul j add} def
            nextcell rstable 64 prev mul j add get 1 bitshift put
            nextcell get 64 and 0 ne {
                nextcell nextcell get 67 xor put
            } if
        } for
        /prev next def
    } repeat
    
    % Calculate the Reed-Solomon codes for triples
    /rscodes encstr length 16 sub 3 idiv 4 add array def
    rscodes 0 [ 4 {0} repeat ] putinterval
    2 3 encstr length 16 sub {
        /i exch def
        rscodes rscodes length i 2 sub 3 idiv sub 1 sub
        encstr i 1 getinterval cvi 16 mul
        encstr i 1 add 1 getinterval cvi 4 mul add
        encstr i 2 add 1 getinterval cvi add        
        put
    } for    
    rscodes length 5 sub -1 0 {
       /i exch def
       0 1 4 {
           /j exch def
           rscodes i j add rscodes i j add get
           rstable 64 [48 17 29 30 1] j get mul rscodes i 4 add get add get
           xor put
       } for
    } for
    /checkcode (000000000000) 12 string copy def
    0 1 3 {
        /i exch def
        /enc rscodes 3 i sub get 4 3 string cvrs def
        checkcode i 3 mul 3 enc length sub add enc putinterval
    } for
    
    % Put checkcode and end characters
    encstr encstr length 14 sub checkcode putinterval
    encstr encstr length 2 sub encs 74 get putinterval 

    /bbs encstr length array def    
    /bhs encstr length array def
    0 1 encstr length 1 sub {
        /i exch def
        /enc encstr i 1 getinterval def
        enc (0) eq {
            bbs i 0 height mul 8 div put
            bhs i 8 height mul 8 div put
        } if
        enc (1) eq {
            bbs i 3 height mul 8 div put
            bhs i 5 height mul 8 div put
        } if
        enc (2) eq {
            bbs i 0 height mul 8 div put
            bhs i 5 height mul 8 div put
        } if
        enc (3) eq {
            bbs i 3 height mul 8 div put
            bhs i 2 height mul 8 div put
        } if
    } for   
    
    % Return the arguments
    <<
    /ren //renlinear
    /bbs bbs
    /bhs bhs
    /sbs [bhs length 1 sub {1.44 1.872} repeat 1.44]
    includetext {
        /txt txt
    } if
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/auspost dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER auspost--

% --BEGIN ENCODER kix--
% --DESC: Royal Dutch TPG Post KIX 4-State Barcode
% --EXAM: 1231FZ13XHS
% --EXOP: includetext includecheckintext
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/kix {

    20 dict begin

    /options exch def              % We are given an option string
    /barcode exch def              % We are given a barcode string

    /dontdraw false def
    /includetext false def          % Enable/disable text
    /includecheckintext false def
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /height 0.175 def
    
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
 
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def
    
    % Create an array containing the character mappings
    /encs
    [ (0033) (0123) (0132) (1023) (1032) (1122)
      (0213) (0303) (0312) (1203) (1212) (1302) 
      (0231) (0321) (0330) (1221) (1230) (1320)
      (2013) (2103) (2112) (3003) (3012) (3102)
      (2031) (2121) (2130) (3021) (3030) (3120) 
      (2211) (2301) (2310) (3201) (3210) (3300) 
    ] def

    % Create a string of the available characters
    /barchars (0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ) def

    /barlen barcode length def
    /encstr barlen 4 mul string def
    /txt barlen array def
    
    0 1 barlen 1 sub {
        /i exch def
        % Lookup the encoding for the each barcode character
        barcode i 1 getinterval barchars exch search
        pop                                 % Discard true leaving pre
        length /indx exch def               % indx is the length of pre
        pop pop                             % Discard seek and post
        /enc encs indx get def              % Get the indxth encoding
        encstr i 4 mul enc putinterval
        txt i [barcode i 1 getinterval i 4 mul 3.312 mul textyoffset textfont textsize] put
    } for

    /bbs encstr length array def    
    /bhs encstr length array def
    0 1 encstr length 1 sub {
        /i exch def
        /enc encstr i 1 getinterval def
        enc (0) eq {
            bbs i 3 height mul 8 div put
            bhs i 2 height mul 8 div put
        } if
        enc (1) eq {
            bbs i 0 height mul 8 div put
            bhs i 5 height mul 8 div put
        } if
        enc (2) eq {
            bbs i 3 height mul 8 div put
            bhs i 5 height mul 8 div put
        } if
        enc (3) eq {
            bbs i 0 height mul 8 div put
            bhs i 8 height mul 8 div put
        } if
    } for
    
    % Return the arguments
    <<
    /ren //renlinear
    /bbs bbs
    /bhs bhs
    /sbs [bhs length 1 sub {1.44 1.872} repeat 1.44]
    includetext {
        /txt txt
    } if
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/kix dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER kix--

% --BEGIN ENCODER japanpost--
% --DESC: Japan Post 4 State Customer Code
% --EXAM: 6540123789-A-K-Z
% --EXOP: includetext includecheckintext
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/japanpost {

    20 dict begin

    /options exch def              % We are given an option string
    /barcode exch def              % We are given a barcode string

    /dontdraw false def
    /includetext false def          % Enable/disable text
    /includecheckintext false def
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /height 0.175 def
  
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
 
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def
    
    % Create an array containing the character mappings
    % 0123456789- C1C2C3C4C5C6C7C8 ST EN
    /encs
    [ (300) (330) (312) (132) (321) (303) (123) (231) (213) (033) (030)
      (120) (102) (210) (012) (201) (021) (003) (333) 
      (31) (13)
    ] def

    % Create a string of the available characters
    /barchars (0123456789-ABCDEFGHIJKLMNOPQRSTUVWXYZ) def
    /barlen barcode length def
    
    /encstr 20 1 add 3 mul 4 add string def
    /digits 20 array def
    /txt barlen 1 add array def

    % Put start character
    encstr 0 encs 19 get putinterval

    /checksum 0 def
    /j 0 def /i 0 def
    0 1 barlen 1 sub {
        /i exch def
        barcode i 1 getinterval barchars exch search
        pop                                  % Discard true leaving pre
        length /indx exch def                % indx is the length of pre
        pop pop                              % Discard match and post
        indx 11 ge indx 37 lt and {          % Insert escape
            j 18 gt {exit} if                % Should fit in 20 chars
                                             % 11-20: C1 (11)
                                             % 21-30: C2 (12)
                                             % 31-36: C3 (13)
            /digit indx 1 sub 10 idiv 10 add def
            encstr j 3 mul 2 add encs digit get putinterval
            /checksum checksum digit add def
            digits j digit put
            /j j 1 add def
        } if
        j 19 gt {exit} if                    % Should fit in 20 chars
        /digit 0 def
        indx 37 eq {
            /digit 14 def                    % space (C14)
        } if
        indx 11 ge indx 37 lt and {
            /digit indx 1 sub 10 mod def
        } if
        indx 11 lt {
            /digit indx def
        } if
        encstr j 3 mul 2 add encs digit get putinterval % space
        /checksum checksum digit add def
        digits j digit put
        txt i [barcode i 1 getinterval j 3 mul 2 add 3.312 mul textyoffset textfont textsize] put
        /j j 1 add def
    } for

    % Fill spaces (c14) at right end
    j 1 20 1 sub {
        /k exch def
        encstr k 3 mul 2 add encs 14 get putinterval
        /checksum checksum 14 add def
        digits k 14 put
    } for

    % Put the checksum character
    /checksum checksum 19 mod 19 exch sub def
    encstr 2 20 3 mul add encs checksum get putinterval

    % Put end character
    encstr 2 21 3 mul add encs 20 get putinterval
    /checkdigit ( ) def
    includecheckintext {
        /checkdigit barchars checksum 1 getinterval def
    } if
    txt i 1 add [ checkdigit 20 3 mul 2 add 3.312 mul textyoffset textfont textsize] put

    % Put end character
    encstr 20 1 add 3 mul 2 add encs 20 get putinterval

    /bbs 21 3 mul 4 add array def
    /bhs bbs length array def
    0 1 bbs length 1 sub {
        /i exch def
        /enc encstr i 1 getinterval def
        /bunit 0 def
        /hunit 0 def
        enc (0) eq {
            /bunit 3 def
            /hunit 2 def
        } if
        enc (1) eq {
            /bunit 0 def
            /hunit 5 def
        } if
        enc (2) eq {
            /bunit 3 def
            /hunit 5 def
        } if
        enc (3) eq {
            /bunit 0 def
            /hunit 8 def
        } if
        bbs i bunit height mul 8 div put
        bhs i hunit height mul 8 div put
    } for

    % Return the arguments
    <<
    /ren //renlinear
    /bbs bbs
    /bhs bhs
    /sbs [bhs length 1 sub {1.44 1.872} repeat 1.44]
    includetext {
        /txt txt
    } if
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/japanpost dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER japanpost--

% --BEGIN ENCODER msi--
% --DESC: MSI Modified Plessey
% --EXAM: 0123456789
% --EXOP: includetext includecheck includecheckintext
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/msi {

    20 dict begin                 % Confine variables to local scope

    /options exch def       % We are given an option string
    /barcode exch def       % We are given a barcode string

    /dontdraw false def
    /includecheck false def  % Enable/disable checkdigit
    /includetext false def   % Enable/disable text
    /includecheckintext false def
    /checktype (mod10) def
    /badmod11 false def
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /height 1 def
    
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
    
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def
    
    % Create an array containing the character mappings
    /encs
    [ (12121212) (12121221) (12122112) (12122121) (12211212)
      (12211221) (12212112) (12212121) (21121212) (21121221)
      (21) (121)
    ] def

    % Create a string of the available characters
    /barchars (0123456789) def

    /barlen barcode length def     % Length of the code
    /txtlen barlen def

    /mod10 {
        /code exch def
        0 0 code {48 sub exch 10 mul add exch} forall pop 2 mul  
        0 {1 index 10 mod add exch 10 idiv dup 0 eq {pop exit} if exch} loop
        0 0 code {48 sub add exch} forall exch pop add
        10 mod 10 exch sub 10 mod
        code length 1 add string dup 0 code putinterval dup code length 4 -1 roll 48 add put
    } bind def

    /mod11 {
        /code exch def
        code length 1 sub code {48 sub exch dup 1 sub exch 6 mod 2 add exch} forall pop
        0 code length {3 1 roll mul add} repeat 
        11 mod 11 exch sub 11 mod
        dup 10 eq badmod11 and {
            pop code length 2 add string dup 0 code putinterval dup code length (10) putinterval
        } {
            code length 1 add string dup 0 code putinterval dup code length 4 -1 roll 48 add put
        } ifelse
    } bind def

    /ncrmod11 {
        /code exch def
        code length 1 sub code {48 sub exch dup 1 sub exch 8 mod 2 add exch} forall pop
        0 code length {3 1 roll mul add} repeat 
        11 mod 11 exch sub 11 mod
        dup 10 eq badmod11 and {
            pop code length 2 add string dup 0 code putinterval dup code length (10) putinterval
        } {
            code length 1 add string dup 0 code putinterval dup code length 4 -1 roll 48 add put
        } ifelse
    } bind def

    % Calculate checksum
    includecheck {
        checktype (mod10) eq      {barcode mod10} if
        checktype (mod1010) eq    {barcode mod10 mod10} if
        checktype (mod11) eq      {barcode mod11} if
        checktype (ncrmod11) eq   {barcode ncrmod11} if
        checktype (mod1110) eq    {barcode mod11 mod10} if
        checktype (ncrmod1110) eq {barcode ncrmod11 mod10} if
        /barcode exch def
        /barlen barcode length def
        includecheckintext {/txtlen barlen def} if
    } if

    /sbs barlen 8 mul 5 add string def
    /txt barlen array def

    % Put start character
    sbs 0 encs 10 get putinterval

    0 1 barlen 1 sub {
        /i exch def
        % Lookup the encoding for the each barcode character
        barcode i 1 getinterval barchars exch search
        pop                                % Discard true leaving pre
        length /indx exch def              % indx is the length of pre
        pop pop                            % Discard seek and post
        /enc encs indx get def             % Get the indxth encoding
        sbs i 8 mul 2 add enc putinterval  % Put encoded digit into sbs
        txt i [barcode i 1 getinterval i 12 mul 3 add textyoffset textfont textsize] put
    } for

    % Put the end character
    sbs barlen 8 mul 2 add encs 11 get putinterval

    % Return the arguments
    <<
    /ren //renlinear
    /sbs [sbs {48 sub} forall]
    /bhs [sbs length 1 add 2 idiv {height} repeat]
    /bbs [sbs length 1 add 2 idiv {0} repeat]
    includetext {
        /txt txt 0 txtlen getinterval
    } if
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/msi dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER msi--

% --BEGIN ENCODER plessey--
% --DESC: Plessey UK
% --EXAM: 01234ABCD
% --EXOP: includetext includecheckintext
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/plessey {

    20 dict begin                  % Confine variables to local scope

    /options exch def        % We are given an option string
    /barcode exch def        % We are given a barcode string

    /dontdraw false def
    /includetext false def    % Enable/disable text
    /includecheckintext false def
    /unidirectional false def
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /height 1 def
    
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
 
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def
    
    % Create an array containing the character mappings
    /encs
    [ (14141414) (32141414) (14321414) (32321414)
      (14143214) (32143214) (14323214) (32323214)
      (14141432) (32141432) (14321432) (32321432)
      (14143232) (32143232) (14323232) (32323232)
      (32321432) (541412323) (323)
    ] def

    % Create a string of the available characters
    /barchars (0123456789ABCDEF) def

    /barlen barcode length def     % Length of the code
    unidirectional {
        /sbs barlen 8 mul 27 add string def
    } {
        /sbs barlen 8 mul 33 add string def
    } ifelse
    /txt barlen 2 add array def
    /checkbits barlen 4 mul 8 add array def
    checkbits barlen 4 mul [ 0 0 0 0 0 0 0 0 ] putinterval

    % Put start character
    sbs 0 encs 16 get putinterval

    0 1 barlen 1 sub {
        /i exch def
        % Lookup the encoding for the each barcode character
        barcode i 1 getinterval barchars exch search
        pop                                % Discard true leaving pre
        length /indx exch def              % indx is the length of pre
        pop pop                            % Discard seek and post
        /enc encs indx get def             % Get the indxth encoding
        sbs i 8 mul 8 add enc putinterval  % Put encoded digit into sbs
        txt i [barcode i 1 getinterval i 20 mul 20 add textyoffset textfont textsize] put
        checkbits i 4 mul [
                indx 1 and
                indx -1 bitshift 1 and
                indx -2 bitshift 1 and
                indx -3 bitshift
        ] putinterval
    } for

    % Checksum is last 8 bits of a CRC using a salt
    /checksalt [ 1 1 1 1 0 1 0 0 1 ] def
    0 1 barlen 4 mul 1 sub {
        /i exch def
        checkbits i get 1 eq {
            0 1 8 {
                /j exch def
                checkbits i j add checkbits i j add get checksalt j get xor put
            } for
        } if
    } for

    % Calculate the value of the checksum digits
    /checkval 0 def
    0 1 7 {
        /i exch def
        /checkval checkval 2 i exp cvi checkbits barlen 4 mul i add get mul add def
    } for

    % Put the checksum characters
    /checksum1 checkval 15 and def
    /checksum2 checkval -4 bitshift def
    sbs barlen 8 mul 8 add encs checksum1 get putinterval
    sbs barlen 8 mul 16 add encs checksum2 get putinterval
    includecheckintext {
        txt barlen [barchars checksum1 1 getinterval barlen 20 mul 20 add textyoffset textfont textsize] put
        txt barlen 1 add [barchars checksum2 1 getinterval barlen 1 add 20 mul 20 add textyoffset textfont textsize] put
    } {
        txt barlen [( ) barlen 20 mul 20 add textyoffset textfont textsize] put
        txt barlen 1 add [( ) barlen 1 add 20 mul 20 add textyoffset textfont textsize] put
    } ifelse

    % Put end character
    unidirectional {
        sbs barlen 8 mul 24 add encs 18 get putinterval
    } {
        sbs barlen 8 mul 24 add encs 17 get putinterval
    } ifelse

    % Return the arguments
    <<
    /ren //renlinear
    /sbs [sbs {48 sub} forall]
    /bhs [sbs length 1 add 2 idiv {height} repeat]
    /bbs [sbs length 1 add 2 idiv {0} repeat]
    includetext {
        /txt txt
    } if
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/plessey dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER plessey--

% --BEGIN ENCODER telepen--
% --DESC: Telepen
% --EXAM: 123456
% --EXOP: numeric includetext
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/telepen {

    20 dict begin                  % Confine variables to local scope

    /options exch def        % We are given an option string
    /barcode exch def        % We are given a barcode string

    /numeric false def
    /dontdraw false def
    /includetext false def    % Enable/disable text
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /height 1 def
    /parse false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def

    % Parse ordinals of the form ^NNN to ASCII
    parse {
        /msg barcode length string def
        /j 0 def
        barcode
        { % loop
            (^) search {
                dup msg exch j exch putinterval
                length j add 1 add /j exch def
                pop
                dup 0 3 getinterval cvi msg exch j 1 sub exch put
                dup length 3 sub 3 exch getinterval
            } {
                dup msg exch j exch putinterval
                length j add /j exch def
                /barcode msg 0 j getinterval def
                exit
            } ifelse 
        } loop
    } if

    % Create an array containing the character mappings
    /encs
    [ (31313131)        (1131313111)     (33313111)       (1111313131)
      (3111313111)      (11333131)       (13133131)       (111111313111)
      (31333111)        (1131113131)     (33113131)       (1111333111)
      (3111113131)      (1113133111)     (1311133111)     (111111113131)
      (3131113111)      (11313331)       (333331)         (111131113111)
      (31113331)        (1133113111)     (1313113111)     (1111113331)
      (31131331)        (113111113111)   (3311113111)     (1111131331)
      (311111113111)    (1113111331)     (1311111331)     (11111111113111)
      (31313311)        (1131311131)     (33311131)       (1111313311)
      (3111311131)      (11333311)       (13133311)       (111111311131)
      (31331131)        (1131113311)     (33113311)       (1111331131)
      (3111113311)      (1113131131)     (1311131131)     (111111113311)
      (3131111131)      (1131131311)     (33131311)       (111131111131)
      (3111131311)      (1133111131)     (1313111131)     (111111131311)
      (3113111311)      (113111111131)   (3311111131)     (111113111311)
      (311111111131)    (111311111311)   (131111111311)   (11111111111131)
      (3131311111)      (11313133)       (333133)         (111131311111)
      (31113133)        (1133311111)     (1313311111)     (1111113133)
      (313333)          (113111311111)   (3311311111)     (11113333)
      (311111311111)    (11131333)       (13111333)       (11111111311111)
      (31311133)        (1131331111)     (33331111)       (1111311133)
      (3111331111)      (11331133)       (13131133)       (111111331111)
      (3113131111)      (1131111133)     (33111133)       (111113131111)
      (3111111133)      (111311131111)   (131111131111)   (111111111133)
      (31311313)        (113131111111)   (3331111111)     (1111311313)
      (311131111111)    (11331313)       (13131313)       (11111131111111)
      (3133111111)      (1131111313)     (33111313)       (111133111111)
      (3111111313)      (111313111111)   (131113111111)   (111111111313)
      (313111111111)    (1131131113)     (33131113)       (11113111111111)
      (3111131113)      (113311111111)   (131311111111)   (111111131113)
      (3113111113)      (11311111111111) (331111111111)   (111113111113)
      (31111111111111)  (111311111113)   (131111111113)   (1111111111111111)
    ] def

    /barlen barcode length def    % Length of the code
    /sbs barlen 16 mul 48 add string def
    /txt barlen array def

    % Put the start character ASCII 95
    /enc encs 95 get def
    sbs 0 enc putinterval
    /l enc length def

    /checksum 0 def
    /i 0 def /j 0 def
    { % loop
        i barlen eq {exit} if
        numeric {  % numeric mode: 00-99 & 0X-9X
            barcode i get 16 gt { 
                /np barcode i 2 getinterval def
                np 1 1 getinterval (X) eq {  % X in even position amongst digits
                    /indx np 0 1 getinterval cvi 17 add def
                } {
                    /indx np cvi 27 add def
                } ifelse
                txt j [np j 16 mul 16 add textyoffset textfont textsize] put
                /i i 2 add def
            } {
                /indx barcode i get def
                txt j [( ) j 16 mul 16 add textyoffset textfont textsize] put
                /i i 1 add def
            } ifelse
        } {  % ASCII mode
            /indx barcode i get def
            indx 32 ge indx 126 le and {
                txt j [barcode i 1 getinterval j 16 mul 16 add textyoffset textfont textsize] put
            } {
                txt j [( ) j 16 mul 16 add textyoffset textfont textsize] put
            } ifelse
            /i i 1 add def
        } ifelse
        /checksum checksum indx add def
        /enc encs indx get def
        sbs l enc putinterval          % Put encoded digit into sbs
        /l l enc length add def
        /j j 1 add def
    } loop

    % Put the checksum character
    /checksum 127 checksum 127 mod sub 127 mod def
    /enc encs checksum get def
    sbs l enc putinterval
    /l l enc length add def

    % Put the end character ASCII 122
    /enc encs 122 get def
    sbs l enc putinterval
    /l l enc length add def

    % Shrink sbs and txt to fit exactly
    /sbs sbs 0 l getinterval def
    /txt txt 0 j getinterval def

    % Return the arguments
    <<
    /ren //renlinear
    /sbs [sbs {48 sub} forall]
    /bhs [sbs length 1 add 2 idiv {height} repeat]
    /bbs [sbs length 1 add 2 idiv {0} repeat]
    includetext {
        /txt txt
    } if
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/telepen dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER telepen--

% --BEGIN ENCODER posicode--
% --DESC: PosiCode
% --EXAM: ABC123
% --EXOP: version=b inkspread=-0.5 parsefnc includetext
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/posicode {

    20 dict begin                  % Confine variables to local scope

    /options exch def        % We are given an option string
    /barcode exch def        % We are given a barcode string

    /dontdraw false def
    /includetext false def    % Enable/disable text
    /textfont /Courier def
    /textsize 10 def
    /textxoffset 0 def
    /textyoffset -7 def
    /height 1 def
    /encoding (auto) def
    /version (a) def
    /checkoffset 0 def
    /raw false def
    /parse false def
    /parsefnc false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textxoffset textxoffset cvr def
    /textyoffset textyoffset cvr def
    /encoding encoding cvlit def
    /version version cvlit def
    /checkoffset checkoffset cvi def
    /height height cvr def

    % Parse ordinals of the form ^NNN to ASCII
    parse {
        /msg barcode length string def
        /j 0 def
        barcode
        { % loop
            (^) search {
                dup msg exch j exch putinterval
                length j add 1 add /j exch def
                pop
                dup 0 3 getinterval cvi msg exch j 1 sub exch put
                dup length 3 sub 3 exch getinterval
            } {
                dup msg exch j exch putinterval
                length j add /j exch def
                /barcode msg 0 j getinterval def
                exit
            } ifelse 
        } loop
    } if

    /barlen barcode length def

    % Special function characters
    /la0  -1 def  /la1  -2 def  /la2  -3 def 
    /sf0  -4 def  /sf1  -5 def  /sf2  -6 def 
    /fn1  -7 def  /fn2  -8 def  /fn3  -9 def  /fn4 -10 def

    % Character maps for each state
    <<
    /normal
      [
          %  0    1    2        0    1    2        0    1    2
          [ (0)  (^)  (') ]  [ (1)  (;)   27 ]  [ (2)  (<)   28 ]  % 0-2 
          [ (3)  (=)   29 ]  [ (4)  (>)   30 ]  [ (5)  (?)   31 ]  % 3-5
          [ (6)  (@)  (!) ]  [ (7)  ([)  (") ]  [ (8)   92  (#) ]  % 6-8
          [ (9)  (])  (&) ]  [ (A)  (a)    1 ]  [ (B)  (b)    2 ]  % 9-11
          [ (C)  (c)    3 ]  [ (D)  (d)    4 ]  [ (E)  (e)    5 ]  % 12-14
          [ (F)  (f)    6 ]  [ (G)  (g)    7 ]  [ (H)  (h)    8 ]  % 15-17
          [ (I)  (i)    9 ]  [ (J)  (j)   10 ]  [ (K)  (k)   11 ]  % 18-20
          [ (L)  (l)   12 ]  [ (M)  (m)   13 ]  [ (N)  (n)   14 ]  % 21-23
          [ (O)  (o)   15 ]  [ (P)  (p)   16 ]  [ (Q)  (q)   17 ]  % 24-26
          [ (R)  (r)   18 ]  [ (S)  (s)   19 ]  [ (T)  (t)   20 ]  % 27-29
          [ (U)  (u)   21 ]  [ (V)  (v)   22 ]  [ (W)  (w)   23 ]  % 30-32
          [ (X)  (x)   24 ]  [ (Y)  (y)   25 ]  [ (Z)  (z)   26 ]  % 33-35
          [ (-)  (_)   40 ]  [ (.)  (`)   41 ]  [ ( )  127    0 ]  % 36-38
          [ ($)  ({)  (*) ]  [ (/)  (|)  (,) ]  [ (+)  (})  (:) ]  % 39-41
          [ (%)  (~)  fn1 ]  [ la1  la0  fn2 ]  [ sf1  sf0  fn3 ]  % 42-44
          [ sf2  sf2  fn4 ]                                        % 45
      ]
    /limited
      [
          [ (0)  -98  -98 ]  [ (1)  -98   -98 ]  [ (2)  -98  -98 ]  % 0-2
          [ (3)  -98  -98 ]  [ (4)  -98   -98 ]  [ (5)  -98  -98 ]  % 3-5
          [ (6)  -98  -98 ]  [ (7)  -98   -98 ]  [ (8)  -98  -98 ]  % 6-8
          [ (9)  -98  -98 ]  [ (A)  -98   -98 ]  [ (B)  -98  -98 ]  % 9-11
          [ (C)  -98  -98 ]  [ (D)  -98   -98 ]  [ (E)  -98  -98 ]  % 12-14
          [ (F)  -98  -98 ]  [ (G)  -98   -98 ]  [ (H)  -98  -98 ]  % 15-17
          [ (I)  -98  -98 ]  [ (J)  -98   -98 ]  [ (K)  -98  -98 ]  % 18-20
          [ (L)  -98  -98 ]  [ (M)  -98   -98 ]  [ (N)  -98  -98 ]  % 21-23
          [ (O)  -98  -98 ]  [ (P)  -98   -98 ]  [ (Q)  -98  -98 ]  % 24-26
          [ (R)  -98  -98 ]  [ (S)  -98   -98 ]  [ (T)  -98  -98 ]  % 27-29
          [ (U)  -98  -98 ]  [ (V)  -98   -98 ]  [ (W)  -98  -98 ]  % 30-32
          [ (X)  -98  -98 ]  [ (Y)  -98   -98 ]  [ (Z)  -98  -98 ]  % 33-35
          [ (-)  -98  -98 ]  [ (.)  -98   -98 ]                     % 36-37
      ]
    >> 
    version (a) eq version (b) eq or {/normal} {/limited} ifelse get 
    /charmaps exch def

    % Invert charmaps to give character to value maps for each state
    /charvals [
        charmaps length dict charmaps length dict charmaps length dict
    ] def
    0 1 charmaps length 1 sub {
        /i exch def
        /encs charmaps i get def
        0 1 2 {
            /j exch def
            encs j get dup type /stringtype eq {0 get} if  % convert string to ASCII if required
            charvals j get exch i put 
        } for
    } for
    /set0 charvals 0 get def
    /set1 charvals 1 get def
    /set2 charvals 2 get def

    raw {/encoding (raw) def} if

    encoding (raw) eq {
        /cws barlen array def
        /i 0 def /j 0 def
        { % loop
            i barlen eq {exit} if
            /cw barcode i 1 add 3 getinterval cvi def
            cws j cw put
            /i i 4 add def
            /j j 1 add def
        } loop
        /cws cws 0 j getinterval def
        /text () def
    } if

    encoding (auto) eq { 

        /fncvals <<
            (FNC1) fn1
            (FNC2) fn2
            (FNC3) fn3
            (FNC4) fn4
        >> def

        % Convert input into bytes accounting for FNC characters 
        /msg barlen array def
        /text barlen string def
        /i 0 def /j 0 def {
            i barlen eq {exit} if
            /char barcode i get def
            text j char put
            parsefnc char 94 eq and i barlen 4 sub lt and {
                barcode i 1 add get 94 ne {
                    /char fncvals barcode i 1 add 4 getinterval get def
                    text j ( ) putinterval
                    /i i 4 add def
                } {
                    /i i 1 add def
                } ifelse
            } if
            msg j char put
            /i i 1 add def
            /j j 1 add def
        } loop
        /msg msg 0 j getinterval def
        /msglen msg length def
        /text text 0 j getinterval def

        % Convert the input message to codewords
        /enc {
            exch get cws exch j exch put
            /j j 1 add def
        } bind def

        /cws barcode length 2 mul array def
        /i 0 def /j 0 def /cset (set0) def
        {
            i msglen eq {exit} if
       
            {  % common exit

                % Read next two characters
                /char1 msg i get def
                /char2 i 1 add msglen lt {msg i 1 add get} {-99} ifelse def

                % If current mode is sufficient then directly encode
                cset load char1 known { 
                    char1 cset load enc
                    /i i 1 add def
                    exit
                } if

                % If char1 is in set2 then shift encode
                set2 char1 known {
                    sf2 cset load enc
                    char1 set2 enc
                    /i i 1 add def
                    exit
                } if 

                % If char2 is also not in this set then latch else shift encode
                cset load char2 known not {
                    cset (set0) eq {
                       la1 cset load enc
                       /cset (set1) def
                    } {
                       la0 cset load enc
                       /cset (set0) def
                    } ifelse
                    exit
                } { 
                    cset (set0) eq {
                        sf1 cset load enc
                        char1 set1 enc
                    } {
                        sf0 cset load enc
                        char1 set0 enc
                    } ifelse 
                    /i i 1 add def
                    exit
                } ifelse

                exit
            } loop
        
        } loop
        /cws cws 0 j getinterval def
    } if  % auto encoding

    % Create an array containing the character mappings
    <<   % ";"=11, "<"=12
    /a
        [ (141112) (131212) (121312) (111412) (131113)
          (121213) (111313) (121114) (111214) (111115)
          (181111) (171211) (161311) (151411) (141511)
          (131611) (121711) (111811) (171112) (161212)
          (151312) (141412) (131512) (121612) (111712)
          (161113) (151213) (141313) (131413) (121513)
          (111613) (151114) (141214) (131314) (121414)
          (111514) (141115) (131215) (121315) (111415)
          (131116) (121216) (111316) (121117) (111217)
          (111118) (1<111112) (111111111;1)
        ]
    /b
        [ (151213) (141313) (131413) (121513) (141214)
          (131314) (121414) (131215) (121315) (121216)
          (191212) (181312) (171412) (161512) (151612)
          (141712) (131812) (121912) (181213) (171313)
          (161413) (151513) (141613) (131713) (121813)
          (171214) (161314) (151414) (141514) (131614)
          (121714) (161215) (151315) (141415) (131515)
          (121615) (151216) (141316) (131416) (121516)
          (141217) (131317) (121417) (131218) (121318)
          (121219) (1<121312) (121212121<1)
        ]
    /limiteda
        [ (111411) (111312) (111213) (111114) (121311)
          (121212) (121113) (141111) (131211) (131112)
          (171111) (161211) (151311) (141411) (131511)
          (121611) (111711) (161112) (151212) (141312)
          (131412) (121512) (111612) (151113) (141213)
          (131313) (121413) (111513) (141114) (131214)
          (121314) (111414) (131115) (121215) (111315)
          (121116) (111216) (111117) (151111) (1)
        ]
    /limitedb
        [ (121512) (121413) (121314) (121215) (131412)
          (131313) (131214) (151212) (141312) (141213)
          (181212) (171312) (161412) (151512) (141612)
          (131712) (121812) (171213) (161313) (151413)
          (141513) (131613) (121713) (161214) (151314)
          (141414) (131514) (121614) (151215) (141315)
          (131415) (121515) (141216) (131316) (121416)
          (131217) (121317) (121218) (141212) (1)
        ]
    >>
    version get /encs exch def

    /c2w [
        [ 495 330 210 126  70  35  15   5 ]
        [ 165 120  84  56  35  20  10   4 ]
        [  45  36  28  21  15  10   6   3 ] 
        [   9   8   7   6   5   4   3   2 ]
        [   1   1   1   1   1   1   1   1 ]
    ] def
    /v 0 def
    cws {
        /cw exch def
        6 {
            cw v xor 1 and 0 ne {
                /v v 7682 xor def
            } if
            /v v -1 bitshift def
            /cw cw -1 bitshift def
        } repeat 
    } forall
    /v v checkoffset add def

    version (limiteda) eq version (limitedb) eq or {
        /v v 1023 and def
        v 824 gt v 853 lt and {
            /v v 292 add def
        } if 
    } {
        /v v 1023 and 45 add def
    } ifelse

    /d [ 2 2 2 2 2 2 ] def
    /r 0 def /c 0 def /w 0 def /sum 0 def
    {
        sum v eq {exit} if
        /t sum c2w r get c get add def
        t v eq {
            /w w 1 add def
            d r w 2 add put
            /sum t def
        } if
        t v gt {
            d r w 2 add put
            /r r 1 add def
            /w 0 def
        } if
        t v lt {
            /c c 1 add def
            /w w 1 add def
            /sum t def
        } if
    } loop
    20 0 1 4 {d exch get sub} for
    d exch 5 exch put
    version (b) eq version (limitedb) eq or {  
        /d [ d {1 add} forall ] def
    } if
    /cbs (111111111111) 12 string copy def
    5 -1 0 {
        /i exch def
        cbs 5 i sub 2 mul 1 add d i get 47 add put
    } for

    % Concatenate the space bar successions
    /sbs cws length 6 mul 31 add string def
    encs encs length 2 sub get dup 
    sbs exch 0 exch putinterval 
    length /j exch def
    0 1 cws length 1 sub {
        /i exch def
        sbs j encs cws i get get putinterval
        /j j 6 add def
    } for
    sbs j cbs putinterval
    /j j 12 add def
    encs encs length 1 sub get dup
    sbs exch j exch putinterval
    length j add /j exch def
    /sbs sbs 0 j getinterval def

    % Return the arguments
    <<
    /ren //renlinear
    /sbs [sbs {48 sub} forall]
    /bhs [sbs length 1 add 2 idiv {height} repeat]
    /bbs [sbs length 1 add 2 idiv {0} repeat]
    /txt [ [text textxoffset textyoffset textfont textsize] ]
    /textxalign (center)
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/posicode dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER posicode--

% --BEGIN ENCODER codablockf--
% --DESC: Codablock F
% --EXAM: CODABLOCK F 34567890123456789010040digit
% --EXOP: cols=8
% --RNDR: renmatrix
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/codablockf {

    20 dict begin

    /options exch def
    /barcode exch def

    /dontdraw false def
    /rows -1 def
    /cols 8 def
    /rowheight 10 def
    /sepheight 1 def
    /encoding (auto) def
    /parse false def
    /parsefnc false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /rows rows cvi def
    /cols cols cvi def
    /rowheight rowheight cvi def
    /sepheight sepheight cvi def

    cols 4 ge cols 62 le and 
    rows 2 ge rows 44 le and rows -1 eq or and {/c cols def} if

    % Parse ordinals of the form ^NNN to ASCII
    parse {
        /msg barcode length string def
        /j 0 def
        barcode
        { % loop
            (^) search {
                dup msg exch j exch putinterval
                length j add 1 add /j exch def
                pop
                dup 0 3 getinterval cvi msg exch j 1 sub exch put
                dup length 3 sub 3 exch getinterval
            } {
                dup msg exch j exch putinterval
                length j add /j exch def
                /barcode msg 0 j getinterval def
                exit
            } ifelse 
        } loop
    } if

    /barlen barcode length def

    % Convert input into bytes accounting for FNC characters 
    /swa -1 def  /swb -2 def  /swc -3 def  /sft -4 def
    /fn1 -5 def  /fn2 -6 def  /fn3 -7 def  /fn4 -8 def
    /sta -9 def  /stp -10 def

    % Character maps for each state
    /charmaps [
      %  A    B    C         A    B    C         A    B    C
      [  32   32  (00) ]  [ (!)  (!)  (01) ]  [ (")  (")  (02) ]  % 0-2 
      [ (#)  (#)  (03) ]  [ ($)  ($)  (04) ]  [ (%)  (%)  (05) ]  % 3-5
      [ (&)  (&)  (06) ]  [ (')  (')  (07) ]  [  40   40  (08) ]  % 6-8
      [  41   41  (09) ]  [ (*)  (*)  (10) ]  [ (+)  (+)  (11) ]  % 9-11
      [ (,)  (,)  (12) ]  [ (-)  (-)  (13) ]  [ (.)  (.)  (14) ]  % 12-14
      [ (/)  (/)  (15) ]  [ (0)  (0)  (16) ]  [ (1)  (1)  (17) ]  % 15-17
      [ (2)  (2)  (18) ]  [ (3)  (3)  (19) ]  [ (4)  (4)  (20) ]  % 18-20
      [ (5)  (5)  (21) ]  [ (6)  (6)  (22) ]  [ (7)  (7)  (23) ]  % 21-23
      [ (8)  (8)  (24) ]  [ (9)  (9)  (25) ]  [ (:)  (:)  (26) ]  % 24-26
      [ (;)  (;)  (27) ]  [ (<)  (<)  (28) ]  [ (=)  (=)  (29) ]  % 27-29
      [ (>)  (>)  (30) ]  [ (?)  (?)  (31) ]  [ (@)  (@)  (32) ]  % 30-32
      [ (A)  (A)  (33) ]  [ (B)  (B)  (34) ]  [ (C)  (C)  (35) ]  % 33-35
      [ (D)  (D)  (36) ]  [ (E)  (E)  (37) ]  [ (F)  (F)  (38) ]  % 36-38
      [ (G)  (G)  (39) ]  [ (H)  (H)  (40) ]  [ (I)  (I)  (41) ]  % 39-41
      [ (J)  (J)  (42) ]  [ (K)  (K)  (43) ]  [ (L)  (L)  (44) ]  % 42-44
      [ (M)  (M)  (45) ]  [ (N)  (N)  (46) ]  [ (O)  (O)  (47) ]  % 45-47
      [ (P)  (P)  (48) ]  [ (Q)  (Q)  (49) ]  [ (R)  (R)  (50) ]  % 48-50
      [ (S)  (S)  (51) ]  [ (T)  (T)  (52) ]  [ (U)  (U)  (53) ]  % 51-53
      [ (V)  (V)  (54) ]  [ (W)  (W)  (55) ]  [ (X)  (X)  (56) ]  % 54-56
      [ (Y)  (Y)  (57) ]  [ (Z)  (Z)  (58) ]  [ ([)  ([)  (59) ]  % 57-59
      [  92   92  (60) ]  [ (])  (])  (61) ]  [ (^)  (^)  (62) ]  % 60-62
      [ (_)  (_)  (63) ]  [   0  (`)  (64) ]  [   1  (a)  (65) ]  % 63-65
      [   2  (b)  (66) ]  [   3  (c)  (67) ]  [   4  (d)  (68) ]  % 66-68
      [   5  (e)  (69) ]  [   6  (f)  (70) ]  [   7  (g)  (71) ]  % 69-71
      [   8  (h)  (72) ]  [   9  (i)  (73) ]  [  10  (j)  (74) ]  % 72-74
      [  11  (k)  (75) ]  [  12  (l)  (76) ]  [  13  (m)  (77) ]  % 75-77
      [  14  (n)  (78) ]  [  15  (o)  (79) ]  [  16  (p)  (80) ]  % 78-80
      [  17  (q)  (81) ]  [  18  (r)  (82) ]  [  19  (s)  (83) ]  % 81-83
      [  20  (t)  (84) ]  [  21  (u)  (85) ]  [  22  (v)  (86) ]  % 84-86
      [  23  (w)  (87) ]  [  24  (x)  (88) ]  [  25  (y)  (89) ]  % 87-89
      [  26  (z)  (90) ]  [  27  ({)  (91) ]  [  28  (|)  (92) ]  % 90-92
      [  29  (})  (93) ]  [  30  (~)  (94) ]  [  31  127  (95) ]  % 93-95
      [ fn3  fn3  (96) ]  [ fn2  fn2  (97) ]  [ sft  sft  (98) ]  % 96-98
      [ swc  swc  (99) ]  [ swb  fn4  swb  ]  [ fn4  swa  swa  ]  % 99-101
      [ fn1  fn1  fn1  ]  [ sta  sta  sta  ]  [ stp  stp  stp  ]  % 102-104
    ] def
    
    % Invert charmaps to give character to value maps for each state
    /charvals [ 105 dict 105 dict 105 dict ] def
    0 1 charmaps length 1 sub {
        /i exch def
        /encs charmaps i get def
        0 1 2 {
            /j exch def
            encs j get dup type /stringtype eq {0 get} if  % convert string to ASCII if required
            charvals j get exch i put 
        } for
    } for
    /seta charvals 0 get def
    /setb charvals 1 get def
    /setc charvals 2 get def
    
    /fncvals <<
        (FNC1) fn1
        (FNC2) fn2
        (FNC3) fn3
        (FNC4) fn4
    >> def
    /msg barlen array def
    /i 0 def /j 0 def {
        i barlen eq {exit} if
        /char barcode i get def
        parsefnc char 94 eq and i barlen 4 sub lt and {
            barcode i 1 add get 94 ne {
                /char fncvals barcode i 1 add 4 getinterval get def
                /i i 4 add def
            } {
                /i i 1 add def
            } ifelse
        } if
        msg j char put
        /i i 1 add def
        /j j 1 add def
    } loop
    /msg msg 0 j getinterval def
    /msglen msg length def

    % Determine digit runlength and characters from given position
    /numsscr {
        /n 0 def /s 0 def
        /p exch def {
            p msglen ge {exit} if
            msg p get
            dup setc exch known not {pop exit} if
            fn1 eq {
                % FNC1 in odd position of run like two digits
                s 2 mod 0 eq {/s s 1 add def} {exit} ifelse
            } if
            /n n 1 add def
            /s s 1 add def
            /p p 1 add def
        } loop
        n s
    } bind def

    % Encoding for each alphabet
    /enca {
        seta exch get cws exch j exch put
        /j j 1 add def
    } bind def
    /encb {
        setb exch get cws exch j exch put
        /j j 1 add def
    } bind def
    /encc {
        dup type /arraytype ne {
            setc exch get
        } {
            aload pop 48 sub exch 48 sub 10 mul add
        } ifelse
        cws exch j exch put
        /j j 1 add def
    } bind def

    % Character exclusively in either alphabet A or B
    /anotb {dup seta exch known exch setb exch known not and} bind def
    /bnota {dup setb exch known exch seta exch known not and} bind def

    % Pre-compute relative position of next anotb and next bnota characters
    /nextanotb [ msg length {0} repeat 9999 ] def
    /nextbnota [ msg length {0} repeat 9999 ] def
    msg length 1 sub -1 0 {
        /i exch def
        msg i get anotb {
            nextanotb i 0 put
        } {
            nextanotb i nextanotb i 1 add get 1 add put
        } ifelse
        msg i get bnota {
            nextbnota i 0 put
        } {
            nextbnota i nextbnota i 1 add get 1 add put
        } ifelse
    } for

    % Does a-only come before b-only after given position and vice versa
    /abeforeb {dup nextanotb exch get exch nextbnota exch get lt} bind def
    /bbeforea {dup nextbnota exch get exch nextanotb exch get lt} bind def

    % Add padding to row
    /padrow {
        {
           {  % common exit
               cset (seta) eq {swc enca /cset (setc) def exit} if
               cset (setb) eq {swc encb /cset (setc) def exit} if
               cset (setc) eq {swb encc /cset (setb) def exit} if
           } loop
        } repeat
    } bind def

    % Convert message to codewords
    /cws c 5 add rows -1 ne {rows} {44} ifelse mul array def

    /i 0 def /j 0 def /r 1 def
    /lastrow false def {
        
        lastrow {exit} if

        % Add start character and code subset selector
        sta enca
        i msglen lt {i numsscr} {-1 -1} ifelse /nums exch def /nchars exch def
        {  % common exit
            msglen 0 eq {
                swb enca
                /cset (setb) def
                exit
            } if
            nums 2 ge {
                swc enca
                /cset (setc) def
                exit
            } if
            i abeforeb { 
                sft enca
                /cset (seta) def
                exit 
            } if 
            swb enca
            /cset (setb) def
            exit
        } loop
        /j j 1 add def  % Skip row indicator position

        % Main encoding loop
        /endofrow false def {
            /rem c 3 add j c 5 add mod sub def  % Codewords to end of row

            i msglen eq endofrow or {exit} if
        
            i numsscr /nums exch def /nchars exch def

            % Determine switches and shifts
            {  % common exit
                cset (seta) eq cset (setb) eq or nums 4 ge and 
                msg i get fn1 ne and {
                    nums 2 mod 0 eq
                    rem 3 ge and {
                        swc cset (seta) eq {enca} {encb} ifelse
                        /cset (setc) def
                        2 {
                            msg i get fn1 eq {
                                fn1 encc
                                /i i 1 add def
                            } {
                                msg i 2 getinterval encc
                                /i i 2 add def
                            } ifelse
                        } repeat
                        exit
                    } if
                    nums 2 mod 0 ne
                    rem 4 ge and {
                        msg i get cset (seta) eq {enca} {encb} ifelse
                        /i i 1 add def
                        swc cset (seta) eq {enca} {encb} ifelse
                        /cset (setc) def
                        2 {
                            msg i get fn1 eq {
                                fn1 encc
                                /i i 1 add def
                            } {
                                msg i 2 getinterval encc
                                /i i 2 add def
                            } ifelse
                        } repeat
                        exit
                    } if
                } if
                cset (setb) eq msg i get anotb and 
                rem 2 ge and { 
                    i msglen 1 sub lt {
                        i 1 add bbeforea { 
                            sft encb
                            msg i get enca
                            /i i 1 add def
                            exit
                        } if
                    } if
                    swa encb
                    /cset (seta) def
                    msg i get enca
                    /i i 1 add def
                    exit
                } if
                cset (seta) eq msg i get bnota and
                rem 2 ge and {
                    i msglen 1 sub lt {
                        i 1 add abeforeb {
                            sft enca
                            msg i get encb
                            /i i 1 add def
                            exit
                        } if
                    } if
                    swb enca
                    /cset (setb) def
                    msg i get encb
                    /i i 1 add def
                    exit
                } if
                cset (setc) eq nums 2 lt and
                rem 2 ge and {
                    i abeforeb {
                        swa encc
                        /cset (seta) def
                        msg i get enca
                        /i i 1 add def
                        exit
                    } if
                    swb encc
                    /cset (setb) def
                    msg i get encb
                    /i i 1 add def
                    exit
                } if
        
                % No switches or latches so try to encode
                cset (seta) eq seta msg i get known and
                rem 1 ge and {
                    msg i get enca
                    /i i 1 add def
                    exit
                } if
                cset (setb) eq setb msg i get known and
                rem 1 ge and {
                    msg i get encb
                    /i i 1 add def
                    exit
                } if
                cset (setc) eq nums 2 ge and
                rem 1 ge and {
                    msg i get fn1 eq {
                        fn1 encc
                        /i i 1 add def
                    } {
                        msg i 2 getinterval encc
                        /i i 2 add def 
                    } ifelse
                    exit
                } if

                % Encoding does not fit in the row
                /endofrow true def
                exit

            } loop  % common exit

        } loop

        % Determine whether this is the final row
        r rows eq rows -1 eq or r 1 gt and i msglen eq and rem 2 ge and {
            rem 2 sub padrow
            /j j 3 add def  % Skip symbol and row checksum character positions
            stp enca
            /lastrow true def
        } {
            rem padrow
            /j j 1 add def  % Skip row checksum character positions
            stp enca
            /r r 1 add def
        } ifelse

    } loop
    /cws cws 0 j getinterval def

    % Maps for row indicators and symbol checksums
    /abmap [
        64 1 95 {} for
         0 1 15 {} for
        26 1 63 {} for
    ] def
    /cmap [ 0 1 85 {} for ] def
    
    % Add symbol check characters to last row
    /chkmsg msglen array def
    /j 0 def
    0 1 msglen 1 sub {
        /i exch def
        /char msg i get def
        char 0 ge {chkmsg j char put /j j 1 add def} if
        char fn1 eq i 0 ne and {chkmsg j 29 put /j j 1 add def} if
    } for
    /t1 0 def /t2 0 def /k1 0 def /k2 0 def
    0 1 j 1 sub {
        /i exch def
        /t1 chkmsg i get i mul 86 mod def
        /t2 t1 chkmsg i get add 86 mod def
        /k1 k1 t2 add 86 mod def
        /k2 k2 t1 add 86 mod def
    } for
    cws cws length 4 sub cset (setc) ne {abmap} {cmap} ifelse k1 get put
    cws cws length 3 sub cset (setc) ne {abmap} {cmap} ifelse k2 get put

    % Populate row indicators
    cws 2 2 copy 1 sub get 99 ne {abmap} {cmap} ifelse r 2 sub get put
    1 1 r 1 sub {
        /i exch def
        cws i c 5 add mul 2 add 2 copy 1 sub get 99 ne {abmap} {cmap} ifelse i 42 add get put
    } for

    % Calculate row check characters
    0 1 r 1 sub {
        cws exch c 5 add mul c 4 add getinterval /rcws exch def
        /csum rcws 0 get def
        1 1 rcws length 2 sub {
            /i exch def
            /csum csum rcws i get i mul add def
        } for
        rcws rcws length 1 sub csum 103 mod put
    } for

    % Create an array containing the character mappings
    /encs
    [ (212222) (222122) (222221) (121223) (121322) (131222) (122213)
      (122312) (132212) (221213) (221312) (231212) (112232) (122132)
      (122231) (113222) (123122) (123221) (223211) (221132) (221231)
      (213212) (223112) (312131) (311222) (321122) (321221) (312212)
      (322112) (322211) (212123) (212321) (232121) (111323) (131123)
      (131321) (112313) (132113) (132311) (211313) (231113) (231311)
      (112133) (112331) (132131) (113123) (113321) (133121) (313121)
      (211331) (231131) (213113) (213311) (213131) (311123) (311321)
      (331121) (312113) (312311) (332111) (314111) (221411) (431111)
      (111224) (111422) (121124) (121421) (141122) (141221) (112214)
      (112412) (122114) (122411) (142112) (142211) (241211) (221114)
      (413111) (241112) (134111) (111242) (121142) (121241) (114212)
      (124112) (124211) (411212) (421112) (421211) (212141) (214121)
      (412121) (111143) (111341) (131141) (114113) (114311) (411113)
      (411311) (113141) (114131) (311141) (411131) (211412) (2331112)
    ] def

    % Derive the bits for each row
    /rowbits r array def
    0 1 r 1 sub {
        /i exch def
        /sbs [
            cws i c 5 add mul c 5 add getinterval {
                encs exch get {48 sub} forall
            } forall 
        ] def
        mark
        0 sbs {1 index 1 eq {{0}} {{1}} ifelse repeat} forall
        counttomark 1 sub array astore exch pop exch pop
        rowbits i 3 -1 roll put
    } for

    % Populate the bitmap
    /symwid c 11 mul 57 add def
    /pixs [
        symwid sepheight mul {1} repeat
        0 1 r 2 sub {
            /i exch def
            rowheight {rowbits i get aload pop} repeat
            sepheight {
                1 1 0 1 0 0 0 0 1 0 0
                symwid 24 sub {1} repeat
                1 1 0 0 0 1 1 1 0 1 0 1 1
            } repeat
        } for
        rowheight {rowbits r 1 sub get aload pop} repeat
        symwid sepheight mul {1} repeat
    ] def
    
    % Return the arguments
    <<
    /ren //renmatrix
    /pixs pixs
    /pixx symwid
    /pixy pixs length symwid idiv
    /height pixs length symwid idiv 72 div
    /width symwid 72 div
    /opt options
    >>

    dontdraw not //renmatrix if

    end

} bind def
/codablockf dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER codablockf--

% --BEGIN ENCODER code16k--
% --DESC: Code 16K
% --EXAM: Abcd-1234567890-wxyZ
% --EXOP:
% --RNDR: renmatrix
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/code16k {

    20 dict begin

    /options exch def
    /barcode exch def

    /dontdraw false def
    /mode -1 def
    /pos -1 def
    /rows 0 def
    /rowheight 8 def
    /sepheight 1 def
    /encoding (auto) def
    /raw false def
    /parse false def
    /parsefnc false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /mode mode cvi def
    /pos pos cvi def
    /rows rows cvi def
    /rowheight rowheight cvi def
    /sepheight sepheight cvi def

    pos -1 ne {/rows 16 def} if

    % Parse ordinals of the form ^NNN to ASCII
    parse {
        /msg barcode length string def
        /j 0 def
        barcode
        { % loop
            (^) search {
                dup msg exch j exch putinterval
                length j add 1 add /j exch def
                pop
                dup 0 3 getinterval cvi msg exch j 1 sub exch put
                dup length 3 sub 3 exch getinterval
            } {
                dup msg exch j exch putinterval
                length j add /j exch def
                /barcode msg 0 j getinterval def
                exit
            } ifelse 
        } loop
    } if

    /barlen barcode length def

    % Convert input into bytes accounting for FNC characters 
    /swa  -1 def  /swb  -2 def  /swc  -3 def 
    /sa1  -4 def  /sb1  -5 def  /sc1  -6 def 
    /sa2  -7 def  /sb2  -8 def  /sc2  -9 def 
    /pad -10 def  /sb3 -11 def  /sc3 -12 def
    /fn1 -13 def  /fn2 -14 def  /fn3 -15 def  /fn4 -16 def

    % Character maps for each state
    /charmaps [
      %  A    B    C         A    B    C         A    B    C
      [  32   32  (00) ]  [ (!)  (!)  (01) ]  [ (")  (")  (02) ]  % 0-2 
      [ (#)  (#)  (03) ]  [ ($)  ($)  (04) ]  [ (%)  (%)  (05) ]  % 3-5
      [ (&)  (&)  (06) ]  [ (')  (')  (07) ]  [  40   40  (08) ]  % 6-8
      [  41   41  (09) ]  [ (*)  (*)  (10) ]  [ (+)  (+)  (11) ]  % 9-11
      [ (,)  (,)  (12) ]  [ (-)  (-)  (13) ]  [ (.)  (.)  (14) ]  % 12-14
      [ (/)  (/)  (15) ]  [ (0)  (0)  (16) ]  [ (1)  (1)  (17) ]  % 15-17
      [ (2)  (2)  (18) ]  [ (3)  (3)  (19) ]  [ (4)  (4)  (20) ]  % 18-20
      [ (5)  (5)  (21) ]  [ (6)  (6)  (22) ]  [ (7)  (7)  (23) ]  % 21-23
      [ (8)  (8)  (24) ]  [ (9)  (9)  (25) ]  [ (:)  (:)  (26) ]  % 24-26
      [ (;)  (;)  (27) ]  [ (<)  (<)  (28) ]  [ (=)  (=)  (29) ]  % 27-29
      [ (>)  (>)  (30) ]  [ (?)  (?)  (31) ]  [ (@)  (@)  (32) ]  % 30-32
      [ (A)  (A)  (33) ]  [ (B)  (B)  (34) ]  [ (C)  (C)  (35) ]  % 33-35
      [ (D)  (D)  (36) ]  [ (E)  (E)  (37) ]  [ (F)  (F)  (38) ]  % 36-38
      [ (G)  (G)  (39) ]  [ (H)  (H)  (40) ]  [ (I)  (I)  (41) ]  % 39-41
      [ (J)  (J)  (42) ]  [ (K)  (K)  (43) ]  [ (L)  (L)  (44) ]  % 42-44
      [ (M)  (M)  (45) ]  [ (N)  (N)  (46) ]  [ (O)  (O)  (47) ]  % 45-47
      [ (P)  (P)  (48) ]  [ (Q)  (Q)  (49) ]  [ (R)  (R)  (50) ]  % 48-50
      [ (S)  (S)  (51) ]  [ (T)  (T)  (52) ]  [ (U)  (U)  (53) ]  % 51-53
      [ (V)  (V)  (54) ]  [ (W)  (W)  (55) ]  [ (X)  (X)  (56) ]  % 54-56
      [ (Y)  (Y)  (57) ]  [ (Z)  (Z)  (58) ]  [ ([)  ([)  (59) ]  % 57-59
      [  92   92  (60) ]  [ (])  (])  (61) ]  [ (^)  (^)  (62) ]  % 60-62
      [ (_)  (_)  (63) ]  [   0  (`)  (64) ]  [   1  (a)  (65) ]  % 63-65
      [   2  (b)  (66) ]  [   3  (c)  (67) ]  [   4  (d)  (68) ]  % 66-68
      [   5  (e)  (69) ]  [   6  (f)  (70) ]  [   7  (g)  (71) ]  % 69-71
      [   8  (h)  (72) ]  [   9  (i)  (73) ]  [  10  (j)  (74) ]  % 72-74
      [  11  (k)  (75) ]  [  12  (l)  (76) ]  [  13  (m)  (77) ]  % 75-77
      [  14  (n)  (78) ]  [  15  (o)  (79) ]  [  16  (p)  (80) ]  % 78-80
      [  17  (q)  (81) ]  [  18  (r)  (82) ]  [  19  (s)  (83) ]  % 81-83
      [  20  (t)  (84) ]  [  21  (u)  (85) ]  [  22  (v)  (86) ]  % 84-86
      [  23  (w)  (87) ]  [  24  (x)  (88) ]  [  25  (y)  (89) ]  % 87-89
      [  26  (z)  (90) ]  [  27  ({)  (91) ]  [  28  (|)  (92) ]  % 90-92
      [  29  (})  (93) ]  [  30  (~)  (94) ]  [  31  127  (95) ]  % 93-95
      [ fn3  fn3  (96) ]  [ fn2  fn2  (97) ]  [ sb1  sa1  (98) ]  % 96-98
      [ swc  swc  (99) ]  [ swb  fn4  swb  ]  [ fn4  swa  swa  ]  % 99-101
      [ fn1  fn1  fn1  ]  [ pad  pad  pad  ]  [ sb2  sa2  sb1  ]  % 102-104
      [ sc2  sc2  sb2  ]  [ sc3  sc3  sb3  ]                      % 105-106
    ] def 
    
    % Invert charmaps to give character to value maps for each state
    /charvals [ 109 dict 109 dict 109 dict ] def
    0 1 charmaps length 1 sub {
        /i exch def
        /encs charmaps i get def
        0 1 2 {
            /j exch def
            encs j get dup type /stringtype eq {0 get} if  % convert string to ASCII if required
            charvals j get exch i put 
        } for
    } for
    /seta charvals 0 get def
    /setb charvals 1 get def
    /setc charvals 2 get def

    raw {/encoding (raw) def} if

    encoding (raw) eq {
        /cws barlen array def
        /i 0 def /j 0 def
        { % loop
            i barlen eq {exit} if
            /cw barcode i 1 add 3 getinterval cvi def
            cws j cw put
            /i i 4 add def
            /j j 1 add def
        } loop
        /cws cws 0 j getinterval def
        /text () def
    } if

    encoding (auto) eq { 

        /fncvals <<
            (FNC1) fn1
            (FNC2) fn2
            (FNC3) fn3
            (FNC4) fn4
        >> def
        /msg barlen array def
        /i 0 def /j 0 def {
            i barlen eq {exit} if
            /char barcode i get def
            parsefnc char 94 eq and i barlen 4 sub lt and {
                barcode i 1 add get 94 ne {
                    /char fncvals barcode i 1 add 4 getinterval get def
                    /i i 4 add def
                } {
                    /i i 1 add def
                } ifelse
            } if
            msg j char put
            /i i 1 add def
            /j j 1 add def
        } loop
        /msg msg 0 j getinterval def
        /msglen msg length def
    
        % Determine digit runlength and characters from given position
        /numsscr {
            /n 0 def /s 0 def
            /p exch def {
                p msglen ge {exit} if
                msg p get
                dup setc exch known not {pop exit} if
                fn1 eq {
                    % FNC1 in odd position of run like two digits
                    s 2 mod 0 eq {/s s 1 add def} {exit} ifelse
                } if
                /n n 1 add def
                /s s 1 add def
                /p p 1 add def
            } loop
            n s
        } bind def

        % Encoding for each alphabet
        /enca {
            seta exch get cws exch j exch put
            /j j 1 add def
        } bind def
        /encb {
            setb exch get cws exch j exch put
            /j j 1 add def
        } bind def
        /encc {
            dup type /arraytype ne {
                setc exch get
            } {
                aload pop 48 sub exch 48 sub 10 mul add
            } ifelse
            cws exch j exch put
            /j j 1 add def
        } bind def

        % Character exclusively in either alphabet A or B
        /anotb {dup seta exch known exch setb exch known not and} bind def
        /bnota {dup setb exch known exch seta exch known not and} bind def

        % Pre-compute relative position of next anotb and next bnota characters
        /nextanotb [ msg length {0} repeat 9999 ] def
        /nextbnota [ msg length {0} repeat 9999 ] def
        msg length 1 sub -1 0 {
            /i exch def
            msg i get anotb {
                nextanotb i 0 put
            } {
                nextanotb i nextanotb i 1 add get 1 add put
            } ifelse
            msg i get bnota {
                nextbnota i 0 put
            } {
                nextbnota i nextbnota i 1 add get 1 add put
            } ifelse
        } for

        % Does a-only come before b-only after given position and vice versa
        /abeforeb {dup nextanotb exch get exch nextbnota exch get lt} bind def
        /bbeforea {dup nextbnota exch get exch nextanotb exch get lt} bind def
 
        /cws barcode length 2 mul 3 add array def
       
        % Select mode and encode first characters
        /i 0 def /j 0 def
        {  % common exit
            % extended data length
            pos -1 ne {
                % encode one and two
                cws 0 pos 10 idiv 1 sub put
                cws 1 pos 10 mod 1 sub put 
                /j 2 def
                /cset (setb) def
                /mode 7 def
                exit
            } if
            % empty => b
            msglen 0 eq {
                /cset (setb) def
                /mode 1 def
                exit
            } if
            % FNC1 . 2+ nums => c fnc1
            msglen 2 ge {
                msg 0 get fn1 eq 1 numsscr exch pop 2 ge and {
                    /cset (setc) def
                    /mode 4 def
                    /i 1 def
                    exit
                } if
            } if
            % FNC1 => b fnc1
            msg 0 get fn1 eq {
                /cset (setb) def
                /mode 3 def
                /i 1 def
                exit
            } if
            msglen 2 ge {
                % 2+ even nums => c
                0 numsscr exch pop dup 2 ge exch 2 mod 0 eq and {
                    /cset (setc) def
                    /mode 2 def
                    exit
                } if
                % 3+ odd nums => c sb1 encode
                0 numsscr exch pop dup 3 ge exch 2 mod 1 eq and {
                    msg 0 get encb
                    /cset (setc) def
                    /mode 5 def
                    /i 1 def
                    exit
                } if
                % b . 2+ even nums => c sb1 encode
                setb msg 0 get known
                1 numsscr exch pop dup 2 ge exch 2 mod 0 eq and and {
                    msg 0 get encb
                    /cset (setc) def
                    /mode 5 def
                    /i 1 def
                    exit
                } if
                % b . 3+ odd nums => c sb2 encode 
                setb msg 0 get known
                1 numsscr exch pop dup 3 ge exch 2 mod 1 eq and and {
                    msg 0 get encb
                    msg 1 get encb
                    /cset (setc) def
                    /mode 6 def
                    /i 2 def
                    exit
                } if
                % b . b . 2+ even nums => c sb2 encode
                setb msg 0 get known
                setb msg 1 get known and
                2 numsscr exch pop dup 2 ge exch 2 mod 0 eq and and {
                    msg 0 get encb
                    msg 1 get encb
                    /cset (setc) def
                    /mode 6 def
                    /i 2 def
                    exit
                } if
            } if
            % anotb before bnota => a
            0 abeforeb {
                /cset (seta) def
                /mode 0 def
                exit
            } if
            % otherwise => b
            /cset (setb) def
            /mode 1 def
            exit
        } loop

        {  % Encode remainder
            i msglen eq {exit} if
        
            i numsscr /nums exch def /nchars exch def
        
            % Determine switches and shifts
            {  % common exit
                cset (seta) eq {
                    % bnota . anotb before bnota => sb1 encode
                    i msglen 1 sub lt {
                        msg i get bnota
                        i 1 add abeforeb and {
                            sb1 enca
                            msg i get encb
                            /i i 1 add def
                            exit
                        } if
                    } if
                    % bnota . bnota . anotb before bnota => sb2 encode
                    i msglen 2 sub lt {
                        msg i get bnota
                        msg i 1 add get bnota and
                        i 2 add abeforeb and {
                            sb2 enca
                            msg i get encb
                            msg i 1 add get encb
                            /i i 2 add def
                            exit
                        } if
                    } if
                    % bnota => swb
                    msg i get bnota {
                        swb enca
                        /cset (setb) def
                        exit
                    } if
                    % 4 nums . a => sc2 encode
                    i msglen 4 sub lt {
                        nums 4 eq 
                        seta msg i 4 add get known and {
                            sc2 enca
                            2 {
                                msg i get fn1 eq {
                                    fn1 encc
                                    /i i 1 add def
                                } {
                                    msg i 2 getinterval encc
                                    /i i 2 add def 
                                } ifelse
                            } repeat
                            exit
                        } if
                    } if
                    % 6 nums . a => sc3 encode
                    i msglen 6 sub lt { 
                        nums 6 eq 
                        seta msg i 6 add get known and {
                            sc3 enca
                            3 {
                                msg i get fn1 eq {
                                    fn1 encc
                                    /i i 1 add def
                                } {
                                    msg i 2 getinterval encc
                                    /i i 2 add def
                                } ifelse
                            } repeat
                            exit
                        } if
                    } if
                    % 4+ even nums => swc
                    nums 4 ge nums 2 mod 0 eq and {
                        swc enca
                        /cset (setc) def
                        exit
                    } if
                    % otherwise => encode
                    msg i get enca
                    /i i 1 add def
                    exit
                } if
                cset (setb) eq {
                    % anotb . bnota before anotb => sa1 encode
                    i msglen 1 sub lt {
                        msg i get anotb
                        i 1 add bbeforea and {
                            sa1 encb
                            msg i get enca
                            /i i 1 add def
                            exit
                        } if
                    } if
                    % anotb . anotb . bnota before anotb => sa2 encode
                    i msglen 2 sub lt {
                        msg i get anotb 
                        msg i 1 add get anotb and
                        i 2 add bbeforea and {
                            sa2 encb
                            msg i get enca
                            msg i 1 add get enca
                            /i i 2 add def
                            exit
                        } if
                    } if
                    % anotb => swa
                    msg i get anotb {
                        swa encb
                        /cset (seta) def
                        exit
                    } if
                    % 4 nums . b => sc2 encode
                    i msglen 4 sub lt {
                        nums 4 eq
                        setb msg i 4 add get known and {
                            sc2 encb
                            2 {
                                msg i get fn1 eq {
                                    fn1 encc
                                    /i i 1 add def
                                } {
                                    msg i 2 getinterval encc
                                    /i i 2 add def
                                } ifelse
                            } repeat
                            exit
                        } if
                    } if
                    % 6 nums . b => sc3 encode
                    i msglen 6 sub lt {
                        nums 6 eq
                        setb msg i 6 add get known and {
                            sc3 encb
                            3 {
                                msg i get fn1 eq {
                                    fn1 encc
                                    /i i 1 add def
                                } {
                                    msg i 2 getinterval encc
                                    /i i 2 add def
                                } ifelse
                            } repeat
                            exit
                        } if
                    } if
                    % 4+ even nums => swc
                    nums 4 ge nums 2 mod 0 eq and {
                        swc encb
                        /cset (setc) def
                        exit
                    } if
                    % otherwise => encode
                    msg i get encb
                    /i i 1 add def
                    exit 
                } if
                cset (setc) eq {
                    % 2+ nums => encode
                    nums 2 ge {
                        msg i get fn1 eq {
                            fn1 encc
                            /i i 1 add def
                        } {
                            msg i 2 getinterval encc
                            /i i 2 add def
                        } ifelse
                        exit
                    } if
                    % b . 2+ even nums => sb1 encode
                    i msglen 1 sub lt {
                        setb msg i get known
                        i 1 add numsscr exch pop dup 2 ge exch 2 mod 0 eq and and {
                            sb1 encc
                            msg i get encb
                            /i i 1 add def
                            exit
                        } if
                    } if
                    % b . 3+ odd nums => sb2 encode
                    i msglen 1 sub lt {
                        setb msg i get known
                        i 1 add numsscr exch pop dup 3 ge exch 2 mod 1 eq and and {
                            sb2 encc
                            msg i get encb
                            msg i 1 add get encb
                            /i i 2 add def
                            exit
                        } if
                    } if
                    % b . b . 2+ even nums => sb2 encode
                    i msglen 2 sub lt {
                        setb msg i get known
                        setb msg i 1 add get known and
                        i 2 add numsscr exch pop dup 2 ge exch 2 mod 0 eq and and {
                            sb2 encc
                            msg i get encb
                            msg i 1 add get encb
                            /i i 2 add def
                            exit
                        } if
                    } if
                    % b . b . 3+ odd nums => sb3 encode
                    i msglen 3 sub lt {
                        setb msg i get known
                        setb msg i 1 add get known and
                        i 2 add numsscr exch pop dup 3 ge exch 2 mod 1 eq and and {
                            sb3 encc
                            msg i get encb
                            msg i 1 add get encb
                            msg i 2 add get encb
                            /i i 3 add def
                            exit
                        } if
                    } if
                    % b . b . b . 2+ even nums => sb3 encode
                    i msglen 3 sub lt {
                        setb msg i get known 
                        setb msg i 1 add get known and
                        setb msg i 2 add get known and
                        i 3 add numsscr exch pop dup 2 ge exch 2 mod 0 eq and and {
                            sb3 encc
                            msg i get encb
                            msg i 1 add get encb
                            msg i 2 add get encb
                            /i i 3 add def
                            exit 
                        } if
                    } if
                    % anotb before bnota => swa
                    i abeforeb {
                        swa encc
                        /cset (seta) def
                        exit
                    } if
                    % otherwise => swb
                    swb encc
                    /cset (setb) def
                    exit
                } if
                exit
            } loop
        
        } loop
        /cws cws 0 j getinterval def
    } if  % auto encoding
    
    % Basic metrics for the each symbol
    %     r  dcws 
    /metrics [
        [  2    7 ]
        [  3   12 ]
        [  4   17 ]
        [  5   22 ]
        [  6   27 ]
        [  7   32 ]
        [  8   37 ]
        [  9   42 ]
        [ 10   47 ]
        [ 11   52 ]
        [ 12   57 ]
        [ 13   62 ]
        [ 14   67 ]
        [ 15   72 ]
        [ 16   77 ]
    ] def

    % Select metrics of an appropriate symbol
    /urows rows def
    /i 0 def
    { % loop
        /m metrics i get def
        /r    m 0 get def        % Columns in symbol
        /dcws m 1 get def        % Data codewords in symbol
        /okay true def
        urows 0 ne urows r ne and {/okay false def} if
        cws length dcws gt {/okay false def} if
        okay {exit} if
        /i i 1 add def
    } loop

    % Extend cws to ncws codewords by addition of pad characters
    /cws [ cws aload pop dcws cws length sub {103} repeat ] def

    % Add the start character
    /cws [ r 2 sub 7 mul mode add cws aload pop ] def

    % Calculate the check characters
    0 0 1 dcws {dup 2 add exch cws exch get mul add} for 
    107 mod /c1 exch def
    0 0 1 dcws {dup 1 add exch cws exch get mul add} for 
    c1 dcws 2 add mul add 107 mod /c2 exch def
    /cws [ cws aload pop c1 c2 ] def

    % Create an array containing the character mappings
    /encs
    [ (212222) (222122) (222221) (121223) (121322) (131222) (122213)
      (122312) (132212) (221213) (221312) (231212) (112232) (122132)
      (122231) (113222) (123122) (123221) (223211) (221132) (221231)
      (213212) (223112) (312131) (311222) (321122) (321221) (312212)
      (322112) (322211) (212123) (212321) (232121) (111323) (131123)
      (131321) (112313) (132113) (132311) (211313) (231113) (231311)
      (112133) (112331) (132131) (113123) (113321) (133121) (313121)
      (211331) (231131) (213113) (213311) (213131) (311123) (311321)
      (331121) (312113) (312311) (332111) (314111) (221411) (431111)
      (111224) (111422) (121124) (121421) (141122) (141221) (112214)
      (112412) (122114) (122411) (142112) (142211) (241211) (221114)
      (413111) (241112) (134111) (111242) (121142) (121241) (114212)
      (124112) (124211) (411212) (421112) (421211) (212141) (214121)
      (412121) (111143) (111341) (131141) (114113) (114311) (411113)
      (411311) (113141) (114131) (311141) (411131) (211412) (211214)
      (211232) (211133)
    ] def

    % Start/stop character encodings
    /startencs [ 
        (3211) (2221) (2122) (1411) (1132) (1231) (1114) (3112)
        (3211) (2221) (2122) (1411) (1132) (1231) (1114) (3112)
    ] def
    /stopencsodd [
        (3211) (2221) (2122) (1411) (1132) (1231) (1114) (3112)
        (1132) (1231) (1114) (3112) (3211) (2221) (2122) (1411)
    ] def
    /stopencseven [
        (2122) (1411) (1132) (1231) (1114) (3112) (1132) (1231)
        (1114) (3112) (3211) (2221) (2122) (1411) (3211) (2221)
    ] def
    pos -1 eq pos 10 idiv 2 mod 1 eq or {
        /stopencs stopencsodd def
    } {
        /stopencs stopencseven def
    } ifelse
 
    % Derive the bits for each row
    /rowbits r array def
    0 1 r 1 sub {
        /i exch def
        /sbs [
            10
            startencs i get {48 sub} forall
            1
            cws i 5 mul 5 getinterval {
                encs exch get {48 sub} forall
            } forall 
            stopencs i get {48 sub} forall
            1
        ] def
        mark
        1 sbs {1 index 0 eq {{1}} {{0}} ifelse repeat} forall
        counttomark 1 sub array astore exch pop exch pop
        rowbits i 3 -1 roll put
    } for

    % Populate the bitmap
    /pixs [
        81 sepheight mul {1} repeat
        0 1 r 2 sub {
            /i exch def
            rowheight {rowbits i get aload pop} repeat
            sepheight {10 {0} repeat 70 {1} repeat 0} repeat
        } for
        rowheight {rowbits r 1 sub get aload pop} repeat
        81 sepheight mul {1} repeat
    ] def
    
    % Return the arguments
    <<
    /ren //renmatrix
    /pixs pixs
    /pixx 81
    /pixy pixs length 81 idiv
    /height pixs length 81 idiv 72 div
    /width 81 72 div
    /opt options
    >>

    dontdraw not //renmatrix if

    end

} bind def
/code16k dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER code16k--

% --BEGIN ENCODER code49--
% --DESC: Code 49
% --EXAM: MULTIPLE ROWS IN CODE 49
% --EXOP:
% --RNDR: renmatrix
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/code49 {

    20 dict begin

    /options exch def
    /barcode exch def

    /dontdraw false def
    /mode -1 def
    /pos -1 def
    /rows 0 def
    /rowheight 8 def
    /sepheight 1 def
    /parse false def
    /parsefnc false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /mode mode cvi def
    /pos pos cvi def
    /rows rows cvi def
    /rowheight rowheight cvi def
    /sepheight sepheight cvi def

    % Parse ordinals of the form ^NNN to ASCII
    parse {
        /msg barcode length string def
        /j 0 def
        barcode
        { % loop
            (^) search {
                dup msg exch j exch putinterval
                length j add 1 add /j exch def
                pop
                dup 0 3 getinterval cvi msg exch j 1 sub exch put
                dup length 3 sub 3 exch getinterval
            } {
                dup msg exch j exch putinterval
                length j add /j exch def
                /barcode msg 0 j getinterval def
                exit
            } ifelse 
        } loop
    } if

    /barlen barcode length def

    % Convert input into bytes accounting for FNC characters 
    /s1 -1 def /s2 -2 def /fn1 -3 def /fn2 -4 def /fn3 -5 def /ns -6 def
    /fncvals <<
        (FNC1) fn1
        (FNC2) fn2
        (FNC3) fn3
    >> def
    /msg barlen array def
    /i 0 def /j 0 def {
        i barlen eq {exit} if
        /char barcode i get def
        parsefnc char 94 eq and i barlen 4 sub lt and {
            barcode i 1 add get 94 ne {
                /char fncvals barcode i 1 add 4 getinterval get def
                /i i 4 add def
            } {
                /i i 1 add def
            } ifelse
        } if
        msg j char put
        /i i 1 add def
        /j j 1 add def
    } loop
    /msg msg 0 j getinterval def
    /msglen msg length def

    % Character encodings
    /charmap [
        (0) (1) (2) (3) (4) (5) (6) (7) (8) (9)
        (A) (B) (C) (D) (E) (F) (G) (H) (I) (J) (K) (L) (M)
        (N) (O) (P) (Q) (R) (S) (T) (U) (V) (W) (X) (Y) (Z)
        (-) (.) ( ) ($) (/) (+) (%)
        s1  s2  fn1 fn2 fn3 ns
    ] def

    % Invert charmap to give character to value map
    /charvals 49 dict def
    0 1 48 {
        /i exch def
        charmap i get 
        dup type /stringtype eq {0 get} if  % convert string to ASCII if required
        charvals exch i put 
    } for

    % Shifted character encodings
    /combos
    [ (1 ) (1A) (1B) (1C) (1D) (1E) (1F) (1G) (1H) (1I) (1J) (1K) (1L) (1M) (1N) (1O)
      (1P) (1Q) (1R) (1S) (1T) (1U) (1V) (1W) (1X) (1Y) (1Z) (11) (12) (13) (14) (15)
      (  ) (16) (17) (18) ( $) ( %) (19) (10) (1-) (1.) (1$) ( +) (1/) ( -) ( .) ( /)
      ( 0) ( 1) ( 2) ( 3) ( 4) ( 5) ( 6) ( 7) ( 8) ( 9) (1+) (21) (22) (23) (24) (25)
      (26) ( A) ( B) ( C) ( D) ( E) ( F) ( G) ( H) ( I) ( J) ( K) ( L) ( M) ( N) ( O)
      ( P) ( Q) ( R) ( S) ( T) ( U) ( V) ( W) ( X) ( Y) ( Z) (27) (28) (29) (20) (2-)
      (2.) (2A) (2B) (2C) (2D) (2E) (2F) (2G) (2H) (2I) (2J) (2K) (2L) (2M) (2N) (2O)
      (2P) (2Q) (2R) (2S) (2T) (2U) (2V) (2W) (2X) (2Y) (2Z) (2$) (2/) (2+) (2%) (2 )
    ] def
    0 1 127 {
        /i exch def
        combos i get dup 0 get /c1 exch def 1 get /c2 exch def
        c1 49 eq {  % s1 char
            charvals i [ charvals s1 get charvals c2 get ] put
        } if
        c1 50 eq {  % s2 char
            charvals i [ charvals s2 get charvals c2 get ] put
        } if
    } for

    /encodealpha {
        charvals exch get
        dup type /arraytype ne {1 array astore} if
        dup cws exch j exch putinterval
        length j add /j exch def
    } bind def

    /base48 {
        0 exch {48 sub exch 10 mul add} forall
        [ 3 1 roll exch 1 sub {dup 48 mod exch 48 idiv} repeat ]
        [ exch dup length 1 sub -1 0 {1 index exch get exch} for pop ]
        dup cws exch j exch putinterval
        length j add /j exch def
    } bind def

    /encodenumeric {
        /nums exch def
        /pre nums length dup 5 mod dup 2 ne {sub} {sub 5 sub} ifelse def
        0 5 pre 1 sub {nums exch 5 getinterval 3 exch base48} for
        /nums nums pre nums length pre sub getinterval def
        nums length
        dup 1 eq {nums i get encodealpha} if
        dup 3 eq {2 nums base48} if
        dup 4 eq {3 [49 48 nums aload pop] base48} if
        7 eq {
            3 [49 48 nums 0 4 getinterval aload pop] base48
            2 nums 4 3 getinterval base48
        } if
    } bind def

    % Pre-compute alphanumeric and numeric runlengths
    /numericruns [ msglen {0} repeat 0 ] def
    msglen 1 sub -1 0 {
        /i exch def
        msg i get
        dup 48 ge exch 57 le and {
            numericruns i numericruns i 1 add get 1 add put
        } {
            numericruns i 0 put
        } ifelse
    } for

    % Autoselect mode
    mode -1 eq {
        {  % common exit
            pos -1 ne {/mode 3 def exit} if
            numericruns 0 get 5 ge {/mode 2 def exit} if
            charvals msg 0 get get
            dup type /arraytype ne {pop /mode 0 def exit} if
            0 get 43 eq {4} {5} ifelse /mode exch def
            exit
        } loop
    } if

    /cws msglen 2 mul 1 add array def
    /method (alpha) def /i -1 def /j -1 def

    % Handle start for each mode
    mode 0 eq mode 1 eq or {/method (alpha) def /i 0 def /j 0 def} if 
    mode 2 eq {/method (numeric) def /i 0 def /j 0 def} if
    mode 3 eq {
        /posval [ 
            12 22
            13 23 33
            14 24 34 44
            15 25 35 45 55
            16 26 36 46 56 66
            17 27 37 47 57 67 77 
            18 28 38 48 58 68 78 88 
            19 29 39 49 59 69 79 89 99
        ] def
        cws 0 0 1 43 {dup posval exch get pos ne {pop} if} for 1 add put
        /method (alpha) def /i 0 def /j 1 def
    } if
    mode 4 eq mode 5 eq or {
        cws 0 charvals msg 0 get get 1 get put
        /method (alpha) def /i 1 def /j 1 def
    } if

    % Encode remainder
    {
        i msglen eq {exit} if
        {  % not a loop but common exit point
            method (alpha) eq {
                numericruns i get 5 ge {
                    ns encodealpha
                    /method (numeric) def
                    exit
                } if
                msg i get encodealpha
                /i i 1 add def
                exit
            } if
            method (numeric) eq {
                numericruns i get 5 lt {
                    ns encodealpha
                    /method (alpha) def
                    exit
                } if
                msg i numericruns i get getinterval encodenumeric
                /i i numericruns i get add def
                exit
            } if
        } loop
    } loop
    /cws cws 0 j getinterval def

    % Basic metrics for the each symbol
    %     r dcws 
    /metrics [
        [ 2    9 ]
        [ 3   16 ]
        [ 4   23 ]
        [ 5   30 ]
        [ 6   37 ]
        [ 7   42 ]
        [ 8   49 ]
    ] def

    % Select metrics of an appropriate symbol
    /urows rows def
    /i 0 def
    { % loop
        /m metrics i get def
        /r    m 0 get def        % Columns in symbol
        /dcws m 1 get def        % Data codewords in symbol
        /okay true def
        urows 0 ne urows r ne and {/okay false def} if
        cws length dcws gt {/okay false def} if
        okay {exit} if
        /i i 1 add def
    } loop

    % Extend cws to ncws codewords by addition of pad characters
    /cws [ cws aload pop dcws cws length sub {48} repeat ] def

    % Populate code character array and add row check characters
    /ccs r 8 mul array def
    /j 0 def
    0 1 r 2 sub {
        /i exch def
        /cc cws j 7 getinterval def
        ccs i 8 mul cc putinterval       
        ccs i 8 mul 7 add 0 cc {add} forall 49 mod put
        /j j 7 add def
    } for
    j dcws lt {
        ccs ccs length 8 sub cws j dcws j sub getinterval putinterval
    } if

    % Place row count character
    /cr7 r 2 sub 7 mul mode add def
    ccs ccs length 2 sub cr7 put

    % Calculate the symbol check characters
    [  1  9 31 26  2 12 17 23 37 18 22  6 27 44 15 43 39
      11 13  5 41 33 36  8  4 32  3 19 40 25 29 10 24 30 ]
    dup [ exch 20 exch 0 32 getinterval aload pop ] /weightx exch def
    dup [ exch 16 exch 1 32 getinterval aload pop ] /weighty exch def
        [ exch 38 exch 2 32 getinterval aload pop ] /weightz exch def
    /calccheck {
        /weights exch def
        /score 0 def
        0 1 r 1 sub 8 mul 2 idiv 1 sub {
            /i exch def
            ccs i 2 mul get 49 mul ccs i 2 mul 1 add get add 
            weights i 1 add get mul /score exch score add def
        } for
        score
    } bind def
    /lastrow ccs ccs length 8 sub 8 getinterval def

    % wr1 check character
    r 7 ge {
        cr7 weightz 0 get mul weightz calccheck add 2401 mod
        dup 49 idiv exch 49 mod 2 array astore
        lastrow 0 3 -1 roll putinterval
    } if
    /wr1 lastrow 0 get 49 mul lastrow 1 get add def

    % wr2 check character
    cr7 weighty 0 get mul weighty calccheck add 
    wr1 weighty r 4 mul 3 sub get mul add
    2401 mod dup /wr2 exch def
    dup 49 idiv exch 49 mod 2 array astore        
    lastrow 2 3 -1 roll putinterval

    % wr3 check character
    cr7 weightx 0 get mul weightx calccheck add
    wr1 weightx r 4 mul 3 sub get mul add
    wr2 weightx r 4 mul 2 sub get mul add
    2401 mod
    dup 49 idiv exch 49 mod 2 array astore        
    lastrow 4 3 -1 roll putinterval

    % Place last row check character
    ccs ccs length 8 sub 7 getinterval 0 exch {add} forall 49 mod
    ccs ccs length 1 sub 3 -1 roll put

    /patterns [
        [  % Even parity
            (11521132) (25112131) (14212132) (25121221) (14221222) (12412132) (23321221)
            (12421222) (21521221) (15112222) (15121312) (13312222) (24221311) (13321312)
            (11512222) (22421311) (11521312) (25112311) (14212312) (23312311) (12412312)
            (21512311) (16121131) (14321131) (12521131) (15212131) (15221221) (13412131)
            (13421221) (11612131) (16112221) (16121311) (14312221) (14321311) (12512221)
            (12521311) (15212311) (13412311) (11612311) (11131135) (31131133) (51131131)
            (21122134) (41122132) (21131224) (41131222) (11113135) (31113133) (51113131)
            (11122225) (31122223) (51122221) (11131315) (31131313) (51131311) (21113224)
            (41113222) (21122314) (41122312) (11113315) (31113313) (51113311) (12131134)
            (32131132) (21231133) (41231131) (22122133) (42122131) (11222134) (22131223)
            (42131221) (11231224) (31231222) (12113134) (32113132) (12122224) (32122222)
            (12131314) (32131312) (21231313) (41231311) (22113223) (42113221) (11213224)
            (22122313) (42122311) (11222314) (31222312) (12113314) (32113312) (21213313)
            (41213311) (13131133) (33131131) (22231132) (11331133) (31331131) (23122132)
            (12222133) (23131222) (12231223) (32231221) (21331222) (13113133) (33113131)
            (13122223) (33122221) (11313133) (13131313) (33131311) (11322223) (22231312)
            (11331313) (31331311) (23113222) (12213223) (23122312) (12222313) (32222311)
            (21322312) (13113313) (33113311) (22213312) (11313313) (31313311) (14131132)
            (23231131) (12331132) (21431131) (24122131) (13222132) (24131221) (13231222)
            (11422132) (22331221) (11431222) (14113132) (14122222) (12313132) (14131312)
            (12322222) (23231311) (12331312) (21431311) (24113221) (13213222) (24122311)
            (13222312) (11413222) (22322311) (11422312) (14113312) (23213311) (12313312)
            (21413311) (15131131) (13331131) (14222131) (14231221) (12422131) (12431221)
            (15113131) (15122221) (13313131) (15131311) (13322221) (11513131) (13331311)
            (11522221) (14213221) (14222311) (12413221) (12422311) (15113311) (13313311)
            (11513311) (11141134) (31141132) (21132133) (41132131) (21141223) (41141221)
            (11123134) (31123132) (11132224) (31132222) (11141314) (31141312) (21114133)
            (41114131) (21123223) (41123221) (21132313) (41132311) (11114224) (31114222)
            (11123314) (31123312) (21114313) (41114311) (12141133) (32141131) (21241132)
            (22132132) (11232133) (22141222) (11241223) (31241221) (12123133) (32123131)
            (12132223) (32132221) (12141313) (32141311) (21241312) (22114132) (11214133)
            (22123222) (11223223) (22132312) (11232313) (31232311) (12114223) (32114221)
            (12123313) (32123311) (21223312) (22114312) (11214313) (31214311) (13141132)
            (22241131) (11341132) (23132131) (12232132) (23141221) (12241222) (21341221)
            (13123132) (13132222) (11323132) (13141312) (11332222) (22241311) (11341312)
            (23114131) (12214132) (23123221) (12223222) (23132311) (12232312) (21332311)
            (13114222) (13123312) (11314222) (22223311) (11323312) (23114311) (12214312)
            (21314311) (14141131) (12341131) (13232131) (13241221) (11432131) (14123131)
            (14132221) (12323131) (14141311) (12332221) (12341311) (13214131) (13223221)
            (11414131) (13232311) (11423221) (11432311) (14114221) (14123311) (12314221)
            (12323311) (13214311) (11414311) (11151133) (31151131) (21142132) (21151222)
            (11133133) (31133131) (11142223) (31142221) (11151313) (31151311) (21124132)
            (21133222) (21142312) (11115133) (31115131) (11124223) (31124221) (11133313)
            (31133311) (21115222) (21124312) (12151132) (21251131) (22142131) (11242132)
            (22151221) (11251222) (12133132) (12142222) (12151312) (21251311) (22124131)
            (11224132) (22133221) (11233222) (22142311) (11242312) (12115132) (12124222)
            (12133312) (21233311) (22115221) (11215222) (22124311) (11224312) (13151131)
            (12242131) (12251221) (13133131) (13142221) (11333131) (13151311) (11342221)
            (12224131) (12233221) (12242311) (13115131) (13124221) (11315131) (13133311)
            (11324221) (11333311) (12215221) (12224311) (11161132) (21152131) (21161221)
            (11143132) (11152222) (11161312) (21134131) (21143221) (21152311) (11125132)
            (11134222) (11143312) (21116131) (21125221) (21134311) (12161131) (11252131)
            (12143131) (12152221) (12161311) (11234131) (11243221) (11252311) (12125131)
            (12134221) (12143311) (11216131) (11225221) (11234311) (11111236) (31111234)
            (51111232) (21111325) (41111323) (61111321) (11111416) (31111414) (51111412)
            (31211143) (51211141) (12111235) (32111233) (52111231) (21211234) (41211232)
            (22111324) (42111322) (11211325) (31211323) (51211321) (12111415) (32111413)
            (52111411) (21211414) (41211412) (12211144) (32211142) (21311143) (41311141)
            (13111234) (33111232) (22211233) (42211231) (11311234) (31311232) (23111323)
            (43111321) (12211324) (32211322) (21311323) (41311321) (13111414) (33111412)
            (22211413) (42211411) (11311414) (31311412) (13211143) (33211141) (22311142)
            (11411143) (31411141) (14111233) (34111231) (23211232) (12311233) (32311231)
            (21411232) (24111322) (13211323) (33211321) (22311322) (11411323) (31411321)
            (14111413) (34111411) (23211412) (12311413) (32311411) (21411412) (14211142)
            (23311141) (12411142) (21511141) (15111232) (24211231) (13311232) (22411231)
            (11511232) (25111321) (14211322) (23311321) (12411322) (21511321) (15111412)
            (24211411) (13311412) (22411411) (11511412) (15211141) (13411141) (11611141)
            (16111231) (14311231) (12511231) (15211321) (13411321) (11611321) (16111411)
            (14311411) (12511411) (21121144) (41121142) (11112145) (31112143) (51112141)
            (11121235) (31121233) (51121231) (21112234) (41112232) (21121324) (41121322)
            (11112325) (31112323) (51112321) (11121415) (31121413) (51121411) (21112414)
            (41112412) (22121143) (42121141) (11221144) (31221142) (12112144) (32112142)
            (12121234) (32121232) (21221233) (41221231) (22112233) (42112231) (11212234)
            (22121323) (42121321) (11221324) (31221322) (12112324) (32112322) (12121414)
            (32121412) (21221413) (41221411) (22112413) (42112411) (11212414) (31212412)
            (23121142) (12221143) (32221141) (21321142) (13112143) (33112141) (13121233)
            (33121231) (11312143) (22221232) (11321233) (31321231) (23112232) (12212233)
            (23121322) (12221323) (32221321) (21321322) (13112323) (33112321) (13121413)
            (33121411) (11312323) (22221412) (11321413) (31321411) (23112412) (12212413)
            (32212411) (21312412) (24121141) (13221142) (22321141) (11421142) (14112142)
            (14121232) (12312142) (23221231) (12321232) (21421231) (24112231) (13212232)
            (24121321) (13221322) (11412232) (22321321) (11421322) (14112322) (14121412)
            (12312322) (23221411) (12321412) (21421411) (24112411) (13212412) (22312411)
            (11412412) (14221141) (12421141) (15112141) (15121231) (13312141) (13321231)
            (11512141) (11521231) (14212231) (14221321) (12412231) (12421321) (15112321)
            (15121411) (13312321) (13321411) (11512321) (11521411) (14212411) (12412411)
            (21131143) (41131141) (11122144) (31122142) (11131234) (31131232) (21113143)
            (41113141) (21122233) (41122231) (21131323) (41131321) (11113234) (31113232)
            (11122324) (31122322) (11131414) (31131412) (21113323) (41113321) (21122413)
            (41122411) (11113414) (31113412) (22131142) (11231143) (31231141) (12122143)
            (32122141) (12131233) (32131231) (21231232) (22113142) (11213143) (22122232)
            (11222233) (22131322) (11231323) (31231321) (12113233) (32113231) (12122323)
            (32122321) (12131413) (32131411) (21231412) (22113322) (11213323) (22122412)
            (11222413) (31222411) (12113413) (32113411) (21213412) (23131141) (12231142)
            (21331141) (13122142) (13131232) (11322142) (22231231) (11331232) (23113141)
            (12213142) (23122231) (12222232) (23131321) (12231322) (21331321) (13113232)
            (13122322) (11313232) (13131412) (11322322) (22231411) (11331412) (23113321)
            (12213322) (23122411) (12222412) (21322411) (13113412) (22213411) (11313412)
            (13231141) (11431141) (14122141) (14131231) (12322141) (12331231) (13213141)
            (13222231) (11413141) (13231321) (11422231) (11431321) (14113231) (14122321)
            (12313231) (14131411) (12322321) (12331411) (13213321) (13222411) (11413321)
            (11422411) (14113411) (12313411) (21141142) (11132143) (31132141) (11141233)
            (31141231) (21123142) (21132232) (21141322) (11114143) (31114141) (11123233)
            (31123231) (11132323) (31132321) (11141413) (31141411) (21114232) (21123322)
            (21132412) (11114323) (31114321) (11123413) (31123411) (22141141) (11241142)
            (12132142) (12141232) (21241231) (22123141) (11223142) (22132231) (11232232)
            (22141321) (11241322) (12114142) (12123232) (12132322) (12141412) (21241411)
            (22114231) (11214232) (22123321) (11223322) (22132411) (11232412) (12114322)
            (12123412) (21223411) (12241141) (13132141) (13141231) (11332141) (11341231)
            (12223141) (12232231) (12241321) (13114141) (13123231) (11314141) (13132321)
            (11323231) (13141411) (11332321) (11341411) (12214231) (12223321) (12232411)
            (13114321) (13123411) (11314321) (11323411) (21151141) (11142142) (11151232)
            (21133141) (21142231) (21151321) (11124142) (11133232) (11142322) (11151412)
            (21115141) (21124231) (21133321) (21142411) (11115232) (11124322) (11133412)
            (11251141) (12142141) (12151231) (11233141) (11242231) (11251321) (12124141)
            (12133231) (12142321) (12151411) (11215141) (11224231) (11233321) (11242411)
            (12115231) (12124321) (12133411) (11152141) (11161231) (11134141) (11143231)
            (11152321) (11161411) (11116141) (11125231) (11134321) (11143411) (21111244)
            (41111242) (11111335) (31111333) (51111331) (21111424) (41111422) (11111515)
            (31111513) (51111511) (21211153) (41211151) (22111243) (42111241) (11211244)
            (31211242) (12111334) (32111332) (21211333) (41211331) (22111423) (42111421)
            (11211424) (31211422) (12111514) (32111512) (21211513) (41211511) (22211152)
            (11311153) (31311151) (23111242) (12211243) (32211241) (21311242) (13111333)
            (33111331) (22211332) (11311333) (31311331) (23111422) (12211423) (32211421)
            (21311422) (13111513) (33111511) (22211512) (11311513) (31311511) (23211151)
            (12311152) (21411151) (24111241) (13211242) (22311241) (11411242) (14111332)
            (23211331) (12311332) (21411331) (24111421) (13211422) (22311421) (11411422)
            (14111512) (23211511) (12311512) (21411511) (13311151) (11511151) (14211241)
            (12411241) (15111331) (13311331) (11511331) (14211421) (12411421) (15111511)
            (13311511) (11511511) (31121152) (21112153) (41112151) (21121243) (41121241)
            (11112244) (31112242) (11121334) (31121332) (21112333) (41112331) (21121423)
            (41121421) (11112424) (31112422) (11121514) (31121512) (21112513) (41112511)
            (12121153) (32121151) (21221152) (22112152) (11212153) (22121242) (11221243)
            (31221241) (12112243) (32112241) (12121333) (32121331) (21221332) (22112332)
            (11212333) (22121422) (11221423) (31221421) (12112423) (32112421) (12121513)
            (32121511) (21221512) (22112512) (11212513) (31212511) (13121152) (22221151)
            (11321152) (23112151) (12212152) (23121241) (12221242) (21321241) (13112242)
            (13121332) (11312242) (22221331) (11321332) (23112331) (12212332) (23121421)
            (12221422) (21321421) (13112422) (13121512) (11312422) (22221511) (11321512)
            (23112511) (12212512) (21312511) (14121151) (12321151) (13212151) (13221241)
            (11412151) (11421241) (14112241) (14121331) (12312241) (12321331) (13212331)
            (13221421) (11412331) (11421421) (14112421) (14121511) (12312421) (12321511)
            (13212511) (11412511) (11131153) (31131151) (21122152) (21131242) (11113153)
            (31113151) (11122243) (31122241) (11131333) (31131331) (21113242) (21122332)
            (21131422) (11113333) (31113331) (11122423) (31122421) (11131513) (31131511)
            (21113422) (21122512) (12131152) (21231151) (22122151) (11222152) (22131241)
            (11231242) (12113152) (12122242) (12131332) (21231331) (22113241) (11213242)
            (22122331) (11222332) (22131421) (11231422) (12113332) (12122422) (12131512)
            (21231511) (22113421) (11213422) (22122511) (11222512) (13131151) (11331151)
            (12222151) (12231241) (13113151) (13122241) (11313151) (13131331) (11322241)
            (11331331) (12213241) (12222331) (12231421) (13113331) (13122421) (11313331)
            (13131511) (11322421) (11331511) (12213421) (12222511) (11141152) (21132151)
            (21141241) (11123152) (11132242) (11141332) (21114151) (21123241) (21132331)
            (21141421) (11114242) (11123332) (11132422) (11141512) (21114331) (21123421)
            (21132511) (12141151) (11232151) (11241241) (12123151) (12132241) (12141331)
            (11214151) (11223241) (11232331) (11241421) (12114241) (12123331) (12132421)
            (12141511) (11214331) (11223421) (11232511) (11151151) (11133151) (11142241)
            (11151331) (11115151) (11124241) (11133331) (11142421) (11151511) (11111254)
            (31111252) (21111343) (41111341) (11111434) (31111432) (21111523) (41111521)
            (11111614) (31111612) (31211161) (12111253) (32111251) (21211252) (22111342)
            (11211343) (31211341) (12111433) (32111431) (21211432) (22111522) (11211523)
            (31211521) (12111613) (32111611) (21211612) (12211162) (21311161) (13111252)
            (22211251) (11311252) (23111341) (12211342) (21311341) (13111432) (22211431)
            (11311432) (23111521) (12211522) (21311521) (13111612) (22211611) (11311612)
            (13211161) (11411161) (14111251) (12311251) (13211341) (11411341) (14111431)
            (12311431) (13211521) (11411521) (14111611) (12311611) (21121162) (11112163)
            (31112161) (11121253) (31121251) (21112252) (21121342) (11112343) (31112341)
            (11121433) (31121431) (21112432) (21121522) (11112523) (31112521) (11121613)
            (31121611) (22121161) (11221162) (12112162) (12121252) (21221251) (22112251)
            (11212252) (22121341) (11221342) (12112342) (12121432) (21221431) (22112431)
            (11212432) (22121521) (11221522) (12112522) (12121612) (21221611) (12221161)
            (13112161) (13121251) (11312161) (11321251) (32121115) (52121113) (21221116)
            (41221114) (61221112) (22112116) (42112114) (31212115) (51212113) (13121116)
            (33121114) (22221115) (42221113) (11321116) (31321114) (51321112) (23112115)
            (43112113) (12212116) (32212114) (52212112) (21312115) (41312113) (61312111)
            (14121115) (34121113) (23221114) (43221112) (12321115) (32321113) (52321111)
            (21421114) (41421112) (24112114) (13212115) (33212113) (22312114) (42312112)
            (11412115) (31412113) (51412111) (15121114) (24221113) (13321114) (33321112)
            (22421113) (42421111) (11521114) (31521112) (25112113) (14212114) (34212112)
            (23312113) (43312111) (12412114) (32412112) (21512113) (41512111) (16121113)
            (25221112) (14321113) (34321111) (23421112) (12521113) (32521111) (15212113)
            (24312112) (13412113) (33412111) (22512112) (11612113) (31612111) (31131115)
            (51131113) (21122116) (41122114) (61122112) (31113115) (51113113) (12131116)
            (32131114) (52131112) (21231115) (41231113) (61231111) (22122115) (42122113)
            (11222116) (31222114) (51222112) (12113116) (32113114) (52113112) (21213115)
            (41213113) (61213111) (13131115) (33131113) (22231114) (42231112) (11331115)
            (31331113) (51331111) (23122114) (43122112) (12222115) (32222113) (52222111)
            (21322114) (41322112) (13113115) (33113113) (22213114) (42213112) (11313115)
            (31313113) (51313111) (14131114) (34131112) (23231113) (43231111) (12331114)
            (32331112) (21431113) (41431111) (24122113) (13222114) (33222112) (22322113)
            (42322111) (11422114) (31422112) (14113114) (34113112) (23213113) (43213111)
            (12313114) (32313112) (21413113) (41413111) (15131113) (24231112) (13331113)
            (33331111) (22431112) (25122112) (14222113) (34222111) (23322112) (12422113)
            (32422111) (21522112) (15113113) (24213112) (13313113) (33313111) (22413112)
            (11513113) (31513111) (16131112) (25231111) (14331112) (23431111) (15222112)
            (24322111) (13422112) (22522111) (16113112) (25213111) (14313112) (23413111)
            (12513112) (21613111) (11141116) (31141114) (51141112) (21132115) (41132113)
            (61132111) (11123116) (31123114) (51123112) (21114115) (41114113) (61114111)
            (12141115) (32141113) (52141111) (21241114) (41241112) (22132114) (42132112)
            (11232115) (31232113) (51232111) (12123115) (32123113) (52123111) (21223114)
            (41223112) (22114114) (42114112) (11214115) (31214113) (51214111) (13141114)
            (33141112) (22241113) (42241111) (11341114) (31341112) (23132113) (43132111)
            (12232114) (32232112) (21332113) (41332111) (13123114) (33123112) (22223113)
            (42223111) (11323114) (31323112) (23114113) (43114111) (12214114) (32214112)
            (21314113) (41314111) (14141113) (34141111) (23241112) (12341113) (32341111)
            (24132112) (13232113) (33232111) (22332112) (11432113) (31432111) (14123113)
            (34123111) (23223112) (12323113) (32323111) (21423112) (24114112) (13214113)
            (33214111) (22314112) (11414113) (31414111) (15141112) (24241111) (13341112)
            (25132111) (14232112) (23332111) (12432112) (15123112) (24223111) (13323112)
            (22423111) (11523112) (25114111) (14214112) (23314111) (12414112) (21514111)
            (16141111) (14341111) (15232111) (13432111) (16123111) (14323111) (12523111)
            (15214111) (13414111) (11614111) (11151115) (31151113) (51151111) (21142114)
            (41142112) (11133115) (31133113) (51133111) (21124114) (41124112) (11115115)
            (31115113) (51115111) (12151114) (32151112) (21251113) (41251111) (22142113)
            (42142111) (11242114) (31242112) (12133114) (32133112) (21233113) (41233111)
            (22124113) (42124111) (11224114) (31224112) (12115114) (32115112) (21215113)
            (41215111) (13151113) (33151111) (22251112) (23142112) (12242113) (32242111)
            (21342112) (13133113) (33133111) (22233112) (11333113) (31333111) (23124112)
            (12224113) (32224111) (21324112) (13115113) (33115111) (22215112) (11315113)
            (31315111) (14151112) (23251111) (24142111) (13242112) (22342111) (14133112)
            (23233111) (12333112) (21433111) (24124111) (13224112) (22324111) (11424112)
            (14115112) (23215111) (12315112) (21415111) (15151111) (14242111) (15133111)
            (13333111) (14224111) (12424111) (15115111) (13315111) (11515111) (11161114)
            (31161112) (21152113) (41152111) (11143114) (31143112) (21134113) (41134111)
            (11125114) (31125112) (21116113) (41116111) (12161113) (32161111) (22152112)
            (11252113) (31252111) (12143113) (32143111) (21243112) (22134112) (11234113)
            (31234111) (12125113) (32125111) (21225112) (22116112) (11216113) (31216111)
            (13161112) (23152111) (12252112) (13143112) (22243111) (11343112) (23134111)
            (12234112) (21334111) (13125112) (22225111) (11325112) (23116111) (12216112)
            (21316111) (14161111) (13252111) (14143111) (12343111) (13234111) (11434111)
            (14125111) (12325111) (13216111) (11416111) (31111216) (51111214) (31211125)
            (51211123) (32111215) (52111213) (21211216) (41211214) (61211212) (12211126)
            (32211124) (52211122) (21311125) (41311123) (61311121) (13111216) (33111214)
            (22211215) (42211213) (11311216) (31311214) (51311212) (13211125) (33211123)
            (22311124) (42311122) (11411125) (31411123) (51411121) (14111215) (34111213)
            (23211214) (43211212) (12311215) (32311213) (52311211) (21411214) (41411212)
            (14211124) (34211122) (23311123) (43311121) (12411124) (32411122) (21511123)
            (41511121) (15111214) (24211213) (13311214) (33311212) (22411213) (42411211)
            (11511214) (31511212) (15211123) (24311122) (13411123) (33411121) (22511122)
            (11611123) (31611121) (16111213) (25211212) (14311213) (34311211) (23411212)
            (12511213) (32511211) (21611212) (21121126) (41121124) (61121122) (31112125)
            (51112123) (31121215) (51121213) (21112216) (41112214) (61112212) (22121125)
            (42121123) (11221126) (31221124) (51221122) (12112126) (32112124) (52112122)
            (12121216) (32121214) (52121212) (21221215) (41221213) (61221211) (22112215)
            (42112213) (11212216) (31212214) (51212212) (23121124) (43121122) (12221125)
            (32221123) (52221121) (21321124) (41321122) (13112125) (33112123) (13121215)
            (33121213) (11312125) (22221214) (42221212) (11321215) (31321213) (51321211)
            (23112214) (43112212) (12212215) (32212213) (52212211) (21312214) (41312212)
            (24121123) (13221124) (33221122) (22321123) (42321121) (11421124) (31421122)
            (14112124) (34112122) (14121214) (34121212) (12312124) (23221213) (43221211)
            (12321214) (32321212) (21421213) (41421211) (24112213) (13212214) (33212212)
            (22312213) (42312211) (11412214) (31412212) (25121122) (14221123) (34221121)
            (23321122) (12421123) (32421121) (21521122) (15112123) (15121213) (13312123)
            (24221212) (13321213) (33321211) (11512123) (22421212) (11521213) (31521211)
            (25112212) (14212213) (34212211) (23312212) (12412213) (32412211) (21512212)
            (15221122) (24321121) (13421122) (22521121) (16112122) (16121212) (14312122)
            (25221211) (14321212) (12512122) (23421211) (12521212) (15212212) (24312211)
            (13412212) (22512211) (11612212) (21131125) (41131123) (61131121) (11122126)
            (31122124) (51122122) (11131216) (31131214) (51131212) (21113125) (41113123)
            (61113121) (21122215) (41122213) (61122211) (11113216) (31113214) (51113212)
            (22131124) (42131122) (11231125) (31231123) (51231121) (12122125) (32122123)
            (52122121) (12131215) (32131213) (52131211) (21231214) (41231212) (22113124)
            (42113122) (11213125) (22122214) (42122212) (11222215) (31222213) (51222211)
            (12113215) (32113213) (52113211) (21213214) (41213212) (23131123) (43131121)
            (12231124) (32231122) (21331123) (41331121) (13122124) (33122122) (13131214)
            (33131212) (11322124) (22231213) (42231211) (11331214) (31331212) (23113123)
            (43113121) (12213124) (23122213) (43122211) (12222214) (32222212) (21322213)
            (41322211) (13113214) (33113212) (22213213) (42213211) (11313214) (31313212)
            (24131122) (13231123) (33231121) (22331122) (11431123) (31431121) (14122123)
            (34122121) (14131213) (34131211) (12322123) (23231212) (12331213) (32331211)
            (21431212) (24113122) (13213123) (24122212) (13222213) (33222211) (11413123)
            (22322212) (11422213) (31422211) (14113213) (34113211) (23213212) (12313213)
            (32313211) (21413212) (25131121) (14231122) (23331121) (12431122) (15122122)
            (15131212) (13322122) (24231211) (13331212) (11522122) (22431211) (25113121)
            (14213122) (25122211) (14222212) (12413122) (23322211) (12422212) (21522211)
            (15113212) (24213211) (13313212) (22413211) (11513212) (15231121) (13431121)
            (16122121) (16131211) (14322121) (14331211) (12522121) (15213121) (15222211)
            (13413121) (13422211) (11613121) (16113211) (14313211) (12513211) (21141124)
            (41141122) (11132125) (31132123) (51132121) (11141215) (31141213) (51141211)
            (21123124) (41123122) (21132214) (41132212) (11114125) (31114123) (51114121)
            (11123215) (31123213) (51123211) (21114214) (41114212) (22141123) (42141121)
            (11241124) (31241122) (12132124) (32132122) (12141214) (32141212) (21241213)
            (41241211) (22123123) (42123121) (11223124) (22132213) (42132211) (11232214)
            (31232212) (12114124) (32114122) (12123214) (32123212) (21223213) (41223211)
            (22114213) (42114211) (11214214) (31214212) (23141122) (12241123) (32241121)
            (21341122) (13132123) (33132121) (13141213) (33141211) (11332123) (22241212)
            (11341213) (31341211) (23123122) (12223123) (23132212) (12232213) (32232211)
            (21332212) (13114123) (33114121) (13123213) (33123211) (11314123) (22223212)
            (11323213) (31323211) (23114212) (12214213) (32214211) (21314212) (24141121)
            (13241122) (22341121) (14132122) (14141212) (12332122) (23241211) (12341212)
            (24123121) (13223122) (24132211) (13232212) (11423122) (22332211) (11432212)
            (14114122) (14123212) (12314122) (23223211) (12323212) (21423211) (24114211)
            (13214212) (22314211) (11414212) (14241121) (15132121) (15141211) (13332121)
            (13341211) (14223121) (14232211) (12423121) (12432211) (15114121) (15123211)
            (13314121) (13323211) (11514121) (11523211) (14214211) (12414211) (21151123)
            (41151121) (11142124) (31142122) (11151214) (31151212) (21133123) (41133121)
            (21142213) (41142211) (11124124) (31124122) (11133214) (31133212) (21115123)
            (41115121) (21124213) (41124211) (11115214) (31115212) (22151122) (11251123)
            (31251121) (12142123) (32142121) (12151213) (32151211) (21251212) (22133122)
            (11233123) (22142212) (11242213) (31242211) (12124123) (32124121) (12133213)
            (32133211) (21233212) (22115122) (11215123) (22124212) (11224213) (31224211)
            (12115213) (32115211) (21215212) (23151121) (12251122) (13142122) (13151212)
            (11342122) (22251211) (23133121) (12233122) (23142211) (12242212) (21342211)
            (13124122) (13133212) (11324122) (22233211) (11333212) (23115121) (12215122)
            (23124211) (12224212) (21324211) (13115212) (22215211) (11315212) (13251121)
            (14142121) (14151211) (12342121) (13233121) (13242211) (11433121) (14124121)
            (14133211) (12324121) (12333211) (13215121) (13224211) (11415121) (11424211)
            (14115211) (12315211) (21161122) (11152123) (31152121) (11161213) (31161211)
            (21143122) (21152212) (11134123) (31134121) (11143213) (31143211) (21125122)
            (21134212) (11116123) (31116121) (11125213) (31125211) (22161121) (12152122)
            (12161212) (22143121) (11243122) (22152211) (11252212) (12134122) (12143212)
            (21243211) (22125121) (11225122) (22134211) (11234212) (12116122) (12125212)
            (21225211) (13152121) (13161211) (12243121) (12252211) (13134121) (13143211)
            (11334121) (11343211) (12225121) (12234211) (13116121) (13125211) (11316121)
            (11325211) (21111226) (41111224) (61111222) (31111315) (51111313) (21211135)
            (41211133) (61211131) (22111225) (42111223) (11211226) (31211224) (51211222)
            (12111316) (32111314) (52111312) (21211315) (41211313) (61211311) (22211134)
            (42211132) (11311135) (31311133) (51311131) (23111224) (43111222) (12211225)
            (32211223) (52211221) (21311224) (41311222) (13111315) (33111313) (22211314)
            (42211312) (11311315) (31311313) (51311311) (23211133) (43211131) (12311134)
            (32311132) (21411133) (41411131) (24111223) (13211224) (33211222) (22311223)
            (42311221) (11411224) (31411222) (14111314) (34111312) (23211313) (43211311)
            (12311314) (32311312) (21411313) (41411311) (24211132) (13311133) (33311131)
            (22411132) (11511133) (31511131) (25111222) (14211223) (34211221) (23311222)
            (12411223) (32411221) (21511222) (15111313) (24211312) (13311313) (33311311)
            (22411312) (11511313) (31511311) (25211131) (14311132) (23411131) (12511132)
            (21611131) (15211222) (24311221) (13411222) (22511221) (11611222) (16111312)
            (25211311) (14311312) (23411311) (12511312) (21611311) (31121134) (51121132)
            (21112135) (41112133) (61112131) (21121225) (41121223) (61121221) (11112226)
            (31112224) (51112222) (11121316) (31121314) (51121312) (21112315) (41112313)
            (61112311) (12121135) (32121133) (52121131) (21221134) (41221132) (22112134)
            (42112132) (11212135) (22121224) (42121222) (11221225) (31221223) (51221221)
            (12112225) (32112223) (52112221) (12121315) (32121313) (52121311) (21221314)
            (41221312) (22112314) (42112312) (11212315) (31212313) (51212311) (13121134)
            (33121132) (22221133) (42221131) (11321134) (31321132) (23112133) (43112131)
            (12212134) (23121223) (43121221) (12221224) (32221222) (21321223) (41321221)
            (13112224) (33112222) (13121314) (33121312) (11312224) (22221313) (42221311)
            (11321314) (31321312) (23112313) (43112311) (12212314) (32212312) (21312313)
            (41312311) (14121133) (34121131) (23221132) (12321133) (32321131) (21421132)
            (24112132) (13212133) (24121222) (13221223) (33221221) (11412133) (22321222)
            (11421223) (31421221) (14112223) (34112221) (14121313) (34121311) (12312223)
            (23221312) (12321313) (32321311) (21421312) (24112312) (13212313) (33212311)
            (22312312) (11412313) (31412311) (15121132) (24221131) (13321132) (22421131)
        ] [  % Odd parity
            (22121116) (42121114) (31221115) (51221113) (32112115) (52112113) (21212116)
            (41212114) (61212112) (23121115) (43121113) (12221116) (32221114) (52221112)
            (21321115) (41321113) (61321111) (13112116) (33112114) (22212115) (42212113)
            (11312116) (31312114) (51312112) (24121114) (13221115) (33221113) (22321114)
            (42321112) (11421115) (31421113) (51421111) (14112115) (34112113) (23212114)
            (43212112) (12312115) (32312113) (52312111) (21412114) (41412112) (25121113)
            (14221114) (34221112) (23321113) (43321111) (12421114) (32421112) (21521113)
            (41521111) (15112114) (24212113) (13312114) (33312112) (22412113) (42412111)
            (11512114) (31512112) (15221113) (24321112) (13421113) (33421111) (22521112)
            (16112113) (25212112) (14312113) (34312111) (23412112) (12512113) (32512111)
            (21612112) (21131116) (41131114) (61131112) (31122115) (51122113) (21113116)
            (41113114) (61113112) (22131115) (42131113) (11231116) (31231114) (51231112)
            (12122116) (32122114) (52122112) (21222115) (41222113) (61222111) (22113115)
            (42113113) (11213116) (31213114) (51213112) (23131114) (43131112) (12231115)
            (32231113) (52231111) (21331114) (41331112) (13122115) (33122113) (22222114)
            (42222112) (11322115) (31322113) (51322111) (23113114) (43113112) (12213115)
            (32213113) (52213111) (21313114) (41313112) (24131113) (13231114) (33231112)
            (22331113) (42331111) (11431114) (31431112) (14122114) (34122112) (23222113)
            (43222111) (12322114) (32322112) (21422113) (41422111) (24113113) (13213114)
            (33213112) (22313113) (42313111) (11413114) (31413112) (25131112) (14231113)
            (34231111) (23331112) (12431113) (32431111) (15122113) (24222112) (13322113)
            (33322111) (22422112) (11522113) (31522111) (25113112) (14213113) (34213111)
            (23313112) (12413113) (32413111) (21513112) (15231112) (24331111) (13431112)
            (16122112) (25222111) (14322112) (23422111) (12522112) (15213112) (24313111)
            (13413112) (22513111) (11613112) (21141115) (41141113) (61141111) (11132116)
            (31132114) (51132112) (21123115) (41123113) (61123111) (11114116) (31114114)
            (51114112) (22141114) (42141112) (11241115) (31241113) (51241111) (12132115)
            (32132113) (52132111) (21232114) (41232112) (22123114) (42123112) (11223115)
            (31223113) (51223111) (12114115) (32114113) (52114111) (21214114) (41214112)
            (23141113) (43141111) (12241114) (32241112) (21341113) (41341111) (13132114)
            (33132112) (22232113) (42232111) (11332114) (31332112) (23123113) (43123111)
            (12223114) (32223112) (21323113) (41323111) (13114114) (33114112) (22214113)
            (42214111) (11314114) (31314112) (24141112) (13241113) (33241111) (22341112)
            (14132113) (34132111) (23232112) (12332113) (32332111) (21432112) (24123112)
            (13223113) (33223111) (22323112) (11423113) (31423111) (14114113) (34114111)
            (23214112) (12314113) (32314111) (21414112) (25141111) (14241112) (23341111)
            (15132112) (24232111) (13332112) (22432111) (25123111) (14223112) (23323111)
            (12423112) (21523111) (15114112) (24214111) (13314112) (22414111) (11514112)
            (15241111) (16132111) (14332111) (15223111) (13423111) (16114111) (14314111)
            (12514111) (21151114) (41151112) (11142115) (31142113) (51142111) (21133114)
            (41133112) (11124115) (31124113) (51124111) (21115114) (41115112) (22151113)
            (42151111) (11251114) (31251112) (12142114) (32142112) (21242113) (41242111)
            (22133113) (42133111) (11233114) (31233112) (12124114) (32124112) (21224113)
            (41224111) (22115113) (42115111) (11215114) (31215112) (23151112) (12251113)
            (32251111) (13142113) (33142111) (22242112) (11342113) (31342111) (23133112)
            (12233113) (32233111) (21333112) (13124113) (33124111) (22224112) (11324113)
            (31324111) (23115112) (12215113) (32215111) (21315112) (24151111) (13251112)
            (14142112) (23242111) (12342112) (24133111) (13233112) (22333111) (11433112)
            (14124112) (23224111) (12324112) (21424111) (24115111) (13215112) (22315111)
            (11415112) (14251111) (15142111) (13342111) (14233111) (12433111) (15124111)
            (13324111) (11524111) (14215111) (12415111) (21161113) (41161111) (11152114)
            (31152112) (21143113) (41143111) (11134114) (31134112) (21125113) (41125111)
            (11116114) (31116112) (22161112) (12152113) (32152111) (21252112) (22143112)
            (11243113) (31243111) (12134113) (32134111) (21234112) (22125112) (11225113)
            (31225111) (12116113) (32116111) (21216112) (23161111) (13152112) (22252111)
            (23143111) (12243112) (21343111) (13134112) (22234111) (11334112) (23125111)
            (12225112) (21325111) (13116112) (22216111) (11316112) (14152111) (13243111)
            (14134111) (12334111) (13225111) (11425111) (14116111) (12316111) (41111215)
            (61111213) (21211126) (41211124) (61211122) (22111216) (42111214) (31211215)
            (51211213) (22211125) (42211123) (11311126) (31311124) (51311122) (23111215)
            (43111213) (12211216) (32211214) (52211212) (21311215) (41311213) (61311211)
            (23211124) (43211122) (12311125) (32311123) (52311121) (21411124) (41411122)
            (24111214) (13211215) (33211213) (22311214) (42311212) (11411215) (31411213)
            (51411211) (24211123) (13311124) (33311122) (22411123) (42411121) (11511124)
            (31511122) (25111213) (14211214) (34211212) (23311213) (43311211) (12411214)
            (32411212) (21511213) (41511211) (25211122) (14311123) (34311121) (23411122)
            (12511123) (32511121) (21611122) (15211213) (24311212) (13411213) (33411211)
            (22511212) (11611213) (31611211) (31121125) (51121123) (21112126) (41112124)
            (61112122) (21121216) (41121214) (61121212) (31112215) (51112213) (12121126)
            (32121124) (52121122) (21221125) (41221123) (61221121) (22112125) (42112123)
            (11212126) (22121215) (42121213) (11221216) (31221214) (51221212) (12112216)
            (32112214) (52112212) (21212215) (41212213) (61212211) (13121125) (33121123)
            (22221124) (42221122) (11321125) (31321123) (51321121) (23112124) (43112122)
            (12212125) (23121214) (43121212) (12221215) (32221213) (52221211) (21321214)
            (41321212) (13112215) (33112213) (22212214) (42212212) (11312215) (31312213)
            (51312211) (14121124) (34121122) (23221123) (43221121) (12321124) (32321122)
            (21421123) (41421121) (24112123) (13212124) (24121213) (13221214) (33221212)
            (11412124) (22321213) (42321211) (11421214) (31421212) (14112214) (34112212)
            (23212213) (43212211) (12312214) (32312212) (21412213) (41412211) (15121123)
            (24221122) (13321123) (33321121) (22421122) (11521123) (31521121) (25112122)
            (14212123) (25121212) (14221213) (34221211) (12412123) (23321212) (12421213)
            (32421211) (21521212) (15112213) (24212212) (13312213) (33312211) (22412212)
            (11512213) (31512211) (16121122) (25221121) (14321122) (23421121) (12521122)
            (15212122) (15221212) (13412122) (24321211) (13421212) (11612122) (22521211)
            (16112212) (25212211) (14312212) (23412211) (12512212) (21612211) (11131126)
            (31131124) (51131122) (21122125) (41122123) (61122121) (21131215) (41131213)
            (61131211) (11113126) (31113124) (51113122) (11122216) (31122214) (51122212)
            (21113215) (41113213) (61113211) (12131125) (32131123) (52131121) (21231124)
            (41231122) (22122124) (42122122) (11222125) (22131214) (42131212) (11231215)
            (31231213) (51231211) (12113125) (32113123) (52113121) (12122215) (32122213)
            (52122211) (21222214) (41222212) (22113214) (42113212) (11213215) (31213213)
            (51213211) (13131124) (33131122) (22231123) (42231121) (11331124) (31331122)
            (23122123) (43122121) (12222124) (23131213) (43131211) (12231214) (32231212)
            (21331213) (41331211) (13113124) (33113122) (13122214) (33122212) (11313124)
            (22222213) (42222211) (11322214) (31322212) (23113213) (43113211) (12213214)
            (32213212) (21313213) (41313211) (14131123) (34131121) (23231122) (12331123)
            (32331121) (21431122) (24122122) (13222123) (24131212) (13231213) (33231211)
            (11422123) (22331212) (11431213) (31431211) (14113123) (34113121) (14122213)
            (34122211) (12313123) (23222212) (12322213) (32322211) (21422212) (24113212)
            (13213213) (33213211) (22313212) (11413213) (31413211) (15131122) (24231121)
            (13331122) (22431121) (25122121) (14222122) (25131211) (14231212) (12422122)
            (23331211) (12431212) (15113122) (15122212) (13313122) (24222211) (13322212)
            (11513122) (22422211) (11522212) (25113211) (14213212) (23313211) (12413212)
            (21513211) (16131121) (14331121) (15222121) (15231211) (13422121) (13431211)
            (16113121) (16122211) (14313121) (14322211) (12513121) (12522211) (15213211)
            (13413211) (11613211) (11141125) (31141123) (51141121) (21132124) (41132122)
            (21141214) (41141212) (11123125) (31123123) (51123121) (11132215) (31132213)
            (51132211) (21114124) (41114122) (21123214) (41123212) (11114215) (31114213)
            (51114211) (12141124) (32141122) (21241123) (41241121) (22132123) (42132121)
            (11232124) (22141213) (42141211) (11241214) (31241212) (12123124) (32123122)
            (12132214) (32132212) (21232213) (41232211) (22114123) (42114121) (11214124)
            (22123213) (42123211) (11223214) (31223212) (12114214) (32114212) (21214213)
            (41214211) (13141123) (33141121) (22241122) (11341123) (31341121) (23132122)
            (12232123) (23141212) (12241213) (32241211) (21341212) (13123123) (33123121)
            (13132213) (33132211) (11323123) (22232212) (11332213) (31332211) (23114122)
            (12214123) (23123212) (12223213) (32223211) (21323212) (13114213) (33114211)
            (22214212) (11314213) (31314211) (14141122) (23241121) (12341122) (24132121)
            (13232122) (24141211) (13241212) (11432122) (22341211) (14123122) (14132212)
            (12323122) (23232211) (12332212) (21432211) (24114121) (13214122) (24123211)
            (13223212) (11414122) (22323211) (11423212) (14114212) (23214211) (12314212)
            (21414211) (15141121) (13341121) (14232121) (14241211) (12432121) (15123121)
            (15132211) (13323121) (13332211) (11523121) (14214121) (14223211) (12414121)
            (12423211) (15114211) (13314211) (11514211) (11151124) (31151122) (21142123)
            (41142121) (21151213) (41151211) (11133124) (31133122) (11142214) (31142212)
            (21124123) (41124121) (21133213) (41133211) (11115124) (31115122) (11124214)
            (31124212) (21115213) (41115211) (12151123) (32151121) (21251122) (22142122)
            (11242123) (22151212) (11251213) (31251211) (12133123) (32133121) (12142213)
            (32142211) (21242212) (22124122) (11224123) (22133212) (11233213) (31233211)
            (12115123) (32115121) (12124213) (32124211) (21224212) (22115212) (11215213)
            (31215211) (13151122) (22251121) (23142121) (12242122) (23151211) (12251212)
            (13133122) (13142212) (11333122) (22242211) (11342212) (23124121) (12224122)
            (23133211) (12233212) (21333211) (13115122) (13124212) (11315122) (22224211)
            (11324212) (23115211) (12215212) (21315211) (14151121) (13242121) (13251211)
            (14133121) (14142211) (12333121) (12342211) (13224121) (13233211) (11424121)
            (11433211) (14115121) (14124211) (12315121) (12324211) (13215211) (11415211)
            (11161123) (31161121) (21152122) (21161212) (11143123) (31143121) (11152213)
            (31152211) (21134122) (21143212) (11125123) (31125121) (11134213) (31134211)
            (21116122) (21125212) (12161122) (22152121) (11252122) (22161211) (12143122)
            (12152212) (21252211) (22134121) (11234122) (22143211) (11243212) (12125122)
            (12134212) (21234211) (22116121) (11216122) (22125211) (11225212) (13161121)
            (12252121) (13143121) (13152211) (11343121) (12234121) (12243211) (13125121)
            (13134211) (11325121) (11334211) (12216121) (12225211) (31111225) (51111223)
            (21111316) (41111314) (61111312) (31211134) (51211132) (12111226) (32111224)
            (52111222) (21211225) (41211223) (61211221) (22111315) (42111313) (11211316)
            (31211314) (51211312) (12211135) (32211133) (52211131) (21311134) (41311132)
            (13111225) (33111223) (22211224) (42211222) (11311225) (31311223) (51311221)
            (23111314) (43111312) (12211315) (32211313) (52211311) (21311314) (41311312)
            (13211134) (33211132) (22311133) (42311131) (11411134) (31411132) (14111224)
            (34111222) (23211223) (43211221) (12311224) (32311222) (21411223) (41411221)
            (24111313) (13211314) (33211312) (22311313) (42311311) (11411314) (31411312)
            (14211133) (34211131) (23311132) (12411133) (32411131) (21511132) (15111223)
            (24211222) (13311223) (33311221) (22411222) (11511223) (31511221) (25111312)
            (14211313) (34211311) (23311312) (12411313) (32411311) (21511312) (15211132)
            (24311131) (13411132) (22511131) (11611132) (16111222) (25211221) (14311222)
            (23411221) (12511222) (21611221) (15211312) (24311311) (13411312) (22511311)
            (11611312) (21121135) (41121133) (61121131) (11112136) (31112134) (51112132)
            (11121226) (31121224) (51121222) (21112225) (41112223) (61112221) (21121315)
            (41121313) (61121311) (11112316) (31112314) (51112312) (22121134) (42121132)
            (11221135) (31221133) (51221131) (12112135) (32112133) (52112131) (12121225)
            (32121223) (52121221) (21221224) (41221222) (22112224) (42112222) (11212225)
            (22121314) (42121312) (11221315) (31221313) (51221311) (12112315) (32112313)
            (52112311) (21212314) (41212312) (23121133) (43121131) (12221134) (32221132)
            (21321133) (41321131) (13112134) (33112132) (13121224) (33121222) (11312134)
            (22221223) (42221221) (11321224) (31321222) (23112223) (43112221) (12212224)
            (23121313) (43121311) (12221314) (32221312) (21321313) (41321311) (13112314)
            (33112312) (22212313) (42212311) (11312314) (31312312) (24121132) (13221133)
            (33221131) (22321132) (11421133) (31421131) (14112133) (34112131) (14121223)
            (34121221) (12312133) (23221222) (12321223) (32321221) (21421222) (24112222)
            (13212223) (24121312) (13221313) (33221311) (11412223) (22321312) (11421313)
            (31421311) (14112313) (34112311) (23212312) (12312313) (32312311) (21412312)
            (25121131) (14221132) (23321131) (12421132) (21521131) (15112132) (15121222)
            (13312132) (24221221) (13321222) (11512132) (22421221) (11521222) (25112221)
            (14212222) (25121311) (14221312) (12412222) (23321311) (12421312) (21521311)
            (15112312) (24212311) (13312312) (22412311) (11512312) (15221131) (13421131)
            (16112131) (16121221) (14312131) (14321221) (12512131) (12521221) (15212221)
            (15221311) (13412221) (13421311) (11612221) (16112311) (14312311) (12512311)
            (21131134) (41131132) (11122135) (31122133) (51122131) (11131225) (31131223)
            (51131221) (21113134) (41113132) (21122224) (41122222) (21131314) (41131312)
            (11113225) (31113223) (51113221) (11122315) (31122313) (51122311) (21113314)
            (41113312) (22131133) (42131131) (11231134) (31231132) (12122134) (32122132)
            (12131224) (32131222) (21231223) (41231221) (22113133) (42113131) (11213134)
            (22122223) (42122221) (11222224) (22131313) (42131311) (11231314) (31231312)
            (12113224) (32113222) (12122314) (32122312) (21222313) (41222311) (22113313)
            (42113311) (11213314) (31213312) (23131132) (12231133) (32231131) (21331132)
            (13122133) (33122131) (13131223) (33131221) (11322133) (22231222) (11331223)
            (31331221) (23113132) (12213133) (23122222) (12222223) (23131312) (12231313)
            (32231311) (21331312) (13113223) (33113221) (13122313) (33122311) (11313223)
            (22222312) (11322313) (31322311) (23113312) (12213313) (32213311) (21313312)
            (24131131) (13231132) (22331131) (11431132) (14122132) (14131222) (12322132)
            (23231221) (12331222) (21431221) (24113131) (13213132) (24122221) (13222222)
            (24131311) (11413132) (13231312) (11422222) (22331311) (11431312) (14113222)
            (14122312) (12313222) (23222311) (12322312) (21422311) (24113311) (13213312)
            (22313311) (11413312) (14231131) (12431131) (15122131) (15131221) (13322131)
            (13331221) (11522131) (14213131) (14222221) (12413131) (14231311) (12422221)
            (12431311) (15113221) (15122311) (13313221) (13322311) (11513221) (11522311)
            (14213311) (12413311) (21141133) (41141131) (11132134) (31132132) (11141224)
            (31141222) (21123133) (41123131) (21132223) (41132221) (21141313) (41141311)
            (11114134) (31114132) (11123224) (31123222) (11132314) (31132312) (21114223)
            (41114221) (21123313) (41123311) (11114314) (31114312) (22141132) (11241133)
            (31241131) (12132133) (32132131) (12141223) (32141221) (21241222) (22123132)
            (11223133) (22132222) (11232223) (22141312) (11241313) (31241311) (12114133)
            (32114131) (12123223) (32123221) (12132313) (32132311) (21232312) (22114222)
            (11214223) (22123312) (11223313) (31223311) (12114313) (32114311) (21214312)
            (23141131) (12241132) (21341131) (13132132) (13141222) (11332132) (22241221)
            (11341222) (23123131) (12223132) (23132221) (12232222) (23141311) (12241312)
            (21341311) (13114132) (13123222) (11314132) (13132312) (11323222) (22232311)
            (11332312) (23114221) (12214222) (23123311) (12223312) (21323311) (13114312)
            (22214311) (11314312) (13241131) (14132131) (14141221) (12332131) (12341221)
            (13223131) (13232221) (11423131) (13241311) (11432221) (14114131) (14123221)
            (12314131) (14132311) (12323221) (12332311) (13214221) (13223311) (11414221)
            (11423311) (14114311) (12314311) (21151132) (11142133) (31142131) (11151223)
            (31151221) (21133132) (21142222) (21151312) (11124133) (31124131) (11133223)
            (31133221) (11142313) (31142311) (21115132) (21124222) (21133312) (11115223)
            (31115221) (11124313) (31124311) (22151131) (11251132) (12142132) (12151222)
            (21251221) (22133131) (11233132) (22142221) (11242222) (22151311) (11251312)
            (12124132) (12133222) (12142312) (21242311) (22115131) (11215132) (22124221)
            (11224222) (22133311) (11233312) (12115222) (12124312) (21224311) (12251131)
            (13142131) (13151221) (11342131) (12233131) (12242221) (12251311) (13124131)
            (13133221) (11324131) (13142311) (11333221) (11342311) (12215131) (12224221)
            (12233311) (13115221) (13124311) (11315221) (11324311) (21161131) (11152132)
            (11161222) (21143131) (21152221) (21161311) (11134132) (11143222) (11152312)
            (21125131) (21134221) (21143311) (11116132) (11125222) (11134312) (12152131)
            (12161221) (11243131) (11252221) (12134131) (12143221) (12152311) (11225131)
            (11234221) (11243311) (12116131) (12125221) (12134311) (21111235) (41111233)
            (61111231) (11111326) (31111324) (51111322) (21111415) (41111413) (61111411)
            (21211144) (41211142) (22111234) (42111232) (11211235) (31211233) (51211231)
            (12111325) (32111323) (52111321) (21211324) (41211322) (22111414) (42111412)
            (11211415) (31211413) (51211411) (22211143) (42211141) (11311144) (31311142)
            (23111233) (43111231) (12211234) (32211232) (21311233) (41311231) (13111324)
            (33111322) (22211323) (42211321) (11311324) (31311322) (23111413) (43111411)
            (12211414) (32211412) (21311413) (41311411) (23211142) (12311143) (32311141)
            (21411142) (24111232) (13211233) (33211231) (22311232) (11411233) (31411231)
            (14111323) (34111321) (23211322) (12311323) (32311321) (21411322) (24111412)
            (13211413) (33211411) (22311412) (11411413) (31411411) (24211141) (13311142)
            (22411141) (11511142) (25111231) (14211232) (23311231) (12411232) (21511231)
            (15111322) (24211321) (13311322) (22411321) (11511322) (25111411) (14211412)
            (23311411) (12411412) (21511411) (14311141) (12511141) (15211231) (13411231)
            (11611231) (16111321) (14311321) (12511321) (15211411) (13411411) (11611411)
            (31121143) (51121141) (21112144) (41112142) (21121234) (41121232) (11112235)
            (31112233) (51112231) (11121325) (31121323) (51121321) (21112324) (41112322)
            (21121414) (41121412) (11112415) (31112413) (51112411) (12121144) (32121142)
            (21221143) (41221141) (22112143) (42112141) (11212144) (22121233) (42121231)
            (11221234) (31221232) (12112234) (32112232) (12121324) (32121322) (21221323)
            (41221321) (22112323) (42112321) (11212324) (22121413) (42121411) (11221414)
            (31221412) (12112414) (32112412) (21212413) (41212411) (13121143) (33121141)
            (22221142) (11321143) (31321141) (23112142) (12212143) (23121232) (12221233)
            (32221231) (21321232) (13112233) (33112231) (13121323) (33121321) (11312233)
            (22221322) (11321323) (31321321) (23112322) (12212323) (23121412) (12221413)
            (32221411) (21321412) (13112413) (33112411) (22212412) (11312413) (31312411)
            (14121142) (23221141) (12321142) (21421141) (24112141) (13212142) (24121231)
            (13221232) (11412142) (22321231) (11421232) (14112232) (14121322) (12312232)
            (23221321) (12321322) (21421321) (24112321) (13212322) (24121411) (13221412)
            (11412322) (22321411) (11421412) (14112412) (23212411) (12312412) (21412411)
            (15121141) (13321141) (11521141) (14212141) (14221231) (12412141) (12421231)
            (15112231) (15121321) (13312231) (13321321) (11512231) (11521321) (14212321)
            (14221411) (12412321) (12421411) (15112411) (13312411) (11512411) (11131144)
            (31131142) (21122143) (41122141) (21131233) (41131231) (11113144) (31113142)
            (11122234) (31122232) (11131324) (31131322) (21113233) (41113231) (21122323)
            (41122321) (21131413) (41131411) (11113324) (31113322) (11122414) (31122412)
            (21113413) (41113411) (12131143) (32131141) (21231142) (22122142) (11222143)
            (22131232) (11231233) (31231231) (12113143) (32113141) (12122233) (32122231)
            (12131323) (32131321) (21231322) (22113232) (11213233) (22122322) (11222323)
            (22131412) (11231413) (31231411) (12113323) (32113321) (12122413) (32122411)
            (21222412) (22113412) (11213413) (31213411) (13131142) (22231141) (11331142)
            (23122141) (12222142) (23131231) (12231232) (21331231) (13113142) (13122232)
            (11313142) (13131322) (11322232) (22231321) (11331322) (23113231) (12213232)
            (23122321) (12222322) (23131411) (12231412) (21331411) (13113322) (13122412)
            (11313322) (22222411) (11322412) (23113411) (12213412) (21313411) (14131141)
            (12331141) (13222141) (13231231) (11422141) (11431231) (14113141) (14122231)
            (12313141) (14131321) (12322231) (12331321) (13213231) (13222321) (11413231)
            (13231411) (11422321) (11431411) (14113321) (14122411) (12313321) (12322411)
            (13213411) (11413411) (11141143) (31141141) (21132142) (21141232) (11123143)
            (31123141) (11132233) (31132231) (11141323) (31141321) (21114142) (21123232)
            (21132322) (21141412) (11114233) (31114231) (11123323) (31123321) (11132413)
            (31132411) (21114322) (21123412) (12141142) (21241141) (22132141) (11232142)
            (22141231) (11241232) (12123142) (12132232) (12141322) (21241321) (22114141)
            (11214142) (22123231) (11223232) (22132321) (11232322) (22141411) (11241412)
            (12114232) (12123322) (12132412) (21232411) (22114321) (11214322) (22123411)
            (11223412) (13141141) (11341141) (12232141) (12241231) (13123141) (13132231)
            (11323141) (13141321) (11332231) (11341321) (12214141) (12223231) (12232321)
            (12241411) (13114231) (13123321) (11314231) (13132411) (11323321) (11332411)
            (12214321) (12223411) (11151142) (21142141) (21151231) (11133142) (11142232)
            (11151322) (21124141) (21133231) (21142321) (21151411) (11115142) (11124232)
            (11133322) (11142412) (21115231) (21124321) (21133411) (12151141) (11242141)
            (11251231) (12133141) (12142231) (12151321) (11224141) (11233231) (11242321)
            (11251411) (12115141) (12124231) (12133321) (12142411) (11215231) (11224321)
            (11233411) (11161141) (11143141) (11152231) (11161321) (11125141) (11134231)
            (11143321) (11152411) (11111245) (31111243) (51111241) (21111334) (41111332)
            (11111425) (31111423) (51111421) (21111514) (41111512) (31211152) (12111244)
            (32111242) (21211243) (41211241) (22111333) (42111331) (11211334) (31211332)
            (12111424) (32111422) (21211423) (41211421) (22111513) (42111511) (11211514)
            (31211512) (12211153) (32211151) (21311152) (13111243) (33111241) (22211242)
            (11311243) (31311241) (23111332) (12211333) (32211331) (21311332) (13111423)
            (33111421) (22211422) (11311423) (31311421) (23111512) (12211513) (32211511)
            (21311512) (13211152) (22311151) (11411152) (14111242) (23211241) (12311242)
            (21411241) (24111331) (13211332) (22311331) (11411332) (14111422) (23211421)
            (12311422) (21411421) (24111511) (13211512) (22311511) (11411512) (14211151)
            (12411151) (15111241) (13311241) (11511241) (14211331) (12411331) (15111421)
            (13311421) (11511421) (14211511) (12411511) (21121153) (41121151) (11112154)
            (31112152) (11121244) (31121242) (21112243) (41112241) (21121333) (41121331)
            (11112334) (31112332) (11121424) (31121422) (21112423) (41112421) (21121513)
            (41121511) (11112514) (31112512) (22121152) (11221153) (31221151) (12112153)
            (32112151) (12121243) (32121241) (21221242) (22112242) (11212243) (22121332)
            (11221333) (31221331) (12112333) (32112331) (12121423) (32121421) (21221422)
            (22112422) (11212423) (22121512) (11221513) (31221511) (12112513) (32112511)
            (21212512) (23121151) (12221152) (21321151) (13112152) (13121242) (11312152)
            (22221241) (11321242) (23112241) (12212242) (23121331) (12221332) (21321331)
            (13112332) (13121422) (11312332) (22221421) (11321422) (23112421) (12212422)
            (23121511) (12221512) (21321511) (13112512) (22212511) (11312512) (13221151)
            (11421151) (14112151) (14121241) (12312151) (12321241) (13212241) (13221331)
            (11412241) (11421331) (14112331) (14121421) (12312331) (12321421) (13212421)
            (13221511) (11412421) (11421511) (14112511) (12312511) (21131152) (11122153)
            (31122151) (11131243) (31131241) (21113152) (21122242) (21131332) (11113243)
            (31113241) (11122333) (31122331) (11131423) (31131421) (21113332) (21122422)
            (21131512) (11113423) (31113421) (11122513) (31122511) (22131151) (11231152)
            (12122152) (12131242) (21231241) (22113151) (11213152) (22122241) (11222242)
            (22131331) (11231332) (12113242) (12122332) (12131422) (21231421) (22113331)
            (11213332) (22122421) (11222422) (22131511) (11231512) (12113422) (12122512)
            (21222511) (12231151) (13122151) (13131241) (11322151) (11331241) (12213151)
            (12222241) (12231331) (13113241) (13122331) (11313241) (13131421) (11322331)
            (11331421) (12213331) (12222421) (12231511) (13113421) (13122511) (11313421)
            (11322511) (21141151) (11132152) (11141242) (21123151) (21132241) (21141331)
            (11114152) (11123242) (11132332) (11141422) (21114241) (21123331) (21132421)
            (21141511) (11114332) (11123422) (11132512) (11241151) (12132151) (12141241)
            (11223151) (11232241) (11241331) (12114151) (12123241) (12132331) (12141421)
            (11214241) (11223331) (11232421) (11241511) (12114331) (12123421) (12132511)
            (11142151) (11151241) (11124151) (11133241) (11142331) (11151421) (11115241)
            (11124331) (11133421) (11142511) (21111253) (41111251) (11111344) (31111342)
            (21111433) (41111431) (11111524) (31111522) (21111613) (41111611) (21211162)
            (22111252) (11211253) (31211251) (12111343) (32111341) (21211342) (22111432)
            (11211433) (31211431) (12111523) (32111521) (21211522) (22111612) (11211613)
            (31211611) (22211161) (11311162) (23111251) (12211252) (21311251) (13111342)
            (22211341) (11311342) (23111431) (12211432) (21311431) (13111522) (22211521)
            (11311522) (23111611) (12211612) (21311611) (12311161) (13211251) (11411251)
            (14111341) (12311341) (13211431) (11411431) (14111521) (12311521) (13211611)
            (11411611) (31121161) (21112162) (21121252) (11112253) (31112251) (11121343)
            (31121341) (21112342) (21121432) (11112433) (31112431) (11121523) (31121521)
            (21112522) (21121612) (12121162) (21221161) (22112161) (11212162) (22121251)
            (11221252) (12112252) (12121342) (21221341) (22112341) (11212342) (22121431)
            (11221432) (12112432) (12121522) (21221521) (22112521) (11212522) (22121611)
            (11221612) (13121161) (11321161) (12212161) (12221251) (13112251) (13121341)
            (11312251) (11321341) (12212341) (12221431) (13112431) (13121521) (11312431)
            (11321521) (12212521) (12221611) (11131162) (21122161) (21131251) (11113162)
        ]
    ] def

    /parity [
        (1001) (0101) (1100) (0011) (1010) (0110) (1111) (0000)
    ] def

    % Derive the bits for each row
    /rowbits r array def
    0 1 r 1 sub {
        /i exch def
        /p i r 1 sub ne {parity i get} {(0000)} ifelse def
        /ccrow ccs i 8 mul 8 getinterval def
        /scrow [
            0 2 7 {ccrow exch 2 getinterval aload pop exch 49 mul add} for
        ] def
        /sbs [
            10 1 1
            0 1 3 {
                /j exch def
                patterns p j get 48 sub get scrow j get get {48 sub} forall
            } for
            4 1
        ] def
        mark
        1 sbs {1 index 0 eq {{1}} {{0}} ifelse repeat} forall
        counttomark 1 sub array astore exch pop exch pop
        rowbits i 3 -1 roll put
    } for

    % Populate the bitmap
    /pixs [
        81 sepheight mul {1} repeat
        0 1 r 2 sub {
            /i exch def
            rowheight {rowbits i get aload pop} repeat
            sepheight {10 {0} repeat 70 {1} repeat 0} repeat
        } for
        rowheight {rowbits r 1 sub get aload pop} repeat
        81 sepheight mul {1} repeat
    ] def

    % Return the arguments
    <<
    /ren //renmatrix
    /pixs pixs
    /pixx 81
    /pixy pixs length 81 idiv
    /height pixs length 81 idiv 72 div
    /width 81 72 div
    /opt options
    >>

    dontdraw not //renmatrix if

    end

} bind def
/code49 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER code49--

% --BEGIN ENCODER channelcode--
% --DESC: Channel Code
% --EXAM: 3493
% --EXOP: height=0.5 includetext 
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/channelcode {

    20 dict begin                 % Confine variables to local scope

    /options exch def       % We are given an option string
    /barcode exch def       % We are given a barcode string

    /dontdraw false def
    /shortfinder false def
    /includetext false def
    /includecheck false def
    /height 1 def
    
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /height height cvr def
  
    /barlen barcode length def

    barlen 2 ge barlen 7 le and {
        /channels barlen 1 add def
    } if

    % Determine finder
    shortfinder {
        /finder [ 1 1 1 1 1 ] def
    } {
        /finder [ 1 1 1 1 1 1 1 1 1 ] def
    } ifelse

    /nextb {
        dup
        dup s exch get exch
        dup b exch 1 sub get exch
        dup s exch 1 sub get exch
        b exch 2 sub get exch
        add add add 4 gt {1} {2} ifelse
        1 index chan 2 add lt {
            dup 1 4 index {
                b 3 index 2 index put
                3 index exch sub 1 add 4 index 3 index 1 add nexts
            } for
        } {
            dup 3 index le {
                b 2 index 4 index put
                value target eq {
                    /out [ 
                        3 1 10 {dup s exch get exch b exch get} for
                    ] 0 chan 2 mul getinterval def 
                } if
                /value value 1 add def
            } if
        } ifelse 
        pop pop pop pop
    } bind def

    /nexts {
        dup chan 2 add lt {1} {1 index} ifelse 1 3 index {
            s 2 index 2 index put
            2 index exch sub 1 add 3 index 2 index nextb
        } for
        pop pop pop
    } bind def

    /encode {
        /chan exch def
        /target exch def
        /value 0 def
        /out -1 def
        /b [ 1 1 1 0 0 0 0 0 0 0 0 ] def
        /s [ 0 1 1 0 0 0 0 0 0 0 0 ] def
        chan dup 3 nexts
        out
    } bind def

    % Encode the main data
    /data barcode cvi channels encode def

    % Determine check data
    /check [] def
    includecheck {
        /mod23 [
            [] [] []
            [ 13 12  4  9  3  1 ]
            [ 13  2 12  3 18 16  4  1 ]
            [ 11 16 17  8 20  4 10  2  5  1 ]
            [  1  4 16 18  3 12  2  8  9 13  6  1 ]
            [ 20 16 22 13 15 12  5  4  8  9 21  3  7  1 ]
            [  2  6 18  8  1  3  9  4 12 13 16  2  6 18  8  1 ]
        ] channels get def
        0
        0 1 data length 1 sub {
            dup data exch get 1 sub exch mod23 exch get mul add
        } for
        23 mod 3 encode /check exch def
    } if

    % Construct the symbol
    /sbs [
        finder aload pop
        data aload pop
        check aload pop
    ] def

    % Create the human readable text
    /txt barlen array def
    0 1 barlen 1 sub {
        /i exch def
        txt i [barcode i 1 getinterval 0 0 () 0] put
    } for

    % Return the arguments
    <<
    /ren //renlinear
    /sbs sbs
    /bhs [sbs length 1 add 2 idiv {height} repeat]
    /bbs [sbs length 1 add 2 idiv {0} repeat]
    /txt txt
    /textxalign (center)
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/channelcode dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER channelcode--

% --BEGIN ENCODER flattermarken--
% --DESC: Flattermarken
% --EXAM: 12345
% --EXOP: inkspread=-0.25
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/flattermarken {

    20 dict begin                 % Confine variable to local scope

    /options exch def       % We are given an option string
    /barcode exch def       % We are given a barcode string

    /dontdraw false def
    /includetext false def   % Enable/disable text
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /height 0.3 def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def

    % Create an array containing the character mappings
    /encs
    [ (0018) (0117) (0216) (0315) (0414) (0513) (0612) (0711) (0810)
      (0900)
    ] def

    % Create a string of the available characters
    /barchars (1234567890) def

    /barlen barcode length def            % Length of the code

    /sbs barlen 4 mul string def
    /txt barlen array def

    0 1 barlen 1 sub {
        /i exch def
        % Lookup the encoding for the each barcode character
        barcode i 1 getinterval barchars exch search
        pop                                 % Discard true leaving pre
        length /indx exch def               % indx is the length of pre
        pop pop                             % Discard seek and post
        /enc encs indx get def              % Get the indxth encoding
        sbs i 4 mul enc putinterval         % Put encoded digit into sbs
        txt i [barcode i 1 getinterval i 9 mul textyoffset textfont textsize] put
    } for

    % Return the arguments
    <<
    /ren //renlinear
    /sbs [sbs {48 sub} forall]
    /bhs [sbs length 1 add 2 idiv {height} repeat]
    /bbs [sbs length 1 add 2 idiv {0} repeat]
    /txt txt
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/flattermarken dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER flattermarken--

% --BEGIN ENCODER raw--
% --DESC: Raw bar space succession for custom symbologies 
% --EXAM: 331132131313411122131311333213114131131221323
% --EXOP: height=0.5
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/raw {

    20 dict begin                  % Confine variables to local scope

    /options exch def        % We are given an option string
    /sbs exch def        % We are given a barcode string

    /dontdraw false def
    /height 1 def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /height height cvr def

    % Return the arguments
    <<
    /ren //renlinear
    /sbs [sbs {48 sub} forall]
    /bhs [sbs length 1 add 2 idiv {height} repeat]
    /bbs [sbs length 1 add 2 idiv {0} repeat]
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/raw dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER raw--

% --BEGIN ENCODER daft--
% --DESC: Raw DAFT succession for custom 4 state symbologies
% --EXAM: FATDAFTDAD
% --EXOP:
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/daft {

    20 dict begin

    /options exch def              % We are given an option string
    /barcode exch def              % We are given a barcode string

    /dontdraw false def
    /height 0.175 def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /height height cvr def

    /barlen barcode length def

    /bbs barlen array def
    /bhs barlen array def
    0 1 barlen 1 sub {
        /i exch def
        /enc barcode i 1 getinterval def
        enc (D) eq {
            bbs i 0 height mul 8 div put
            bhs i 5 height mul 8 div put
        } if
        enc (A) eq {
            bbs i 3 height mul 8 div put
            bhs i 5 height mul 8 div put
        } if
        enc (F) eq {
            bbs i 0 height mul 8 div put
            bhs i 8 height mul 8 div put
        } if
        enc (T) eq {
            bbs i 3 height mul 8 div put
            bhs i 2 height mul 8 div put
        } if
    } for

    % Return the arguments
    <<
    /ren //renlinear
    /bbs bbs
    /bhs bhs
    /sbs [bhs length 1 sub {1.44 1.872} repeat 1.44]
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/daft dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER daft--

% --BEGIN ENCODER symbol--
% --DESC: Miscellaneous symbols
% --EXAM: fima
% --EXOP: backgroundcolor=DD000011
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/symbol {

    20 dict begin            % Confine variables to local scope

    /options exch def  % We are given an option string
    /barcode exch def  % We are given a barcode string

    /dontdraw false def

    barcode (fima) eq {
        /sbs [2.25 2.25 2.25 11.25 2.25 11.25 2.25 2.25 2.25] def
        /bhs [.625 .625 .625 .625 .625] def
        /bbs [0 0 0 0 0] def
    } if

    barcode (fimb) eq {
        /sbs [2.25 6.75 2.25 2.25 2.25 6.25 2.25 2.25 2.25 6.75 2.25] def
        /bhs [.625 .625 .625 .625 .625 .625] def
        /bbs [0 0 0 0 0 0] def
    } if

    barcode (fimc) eq {
        /sbs [2.25 2.25 2.25 6.75 2.25 6.75 2.25 6.75 2.25 2.25 2.25] def
        /bhs [.625 .625 .625 .625 .625 .625] def
        /bbs [0 0 0 0 0 0] def
    } if
    
    barcode (fimd) eq {
        /sbs [2.25 2.25 2.25 2.25 2.25 6.75 2.25 6.75 2.25 2.25 2.25 2.25 2.25] def
        /bhs [.625 .625 .625 .625 .625 .625 .625] def
        /bbs [0 0 0 0 0 0 0] def
    } if
    
    % Return the arguments
    <<
    /ren //renlinear
    /sbs sbs
    /bhs bhs
    /bbs bbs
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/symbol dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER symbol--

% --BEGIN ENCODER pdf417--
% --DESC: PDF417
% --EXAM: This is PDF417
% --EXOP:
% --RNDR: renmatrix
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/pdf417 {

    20 dict begin

    /options exch def
    /barcode exch def

    /dontdraw false def
    /compact false def
    /eclevel -1 def
    /columns 0 def
    /rows 0 def
    /rowmult 3 def
    /ccc false def
    /raw false def
    /parse false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /eclevel eclevel cvi def
    /columns columns cvi def
    /rows rows cvi def
    /rowmult rowmult cvr def

    % Parse ordinals of the form ^NNN to ASCII
    parse {
        /msg barcode length string def
        /j 0 def
        barcode
        { % loop
            (^) search {
                dup msg exch j exch putinterval
                length j add 1 add /j exch def
                pop
                dup 0 3 getinterval cvi msg exch j 1 sub exch put
                dup length 3 sub 3 exch getinterval
            } {
                dup msg exch j exch putinterval
                length j add /j exch def
                /barcode msg 0 j getinterval def
                exit
            } ifelse 
        } loop
    } if

    % Convert input into array of codewords
    raw {
        /datcws barcode length array def
        /i 0 def /j 0 def
        { % loop
            i barcode length eq {exit} if
            /cw barcode i 1 add 3 getinterval cvi def
            datcws j cw put
            /i i 4 add def
            /j j 1 add def
        } loop
        /datcws datcws 0 j getinterval def
    } {  % Simple autoencoder from input to codewords using byte mode
        /barlen barcode length def
        barlen 6 mod 0 eq {
            /datcws barlen 6 idiv 5 mul 1 add array def
            datcws 0 924 put
        } {
            /datcws barlen 6 idiv 5 mul barlen 6 mod add 1 add array def
            datcws 0 901 put 
        } ifelse

        % Rebase groups of 6 bytes splitting into 3 byte chunks
        0 1 barlen 6 idiv 1 sub {
            /i exch def
            /msbs [ barcode i 6 mul 3 getinterval {} forall ] def
            /mscs [
                msbs aload pop exch 256 mul add exch 65536 mul add 
                3 {dup 900 mod exch 900 idiv} repeat 
            ] def
            /lsbs [barcode i 6 mul 3 add 3 getinterval {} forall] def
            /lscs [
                lsbs aload pop exch 256 mul add exch 65536 mul add
                3 {dup 900 mod exch 900 idiv} repeat
            ] def
            /cws 5 array def
            lscs 0 get mscs 0 get 316 mul add
            cws 4 2 index 900 mod put
            900 idiv lscs 1 get add mscs 0 get 641 mul add mscs 1 get 316 mul add
            cws 3 2 index 900 mod put 
            900 idiv lscs 2 get add mscs 0 get 20 mul add mscs 1 get 641 mul add mscs 2 get 316 mul add 
            cws 2 2 index 900 mod put
            900 idiv lscs 3 get add mscs 1 get 20 mul add mscs 2 get 641 mul add
            cws 1 2 index 900 mod put
            900 idiv mscs 2 get 20 mul add
            cws 0 3 -1 roll 900 mod put
            datcws i 5 mul 1 add cws putinterval 
        } for

        % Add the remaining bytes to the end of the codewords
        /rem barlen 6 mod def
        rem 0 ne {
            datcws datcws length rem sub 
            [ barcode barlen rem sub rem getinterval {} forall ] 
            putinterval
        } if

        ccc {/datcws [920 datcws aload pop] def} if

    } ifelse

    % Determine the error correction level if unspecified
    /m datcws length def
    eclevel -1 eq {
        m  40 le              {/eclevel 2 def} if
        m  41 ge m 160 le and {/eclevel 3 def} if
        m 161 ge m 320 le and {/eclevel 4 def} if
        m 321 ge              {/eclevel 5 def} if
    } if

    % Reduce the error level so that it does not cause an excessive number of codewords
    /maxeclevel 928 1 sub m sub ln 2 ln div cvi 1 sub def
    eclevel maxeclevel gt {/eclevel maxeclevel def} if
    /k 2 eclevel 1 add exp cvi def

    % To determine size of matrix, number of columns if given by user...
    columns 0 eq {/columns m k add 3 div sqrt round cvi def} if
    columns 1 ge columns 30 le and {/c columns def} if

    % ... and rows is greater of those required and that given by user within limits
    /r m k add 1 add columns div ceiling cvi def  % Required
    r rows lt rows 90 le and {/r rows def} if
    r 3 lt {/r 3 def} if

    % Opportunistically raise the error level if a better fit to the matrix is possible
    /maxeclevel c r mul 1 sub m sub ln 2 ln div cvi 1 sub 8 2 copy gt {exch} if pop def
    maxeclevel eclevel gt {
      /eclevel maxeclevel def
      /k 2 eclevel 1 add exp cvi def
    } if

    % Create codewords array with one extra working space element and add padding
    /n c r mul k sub def
    /cws c r mul 1 add array def
    cws 0 n put
    cws 1 datcws putinterval
    cws m 1 add [ n m sub 1 sub {900} repeat ] putinterval
    cws n [ k {0} repeat 0 ] putinterval

    % Calculate the log and anti-log tables
    /rsalog [ 1 928 {dup 3 mul 929 mod} repeat ] def
    /rslog 929 array def
    1 1 928 {dup rsalog exch get exch rslog 3 1 roll put} for

    % Function to calculate the product in the field
    /rsprod {
        2 copy 0 ne exch 0 ne and {
            rslog exch get exch rslog exch get add 928 mod rsalog exch get
        } {
            pop pop 0
        } ifelse
    } bind def

    % Generate the coefficients
    /coeffs [ 1 k {0} repeat ] def
    1 1 k {
        /i exch def 
        coeffs i coeffs i 1 sub get put
        i 1 sub -1 1 {
            /j exch def
            coeffs j coeffs j 1 sub get coeffs j get rsalog i get rsprod add 929 mod put
        } for 
        coeffs 0 coeffs 0 get rsalog i get rsprod put
    } for
    /coeffs coeffs 0 coeffs length 1 sub getinterval def
    coeffs length 1 sub -2 0 {coeffs exch 2 copy get 929 exch sub put} for

    % Derive the error codewords
    0 1 n 1 sub {
        /t exch cws exch get cws n get add 929 mod def
        0 1 k 1 sub {
            /j exch def
            cws n j add cws n j add 1 add get 929 t coeffs k j sub 1 sub get mul 929 mod sub add 929 mod put
        } for
    } for
    n 1 n k add { dup cws exch 929 cws 5 -1 roll get sub 929 mod put } for

    % Trim the working space from the end of the codewords
    /cws cws 0 cws length 1 sub getinterval def

    % Base 10 encoding of the bar space successions for the codewords in each cluster
    /clusters [
        [
            120256 125680 128380 120032 125560 128318 108736 119920 108640  86080 108592  86048
            110016 120560 125820 109792 120440 125758  88256 109680  88160  89536 110320 120700
             89312 110200 120638  89200 110140  89840 110460  89720 110398  89980 128506 119520
            125304 128190 107712 119408 125244 107616 119352  84032 107568 119324  84000 107544
             83984 108256 119672 125374  85184 108144 119612  85088 108088 119582  85040 108060
             85728 108408 119742  85616 108348  85560 108318  85880 108478  85820  85790 107200
            119152 125116 107104 119096 125086  83008 107056 119068  82976 107032  82960  82952
             83648 107376 119228  83552 107320 119198  83504 107292  83480  83468  83824 107452
             83768 107422  83740  83900 106848 118968 125022  82496 106800 118940  82464 106776
            118926  82448 106764  82440 106758  82784 106936 119006  82736 106908  82712 106894
             82700  82694 106974  82830  82240 106672 118876  82208 106648 118862  82192 106636
             82184 106630  82180  82352  82328  82316  82080 118830 106572 106566  82050 117472
            124280 127678 103616 117360 124220 103520 117304 124190  75840 103472  75808 104160
            117624 124350  76992 104048 117564  76896 103992  76848  76824  77536 104312 117694
             77424 104252  77368  77340  77688 104382  77628  77758 121536 126320 128700 121440
            126264 128670 111680 121392 126236 111648 121368 126222 111632 121356 103104 117104
            124092 112320 103008 117048 124062 112224 121656 126366  93248  74784 102936 117006
             93216 112152  93200  75456 103280 117180  93888  75360 103224 117150  93792 112440
            121758  93744  75288  93720  75632 103356  94064  75576 103326  94008 112542  93980
             75708  94140  75678  94110 121184 126136 128606 111168 121136 126108 111136 121112
            126094 111120 121100 111112 111108 102752 116920 123998 111456 102704 116892  91712
             74272 121244 116878  91680  74256 102668  91664 111372 102662  74244  74592 102840
            116958  92000  74544 102812  91952 111516 102798  91928  74508  74502  74680 102878
             92088  74652  92060  74638  92046  92126 110912 121008 126044 110880 120984 126030
            110864 120972 110856 120966 110852 110850  74048 102576 116828  90944  74016 102552
            116814  90912 111000 121038  90896  73992 102534  90888 110982  90884  74160 102620
             91056  74136 102606  91032 111054  91020  74118  91014  91100  91086 110752 120920
            125998 110736 120908 110728 120902 110724 110722  73888 102488 116782  90528  73872
            102476  90512 110796 102470  90504  73860  90500  73858  73944  90584  90572  90566
            120876 120870 110658 102444  73800  90312  90308  90306 101056 116080 123580 100960
            116024  70720 100912 115996  70688 100888  70672  70664  71360 101232 116156  71264
            101176 116126  71216 101148  71192  71180  71536 101308  71480 101278  71452  71612
             71582 118112 124600 127838 105024 118064 124572 104992 118040 124558 104976 118028
            104968 118022 100704 115896 123486 105312 100656 115868  79424  70176 118172 115854
             79392 105240 100620  79376  70152  79368  70496 100792 115934  79712  70448 118238
             79664 105372 100750  79640  70412  79628  70584 100830  79800  70556  79772  70542
             70622  79838 122176 126640 128860 122144 126616 128846 122128 126604 122120 126598
            122116 104768 117936 124508 113472 104736 126684 124494 113440 122264 126670 113424
            104712 117894 113416 122246 104706  69952 100528 115804  78656  69920 100504 115790
             96064  78624 104856 117966  96032 113560 122318 100486  96016  78600 104838  96008
             69890  70064 100572  78768  70040 100558  96176  78744 104910  96152 113614  70022
             78726  70108  78812  70094  96220  78798 122016 126552 128814 122000 126540 121992
            126534 121988 121986 104608 117848 124462 113056 104592 126574 113040 122060 117830
            113032 104580 113028 104578 113026  69792 100440 115758  78240  69776 100428  95136
             78224 104652 100422  95120 113100  69764  95112  78212  69762  78210  69848 100462
             78296  69836  95192  78284  69830  95180  78278  69870  95214 121936 126508 121928
            126502 121924 121922 104528 117804 112848 104520 117798 112840 121958 112836 104514
            112834  69712 100396  78032  69704 100390  94672  78024 104550  94664 112870  69698
             94660  78018  94658  78060  94700  94694 126486 121890 117782 104484 104482  69672
             77928  94440  69666  77922  99680  68160  99632  68128  99608 115342  68112  99596
             68104  99590  68448  99768 115422  68400  99740  68376  99726  68364  68358  68536
             99806  68508  68494  68574 101696 116400 123740 101664 116376 101648 116364 101640
            116358 101636  67904  99504 115292  72512  67872 116444 115278  72480 101784 116430
             72464  67848  99462  72456 101766  67842  68016  99548  72624  67992  99534  72600
            101838  72588  67974  68060  72668  68046  72654 118432 124760 127918 118416 124748
            118408 124742 118404 118402 101536 116312 105888 101520 116300 105872 118476 116294
            105864 101508 105860 101506 105858  67744  99416  72096  67728 116334  80800  72080
            101580  99398  80784 105932  67716  80776  72068  67714  72066  67800  99438  72152
             67788  80856  72140  67782  80844  72134  67822  72174  80878 126800 128940 126792
            128934 126788 126786 118352 124716 122576 126828 124710 122568 126822 122564 118338
            122562 101456 116268 105680 101448 116262 114128 105672 118374 114120 122598 101442
            114116 105666 114114  67664  99372  71888  67656  99366  80336  71880 101478  97232
             80328 105702  67650  97224 114150  71874  97220  67692  71916  67686  80364  71910
             97260  80358  97254 126760 128918 126756 126754 118312 124694 122472 126774 122468
            118306 122466 101416 116246 105576 101412 113896 105572 101410 113892 105570 113890
             67624  99350  71784 101430  80104  71780  67618  96744  80100  71778  96740  80098
             96738  71798  96758 126738 122420 122418 105524 113780 113778  71732  79988  96500
             96498  66880  66848  98968  66832  66824  66820  66992  66968  66956  66950  67036
             67022 100000  99984 115532  99976 115526  99972  99970  66720  98904  69024 100056
             98892  69008 100044  69000 100038  68996  66690  68994  66776  98926  69080 100078
             69068  66758  69062  66798  69102 116560 116552 116548 116546  99920 102096 116588
            115494 102088 116582 102084  99906 102082  66640  68816  66632  98854  73168  68808
             66628  73160  68804  66626  73156  68802  66668  68844  66662  73196  68838  73190
            124840 124836 124834 116520 118632 124854 118628 116514 118626  99880 115478 101992
            116534 106216 101988  99874 106212 101986 106210  66600  98838  68712  99894  72936
             68708  66594  81384  72932  68706  81380  72930  66614  68726  72950  81398 128980
            128978 124820 126900 124818 126898 116500 118580 116498 122740 118578 122738  99860
            101940  99858 106100 101938 114420
        ] [
            128352 129720 125504 128304 129692 125472 128280 129678 125456 128268 125448 128262
            125444 125792 128440 129758 120384 125744 128412 120352 125720 128398 120336 125708
            120328 125702 120324 120672 125880 128478 110144 120624 125852 110112 120600 125838
            110096 120588 110088 120582 110084 110432 120760 125918  89664 110384 120732  89632
            110360 120718  89616 110348  89608 110342  89952 110520 120798  89904 110492  89880
            110478  89868  90040 110558  90012  89998 125248 128176 129628 125216 128152 129614
            125200 128140 125192 128134 125188 125186 119616 125360 128220 119584 125336 128206
            119568 125324 119560 125318 119556 119554 108352 119728 125404 108320 119704 125390
            108304 119692 108296 119686 108292 108290  85824 108464 119772  85792 108440 119758
             85776 108428  85768 108422  85764  85936 108508  85912 108494  85900  85894  85980
             85966 125088 128088 129582 125072 128076 125064 128070 125060 125058 119200 125144
            128110 119184 125132 119176 125126 119172 119170 107424 119256 125166 107408 119244
            107400 119238 107396 107394  83872 107480 119278  83856 107468  83848 107462  83844
             83842  83928 107502  83916  83910  83950 125008 128044 125000 128038 124996 124994
            118992 125036 118984 125030 118980 118978 106960 119020 106952 119014 106948 106946
             82896 106988  82888 106982  82884  82882  82924  82918 124968 128022 124964 124962
            118888 124982 118884 118882 106728 118902 106724 106722  82408 106742  82404  82402
            124948 124946 118836 118834 106612 106610 124224 127664 129372 124192 127640 129358
            124176 127628 124168 127622 124164 124162 117568 124336 127708 117536 124312 127694
            117520 124300 117512 124294 117508 117506 104256 117680 124380 104224 117656 124366
            104208 117644 104200 117638 104196 104194  77632 104368 117724  77600 104344 117710
             77584 104332  77576 104326  77572  77744 104412  77720 104398  77708  77702  77788
             77774 128672 129880  93168 128656 129868  92664 128648 129862  92412 128644 128642
            124064 127576 129326 126368 124048 129902 126352 128716 127558 126344 124036 126340
            124034 126338 117152 124120 127598 121760 117136 124108 121744 126412 124102 121736
            117124 121732 117122 121730 103328 117208 124142 112544 103312 117196 112528 121804
            117190 112520 103300 112516 103298 112514  75680 103384 117230  94112  75664 103372
             94096 112588 103366  94088  75652  94084  75650  75736 103406  94168  75724  94156
             75718  94150  75758 128592 129836  91640 128584 129830  91388 128580  91262 128578
            123984 127532 126160 123976 127526 126152 128614 126148 123970 126146 116944 124012
            121296 116936 124006 121288 126182 121284 116930 121282 102864 116972 111568 102856
            116966 111560 121318 111556 102850 111554  74704 102892  92112  74696 102886  92104
            111590  92100  74690  92098  74732  92140  74726  92134 128552 129814  90876 128548
             90750 128546 123944 127510 126056 128566 126052 123938 126050 116840 123958 121064
            116836 121060 116834 121058 102632 116854 111080 121078 111076 102626 111074  74216
            102646  91112  74212  91108  74210  91106  74230  91126 128532  90494 128530 123924
            126004 123922 126002 116788 120948 116786 120946 102516 110836 102514 110834  73972
             90612  73970  90610 128522 123914 125978 116762 120890 102458 110714 123552 127320
            129198 123536 127308 123528 127302 123524 123522 116128 123608 127342 116112 123596
            116104 123590 116100 116098 101280 116184 123630 101264 116172 101256 116166 101252
            101250  71584 101336 116206  71568 101324  71560 101318  71556  71554  71640 101358
             71628  71622  71662 127824 129452  79352 127816 129446  79100 127812  78974 127810
            123472 127276 124624 123464 127270 124616 127846 124612 123458 124610 115920 123500
            118224 115912 123494 118216 124646 118212 115906 118210 100816 115948 105424 100808
            115942 105416 118246 105412 100802 105410  70608 100844  79824  70600 100838  79816
            105446  79812  70594  79810  70636  79852  70630  79846 129960  95728 113404 129956
             95480 113278 129954  95356  95294 127784 129430  78588 128872 129974  95996  78462
            128868 127778  95870 128866 123432 127254 124520 123428 126696 128886 123426 126692
            124514 126690 115816 123446 117992 115812 122344 117988 115810 122340 117986 122338
            100584 115830 104936 100580 113640 104932 100578 113636 104930 113634  70120 100598
             78824  70116  96232  78820  70114  96228  78818  96226  70134  78838 129940  94968
            113022 129938  94844  94782 127764  78206 128820 127762  95102 128818 123412 124468
            123410 126580 124466 126578 115764 117876 115762 122100 117874 122098 100468 104692
            100466 113140 104690 113138  69876  78324  69874  95220  78322  95218 129930  94588
             94526 127754 128794 123402 124442 126522 115738 117818 121978 100410 104570 112890
             69754  78074  94714  94398 123216 127148 123208 127142 123204 123202 115408 123244
            115400 123238 115396 115394  99792 115436  99784 115430  99780  99778  68560  99820
             68552  99814  68548  68546  68588  68582 127400 129238  72444 127396  72318 127394
            123176 127126 123752 123172 123748 123170 123746 115304 123190 116456 115300 116452
            115298 116450  99560 115318 101864  99556 101860  99554 101858  68072  99574  72680
             68068  72676  68066  72674  68086  72694 129492  80632 105854 129490  80508  80446
            127380  72062 127924 127378  80766 127922 123156 123700 123154 124788 123698 124786
            115252 116340 115250 118516 116338 118514  99444 101620  99442 105972 101618 105970
             67828  72180  67826  80884  72178  80882  97008 114044  96888 113982  96828  96798
            129482  80252 130010  97148  80190  97086 127370 127898 128954 123146 123674 124730
            126842 115226 116282 118394 122618  99386 101498 105722 114170  67706  71930  80378
             96632 113854  96572  96542  80062  96702  96444  96414  96350 123048 123044 123042
            115048 123062 115044 115042  99048 115062  99044  99042  67048  99062  67044  67042
             67062 127188  68990 127186 123028 123316 123026 123314 114996 115572 114994 115570
             98932 100084  98930 100082  66804  69108  66802  69106 129258  73084  73022 127178
            127450 123018 123290 123834 114970 115514 116602  98874  99962 102138  66682  68858
             73210  81272 106174  81212  81182  72894  81342  97648 114364  97592 114334  97564
             97550  81084  97724  81054  97694  97464 114270  97436  97422  80990  97502  97372
             97358  97326 114868 114866  98676  98674  66292  66290 123098 114842 115130  98618
             99194  66170  67322  69310  73404  73374  81592 106334  81564  81550  73310  81630
             97968 114524  97944 114510  97932  97926  81500  98012  81486  97998  97880 114478
             97868  97862  81454  97902  97836  97830  69470  73564  73550  81752 106414  81740
             81734  73518  81774  81708  81702
        ] [
            109536 120312  86976 109040 120060  86496 108792 119934  86256 108668  86136 129744
             89056 110072 129736  88560 109820 129732  88312 109694 129730  88188 128464 129772
             89592 128456 129766  89340 128452  89214 128450 125904 128492 125896 128486 125892
            125890 120784 125932 120776 125926 120772 120770 110544 120812 110536 120806 110532
             84928 108016 119548  84448 107768 119422  84208 107644  84088 107582  84028 129640
             85488 108284 129636  85240 108158 129634  85116  85054 128232 129654  85756 128228
             85630 128226 125416 128246 125412 125410 119784 125430 119780 119778 108520 119798
            108516 108514  83424 107256 119166  83184 107132  83064 107070  83004  82974 129588
             83704 107390 129586  83580  83518 128116  83838 128114 125172 125170 119284 119282
            107508 107506  82672 106876  82552 106814  82492  82462 129562  82812  82750 128058
            125050 119034  82296 106686  82236  82206  82366  82108  82078  76736 103920 117500
             76256 103672 117374  76016 103548  75896 103486  75836 129384  77296 104188 129380
             77048 104062 129378  76924  76862 127720 129398  77564 127716  77438 127714 124392
            127734 124388 124386 117736 124406 117732 117730 104424 117750 104420 104418 112096
            121592 126334  92608 111856 121468  92384 111736 121406  92272 111676  92216 111646
             92188  75232 103160 117118  93664  74992 103036  93424 112252 102974  93304  74812
             93244  74782  93214 129332  75512 103294 129908 129330  93944  75388 129906  93820
             75326  93758 127604  75646 128756 127602  94078 128754 124148 126452 124146 126450
            117236 121844 117234 121842 103412 103410  91584 111344 121212  91360 111224 121150
             91248 111164  91192 111134  91164  91150  74480 102780  91888  74360 102718  91768
            111422  91708  74270  91678 129306  74620 129850  92028  74558  91966 127546 128634
            124026 126202 116986 121338 102906  90848 110968 121022  90736 110908  90680 110878
             90652  90638  74104 102590  91000  74044  90940  74014  90910  74174  91070  90480
            110780  90424 110750  90396  90382  73916  90556  73886  90526  90296 110686  90268
             90254  73822  90334  90204  90190  71136 101112 116094  70896 100988  70776 100926
             70716  70686 129204  71416 101246 129202  71292  71230 127348  71550 127346 123636
            123634 116212 116210 101364 101362  79296 105200 118140  79072 105080 118078  78960
            105020  78904 104990  78876  78862  70384 100732  79600  70264 100670  79480 105278
             79420  70174  79390 129178  70524 129466  79740  70462  79678 127290 127866 123514
            124666 115962 118266 100858 113376 122232 126654  95424 113264 122172  95328 113208
            122142  95280 113180  95256 113166  95244  78560 104824 117950  95968  78448 104764
             95856 113468 104734  95800  78364  95772  78350  95758  70008 100542  78712  69948
             96120  78652  69918  96060  78622  96030  70078  78782  96190  94912 113008 122044
             94816 112952 122014  94768 112924  94744 112910  94732  94726  78192 104636  95088
             78136 104606  95032 113054  95004  78094  94990  69820  78268  69790  95164  78238
             95134  94560 112824 121950  94512 112796  94488 112782  94476  94470  78008 104542
             94648  77980  94620  77966  94606  69726  78046  94686  94384 112732  94360 112718
             94348  94342  77916  94428  77902  94414  94296 112686  94284  94278  77870  94318
             94252  94246  68336  99708  68216  99646  68156  68126  68476  68414 127162 123258
            115450  99834  72416 101752 116414  72304 101692  72248 101662  72220  72206  67960
             99518  72568  67900  72508  67870  72478  68030  72638  80576 105840 118460  80480
            105784 118430  80432 105756  80408 105742  80396  80390  72048 101564  80752  71992
            101534  80696  71964  80668  71950  80654  67772  72124  67742  80828  72094  80798
            114016 122552 126814  96832 113968 122524  96800 113944 122510  96784 113932  96776
            113926  96772  80224 105656 118366  97120  80176 105628  97072 114076 105614  97048
             80140  97036  80134  97030  71864 101470  80312  71836  97208  80284  71822  97180
             80270  97166  67678  71902  80350  97246  96576 113840 122460  96544 113816 122446
             96528 113804  96520 113798  96516  96514  80048 105564  96688  80024 105550  96664
            113870  96652  80006  96646  71772  80092  71758  96732  80078  96718  96416 113752
            122414  96400 113740  96392 113734  96388  96386  79960 105518  96472  79948  96460
             79942  96454  71726  79982  96494  96336 113708  96328 113702  96324  96322  79916
             96364  79910  96358  96296 113686  96292  96290  79894  96310  66936  99006  66876
             66846  67006  68976 100028  68920  99998  68892  68878  66748  69052  66718  69022
             73056 102072 116574  73008 102044  72984 102030  72972  72966  68792  99934  73144
             68764  73116  68750  73102  66654  68830  73182  81216 106160 118620  81184 106136
            118606  81168 106124  81160 106118  81156  81154  72880 101980  81328  72856 101966
             81304 106190  81292  72838  81286  68700  72924  68686  81372  72910  81358 114336
            122712 126894 114320 122700 114312 122694 114308 114306  81056 106072 118574  97696
             81040 106060  97680 114380 106054  97672  81028  97668  81026  97666  72792 101934
             81112  72780  97752  81100  72774  97740  81094  97734  68654  72814  81134  97774
            114256 122668 114248 122662 114244 114242  80976 106028  97488  80968 106022  97480
            114278  97476  80962  97474  72748  81004  72742  97516  80998  97510 114216 122646
            114212 114210  80936 106006  97384  80932  97380  80930  97378  72726  80950  97398
            114196 114194  80916  97332  80914  97330  66236  66206  67256  99166  67228  67214
             66142  67294  69296 100188  69272 100174  69260  69254  67164  69340  67150  69326
             73376 102232 116654  73360 102220  73352 102214  73348  73346  69208 100142  73432
            102254  73420  69190  73414  67118  69230  73454 106320 118700 106312 118694 106308
            106306  73296 102188  81616 106348 102182  81608  73284  81604  73282  81602  69164
             73324  69158  81644  73318  81638 122792 126934 122788 122786 106280 118678 114536
            106276 114532 106274 114530  73256 102166  81512  73252  98024  81508  73250  98020
             81506  98018  69142  73270  81526  98038 122772 122770 106260 114484 106258 114482
             73236  81460  73234  97908  81458  97906 122762 106250 114458  73226  81434  97850
             66396  66382  67416  99246  67404  67398  66350  67438  69456 100268  69448 100262
             69444  69442  67372  69484  67366  69478 102312 116694 102308 102306  69416 100246
             73576 102326  73572  69410  73570  67350  69430  73590 118740 118738 102292 106420
            102290 106418  69396  73524  69394  81780  73522  81778 118730 102282 106394  69386
             73498  81722  66476  66470  67496  99286  67492  67490  66454  67510 100308 100306
             67476  69556  67474  69554 116714
        ]
    ] def

    % Return the 17 bits for a codeword in a given cluster
    /cwtobits {
        clusters exch get exch get /v exch def
        [ 17 {0} repeat v 2 17 string cvrs {48 sub} forall ]
        dup length 17 sub 17 getinterval
    } bind def

    % Populate bitmap for the image
    compact {
        /rwid 17 c mul 17 add 17 add 1 add def
    } {
        /rwid 17 c mul 17 add 17 add 17 add 18 add def
    } ifelse
    /pixs rwid r mul array def

   0 1 r 1 sub {
        /i exch def

        i 3 mod 0 eq {
            /lcw i 3 idiv 30 mul r 1 sub 3 idiv add def
            /rcw i 3 idiv 30 mul c add 1 sub def
        } if
        i 3 mod 1 eq {
            /lcw i 3 idiv 30 mul eclevel 3 mul add r 1 sub 3 mod add def
            /rcw i 3 idiv 30 mul r 1 sub 3 idiv add def
        } if
        i 3 mod 2 eq {
            /lcw i 3 idiv 30 mul c add 1 sub def
            /rcw i 3 idiv 30 mul eclevel 3 mul add r 1 sub 3 mod add def
        } if

        pixs rwid i mul [
            1 1 1 1 1 1 1 1 0 1 0 1 0 1 0 0 0
            lcw i 3 mod cwtobits {} forall
            cws c i mul c getinterval { i 3 mod cwtobits {} forall } forall
            compact {
                1
            } {
                rcw i 3 mod cwtobits {} forall
                1 1 1 1 1 1 1 0 1 0 0 0 1 0 1 0 0 1
            } ifelse
        ] putinterval

    } for

    % Return the arguments
    <<
    /ren //renmatrix
    /pixs pixs
    /pixx rwid
    /pixy r
    /height r 72 div rowmult mul
    /width rwid 72 div
    /opt options
    >>

    dontdraw not //renmatrix if

    end

} bind def
/pdf417 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER pdf417--

% --BEGIN ENCODER micropdf417--
% --DESC: MicroPDF417
% --EXAM: MicroPDF417
% --EXOP:
% --RNDR: renmatrix
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/micropdf417 {

    20 dict begin

    /options exch def
    /barcode exch def

    /dontdraw false def
    /columns 0 def
    /rows 0 def
    /rowmult 2 def
    /cca false def
    /ccb false def
    /raw false def
    /parse false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /columns columns cvi def
    /rows rows cvi def
    /rowmult rowmult cvr def

    cca {/raw true def} if

    % Parse ordinals of the form ^NNN to ASCII
    parse {
        /msg barcode length string def
        /j 0 def
        barcode
        { % loop
            (^) search {
                dup msg exch j exch putinterval
                length j add 1 add /j exch def
                pop
                dup 0 3 getinterval cvi msg exch j 1 sub exch put
                dup length 3 sub 3 exch getinterval
            } {
                dup msg exch j exch putinterval
                length j add /j exch def
                /barcode msg 0 j getinterval def
                exit
            } ifelse 
        } loop
    } if

    % Convert input into array of codewords
    raw {
        /datcws barcode length array def
        /i 0 def /j 0 def
        { % loop
            i barcode length eq {exit} if
            /cw barcode i 1 add 3 getinterval cvi def
            datcws j cw put
            /i i 4 add def
            /j j 1 add def
        } loop
        /datcws datcws 0 j getinterval def
    } {  % Simple autoencoder from input to codewords using byte mode
        /barlen barcode length def
        barlen 6 mod 0 eq {
            /datcws barlen 6 idiv 5 mul 1 add array def
            datcws 0 924 put
        } {
            /datcws barlen 6 idiv 5 mul barlen 6 mod add 1 add array def
            datcws 0 901 put 
        } ifelse

        % Rebase groups of 6 bytes splitting into 3 byte chunks
        0 1 barlen 6 idiv 1 sub {
            /i exch def
            /msbs [ barcode i 6 mul 3 getinterval {} forall ] def
            /mscs [
                msbs aload pop exch 256 mul add exch 65536 mul add 
                3 {dup 900 mod exch 900 idiv} repeat 
            ] def
            /lsbs [barcode i 6 mul 3 add 3 getinterval {} forall] def
            /lscs [
                lsbs aload pop exch 256 mul add exch 65536 mul add
                3 {dup 900 mod exch 900 idiv} repeat
            ] def
            /cws 5 array def
            lscs 0 get mscs 0 get 316 mul add
            cws 4 2 index 900 mod put
            900 idiv lscs 1 get add mscs 0 get 641 mul add mscs 1 get 316 mul add
            cws 3 2 index 900 mod put 
            900 idiv lscs 2 get add mscs 0 get 20 mul add mscs 1 get 641 mul add mscs 2 get 316 mul add 
            cws 2 2 index 900 mod put
            900 idiv lscs 3 get add mscs 1 get 20 mul add mscs 2 get 641 mul add
            cws 1 2 index 900 mod put
            900 idiv mscs 2 get 20 mul add
            cws 0 3 -1 roll 900 mod put
            datcws i 5 mul 1 add cws putinterval 
        } for

        % Add the remaining bytes to the end of the codewords
        /rem barlen 6 mod def
        rem 0 ne {
            datcws datcws length rem sub 
            [ barcode barlen rem sub rem getinterval {} forall ] 
            putinterval
        } if

        ccb {/datcws [920 datcws aload pop] def} if

    } ifelse

    % Basic metrics for the each symbol
    %     c  r ecw  rl rc rr
    /metrics [
        [ 1 11   7   1  0  9 ]
        [ 1 14   7   8  0  8 ]
        [ 1 17   7  36  0 36 ]
        [ 1 20   8  19  0 19 ]
        [ 1 24   8   9  0 17 ]
        [ 1 28   8  25  0 33 ]
        [ 2  8   8   1  0  1 ]
        [ 2 11   9   1  0  9 ]
        [ 2 14   9   8  0  8 ]
        [ 2 17  10  36  0 36 ]
        [ 2 20  11  19  0 19 ]
        [ 2 23  13   9  0 17 ]
        [ 2 26  15  27  0 35 ]
        [ 3  6  12   1  1  1 ]
        [ 3  8  14   7  7  7 ]
        [ 3 10  16  15 15 15 ]
        [ 3 12  18  25 25 25 ]
        [ 3 15  21  37 37 37 ]
        [ 3 20  26   1 17 33 ]
        [ 3 26  32   1  9 17 ]
        [ 3 32  38  21 29 37 ]
        [ 3 38  44  15 31 47 ]
        [ 3 44  50   1 25 49 ]
        [ 4  4   8  47 19 43 ]
        [ 4  6  12   1  1  1 ]
        [ 4  8  14   7  7  7 ]
        [ 4 10  16  15 15 15 ]
        [ 4 12  18  25 25 25 ]
        [ 4 15  21  37 37 37 ]
        [ 4 20  26   1 17 33 ]
        [ 4 26  32   1  9 17 ]
        [ 4 32  38  21 29 37 ]
        [ 4 38  44  15 31 47 ]
        [ 4 44  50   1 25 49 ]
    ] def

    % Basic metrics for the each symbol
    %     c  r ecw  rl rc rr
    /ccametrics [
        [ 2  5   4  39  0 19 ]
        [ 2  6   4   1  0 33 ]
        [ 2  7   5  32  0 12 ]
        [ 2  8   5   8  0 40 ]
        [ 2  9   6  14  0 46 ]
        [ 2 10   6  43  0 23 ]
        [ 2 12   7  20  0 52 ]
        [ 3  4   4  11 43 23 ]
        [ 3  5   5   1 33 13 ]
        [ 3  6   6   5 37 17 ]
        [ 3  7   7  15 47 27 ]
        [ 3  8   7  21  1 33 ]
        [ 4  3   4  40 20 52 ]
        [ 4  4   5  43 23  3 ]
        [ 4  5   6  46 26  6 ]
        [ 4  6   7  34 14 46 ]
        [ 4  7   8  29  9 41 ]
    ] def
    cca {/metrics ccametrics def} if

    % Select metrics of an appropriate symbol
    /urows rows def
    /ucols columns def
    /i 0 def
    { % loop
        /m metrics i get def
        /c    m 0 get def        % Rows in symbol
        /r    m 1 get def        % Columns in symbol
        /k    m 2 get def        % Error correction codewords
        /rapl m 3 get def        % Left row address pattern
        /rapc m 4 get def        % Centre row address pattern
        /rapr m 5 get def        % Right row address pattern
        /ncws r c mul k sub def  % Data codewords
        /okay true def
        datcws length ncws gt     {/okay false def} if
        urows 0 ne urows r ne and {/okay false def} if
        ucols 0 ne ucols c ne and {/okay false def} if
        okay {exit} if
        /i i 1 add def
    } loop
    /m datcws length def

    % Create codewords array with one extra working space element and add padding
    /n c r mul k sub def
    /cws c r mul 1 add array def
    cws 0 datcws putinterval
    cws m [ n m sub {900} repeat ] putinterval
    cws n [ k {0} repeat 0 ] putinterval

    % Calculate the log and anti-log tables
    /rsalog [ 1 928 {dup 3 mul 929 mod} repeat ] def
    /rslog 929 array def
    1 1 928 {dup rsalog exch get exch rslog 3 1 roll put} for

    % Function to calculate the product in the field
    /rsprod {
        2 copy 0 ne exch 0 ne and {
            rslog exch get exch rslog exch get add 928 mod rsalog exch get
        } {
            pop pop 0
        } ifelse
    } bind def

    % Generate the coefficients
    /coeffs [ 1 k {0} repeat ] def
    1 1 k {
        /i exch def 
        coeffs i coeffs i 1 sub get put
        i 1 sub -1 1 {
            /j exch def
            coeffs j coeffs j 1 sub get coeffs j get rsalog i get rsprod add 929 mod put
        } for 
        coeffs 0 coeffs 0 get rsalog i get rsprod put
    } for
    /coeffs coeffs 0 coeffs length 1 sub getinterval def
    coeffs length 1 sub -2 0 {coeffs exch 2 copy get 929 exch sub put} for

    % Derive the error codewords
    0 1 n 1 sub {
        /t exch cws exch get cws n get add 929 mod def
        0 1 k 1 sub {
            /j exch def
            cws n j add cws n j add 1 add get 929 t coeffs k j sub 1 sub get mul 929 mod sub add 929 mod put
        } for
    } for
    n 1 n k add { dup cws exch 929 cws 5 -1 roll get sub 929 mod put } for

    % Trim the working space from the end of the codewords
    /cws cws 0 cws length 1 sub getinterval def

    % Base 10 encoding of the bar space successions for the codewords in each cluster
    /clusters [
        [
            120256 125680 128380 120032 125560 128318 108736 119920 108640  86080 108592  86048
            110016 120560 125820 109792 120440 125758  88256 109680  88160  89536 110320 120700
             89312 110200 120638  89200 110140  89840 110460  89720 110398  89980 128506 119520
            125304 128190 107712 119408 125244 107616 119352  84032 107568 119324  84000 107544
             83984 108256 119672 125374  85184 108144 119612  85088 108088 119582  85040 108060
             85728 108408 119742  85616 108348  85560 108318  85880 108478  85820  85790 107200
            119152 125116 107104 119096 125086  83008 107056 119068  82976 107032  82960  82952
             83648 107376 119228  83552 107320 119198  83504 107292  83480  83468  83824 107452
             83768 107422  83740  83900 106848 118968 125022  82496 106800 118940  82464 106776
            118926  82448 106764  82440 106758  82784 106936 119006  82736 106908  82712 106894
             82700  82694 106974  82830  82240 106672 118876  82208 106648 118862  82192 106636
             82184 106630  82180  82352  82328  82316  82080 118830 106572 106566  82050 117472
            124280 127678 103616 117360 124220 103520 117304 124190  75840 103472  75808 104160
            117624 124350  76992 104048 117564  76896 103992  76848  76824  77536 104312 117694
             77424 104252  77368  77340  77688 104382  77628  77758 121536 126320 128700 121440
            126264 128670 111680 121392 126236 111648 121368 126222 111632 121356 103104 117104
            124092 112320 103008 117048 124062 112224 121656 126366  93248  74784 102936 117006
             93216 112152  93200  75456 103280 117180  93888  75360 103224 117150  93792 112440
            121758  93744  75288  93720  75632 103356  94064  75576 103326  94008 112542  93980
             75708  94140  75678  94110 121184 126136 128606 111168 121136 126108 111136 121112
            126094 111120 121100 111112 111108 102752 116920 123998 111456 102704 116892  91712
             74272 121244 116878  91680  74256 102668  91664 111372 102662  74244  74592 102840
            116958  92000  74544 102812  91952 111516 102798  91928  74508  74502  74680 102878
             92088  74652  92060  74638  92046  92126 110912 121008 126044 110880 120984 126030
            110864 120972 110856 120966 110852 110850  74048 102576 116828  90944  74016 102552
            116814  90912 111000 121038  90896  73992 102534  90888 110982  90884  74160 102620
             91056  74136 102606  91032 111054  91020  74118  91014  91100  91086 110752 120920
            125998 110736 120908 110728 120902 110724 110722  73888 102488 116782  90528  73872
            102476  90512 110796 102470  90504  73860  90500  73858  73944  90584  90572  90566
            120876 120870 110658 102444  73800  90312  90308  90306 101056 116080 123580 100960
            116024  70720 100912 115996  70688 100888  70672  70664  71360 101232 116156  71264
            101176 116126  71216 101148  71192  71180  71536 101308  71480 101278  71452  71612
             71582 118112 124600 127838 105024 118064 124572 104992 118040 124558 104976 118028
            104968 118022 100704 115896 123486 105312 100656 115868  79424  70176 118172 115854
             79392 105240 100620  79376  70152  79368  70496 100792 115934  79712  70448 118238
             79664 105372 100750  79640  70412  79628  70584 100830  79800  70556  79772  70542
             70622  79838 122176 126640 128860 122144 126616 128846 122128 126604 122120 126598
            122116 104768 117936 124508 113472 104736 126684 124494 113440 122264 126670 113424
            104712 117894 113416 122246 104706  69952 100528 115804  78656  69920 100504 115790
             96064  78624 104856 117966  96032 113560 122318 100486  96016  78600 104838  96008
             69890  70064 100572  78768  70040 100558  96176  78744 104910  96152 113614  70022
             78726  70108  78812  70094  96220  78798 122016 126552 128814 122000 126540 121992
            126534 121988 121986 104608 117848 124462 113056 104592 126574 113040 122060 117830
            113032 104580 113028 104578 113026  69792 100440 115758  78240  69776 100428  95136
             78224 104652 100422  95120 113100  69764  95112  78212  69762  78210  69848 100462
             78296  69836  95192  78284  69830  95180  78278  69870  95214 121936 126508 121928
            126502 121924 121922 104528 117804 112848 104520 117798 112840 121958 112836 104514
            112834  69712 100396  78032  69704 100390  94672  78024 104550  94664 112870  69698
             94660  78018  94658  78060  94700  94694 126486 121890 117782 104484 104482  69672
             77928  94440  69666  77922  99680  68160  99632  68128  99608 115342  68112  99596
             68104  99590  68448  99768 115422  68400  99740  68376  99726  68364  68358  68536
             99806  68508  68494  68574 101696 116400 123740 101664 116376 101648 116364 101640
            116358 101636  67904  99504 115292  72512  67872 116444 115278  72480 101784 116430
             72464  67848  99462  72456 101766  67842  68016  99548  72624  67992  99534  72600
            101838  72588  67974  68060  72668  68046  72654 118432 124760 127918 118416 124748
            118408 124742 118404 118402 101536 116312 105888 101520 116300 105872 118476 116294
            105864 101508 105860 101506 105858  67744  99416  72096  67728 116334  80800  72080
            101580  99398  80784 105932  67716  80776  72068  67714  72066  67800  99438  72152
             67788  80856  72140  67782  80844  72134  67822  72174  80878 126800 128940 126792
            128934 126788 126786 118352 124716 122576 126828 124710 122568 126822 122564 118338
            122562 101456 116268 105680 101448 116262 114128 105672 118374 114120 122598 101442
            114116 105666 114114  67664  99372  71888  67656  99366  80336  71880 101478  97232
             80328 105702  67650  97224 114150  71874  97220  67692  71916  67686  80364  71910
             97260  80358  97254 126760 128918 126756 126754 118312 124694 122472 126774 122468
            118306 122466 101416 116246 105576 101412 113896 105572 101410 113892 105570 113890
             67624  99350  71784 101430  80104  71780  67618  96744  80100  71778  96740  80098
             96738  71798  96758 126738 122420 122418 105524 113780 113778  71732  79988  96500
             96498  66880  66848  98968  66832  66824  66820  66992  66968  66956  66950  67036
             67022 100000  99984 115532  99976 115526  99972  99970  66720  98904  69024 100056
             98892  69008 100044  69000 100038  68996  66690  68994  66776  98926  69080 100078
             69068  66758  69062  66798  69102 116560 116552 116548 116546  99920 102096 116588
            115494 102088 116582 102084  99906 102082  66640  68816  66632  98854  73168  68808
             66628  73160  68804  66626  73156  68802  66668  68844  66662  73196  68838  73190
            124840 124836 124834 116520 118632 124854 118628 116514 118626  99880 115478 101992
            116534 106216 101988  99874 106212 101986 106210  66600  98838  68712  99894  72936
             68708  66594  81384  72932  68706  81380  72930  66614  68726  72950  81398 128980
            128978 124820 126900 124818 126898 116500 118580 116498 122740 118578 122738  99860
            101940  99858 106100 101938 114420
        ] [
            128352 129720 125504 128304 129692 125472 128280 129678 125456 128268 125448 128262
            125444 125792 128440 129758 120384 125744 128412 120352 125720 128398 120336 125708
            120328 125702 120324 120672 125880 128478 110144 120624 125852 110112 120600 125838
            110096 120588 110088 120582 110084 110432 120760 125918  89664 110384 120732  89632
            110360 120718  89616 110348  89608 110342  89952 110520 120798  89904 110492  89880
            110478  89868  90040 110558  90012  89998 125248 128176 129628 125216 128152 129614
            125200 128140 125192 128134 125188 125186 119616 125360 128220 119584 125336 128206
            119568 125324 119560 125318 119556 119554 108352 119728 125404 108320 119704 125390
            108304 119692 108296 119686 108292 108290  85824 108464 119772  85792 108440 119758
             85776 108428  85768 108422  85764  85936 108508  85912 108494  85900  85894  85980
             85966 125088 128088 129582 125072 128076 125064 128070 125060 125058 119200 125144
            128110 119184 125132 119176 125126 119172 119170 107424 119256 125166 107408 119244
            107400 119238 107396 107394  83872 107480 119278  83856 107468  83848 107462  83844
             83842  83928 107502  83916  83910  83950 125008 128044 125000 128038 124996 124994
            118992 125036 118984 125030 118980 118978 106960 119020 106952 119014 106948 106946
             82896 106988  82888 106982  82884  82882  82924  82918 124968 128022 124964 124962
            118888 124982 118884 118882 106728 118902 106724 106722  82408 106742  82404  82402
            124948 124946 118836 118834 106612 106610 124224 127664 129372 124192 127640 129358
            124176 127628 124168 127622 124164 124162 117568 124336 127708 117536 124312 127694
            117520 124300 117512 124294 117508 117506 104256 117680 124380 104224 117656 124366
            104208 117644 104200 117638 104196 104194  77632 104368 117724  77600 104344 117710
             77584 104332  77576 104326  77572  77744 104412  77720 104398  77708  77702  77788
             77774 128672 129880  93168 128656 129868  92664 128648 129862  92412 128644 128642
            124064 127576 129326 126368 124048 129902 126352 128716 127558 126344 124036 126340
            124034 126338 117152 124120 127598 121760 117136 124108 121744 126412 124102 121736
            117124 121732 117122 121730 103328 117208 124142 112544 103312 117196 112528 121804
            117190 112520 103300 112516 103298 112514  75680 103384 117230  94112  75664 103372
             94096 112588 103366  94088  75652  94084  75650  75736 103406  94168  75724  94156
             75718  94150  75758 128592 129836  91640 128584 129830  91388 128580  91262 128578
            123984 127532 126160 123976 127526 126152 128614 126148 123970 126146 116944 124012
            121296 116936 124006 121288 126182 121284 116930 121282 102864 116972 111568 102856
            116966 111560 121318 111556 102850 111554  74704 102892  92112  74696 102886  92104
            111590  92100  74690  92098  74732  92140  74726  92134 128552 129814  90876 128548
             90750 128546 123944 127510 126056 128566 126052 123938 126050 116840 123958 121064
            116836 121060 116834 121058 102632 116854 111080 121078 111076 102626 111074  74216
            102646  91112  74212  91108  74210  91106  74230  91126 128532  90494 128530 123924
            126004 123922 126002 116788 120948 116786 120946 102516 110836 102514 110834  73972
             90612  73970  90610 128522 123914 125978 116762 120890 102458 110714 123552 127320
            129198 123536 127308 123528 127302 123524 123522 116128 123608 127342 116112 123596
            116104 123590 116100 116098 101280 116184 123630 101264 116172 101256 116166 101252
            101250  71584 101336 116206  71568 101324  71560 101318  71556  71554  71640 101358
             71628  71622  71662 127824 129452  79352 127816 129446  79100 127812  78974 127810
            123472 127276 124624 123464 127270 124616 127846 124612 123458 124610 115920 123500
            118224 115912 123494 118216 124646 118212 115906 118210 100816 115948 105424 100808
            115942 105416 118246 105412 100802 105410  70608 100844  79824  70600 100838  79816
            105446  79812  70594  79810  70636  79852  70630  79846 129960  95728 113404 129956
             95480 113278 129954  95356  95294 127784 129430  78588 128872 129974  95996  78462
            128868 127778  95870 128866 123432 127254 124520 123428 126696 128886 123426 126692
            124514 126690 115816 123446 117992 115812 122344 117988 115810 122340 117986 122338
            100584 115830 104936 100580 113640 104932 100578 113636 104930 113634  70120 100598
             78824  70116  96232  78820  70114  96228  78818  96226  70134  78838 129940  94968
            113022 129938  94844  94782 127764  78206 128820 127762  95102 128818 123412 124468
            123410 126580 124466 126578 115764 117876 115762 122100 117874 122098 100468 104692
            100466 113140 104690 113138  69876  78324  69874  95220  78322  95218 129930  94588
             94526 127754 128794 123402 124442 126522 115738 117818 121978 100410 104570 112890
             69754  78074  94714  94398 123216 127148 123208 127142 123204 123202 115408 123244
            115400 123238 115396 115394  99792 115436  99784 115430  99780  99778  68560  99820
             68552  99814  68548  68546  68588  68582 127400 129238  72444 127396  72318 127394
            123176 127126 123752 123172 123748 123170 123746 115304 123190 116456 115300 116452
            115298 116450  99560 115318 101864  99556 101860  99554 101858  68072  99574  72680
             68068  72676  68066  72674  68086  72694 129492  80632 105854 129490  80508  80446
            127380  72062 127924 127378  80766 127922 123156 123700 123154 124788 123698 124786
            115252 116340 115250 118516 116338 118514  99444 101620  99442 105972 101618 105970
             67828  72180  67826  80884  72178  80882  97008 114044  96888 113982  96828  96798
            129482  80252 130010  97148  80190  97086 127370 127898 128954 123146 123674 124730
            126842 115226 116282 118394 122618  99386 101498 105722 114170  67706  71930  80378
             96632 113854  96572  96542  80062  96702  96444  96414  96350 123048 123044 123042
            115048 123062 115044 115042  99048 115062  99044  99042  67048  99062  67044  67042
             67062 127188  68990 127186 123028 123316 123026 123314 114996 115572 114994 115570
             98932 100084  98930 100082  66804  69108  66802  69106 129258  73084  73022 127178
            127450 123018 123290 123834 114970 115514 116602  98874  99962 102138  66682  68858
             73210  81272 106174  81212  81182  72894  81342  97648 114364  97592 114334  97564
             97550  81084  97724  81054  97694  97464 114270  97436  97422  80990  97502  97372
             97358  97326 114868 114866  98676  98674  66292  66290 123098 114842 115130  98618
             99194  66170  67322  69310  73404  73374  81592 106334  81564  81550  73310  81630
             97968 114524  97944 114510  97932  97926  81500  98012  81486  97998  97880 114478
             97868  97862  81454  97902  97836  97830  69470  73564  73550  81752 106414  81740
             81734  73518  81774  81708  81702
        ] [
            109536 120312  86976 109040 120060  86496 108792 119934  86256 108668  86136 129744
             89056 110072 129736  88560 109820 129732  88312 109694 129730  88188 128464 129772
             89592 128456 129766  89340 128452  89214 128450 125904 128492 125896 128486 125892
            125890 120784 125932 120776 125926 120772 120770 110544 120812 110536 120806 110532
             84928 108016 119548  84448 107768 119422  84208 107644  84088 107582  84028 129640
             85488 108284 129636  85240 108158 129634  85116  85054 128232 129654  85756 128228
             85630 128226 125416 128246 125412 125410 119784 125430 119780 119778 108520 119798
            108516 108514  83424 107256 119166  83184 107132  83064 107070  83004  82974 129588
             83704 107390 129586  83580  83518 128116  83838 128114 125172 125170 119284 119282
            107508 107506  82672 106876  82552 106814  82492  82462 129562  82812  82750 128058
            125050 119034  82296 106686  82236  82206  82366  82108  82078  76736 103920 117500
             76256 103672 117374  76016 103548  75896 103486  75836 129384  77296 104188 129380
             77048 104062 129378  76924  76862 127720 129398  77564 127716  77438 127714 124392
            127734 124388 124386 117736 124406 117732 117730 104424 117750 104420 104418 112096
            121592 126334  92608 111856 121468  92384 111736 121406  92272 111676  92216 111646
             92188  75232 103160 117118  93664  74992 103036  93424 112252 102974  93304  74812
             93244  74782  93214 129332  75512 103294 129908 129330  93944  75388 129906  93820
             75326  93758 127604  75646 128756 127602  94078 128754 124148 126452 124146 126450
            117236 121844 117234 121842 103412 103410  91584 111344 121212  91360 111224 121150
             91248 111164  91192 111134  91164  91150  74480 102780  91888  74360 102718  91768
            111422  91708  74270  91678 129306  74620 129850  92028  74558  91966 127546 128634
            124026 126202 116986 121338 102906  90848 110968 121022  90736 110908  90680 110878
             90652  90638  74104 102590  91000  74044  90940  74014  90910  74174  91070  90480
            110780  90424 110750  90396  90382  73916  90556  73886  90526  90296 110686  90268
             90254  73822  90334  90204  90190  71136 101112 116094  70896 100988  70776 100926
             70716  70686 129204  71416 101246 129202  71292  71230 127348  71550 127346 123636
            123634 116212 116210 101364 101362  79296 105200 118140  79072 105080 118078  78960
            105020  78904 104990  78876  78862  70384 100732  79600  70264 100670  79480 105278
             79420  70174  79390 129178  70524 129466  79740  70462  79678 127290 127866 123514
            124666 115962 118266 100858 113376 122232 126654  95424 113264 122172  95328 113208
            122142  95280 113180  95256 113166  95244  78560 104824 117950  95968  78448 104764
             95856 113468 104734  95800  78364  95772  78350  95758  70008 100542  78712  69948
             96120  78652  69918  96060  78622  96030  70078  78782  96190  94912 113008 122044
             94816 112952 122014  94768 112924  94744 112910  94732  94726  78192 104636  95088
             78136 104606  95032 113054  95004  78094  94990  69820  78268  69790  95164  78238
             95134  94560 112824 121950  94512 112796  94488 112782  94476  94470  78008 104542
             94648  77980  94620  77966  94606  69726  78046  94686  94384 112732  94360 112718
             94348  94342  77916  94428  77902  94414  94296 112686  94284  94278  77870  94318
             94252  94246  68336  99708  68216  99646  68156  68126  68476  68414 127162 123258
            115450  99834  72416 101752 116414  72304 101692  72248 101662  72220  72206  67960
             99518  72568  67900  72508  67870  72478  68030  72638  80576 105840 118460  80480
            105784 118430  80432 105756  80408 105742  80396  80390  72048 101564  80752  71992
            101534  80696  71964  80668  71950  80654  67772  72124  67742  80828  72094  80798
            114016 122552 126814  96832 113968 122524  96800 113944 122510  96784 113932  96776
            113926  96772  80224 105656 118366  97120  80176 105628  97072 114076 105614  97048
             80140  97036  80134  97030  71864 101470  80312  71836  97208  80284  71822  97180
             80270  97166  67678  71902  80350  97246  96576 113840 122460  96544 113816 122446
             96528 113804  96520 113798  96516  96514  80048 105564  96688  80024 105550  96664
            113870  96652  80006  96646  71772  80092  71758  96732  80078  96718  96416 113752
            122414  96400 113740  96392 113734  96388  96386  79960 105518  96472  79948  96460
             79942  96454  71726  79982  96494  96336 113708  96328 113702  96324  96322  79916
             96364  79910  96358  96296 113686  96292  96290  79894  96310  66936  99006  66876
             66846  67006  68976 100028  68920  99998  68892  68878  66748  69052  66718  69022
             73056 102072 116574  73008 102044  72984 102030  72972  72966  68792  99934  73144
             68764  73116  68750  73102  66654  68830  73182  81216 106160 118620  81184 106136
            118606  81168 106124  81160 106118  81156  81154  72880 101980  81328  72856 101966
             81304 106190  81292  72838  81286  68700  72924  68686  81372  72910  81358 114336
            122712 126894 114320 122700 114312 122694 114308 114306  81056 106072 118574  97696
             81040 106060  97680 114380 106054  97672  81028  97668  81026  97666  72792 101934
             81112  72780  97752  81100  72774  97740  81094  97734  68654  72814  81134  97774
            114256 122668 114248 122662 114244 114242  80976 106028  97488  80968 106022  97480
            114278  97476  80962  97474  72748  81004  72742  97516  80998  97510 114216 122646
            114212 114210  80936 106006  97384  80932  97380  80930  97378  72726  80950  97398
            114196 114194  80916  97332  80914  97330  66236  66206  67256  99166  67228  67214
             66142  67294  69296 100188  69272 100174  69260  69254  67164  69340  67150  69326
             73376 102232 116654  73360 102220  73352 102214  73348  73346  69208 100142  73432
            102254  73420  69190  73414  67118  69230  73454 106320 118700 106312 118694 106308
            106306  73296 102188  81616 106348 102182  81608  73284  81604  73282  81602  69164
             73324  69158  81644  73318  81638 122792 126934 122788 122786 106280 118678 114536
            106276 114532 106274 114530  73256 102166  81512  73252  98024  81508  73250  98020
             81506  98018  69142  73270  81526  98038 122772 122770 106260 114484 106258 114482
             73236  81460  73234  97908  81458  97906 122762 106250 114458  73226  81434  97850
             66396  66382  67416  99246  67404  67398  66350  67438  69456 100268  69448 100262
             69444  69442  67372  69484  67366  69478 102312 116694 102308 102306  69416 100246
             73576 102326  73572  69410  73570  67350  69430  73590 118740 118738 102292 106420
            102290 106418  69396  73524  69394  81780  73522  81778 118730 102282 106394  69386
             73498  81722  66476  66470  67496  99286  67492  67490  66454  67510 100308 100306
             67476  69556  67474  69554 116714
        ]
    ] def

    % Row address patterns
    /raps [
        [  % Left and right
            802 930 946 818 882 890 826 954 922 986 970 906 778
            794 786 914 978 982 980 916 948 932 934 942 940 936
            808 812 814 806 822 950 918 790 788 820 884 868 870
            878 876 872 840 856 860 862 846 844 836 838 834 866
        ] [  % Centre
            718 590 622 558 550 566 534 530 538 570 562 546 610
            626 634 762 754 758 630 628 612 614 582 578 706 738
            742 740 748 620 556 552 616 744 712 716 708 710 646
            654 652 668 664 696 688 656 720 592 600 604 732 734
        ]
    ] def

    % Return the 17 bits for a codeword in a given cluster
    /cwtobits {
        clusters exch get exch get /v exch def
        [ 17 {0} repeat v 2 17 string cvrs {48 sub} forall ]
        dup length 17 sub 17 getinterval
    } bind def

    % Return the 10 bits for a row address pattern
    /raptobits {
        raps exch get exch get /v exch def
        [ 10 {0} repeat v 2 10 string cvrs {48 sub} forall ]
        dup length 10 sub 10 getinterval
    } bind def

    % Populate bitmap for the image
    /rwid [38 55 82 99] c 1 sub get def
    c 3 eq cca and {/rwid 72 def} if
    /pixs rwid r mul array def

    0 1 r 1 sub {
        /i exch def
        /clst i rapl add 1 sub 3 mod def
        pixs rwid i mul [
            c 1 eq {
                i rapl add 1 sub 52 mod 0 raptobits aload pop
                cws i get clst cwtobits aload pop
                i rapr add 1 sub 52 mod 0 raptobits aload pop
            } if
            c 2 eq {
                i rapl add 1 sub 52 mod 0 raptobits aload pop
                cws i 2 mul get clst cwtobits aload pop
                cws i 2 mul 1 add get clst cwtobits aload pop
                i rapr add 1 sub 52 mod 0 raptobits aload pop
            } if
            c 3 eq {
                cca not {
                    i rapl add 1 sub 52 mod 0 raptobits aload pop
                } if
                cws i 3 mul get clst cwtobits aload pop
                i rapc add 1 sub 52 mod 1 raptobits aload pop
                cws i 3 mul 1 add get clst cwtobits aload pop
                cws i 3 mul 2 add get clst cwtobits aload pop
                i rapr add 1 sub 52 mod 0 raptobits aload pop
            } if
            c 4 eq {
                i rapl add 1 sub 52 mod 0 raptobits aload pop
                cws i 4 mul get clst cwtobits aload pop
                cws i 4 mul 1 add get clst cwtobits aload pop
                i rapc add 1 sub 52 mod 1 raptobits aload pop
                cws i 4 mul 2 add get clst cwtobits aload pop
                cws i 4 mul 3 add get clst cwtobits aload pop
                i rapr add 1 sub 52 mod 0 raptobits aload pop
            } if
            1
        ] putinterval
    } for

    % Return the arguments
    <<
    /ren //renmatrix
    /pixs pixs
    /pixx rwid
    /pixy r
    /height r 72 div rowmult mul
    /width rwid 72 div
    /opt options
    >>

    dontdraw not //renmatrix if

    end

} bind def
/micropdf417 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER micropdf417--

% --BEGIN ENCODER datamatrix--
% --DESC: Data Matrix
% --EXAM: This is Data Matrix!
% --EXOP: rows=32 columns=32
% --RNDR: renmatrix
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/datamatrix {

    20 dict begin

    /options exch def
    /barcode exch def

    /dontdraw false def
    /columns 0 def
    /rows 0 def
    /encoding (byte) def
    /raw false def
    /parse false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /columns columns cvi def
    /rows rows cvi def

    % Parse ordinals of the form ^NNN to ASCII
    parse {
        /msg barcode length string def
        /j 0 def
        barcode
        { % loop
            (^) search {
                dup msg exch j exch putinterval
                length j add 1 add /j exch def
                pop
                dup 0 3 getinterval cvi msg exch j 1 sub exch put
                dup length 3 sub 3 exch getinterval
            } {
                dup msg exch j exch putinterval
                length j add /j exch def
                /barcode msg 0 j getinterval def
                exit
            } ifelse 
        } loop
    } if

    /barlen barcode length def

    raw {/encoding (raw) def} if

    encoding (raw) eq {
        /cws barlen array def
        /i 0 def /j 0 def
        { % loop
            i barlen eq {exit} if
            /cw barcode i 1 add 3 getinterval cvi def
            cws j cw put
            /i i 4 add def
            /j j 1 add def
        } loop
        /cws cws 0 j getinterval def
    } if

    encoding (byte) eq {
        barlen 250 lt {
            /cws [231 barlen barcode {} forall] def
        } {
            /cws [231 barlen 250 idiv 249 add barlen 250 mod barcode {} forall] def
        } ifelse 
        1 1 cws length 1 sub {
            /i exch def
            i 1 add 149 mul 255 mod 1 add cws i get add
            dup 256 ge {256 sub} if
            cws exch i exch put
        } for
    } if

    encoding (ascii) eq {
        /cws barlen 2 mul array def
        /i 0 def /j 0 def
        { % loop
            i barlen eq {exit} if
            /char barcode i get def
            char 48 ge char 57 le and i barlen 1 sub lt and {
                barcode i 1 add get dup 48 ge exch 57 le and {  % Digit pair
                    cws j barcode i 2 getinterval cvi 130 add put
                    /i i 2 add def
                    /j j 1 add def
                } {  % Singular digit
                    cws j char 1 add put
                    /i i 1 add def
                    /j j 1 add def
                } ifelse
            } { char 127 le {  % ASCII
                cws j char 1 add put
                /i i 1 add def
                /j j 1 add def
            } {  % Extended ASCII
                cws j 235 put
                cws j 1 add char 127 sub put
                /i i 1 add def
                /j j 2 add def
            } ifelse } ifelse
        } loop
        /cws cws 0 j getinterval def
    } if

    encoding (edifact) eq {
        /cws 1558 array def
        /i 0 def /j 1 def /k 0 def
        cws 0 240 put
        { % loop
            i barlen gt {exit} if
            /k 0 def /v 0 def
            { % loop until triplet is full or beyond end of data
                k 4 eq i barlen gt or {exit} if
                /cval (unset) def
                i barlen lt {
                    /char barcode i get def
                    char 32 ge char 94 le and {
                        /cval char 63 and def
                    } if
                } {  % Unlatch at end of data
                    /cval 31 def
                } ifelse
                /v v cval 3 k sub 6 mul bitshift or def
                /k k 1 add def
                /i i 1 add def
            } loop
            cws j [ v -16 bitshift v -8 bitshift 255 and v 255 and ] putinterval
            /j j 3 add def
        } loop
        /cws cws 0 j getinterval def
    } if

    encoding (c40) eq encoding (text) eq or encoding (x12) eq or {

        /s1 0 def /s2 1 def /s3 2 def /us 30 def

        encoding (c40) eq {
            /latch 230 def
            /charmap [
                0 1 31  { [ exch s1 exch ]            } for  % 0-31
                          [ 3 ]                              % 32
                0 1 14  { [ exch s2 exch ]            } for  % 33-47
                4 1 13  { [ exch ]                    } for  % 48-57
                15 1 21 { [ exch s2 exch ]            } for  % 58-64
                14 1 39 { [ exch ]                    } for  % 65-90
                22 1 26 { [ exch s2 exch ]            } for  % 91-95
                          [ s3 0 ]                           % 96 
                1 1 26  { [ exch s3 exch ]            } for  % 97-122
                27 1 31 { [ exch s3 exch ]            } for  % 123-127
                0 1 31  { [ s2 us 4 -1 roll s1 exch ] } for  % 128-159
                          [ s2 us 3 ]                        % 160
                0 1 14  { [ s2 us 4 -1 roll s2 exch ] } for  % 161-175
                4 1 13  { [ s2 us 4 -1 roll ]         } for  % 176-185
                15 1 21 { [ s2 us 4 -1 roll s2 exch ] } for  % 186-192
                14 1 39 { [ s2 us 4 -1 roll ]         } for  % 193-218
                22 1 26 { [ s2 us 4 -1 roll s2 exch ] } for  % 219-223
                          [ s2 us s3 0 ]                     % 224
                1 1 26  { [ s2 us 4 -1 roll s3 exch ] } for  % 225-250
                27 1 31 { [ s2 us 4 -1 roll s3 exch ] } for  % 251-255
            ] def
        } if

        encoding (text) eq {
            /latch 239 def
            /charmap [
                0 1 31  { [ exch s1 exch ]            } for  % 0-31
                          [ 3 ]                              % 32
                0 1 14  { [ exch s2 exch ]            } for  % 33-47
                4 1 13  { [ exch ]                    } for  % 48-57
                15 1 21 { [ exch s2 exch ]            } for  % 58-64
                1 1 26  { [ exch s3 exch ]            } for  % 65-90
                22 1 26 { [ exch s2 exch ]            } for  % 91-95
                          [ s3 0 ]                           % 96 
                14 1 39 { [ exch ]                    } for  % 97-122
                27 1 31 { [ exch s3 exch ]            } for  % 123-127
                0 1 31  { [ s2 us 4 -1 roll s1 exch ] } for  % 128-159
                          [ s2 us 3 ]                        % 160
                0 1 14  { [ s2 us 4 -1 roll s2 exch ] } for  % 161-175
                4 1 13  { [ s2 us 4 -1 roll ]         } for  % 176-185
                15 1 21 { [ s2 us 4 -1 roll s2 exch ] } for  % 186-192
                1 1 26  { [ s2 us 4 -1 roll s3 exch ] } for  % 193-218
                22 1 26 { [ s2 us 4 -1 roll s2 exch ] } for  % 219-223
                          [ s2 us s3 0 ]                     % 224
                14 1 39 { [ s2 us 4 -1 roll ]         } for  % 225-250
                27 1 31 { [ s2 us 4 -1 roll s3 exch ] } for  % 251-255
            ] def
         } if

         encoding (x12) eq {
             /latch 238 def
             /charmap [
                 13      { [ () ]   } repeat  % 0-12
                           [ 0 ]              % 13
                 18      { [ () ]   } repeat  % 14-31
                           [ 3 ]              % 32
                 9       { [ () ]   } repeat  % 33-41
                           [ 1 ]              % 42
                 5       { [ () ]   } repeat  % 43-47
                 4 1 13  { [ exch ] } for     % 48-57
                 4       { [ () ]   } repeat  % 58-61
                           [ 2 ]              % 62
                 2       { [ () ]   } repeat  % 63-64
                 14 1 39 { [ exch ] } for     % 65-90
                 165     { [ () ]   } repeat  % 91-255 
             ] def
         } if

         % Derive the encoded character stream
         /encstr barlen 4 mul array def
         /j 0 def
         0 1 barlen 1 sub {
             barcode exch get charmap exch get
             dup encstr exch j exch putinterval
             length j add /j exch def
         } for
         /encstr encstr 0 j getinterval def
         /enclen j def

         % Compress triples into doubles
         /cws 1558 array def
         /i 0 def /j 1 def /k 0 def
         cws 0 latch put
         { % loop
            i enclen ge {exit} if
            /k 0 def /v 1 def
            { % loop until triple is full or end of data
                k 3 eq i enclen ge or {exit} if
                /v v encstr i get 40 2 k sub exp cvi mul add def
                /k k 1 add def
                /i i 1 add def
            } loop
            cws j [ v -8 bitshift v 255 and ] putinterval
            /j j 2 add def
        } loop
        cws j 254 put
        /cws cws 0 j 1 add getinterval def

    } if

    % Basic metrics for the each symbol
    %    rows  cols  regh  regv  rscw  rsbl
    /metrics [
        % Standard square symbols
        [  10    10     1     1     5     1 ]
        [  12    12     1     1     7     1 ]
        [  14    14     1     1    10     1 ]
        [  16    16     1     1    12     1 ]
        [  18    18     1     1    14     1 ]
        [  20    20     1     1    18     1 ] 
        [  22    22     1     1    20     1 ]
        [  24    24     1     1    24     1 ]
        [  26    26     1     1    28     1 ]
        [  32    32     2     2    36     1 ]
        [  36    36     2     2    42     1 ]
        [  40    40     2     2    48     1 ]
        [  44    44     2     2    56     1 ]
        [  48    48     2     2    68     1 ]
        [  52    52     2     2    84     2 ]
        [  64    64     4     4   112     2 ]
        [  72    72     4     4   144     4 ]
        [  80    80     4     4   192     4 ]
        [  88    88     4     4   224     4 ]
        [  96    96     4     4   272     4 ]
        [ 104   104     4     4   336     6 ]
        [ 120   120     6     6   408     6 ]
        [ 132   132     6     6   496     8 ]
        [ 144   144     6     6   620    10 ]
        % Optional rectangular symbols
        [   8    18     1     1     7     1 ]
        [   8    32     1     2    11     1 ]
        [  12    26     1     1    14     1 ]
        [  12    36     1     2    18     1 ]
        [  16    36     1     2    24     1 ]
        [  16    48     1     2    28     1 ]
    ] def

    % Select metrics of an appropriate symbol
    /urows rows def
    /ucols columns def
    /i 0 def
    { % loop
        /m metrics i get def
        /rows m 0 get def                          % Rows in symbol
        /cols m 1 get def                          % Columns in symbol
        /regh m 2 get def                          % Horizontal regions
        /regv m 3 get def                          % Vertical regions
        /rscw m 4 get def                          % Error correction codewords
        /rsbl m 5 get def                          % Error correction blocks
        /mrows rows 2 regh mul sub def             % Rows in the mapping matrix
        /mcols cols 2 regv mul sub def             % Columns in the mapping matrix
        /rrows mrows regh idiv def                 % Rows per region
        /rcols mcols regv idiv def                 % Columns per region
        /ncws mrows mcols mul 8 idiv rscw sub def  % Data codewords
        /okay true def
        cws length ncws gt           {/okay false def} if
        urows 0 ne urows rows ne and {/okay false def} if
        ucols 0 ne ucols cols ne and {/okay false def} if
        okay {exit} if
        /i i 1 add def
    } loop

    % Extend cws to ncws codewords by addition of pseudo-randomised pad characters
    cws length ncws lt {
        /datlen cws length def
        /cws [ cws {} forall ncws datlen sub {129} repeat ] def
        datlen 1 add 1 ncws 1 sub {
            /i exch def
            i 1 add 149 mul 253 mod 1 add 129 add
            dup 254 gt {254 sub} if
            cws exch i exch put
        } for
    } if

    % De-interleave the codewords into blocks
    /cwbs rsbl array def  % Array of data codeword blocks
    /ecbs rsbl array def  % Array of error correction blocks
    0 1 rsbl 1 sub {
        /i exch def
        cws length 1558 ne {
            /cwbsize cws length rsbl idiv def
        } {
            i 7 le {/cwbsize 156 def} {/cwbsize 155 def} ifelse
        } ifelse
        /cwb cwbsize array def 
        0 1 cwbsize 1 sub {
            /j exch def
            cwb j cws j rsbl mul i add get put
        } for 
        cwbs i cwb put
        ecbs i [ rscw rsbl idiv {0} repeat ] put
    } for

    % Calculate the log and anti-log tables
    /rsalog [ 1 255 { dup 2 mul dup 256 ge {301 xor} if } repeat ] def
    /rslog 256 array def
    1 1 255 {dup rsalog exch get exch rslog 3 1 roll put} for

    % Function to calculate the product in the field
    /rsprod {
        2 copy 0 ne exch 0 ne and { 
            rslog exch get exch rslog exch get add 255 mod rsalog exch get
        } {
            pop pop 0
        } ifelse
    } bind def

    % Generate the coefficients
    /coeffs [ 1 rscw rsbl idiv {0} repeat ] def
    1 1 rscw rsbl idiv {
        /i exch def 
        coeffs i coeffs i 1 sub get put
        i 1 sub -1 1 {
            /j exch def
            coeffs j coeffs j 1 sub get coeffs j get rsalog i get rsprod xor put
        } for 
        coeffs 0 coeffs 0 get rsalog i get rsprod put
    } for
    /coeffs coeffs 0 coeffs length 1 sub getinterval def

    % Calculate the error correction codewords for each block
    0 1 cwbs length 1 sub {
        /i exch def
        /cwb cwbs i get def
        /ecb ecbs i get def
        0 1 cwb length 1 sub {
            /t exch cwb exch get ecb 0 get xor def 
            ecb length 1 sub -1 0 {
                /j exch def
                /p ecb length j sub 1 sub def
                ecb p t coeffs j get rsprod put
                j 0 gt { ecb p ecb p 1 add get ecb p get xor put } if
            } for 
        } for
    } for

    % Strange fixup for 144x144 symbols
    ncws 1558 eq {
        /ecbs [ ecbs 8 2 getinterval {} forall ecbs 0 8 getinterval {} forall ] def
    } if

    % Extend codewords with the interleaved error correction codes
    /cws [ cws {} forall rscw {0} repeat ] def
    0 1 rscw 1 sub {
        /i exch def
        cws ncws i add ecbs i rsbl mod get i rsbl idiv get put
    } for

    % Place the codewords into the matrix
    /module {
        % cw row col shape
        4 -1 roll 
        (00000000) 8 string copy dup 3 -1 roll 2 8 string cvrs 
        dup length 8 exch sub exch putinterval 
        7 -1 0 {1 index exch get 48 sub exch} for pop
        11 -3 roll
        % 1 2 4 8 16 32 64 128 row col shape
        {  % Place each bit of the codeword in the shape, MSB first
            exec
            1 index 0 lt {
                exch mrows add exch
                4 mrows 4 add 8 mod sub add
            } if
            dup 0 lt {
                mcols add exch
                4 mcols 4 add 8 mod sub add exch
            } if
            exch mcols mul add
            mmat exch 5 -1 roll put
        } forall
    } bind def

    % Placement patterns
    /dmn [
        { 2 copy 2 sub exch 2 sub exch } bind  { 2 copy 1 sub exch 2 sub exch } bind
        { 2 copy 2 sub exch 1 sub exch } bind  { 2 copy 1 sub exch 1 sub exch } bind
        { 2 copy exch 1 sub exch } bind        { 2 copy 2 sub } bind
        { 2 copy 1 sub } bind                  { 2 copy } bind
    ] def
    
    /dmc1 [
        { mrows 1 sub 0 } bind  { mrows 1 sub 1 } bind
        { mrows 1 sub 2 } bind  { 0 mcols 2 sub } bind
        { 0 mcols 1 sub } bind  { 1 mcols 1 sub } bind
        { 2 mcols 1 sub } bind  { 3 mcols 1 sub } bind
    ] def
    
    /dmc2 [
        { mrows 3 sub 0 } bind  { mrows 2 sub 0 } bind
        { mrows 1 sub 0 } bind  { 0 mcols 4 sub } bind
        { 0 mcols 3 sub } bind  { 0 mcols 2 sub } bind
        { 0 mcols 1 sub } bind  { 1 mcols 1 sub } bind
    ] def
    
    /dmc3 [
        { mrows 3 sub 0 } bind  { mrows 2 sub 0 } bind
        { mrows 1 sub 0 } bind  { 0 mcols 2 sub } bind
        { 0 mcols 1 sub } bind  { 1 mcols 1 sub } bind
        { 2 mcols 1 sub } bind  { 3 mcols 1 sub } bind
    ] def
    
    /dmc4 [
        { mrows 1 sub 0 } bind  { mrows 1 sub mcols 1 sub } bind
        { 0 mcols 3 sub } bind  { 0 mcols 2 sub } bind
        { 0 mcols 1 sub } bind  { 1 mcols 3 sub } bind
        { 1 mcols 2 sub } bind  { 1 mcols 1 sub } bind
    ] def

    /mmat [ mrows mcols mul {-1} repeat ] def
    cws length 1 sub -1 0 {cws exch get} for  % Reverse cws onto stack
    4 0  % Starting row and column
    { % loop
        2 copy 0 eq exch mrows eq and {
            dmc1 module
        } if
        2 copy 0 eq exch mrows 2 sub eq and mcols 4 mod 0 ne and {
            dmc2 module
        } if
        2 copy 0 eq exch mrows 2 sub eq and mcols 8 mod 4 eq and {
            dmc3 module
        } if
        2 copy 2 eq exch mrows 4 add eq and mcols 8 mod 0 eq and {
            dmc4 module
        } if

        { % loop for sweeping upwards
            2 copy 0 ge exch mrows lt and {
                2 copy exch mcols mul add mmat exch get -1 eq {
                    dmn module
                } if
            } if
            2 add exch 2 sub exch
            2 copy mcols lt exch 0 ge and not {exit} if
        } loop
        3 add exch 1 add exch

        { % loop for sweeping downwards
            2 copy mcols lt exch 0 ge and {
                2 copy exch mcols mul add mmat exch get -1 eq {
                    dmn module
                } if
            } if
            2 sub exch 2 add exch
            2 copy 0 ge exch mrows lt and not {exit} if
        } loop
        1 add exch 3 add exch

        2 copy mcols lt exch mrows lt or not {pop pop exit} if

    } loop

    % Set checker pattern if required
    mmat mrows mcols mul 1 sub get -1 eq {
        mmat mrows mcols 1 sub mul 2 sub [1 0] putinterval
        mmat mrows mcols mul 2 sub [0 1] putinterval
    } if

    % Place the modules onto a pixel map between alignment patterns
    /pixs rows cols mul array def
    /cwpos 0 def
    0 1 rows 1 sub {
        /i exch def
        i rrows 2 add mod 0 eq { pixs i cols mul [ cols 2 idiv {1 0} repeat ] putinterval } if  
        i rrows 2 add mod rrows 1 add eq { pixs i cols mul [ cols {1} repeat ] putinterval } if 
        i rrows 2 add mod 0 ne i rrows 2 add mod rrows 1 add ne and {
            0 1 cols 1 sub {
                /j exch def
                j rcols 2 add mod 0 eq { pixs i cols mul j add 1 put } if
                j rcols 2 add mod rcols 1 add eq { pixs i cols mul j add i 2 mod put } if
                j rcols 2 add mod 0 ne j rcols 2 add mod rcols 1 add ne and {
                    pixs i cols mul j add mmat cwpos get put
                    /cwpos cwpos 1 add def
                } if
            } for
        } if 
    } for

    % Return the arguments
    <<
    /ren //renmatrix
    /pixs pixs
    /pixx cols
    /pixy rows
    /height rows 72 div 1.5 mul
    /width cols 72 div 1.5 mul
    /opt options
    >>

    dontdraw not //renmatrix if

    end

} bind def
/datamatrix dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER datamatrix--

% --BEGIN ENCODER qrcode--
% --DESC: QR Code
% --EXAM: http://www.terryburton.co.uk/barcodewriter/
% --EXOP: eclevel=M
% --RNDR: renmatrix
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/qrcode {

    20 dict begin

    /options exch def
    /barcode exch def

    /dontdraw false def
    /format (full) def     % full or micro
    /version (unset) def
    /eclevel (unset) def   % L, M, Q or H
    /raw false def
    /parse false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    % Parse ordinals of the form ^NNN to ASCII
    parse {
        /msg barcode length string def
        /j 0 def
        barcode
        { % loop
            (^) search {
                dup msg exch j exch putinterval
                length j add 1 add /j exch def
                pop
                dup 0 3 getinterval cvi msg exch j 1 sub exch put
                dup length 3 sub 3 exch getinterval
            } {
                dup msg exch j exch putinterval
                length j add /j exch def
                /barcode msg 0 j getinterval def
                exit
            } ifelse 
        } loop
    } if

    % Force raw mode for micro format symbols
    format (micro) eq {/raw true def} if

    % Default to error correction level M
    eclevel (unset) eq {/eclevel (M) def} if

    % Convert from input into message bitstream
    raw {
        /msgbits barcode def 
    } {  % Simple autoencoder from input to bitstream using byte mode only for full format symbols

        /barlen barcode length def
        eclevel (unset) eq {/eclevel (M) def} if

        % Determine smallest symbol version to hold given amount of byte-encoded data
        version (unset) eq {
            /caps [
                [
                      17    32    53    78   106   134   154   192   230   271   % 1-L  - 10-L
                     321   367   425   458   520   586   644   718   792   858   % 11-L - 20-L
                     929  1003  1091  1171  1273  1367  1465  1528  1628  1732   % 21-L - 30-L
                    1840  1952  2068  2188  2303  2431  2563  2699  2809  2953   % 31-L - 40-L
                ] [
                      14    26    42    62    84   106   122   152   180   213   % 1-M  - 10-M
                     251   287   331   362   412   450   504   560   624   666   % 11-M - 20-M
                     711   779   857   911   997  1059  1125  1190  1264  1370   % 21-M - 30-M
                    1452  1538  1628  1722  1809  1911  1989  2099  2213  2331   % 31-M - 40-M
                ] [
                      11    20    32    46    60    74    86   108   130   151   % 1-Q  - 10-Q
                     177   203   241   258   292   322   364   394   442   482   % 11-Q - 20-Q
                     509   565   611   661   715   751   805   868   908   982   % 21-Q - 30-Q
                    1030  1112  1168  1228  1283  1351  1423  1499  1579  1663   % 31-Q - 40-Q
                ] [
                       7    14    24    34    44    58    64    84    98   119   % 1-H  - 10-H
                     137   155   177   194   220   250   280   310   338   382   % 11-H - 20-H
                     403   439   461   511   535   593   625   658   698   742   % 21-H - 30-H
                     790   842   898   958   983  1051  1093  1139  1219  1273   % 31-H - 40-H
                ]
            ] def
            /caps caps (LMQH) eclevel search pop length exch pop exch pop get def
            /i 1 def
            {
                barlen caps i 1 sub get le {exit} if 
                /i i 1 add def
            } loop
            /version i 10 2 string cvrs def
        } if

        % Set the control character data for the version
        /mid (0100) def /term (0000) def /cclen 8 def
        version 0 1 getinterval (M) ne {  % Version 10 and above
            version cvi 10 ge {/cclen 16 def} if
        } if
        /midlen mid length def
        /termlen term length def

        % Create the bitstream as byte_mode_id character_count data_bytes term
        /msgbits midlen cclen add barlen 8 mul add termlen add string def
        msgbits 0 mid putinterval
        (0000000000000000) 0 cclen getinterval cclen string copy 
        dup barlen cvi 2 cclen string cvrs dup length cclen exch sub exch putinterval 
        /cc exch def
        msgbits midlen cc putinterval
        0 1 barlen 1 sub {
            /i exch def
            (00000000) 8 string copy dup barcode i get cvi 2 8 string cvrs dup length 8 exch sub exch putinterval 
            msgbits midlen cclen add i 8 mul add 3 -1 roll putinterval
        } for
        msgbits midlen cclen add barlen 8 mul add term putinterval

    } ifelse

    % Lookup the most appropriate symbol specification
    /metrics [
        % format   vers  size align modules    error codewords        error correction blocks 
        %                                      L    M    Q    H       L1 L2 M1 M2 Q1 Q2 H1 H2
        [ (micro)  (M1)   11  98 99     36  [   2   99   99   99 ]  [  1  0 -1 -1 -1 -1 -1 -1 ] ]
        [ (micro)  (M2)   13  98 99     80  [   5    6   99   99 ]  [  1  0  1  0 -1 -1 -1 -1 ] ]
        [ (micro)  (M3)   15  98 99    132  [   6    8   99   99 ]  [  1  0  1  0 -1 -1 -1 -1 ] ]
        [ (micro)  (M4)   17  98 99    192  [   8   10   14   99 ]  [  1  0  1  0  1  0 -1 -1 ] ]
        [ (full)   (1)    21  98 99    208  [   7   10   13   17 ]  [  1  0  1  0  1  0  1  0 ] ]
        [ (full)   (2)    25  18 99    359  [  10   16   22   28 ]  [  1  0  1  0  1  0  1  0 ] ]
        [ (full)   (3)    29  22 99    567  [  15   26   36   44 ]  [  1  0  1  0  2  0  2  0 ] ]
        [ (full)   (4)    33  26 99    807  [  20   36   52   64 ]  [  1  0  2  0  2  0  4  0 ] ]
        [ (full)   (5)    37  30 99   1079  [  26   48   72   88 ]  [  1  0  2  0  2  2  2  2 ] ]
        [ (full)   (6)    41  34 99   1383  [  36   64   96  112 ]  [  2  0  4  0  4  0  4  0 ] ]
        [ (full)   (7)    45  22 38   1568  [  40   72  108  130 ]  [  2  0  4  0  2  4  4  1 ] ]
        [ (full)   (8)    49  24 42   1936  [  48   88  132  156 ]  [  2  0  2  2  4  2  4  2 ] ]
        [ (full)   (9)    53  26 46   2336  [  60  110  160  192 ]  [  2  0  3  2  4  4  4  4 ] ]
        [ (full)   (10)   57  28 50   2768  [  72  130  192  224 ]  [  2  2  4  1  6  2  6  2 ] ]
        [ (full)   (11)   61  30 54   3232  [  80  150  224  264 ]  [  4  0  1  4  4  4  3  8 ] ]
        [ (full)   (12)   65  32 58   3728  [  96  176  260  308 ]  [  2  2  6  2  4  6  7  4 ] ]
        [ (full)   (13)   69  34 62   4256  [ 104  198  288  352 ]  [  4  0  8  1  8  4 12  4 ] ]
        [ (full)   (14)   73  26 46   4651  [ 120  216  320  384 ]  [  3  1  4  5 11  5 11  5 ] ]
        [ (full)   (15)   77  26 48   5243  [ 132  240  360  432 ]  [  5  1  5  5  5  7 11  7 ] ]
        [ (full)   (16)   81  26 50   5867  [ 144  280  408  480 ]  [  5  1  7  3 15  2  3 13 ] ]
        [ (full)   (17)   85  30 54   6523  [ 168  308  448  532 ]  [  1  5 10  1  1 15  2 17 ] ]
        [ (full)   (18)   89  30 56   7211  [ 180  338  504  588 ]  [  5  1  9  4 17  1  2 19 ] ]
        [ (full)   (19)   93  30 58   7931  [ 196  364  546  650 ]  [  3  4  3 11 17  4  9 16 ] ]
        [ (full)   (20)   97  34 62   8683  [ 224  416  600  700 ]  [  3  5  3 13 15  5 15 10 ] ]
        [ (full)   (21)  101  28 50   9252  [ 224  442  644  750 ]  [  4  4 17  0 17  6 19  6 ] ]
        [ (full)   (22)  105  26 50  10068  [ 252  476  690  816 ]  [  2  7 17  0  7 16 34  0 ] ]
        [ (full)   (23)  109  30 54  10916  [ 270  504  750  900 ]  [  4  5  4 14 11 14 16 14 ] ]
        [ (full)   (24)  113  28 54  11796  [ 300  560  810  960 ]  [  6  4  6 14 11 16 30  2 ] ]
        [ (full)   (25)  117  32 58  12708  [ 312  588  870 1050 ]  [  8  4  8 13  7 22 22 13 ] ]
        [ (full)   (26)  121  30 58  13652  [ 336  644  952 1110 ]  [ 10  2 19  4 28  6 33  4 ] ]
        [ (full)   (27)  125  34 62  14628  [ 360  700 1020 1200 ]  [  8  4 22  3  8 26 12 28 ] ]
        [ (full)   (28)  129  26 50  15371  [ 390  728 1050 1260 ]  [  3 10  3 23  4 31 11 31 ] ]
        [ (full)   (29)  133  30 54  16411  [ 420  784 1140 1350 ]  [  7  7 21  7  1 37 19 26 ] ]
        [ (full)   (30)  137  26 52  17483  [ 450  812 1200 1440 ]  [  5 10 19 10 15 25 23 25 ] ]
        [ (full)   (31)  141  30 56  18587  [ 480  868 1290 1530 ]  [ 13  3  2 29 42  1 23 28 ] ]
        [ (full)   (32)  145  34 60  19723  [ 510  924 1350 1620 ]  [ 17  0 10 23 10 35 19 35 ] ]
        [ (full)   (33)  149  30 58  20891  [ 540  980 1440 1710 ]  [ 17  1 14 21 29 19 11 46 ] ]
        [ (full)   (34)  153  34 62  22091  [ 570 1036 1530 1800 ]  [ 13  6 14 23 44  7 59  1 ] ]
        [ (full)   (35)  157  30 54  23008  [ 570 1064 1590 1890 ]  [ 12  7 12 26 39 14 22 41 ] ]
        [ (full)   (36)  161  24 50  24272  [ 600 1120 1680 1980 ]  [  6 14  6 34 46 10  2 64 ] ]
        [ (full)   (37)  165  28 54  25568  [ 630 1204 1770 2100 ]  [ 17  4 29 14 49 10 24 46 ] ]
        [ (full)   (38)  169  32 58  26896  [ 660 1260 1860 2220 ]  [  4 18 13 32 48 14 42 32 ] ]
        [ (full)   (39)  173  26 54  28256  [ 720 1316 1950 2310 ]  [ 20  4 40  7 43 22 10 67 ] ]
        [ (full)   (40)  177  30 58  29648  [ 750 1372 2040 2430 ]  [ 19  6 18 31 34 34 20 61 ] ]
    ] def
    /eclval (LMQH) eclevel search pop length exch pop exch pop def
    /i 0 def
    { % loop
        /m metrics i get def
        /frmt m 0 get def                             % Format of the symbol
        /vers m 1 get def                             % Version of symbol
        /size m 2 get def                             % Length of side
        /asp2 m 3 get def                             % Position of second alignment symbol
        /asp3 m 4 get def                             % Position of third alignment symbol
        /nmod m 5 get def                             % Number of modules
        /ncws nmod 8 idiv def                         % Total number of codewords
        /rbit nmod 8 mod def                          % Number of remainder bits
        /lc4b false def                               % Last data codeword is 4 bits long
        size 11 eq size 15 eq or {                    % Adjustments for M1 and M3 symbols
            /ncws ncws 1 add def
            /rbit 0 def
            /lc4b true def
        } if
        /ecws m 6 get eclval get def                  % Number of error correction codewords
        /dcws ncws ecws sub def                       % Number of data codewords
        /dmod dcws 8 mul lc4b {4} {0} ifelse sub def  % Number of data modules
        /ecb1 m 7 get eclval 2 mul get def            % First error correction blocks
        /ecb2 m 7 get eclval 2 mul 1 add get def      % Second error correction blocks
        /okay true def
        format frmt ne {/okay false def} if           % The format must match that supplied
        version (unset) ne version vers ne and {/okay false def} if  % The version must match that supplied
        msgbits length dmod gt {/okay false def} if   % Bitstream must fit into data modules
        ecb1 -1 eq ecb2 -1 eq or {/okay false def} if % Error correction level must be valid
        okay {exit} if
        /i i 1 add def
    } loop
    /format frmt def
    /version vers def
    /dcpb dcws ecb1 ecb2 add idiv def                 % Base data codewords per block
    /ecpb ncws ecb1 ecb2 add idiv dcpb sub def        % Error correction codewords per block

    % Expand the message bits by adding padding as necessary
    /pad dmod string def
    0 4 dmod 1 sub {pad exch (0000) putinterval} for
    pad 0 msgbits putinterval
    /padstrs [ (11101100) (00010001) ] def
    /padnum 0 def
    msgbits length 8 div ceiling 8 mul cvi 8 dmod lc4b {5} {1} ifelse sub {
        pad exch padstrs padnum get putinterval 
        /padnum padnum 1 add 2 mod def
    } for

    % Evaluate the padded message into codewords
    /cws dcws array def 
    0 1 cws length 1 sub {
        /c exch def
        /bpcw 8 def
        lc4b c cws length 1 sub eq and {/bpcw 4 def} if
        /cwb pad c 8 mul bpcw getinterval def
        /cw 0 def
        0 1 bpcw 1 sub {
            /i exch def
            /cw cw 2 bpcw i sub 1 sub exp cvi cwb i get 48 sub mul add def
        } for 
        cws c cw put
    } for 

    % Calculate the log and anti-log tables
    /rsalog [ 1 255 { dup 2 mul dup 256 ge {285 xor} if } repeat ] def
    /rslog 256 array def
    1 1 255 {dup rsalog exch get exch rslog 3 1 roll put} for

    % Function to calculate the product in the field
    /rsprod {
        2 copy 0 ne exch 0 ne and { 
            rslog exch get exch rslog exch get add 255 mod rsalog exch get
        } {
            pop pop 0
        } ifelse
    } bind def

    % Generate the coefficients for the Reed-Solomon algorithm
    /coeffs [ 1 ecpb {0} repeat ] def
    0 1 ecpb 1 sub {
        /i exch def 
        coeffs i 1 add coeffs i get put
        i -1 1 {
            /j exch def
            coeffs j coeffs j 1 sub get coeffs j get rsalog i get rsprod xor put
        } for 
        coeffs 0 coeffs 0 get rsalog i get rsprod put
    } for
    /coeffs coeffs 0 coeffs length 1 sub getinterval def

    % Reed-Solomon algorithm to derive the error correction codewords
    /rscodes {
        /rscws exch def
        /rsnd rscws length def
        /rscws [ rscws {} forall ecpb {0} repeat ] def
        0 1 rsnd 1 sub {
            /m exch def
            /k rscws m get def
            0 1 ecpb 1 sub {
                /j exch def
                rscws m j add 1 add coeffs ecpb j sub 1 sub get k rsprod rscws m j add 1 add get xor put
            } for
        } for
        rscws rsnd ecpb getinterval
    } bind def

    % Divide codewords into two groups of blocks and calculate the error correction codewords
    /dcwsb ecb1 ecb2 add array def
    /ecwsb ecb1 ecb2 add array def
    0 1 ecb1 1 sub {  % First group of blocks has smaller number of data codewords
        /i exch def
        dcwsb i cws i dcpb mul dcpb getinterval put
        ecwsb i dcwsb i get rscodes put
    } for
    0 1 ecb2 1 sub {  % Second group of blocks has larger number of data codewords
        /i exch def
        dcwsb ecb1 i add cws ecb1 dcpb mul i dcpb 1 add mul add dcpb 1 add getinterval put
        ecwsb ecb1 i add dcwsb ecb1 i add get rscodes put
    } for
    
    % Reassemble the codewords
    /cws ncws array def
    /cw 0 def
    0 1 dcpb {  % Interleave the data codeword blocks
        /i exch def
        0 1 ecb1 ecb2 add 1 sub {
            /j exch def
            i dcwsb j get length lt {  % Ignore the end of short blocks
                cws cw dcwsb j get i get put
                /cw cw 1 add def
            } if
        } for
    } for
    0 1 ecpb 1 sub {  % Interleave the error codeword blocks
        /i exch def
        0 1 ecb1 ecb2 add 1 sub {
            /j exch def
            cws cw ecwsb j get i get put
            /cw cw 1 add def
        } for
    } for
    
    % Extend codewords by one if there are remainder bits
    rbit 0 gt {
        /pad cws length 1 add array def
        pad 0 cws putinterval
        pad pad length 1 sub 0 put
        /cws pad def
    } if
 
    % Fixups for the short final data byte in M1 and M3 symbols
    lc4b {
        dcws 1 sub 1 ncws 2 sub {
            /i exch def
            cws i cws i get 15 and 4 bitshift put
            cws i cws i 1 add get -4 bitshift 15 and cws i get or put
        } for
        cws ncws 1 sub cws ncws 1 sub get 15 and 4 bitshift put
    } if

    % Create the bitmap
    /pixs [ size size mul {-1} repeat ] def
    /qmv {size mul add} bind def
    
    % Finder patterns
    /fpat [
        [ 1 1 1 1 1 1 1 0 ]
        [ 1 0 0 0 0 0 1 0 ]
        [ 1 0 1 1 1 0 1 0 ]
        [ 1 0 1 1 1 0 1 0 ]
        [ 1 0 1 1 1 0 1 0 ]
        [ 1 0 0 0 0 0 1 0 ]
        [ 1 1 1 1 1 1 1 0 ]
        [ 0 0 0 0 0 0 0 0 ]
    ] def
    0 1 fpat length 1 sub {
      /y exch def
      0 1 fpat 0 get length 1 sub {
        /x exch def
        /fpb fpat y get x get def
        pixs x y qmv fpb put
        format (full) eq {
            pixs size x sub 1 sub y qmv fpb put
            pixs x size y sub 1 sub qmv fpb put
        } if
      } for
    } for
    
    % Alignment patterns
    /algnpat [
        [ 1 1 1 1 1 ]
        [ 1 0 0 0 1 ]
        [ 1 0 1 0 1 ]
        [ 1 0 0 0 1 ]
        [ 1 1 1 1 1 ]
    ] def
    /putalgnpat {
        /py exch def
        /px exch def
        0 1 4 {
            /pb exch def
            0 1 4 {
                /pa exch def
                pixs px pa add py pb add qmv algnpat pb get pa get put
            } for
        } for
    } bind def
    asp2 2 sub asp3 asp2 sub size 13 sub {
        /i exch def
        i 4 putalgnpat
        4 i putalgnpat
    } for
    asp2 2 sub asp3 asp2 sub size 9 sub { 
        /x exch def
        asp2 2 sub asp3 asp2 sub size 9 sub {
            /y exch def
            x y putalgnpat
        } for
    } for
    
    % Timing patterns
    format (full) eq {
        8 1 size 9 sub {
            /i exch def
            pixs i 6 qmv i 1 add 2 mod put
            pixs 6 i qmv i 1 add 2 mod put
        } for
    } {
        8 1 size 1 sub {
            /i exch def
            pixs i 0 qmv i 1 add 2 mod put
            pixs 0 i qmv i 1 add 2 mod put
        } for
    } ifelse
    
    % Format information modules
    format (full) eq {
        /formatmap [
            [ [ 0 8 ] [ 8 size 1 sub ] ]  [ [ 1 8 ] [ 8 size 2 sub ] ]  [ [ 2 8 ] [ 8 size 3 sub ] ]
            [ [ 3 8 ] [ 8 size 4 sub ] ]  [ [ 4 8 ] [ 8 size 5 sub ] ]  [ [ 5 8 ] [ 8 size 6 sub ] ]
            [ [ 7 8 ] [ 8 size 7 sub ] ]  [ [ 8 8 ] [ size 8 sub 8 ] ]  [ [ 8 7 ] [ size 7 sub 8 ] ]
            [ [ 8 5 ] [ size 6 sub 8 ] ]  [ [ 8 4 ] [ size 5 sub 8 ] ]  [ [ 8 3 ] [ size 4 sub 8 ] ]
            [ [ 8 2 ] [ size 3 sub 8 ] ]  [ [ 8 1 ] [ size 2 sub 8 ] ]  [ [ 8 0 ] [ size 1 sub 8 ] ]
        ] def
    } {
        /formatmap [
            [ [ 1 8 ] ]  [ [ 2 8 ] ]  [ [ 3 8 ] ]  [ [ 4 8 ] ]  [ [ 5 8 ] ]
            [ [ 6 8 ] ]  [ [ 7 8 ] ]  [ [ 8 8 ] ]  [ [ 8 7 ] ]  [ [ 8 6 ] ]
            [ [ 8 5 ] ]  [ [ 8 4 ] ]  [ [ 8 3 ] ]  [ [ 8 2 ] ]  [ [ 8 1 ] ]
        ] def
    } ifelse
    formatmap {
        { {} forall qmv pixs exch 0 put } forall
    } forall
    
    % Version information modules
    size 45 ge {
        /versionmap [
            [ [ size  9 sub 5 ] [ 5 size  9 sub ] ]  [ [ size 10 sub 5 ] [ 5 size 10 sub ] ]
            [ [ size 11 sub 5 ] [ 5 size 11 sub ] ]  [ [ size  9 sub 4 ] [ 4 size  9 sub ] ]
            [ [ size 10 sub 4 ] [ 4 size 10 sub ] ]  [ [ size 11 sub 4 ] [ 4 size 11 sub ] ]
            [ [ size  9 sub 3 ] [ 3 size  9 sub ] ]  [ [ size 10 sub 3 ] [ 3 size 10 sub ] ]
            [ [ size 11 sub 3 ] [ 3 size 11 sub ] ]  [ [ size  9 sub 2 ] [ 2 size  9 sub ] ]
            [ [ size 10 sub 2 ] [ 2 size 10 sub ] ]  [ [ size 11 sub 2 ] [ 2 size 11 sub ] ]
            [ [ size  9 sub 1 ] [ 1 size  9 sub ] ]  [ [ size 10 sub 1 ] [ 1 size 10 sub ] ]
            [ [ size 11 sub 1 ] [ 1 size 11 sub ] ]  [ [ size  9 sub 0 ] [ 0 size  9 sub ] ]
            [ [ size 10 sub 0 ] [ 0 size 10 sub ] ]  [ [ size 11 sub 0 ] [ 0 size 11 sub ] ]
        ] def
    } {
        /versionmap [] def
    } ifelse
    versionmap {
        { {} forall qmv pixs exch 0 put } forall
    } forall
    
    % Solitary dark module in full symbols
    format (full) eq {
        pixs 8 size 8 sub qmv 1 put
    } if
    
    % Calculate the mask patterns
    format (full) eq {
        /maskfuncs [ 
            {add 2 mod} bind
            {exch pop 2 mod} bind
            {pop 3 mod} bind
            {add 3 mod} bind
            {2 idiv exch 3 idiv add 2 mod} bind
            {mul dup 2 mod exch 3 mod add} bind
            {mul dup 2 mod exch 3 mod add 2 mod} bind
            {2 copy mul 3 mod 3 1 roll add 2 mod add 2 mod} bind
        ] def
    } {
        /maskfuncs [ 
            {exch pop 2 mod} bind
            {2 idiv exch 3 idiv add 2 mod} bind
            {mul dup 2 mod exch 3 mod add 2 mod} bind
            {2 copy mul 3 mod 3 1 roll add 2 mod add 2 mod} bind
        ] def
    } ifelse
    /masks maskfuncs length array def
    0 1 masks length 1 sub {
        /m exch def
        /mask size size mul array def
        0 1 size 1 sub {
            /j exch def
            0 1 size 1 sub {
                /i exch def
                i j maskfuncs m get exec 0 eq 
                pixs i j qmv get -1 eq and {1} {0} ifelse
                mask i j qmv 3 -1 roll put
            } for
        } for
        masks m mask put
    } for
    
    % Walk the symbol placing the bitstream
    /posx size 1 sub def
    /posy size 1 sub def
    /dir -1 def  % -1 is upwards, 1 is downwards
    /col 1 def   % 0 is left bit, 1 is right bit
    /num 0 def
    { % loop
        posx 0 lt {exit} if
        pixs posx posy qmv get -1 eq {
            cws num 8 idiv get 7 num 8 mod sub neg bitshift 1 and
            pixs posx posy qmv 3 -1 roll put
            /num num 1 add def
        } if
        col 1 eq {
            /col 0 def
            /posx posx 1 sub def
        } {
            /col 1 def
            /posx posx 1 add def 
            /posy posy dir add def
            posy 0 lt posy size ge or {  % Turn around at top and bottom
                /dir dir -1 mul def
                /posy posy dir add def
                /posx posx 2 sub def
                % Hop over the timing pattern in full size symbols
                format (full) eq posx 6 eq and {/posx posx 1 sub def} if
            } if
        } ifelse
    } loop

    % Evaluate runlength encoded rows or columns in full symbols
    /evalfulln1n3 {
        /scrle exch def
        % Detect runs of 5 or more like modules
        /scr1 0 scrle { dup 5 ge {add 2 sub dup} if pop } forall def
        % Detect 1:1:3:1:1 ratio next to 4 modules of whitespace
        /scr3 0 def
        3 2 scrle length 3 sub {  % Scan odd (dark) runs within bounds
            /j exch def
            scrle j get 3 mod 0 eq {  % Multiple of 3 black modules
                /fact scrle j get 3 idiv def
                scrle j 2 sub 5 getinterval {fact eq} forall and exch pop and and {
                    j 3 eq j 4 add scrle length ge or {  % At either extent of run
                        /scr3 scr3 40 add def
                    } {  % Bounded by dark modules
                        scrle j 3 sub get 4 ge scrle j 3 add get 4 ge or {
                            /scr3 scr3 40 add def
                        } if
                    } ifelse
                } if
            } if
        } for
        scr1 scr3
    } bind def
    
    % Evaluation algorithm for full symbols
    /evalfull {
        /sym exch def

        /n1 0 def /n2 0 def /n3 0 def
        /rle size 1 add array def
        /lastpairs size array def
        /thispairs size array def
        /sizeadd1 size 1 add def
        0 1 size 1 sub {  
            /i exch def

            % Runlength encode (light, dark, light, ...) and evaluate each column
            mark 0 0
            i size dup dup mul 1 sub {
                sym exch get exch 1 index eq {exch 1 add exch} {1 exch} ifelse
            } for
            pop
            rle 0 counttomark 2 sub getinterval astore
            evalfulln1n3 n3 add /n3 exch def n1 add /n1 exch def
            pop

            % Runlength encode (light, dark, light, ...) and evaluate each row
            /symrow sym i size mul size getinterval def
            mark 0 0 
            symrow { 
                exch 1 index eq {exch 1 add exch} {1 exch} ifelse
            } forall 
            pop
            rle 0 counttomark 2 sub getinterval astore
            evalfulln1n3 n3 add /n3 exch def n1 add /n1 exch def
            pop

            % Count and score same coloured blocks
            /lastpairs thispairs /thispairs lastpairs def def
            symrow 0 get 1 eq {0} {1} ifelse
            symrow {exch 1 index add exch} forall
            pop
            thispairs astore pop
            i 0 gt {
                mark
                lastpairs aload pop thispairs aload pop
                n2 size { exch sizeadd1 index add 3 and 0 eq {3 add} if } repeat
                /n2 exch def
                cleartomark
            } if

        } for
 
        % Score dark/light imbalance 
        /dark 0 sym {add} forall def
        /n4 dark 100 mul size dup mul div 50 sub abs 5 div cvi 10 mul def

        n1 n2 add n3 add n4 add
    } bind def
 
    % Evaluation algorithm for micro symbols
    /evalmicro {
        /sym exch def
        /dkrhs 0 def /dkbot 0 def
        1 1 size 1 sub {
            /i exch def
            /dkrhs dkrhs sym size 1 sub i qmv get add def
            /dkbot dkbot sym i size 1 sub qmv get add def
        } for
        dkrhs dkbot le {
            dkrhs 16 mul dkbot add neg
        } {
            dkbot 16 mul dkrhs add neg
        } ifelse
    } bind def
    
    % Evaluate the masked symbols to find the most suitable
    /bestscore 999999999 def
    0 1 masks length 1 sub {
        /m exch def
        /masksym size size mul array def
        0 1 size size mul 1 sub {
            /i exch def
            masksym i pixs i get masks m get i get xor put
        } for
        format (full) eq {
            masksym evalfull /score exch def
        } {
            masksym evalmicro /score exch def
        } ifelse
        score bestscore lt { 
            /bestsym masksym def
            /bestmaskval m def
            /bestscore score def
        } if    
    } for
    /pixs bestsym def
    
    % Add the format information
    format (full) eq {
        /fmtvals [
            16#5412 16#5125 16#5e7c 16#5b4b 16#45f9 16#40ce 16#4f97 16#4aa0 
            16#77c4 16#72f3 16#7daa 16#789d 16#662f 16#6318 16#6c41 16#6976
            16#1689 16#13be 16#1ce7 16#19d0 16#0762 16#0255 16#0d0c 16#083b 
            16#355f 16#3068 16#3f31 16#3a06 16#24b4 16#2183 16#2eda 16#2bed
        ] def
        /ecid (MLHQ) eclevel search pop length exch pop exch pop def
        /fmtval fmtvals ecid 3 bitshift bestmaskval add get def
    } {
        /fmtvals [
            16#4445 16#4172 16#4e2b 16#4b1c 16#55ae 16#5099 16#5fc0 16#5af7
            16#6793 16#62a4 16#6dfd 16#68ca 16#7678 16#734f 16#7c16 16#7921
            16#06de 16#03e9 16#0cb0 16#0987 16#1735 16#1202 16#1d5b 16#186c
            16#2508 16#203f 16#2f66 16#2a51 16#34e3 16#31d4 16#3e8d 16#3bba
        ] def
        /symid [ [0] [1 2] [3 4] [5 6 7] ] size 11 sub 2 idiv get eclval get def
        /fmtval fmtvals symid 2 bitshift bestmaskval add get def
    } ifelse
    0 1 formatmap length 1 sub {
        /i exch def
        formatmap i get {
            pixs exch {} forall qmv fmtval 14 i sub neg bitshift 1 and put
        } forall
    } for
    
    % Add the version information
    size 45 ge {
        /vervals [
            16#07c94 16#085bc 16#09a99 16#0a4d3 16#0bbf6 16#0c762 16#0d847 
            16#0e60d 16#0f928 16#10b78 16#1145d 16#12a17 16#13532 16#149a6 
            16#15683 16#168c9 16#177ec 16#18ec4 16#191e1 16#1afab 16#1b08e 
            16#1cc1a 16#1d33f 16#1ed75 16#1f250 16#209d5 16#216fd 16#228ba 
            16#2379f 16#24b0b 16#2542e 16#26a64 16#27541 16#28c69
        ] def
        /verval vervals size 17 sub 4 idiv 7 sub get def
        0 1 versionmap length 1 sub {
            /i exch def
            versionmap i get {
                pixs exch {} forall qmv verval 17 i sub neg bitshift 1 and put
            } forall
        } for
    } if

    % Return the arguments
    <<
    /ren //renmatrix
    /pixs pixs
    /pixx size
    /pixy size
    /height size 2 mul 72 div
    /width size 2 mul 72 div
    /opt options
    >>

    dontdraw not //renmatrix if

    end

} bind def
/qrcode dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER qrcode--

% --BEGIN ENCODER maxicode--
% --DESC: MaxiCode
% --EXAM: [\)>^03001^02996152382802^029840^029001^0291Z00004951^029UPSN^02906X610^029159^0291234567^0291/1^029^029Y^029634 ALPHA DR^029PITTSBURGH^029PA^029^004
% --EXOP: mode=2 parse
% --RNDR: renmaximatrix
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renmaximatrix dup /uk.co.terryburton.bwipp findresource put
begin
/maxicode {

    20 dict begin

    /options exch def        % We are given an option string
    /barcode exch def        % We are given a barcode string

    /dontdraw false def
    /mode -1 def
    /sam -1 def
    /parse false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /mode mode cvi def
    /sam sam cvi def

    % Parse ordinals of the form ^NNN to ASCII
    parse {
        /msg barcode length string def
        /j 0 def
        barcode
        { % loop
            (^) search {
                dup msg exch j exch putinterval
                length j add 1 add /j exch def
                pop
                dup 0 3 getinterval cvi msg exch j 1 sub exch put
                dup length 3 sub 3 exch getinterval
            } {
                dup msg exch j exch putinterval
                length j add /j exch def
                /barcode msg 0 j getinterval def
                exit
            } ifelse 
        } loop
    } if
    
    /msg barcode def
    /msglen msg length def

    % Special message handling for modes 2 and 3
    mode 2 eq mode 3 eq or {

        % Normalise messages that begin with a field identifier [)>RS01GSyy
        msg 0 7 getinterval <5b293e1e30311d> eq {
            /fid msg 0 9 getinterval def
            /msg msg 9 msglen 9 sub getinterval def 
        } {
            /fid () def
        } ifelse

        % Read the postcode, country code and service code fields seperated by GS
        msg <1d> search pop /pcode exch def
        pop <1d> search pop /ccode exch def
        pop <1d> search pop /scode exch def
        pop /msg exch def

        % Prepend the field identifier
        msg length fid length add string dup
        0 fid putinterval dup 
        fid length msg putinterval
        /msg exch def
        /msglen msg length def

    } if

    % Special function characters
    /eci -1 def  /pad -2 def  /ns -3 def
    /la  -4 def  /lb  -5 def
    /sa  -6 def  /sb  -7 def  /sc -8 def  /sd -9 def  /se -10 def
    /sa2 -11 def /sa3 -12 def  
    /lkc -13 def /lkd -14 def /lke -15 def
    /pd2 -16 def /pd3 -17 def 
    
    % Character maps for each state
    /charmaps [
        %  A    B    C    D    E
        [  13  (`)  192  224    0 ]  % 0
        [ (A)  (a)  193  225    1 ]  % 1
        [ (B)  (b)  194  226    2 ]  % 2
        [ (C)  (c)  195  227    3 ]  % 3
        [ (D)  (d)  196  228    4 ]  % 4
        [ (E)  (e)  197  229    5 ]  % 5
        [ (F)  (f)  198  230    6 ]  % 6
        [ (G)  (g)  199  231    7 ]  % 7
        [ (H)  (h)  200  232    8 ]  % 8
        [ (I)  (i)  201  233    9 ]  % 9 
        [ (J)  (j)  202  234   10 ]  % 10
        [ (K)  (k)  203  235   11 ]  % 11
        [ (L)  (l)  204  236   12 ]  % 12
        [ (M)  (m)  205  237   13 ]  % 13
        [ (N)  (n)  206  238   14 ]  % 14
        [ (O)  (o)  207  239   15 ]  % 15
        [ (P)  (p)  208  240   16 ]  % 16
        [ (Q)  (q)  209  241   17 ]  % 17
        [ (R)  (r)  210  242   18 ]  % 18
        [ (S)  (s)  211  243   19 ]  % 19
        [ (T)  (t)  212  244   20 ]  % 20
        [ (U)  (u)  213  245   21 ]  % 21
        [ (V)  (v)  214  246   22 ]  % 22
        [ (W)  (w)  215  247   23 ]  % 23
        [ (X)  (x)  216  248   24 ]  % 24
        [ (Y)  (y)  217  249   25 ]  % 25
        [ (Z)  (z)  218  250   26 ]  % 26
        [ eci  eci  eci  eci  eci ]  % 27
        [  28   28   28   28  pad ]  % 28
        [  29   29   29   29  pad ]  % 29
        [  30   30   30   30   27 ]  % 30
        [  ns   ns   ns   ns   ns ]  % 31
        [ ( )  ({)  219  251   28 ]  % 32
        [ pad  pad  220  252   29 ]  % 33
        [ (")  (})  221  253   30 ]  % 34
        [ (#)  (~)  222  254   31 ]  % 35
        [ ($)  127  223  255  159 ]  % 36
        [ (%)  (;)  170  161  160 ]  % 37
        [ (&)  (<)  172  168  162 ]  % 38
        [ (')  (=)  177  171  163 ]  % 39
        [  40  (>)  178  175  164 ]  % 40
        [  41  (?)  179  176  165 ]  % 41
        [ (*)  ([)  181  180  166 ]  % 42
        [ (+)   92  185  183  167 ]  % 43
        [ (,)  (])  186  184  169 ]  % 44
        [ (-)  (^)  188  187  173 ]  % 45
        [ (.)  (_)  189  191  174 ]  % 46
        [ (/)  ( )  190  138  182 ]  % 47
        [ (0)  (,)  128  139  149 ]  % 48
        [ (1)  (.)  129  140  150 ]  % 49
        [ (2)  (/)  130  141  151 ]  % 50
        [ (3)  (:)  131  142  152 ]  % 51
        [ (4)  (@)  132  143  153 ]  % 52
        [ (5)  (!)  133  144  154 ]  % 53
        [ (6)  (|)  134  145  155 ]  % 54
        [ (7)  pd2  135  146  156 ]  % 55
        [ (8)  sa2  136  147  157 ]  % 56
        [ (9)  sa3  137  148  158 ]  % 57
        [ (:)  pd3   la   la   la ]  % 58
        [  sb   sa  ( )  ( )  ( ) ]  % 59
        [  sc   sc  lkc   sc   sc ]  % 60
        [  sd   sd   sd  lkd   sd ]  % 61
        [  se   se   se   se  lke ]  % 62
        [  lb   la   lb   lb   lb ]  % 63
    ] def 
    
    % Invert charmaps to give character to value maps for each state
    /charvals [ 64 dict 64 dict 64 dict 64 dict 64 dict ] def
    0 1 charmaps length 1 sub {
        /i exch def
        /encs charmaps i get def
        0 1 4 {
            /j exch def
            encs j get dup type /stringtype eq {0 get} if  % convert string to ASCII if required
            charvals j get exch i put 
        } for
    } for
    /seta charvals 0 get def
    /setb charvals 1 get def
    /setc charvals 2 get def
    /setd charvals 3 get def
    /sete charvals 4 get def

    % Compute numeric runlengths
    /nseq [ msglen 1 add {0} repeat ] def
    msglen 1 sub -1 0 {
        /i exch def
        msg i get dup 48 ge exch 57 le and {
            nseq i nseq i 1 add get 1 add put
        } {
            nseq i 0 put
        } ifelse
    } for
    /nseq nseq 0 msglen getinterval def

    % Encode the message from ASCII to codewords 
    /prefixinset {
        0 {
            2 copy exch length ge {exit} if 
            2 copy get 3 index exch known {1 add} {exit} ifelse
        } loop
        exch pop exch pop
    } bind def
    
    /enc {
        exch get out exch j exch put
        /j j 1 add def
    } bind def

    /out 144 array def
    /i 0 def /j 0 def /cset (seta) def
    { % loop
        % Exit when no characters remain latching back to A if necessary
        i msglen eq {
            cset (seta) ne cset (setb) ne and {
                la cset load enc
                /cset (seta) def
            } if
            exit
        } if
        { % not a loop but common exit point
    
            % If 9 numerals available then use NS
            nseq i get 9 ge {
                msg i 9 getinterval cvi 4 { dup 63 and exch -6 bitshift } repeat cset load ns get
                0 2 10 {index} for 6 array astore 7 1 roll 6 {pop} repeat
                out exch j exch putinterval
                /i i 9 add def
                /j j 6 add def
                exit
            } if
    
            % Read next three characters
            /char1 msg i get def
            /char2 i 1 add msglen lt {msg i 1 add get} {-99} ifelse def
            /char3 i 2 add msglen lt {msg i 2 add get} {-99} ifelse def
    
            % If current mode is sufficient then directly encode
            cset load char1 known { 
                char1 cset load enc
                /i i 1 add def
                exit
            } if
    
            % For switching from A to B
            cset (seta) eq setb char1 known and {
                setb char2 known {
                    lb seta enc
                    /cset (setb) def
                } {
                    sb seta enc
                    char1 setb enc
                    /i i 1 add def
                } ifelse
                exit
            } if
    
            % For switching from B to A encode according to length of prefix
            cset (setb) eq seta char1 known and {
                /p seta msg i 4 msglen i sub 2 copy gt {exch} if pop getinterval prefixinset def
                p 1 eq {
                    sa setb enc
                    char1 seta enc
                    /i i 1 add def
                } if
                p 2 eq {
                    sa2 setb enc
                    char1 seta enc
                    char2 seta enc
                    /i i 2 add def 
                } if
                p 3 eq {
                    sa3 setb enc
                    char1 seta enc
                    char2 seta enc
                    char3 seta enc
                    /i i 3 add def 
                } if
                p 4 ge {
                    la setb enc
                    /cset (seta) def
                } if
                exit
            } if
    
            % If character is in A or B then directly latch
            seta char1 known {
                la cset load enc
                /cset (seta) def
                exit
            } if      
            setb char1 known {
                lb cset load enc
                /cset (setb) def
                exit
            } if      
     
            % Determine which one of sets C, D or E the character is in
            setc char1 known {/setx (setc) def /sx sc def /lkx lkc def} if
            setd char1 known {/setx (setd) def /sx sd def /lkx lkd def} if
            sete char1 known {/setx (sete) def /sx se def /lkx lke def} if
    
            % Encode according to the length of the prefix
            /p setx load msg i 4 msglen i sub 2 copy gt {exch} if pop getinterval prefixinset def
            p 1 eq {
                sx cset load enc
                char1 setx load enc
                /i i 1 add def
            } if
            p 2 eq {
                sx cset load enc
                char1 setx load enc
                sx cset load enc
                char2 setx load enc
                /i i 2 add def
            } if
            p 3 eq {
                sx cset load enc
                char1 setx load enc
                sx cset load enc
                char2 setx load enc
                sx cset load enc
                char3 setx load enc
                /i i 3 add def
            } if
            p 4 ge {
                sx cset load enc
                lkx setx load enc
                /cset setx def 
            } if
    
            exit
        } loop  % out
    } loop
    /encmsg out 0 j getinterval def
    /padval cset load pad get def 

    % Prefix the encoded message with the structured append insert
    /sami [] def
    sam -1 ne {
        /sami 2 array def
        sami 0 seta pad get put 
        sami 1 sam 10 idiv 1 sub 8 mul sam 10 mod 1 sub add put
    } if
    /encmsg [ sami aload pop encmsg aload pop ] def

    % Derive the primary and secondary codewords for modes 2 and 3
    mode 2 eq mode 3 eq or {

        % Calculate the fixed-width binary values for the mode, postcode, country code and service
        /mdb (0000) 4 string copy dup mode cvi 2 4 string cvrs dup length 4 exch sub exch putinterval def
        /ccb (0000000000) 10 string copy dup ccode cvi 2 10 string cvrs dup length 10 exch sub exch putinterval def
        /scb (0000000000) 10 string copy dup scode cvi 2 10 string cvrs dup length 10 exch sub exch putinterval def
        /pcb (000000000000000000000000000000000000) 36 string copy def
        mode 2 eq {
            % For numeric postcode, first six bits represent length and remaining 30 bits the value
            pcb pcode length 2 6 string cvrs dup length 6 exch sub exch putinterval
            pcb pcode cvi 2 30 string cvrs dup length 36 exch sub exch putinterval
        } {  % mode=3
            % For alphanumeric postcode, trim or pad with spaces to 6 chars and encode to binary
            /pccw [ 
                (      ) 6 string copy dup 0 pcode length 6 gt {pcode 0 6 getinterval} {pcode} ifelse putinterval 
                {seta exch get} forall
            ] def
            0 1 5 {
                /i exch def
                pcb pccw i get 2 6 string cvrs dup length 6 i mul 6 add exch sub exch putinterval
            } for
        } ifelse

        % Convolute the binary values into the structured carrier message
        /scm 60 string def
        scm 2  mdb putinterval
        scm 38 pcb 0  4 getinterval putinterval
        scm 30 pcb 4  6 getinterval putinterval
        scm 24 pcb 10 6 getinterval putinterval
        scm 18 pcb 16 6 getinterval putinterval
        scm 12 pcb 22 6 getinterval putinterval
        scm 6  pcb 28 6 getinterval putinterval
        scm 0  pcb 34 2 getinterval putinterval
        scm 52 ccb 0  2 getinterval putinterval
        scm 42 ccb 2  6 getinterval putinterval
        scm 36 ccb 8  2 getinterval putinterval
        scm 54 scb 0  6 getinterval putinterval
        scm 48 scb 6  4 getinterval putinterval

        % Evaluate the structured carrier message as codewords
        /pri [ 0 0 0 0 0 0 0 0 0 0 ] def
        0 1 59 { 
            /i exch def
            /ps i 6 idiv def
            /ep 2 5 i 6 mod sub exp cvi scm i get 48 sub mul def
            pri ps pri ps get ep add put
        } for

        % Pad the encoded message into the secondary component
        /sec [ 84 {padval} repeat ] def
        sec 0 encmsg putinterval

    } if

    % Derive the primary and secondary codewords for modes 4, 5 and 6
    mode 4 eq mode 5 eq or mode 6 eq or mode -1 eq or {

        % If mode isn't specified then use EEC if message fits, otherwise SEC
        mode -1 eq {
            /mode encmsg length 77 le {5} {4} ifelse def
        } if

        % First symbol is the mode and the remainder are the padded message
        /cws [ mode 5 eq {78} {94} ifelse {padval} repeat ] def
        cws 0 mode put
        cws 1 encmsg putinterval

        % Fit the message into the primary and secondary components
        /pri cws 0 10 getinterval def
        /sec cws 10 cws length 10 sub getinterval def

    } if

    % Calculate the log and anti-log tables
    /rsalog [ 1 63 { dup 2 mul dup 64 ge {67 xor} if } repeat ] def
    /rslog 64 array def
    1 1 63 {dup rsalog exch get exch rslog 3 1 roll put} for

    % Function to calculate the product in the field
    /rsprod {
        2 copy 0 ne exch 0 ne and {
            rslog exch get exch rslog exch get add 63 mod rsalog exch get
        } {
            pop pop 0
        } ifelse
    } bind def

    % Generate error correction codewords
    /rscodes {

        /rsnum exch def
        /cwb exch def

        % Generate the coefficients
        /coeffs [ 1 rsnum {0} repeat ] def
        1 1 rsnum {
            /i exch def
            coeffs i coeffs i 1 sub get put
            i 1 sub -1 1 {
                /j exch def
                coeffs j coeffs j 1 sub get coeffs j get rsalog i get rsprod xor put
            } for
            coeffs 0 coeffs 0 get rsalog i get rsprod put
        } for
        /coeffs coeffs 0 coeffs length 1 sub getinterval def

        % Calculate the error correction codewords
        /ecb [ rsnum {0} repeat ] def
        0 1 cwb length 1 sub {
            /t exch cwb exch get ecb 0 get xor def
            ecb length 1 sub -1 0 {
                /i exch def
                /p ecb length i sub 1 sub def
                ecb p t coeffs i get rsprod put
                i 0 gt { ecb p ecb p 1 add get ecb p get xor put } if
            } for
        } for

        ecb

    } bind def

    % Split secondary codeword into odd and even elements
    /seco [ 0 2 sec length 1 sub { sec exch get } for ] def
    /sece [ 1 2 sec length 1 sub { sec exch get } for ] def

    % Calculate the parity codewords for secondary codeword parts based on mode
    /scodes sec length 84 eq {20} {28} ifelse def  % SEC/EEC mode
    /secochk seco scodes rscodes def
    /secechk sece scodes rscodes def

    % Recompose the secondary parity codewords
    /secchk [ 0 1 scodes 1 sub { dup secochk exch get exch secechk exch get } for ] def

    % Concatinate the data into final codewords
    /codewords [
        pri aload pop 
        pri 10 rscodes aload pop
        sec aload pop 
        secchk aload pop
    ] def

    % Convert the codewords into module bits
    /mods [ 864 {0} repeat ] def
    0 1 143 {
        /i exch def
        /cw [ codewords i get 2 6 string cvrs {48 sub} forall ] def
        mods 6 i mul 6 cw length sub add cw putinterval
    } for

    % Maps modules to pixels in the grid
    /modmap [
        469 529 286 316 347 346 673 672 703 702 647 676 283 282 313 312 370 610 618 379 
        378 409 408 439 705 704 559 589 588 619 458 518 640 701 675 674 285 284 315 314 
        310 340 531 289 288 319 349 348 456 486 517 516 471 470 369 368 399 398 429 428 
        549 548 579 578 609 608 649 648 679 678 709 708 639 638 669 668 699 698 279 278 
        309 308 339 338 381 380 411 410 441 440 561 560 591 590 621 620 547 546 577 576 
        607 606 367 366 397 396 427 426 291 290 321 320 351 350 651 650 681 680 711 710 
        1   0   31  30  61  60  3   2   33  32  63  62  5   4   35  34  65  64  7   6   
        37  36  67  66  9   8   39  38  69  68  11  10  41  40  71  70  13  12  43  42  
        73  72  15  14  45  44  75  74  17  16  47  46  77  76  19  18  49  48  79  78  
        21  20  51  50  81  80  23  22  53  52  83  82  25  24  55  54  85  84  27  26  
        57  56  87  86  117 116 147 146 177 176 115 114 145 144 175 174 113 112 143 142 
        173 172 111 110 141 140 171 170 109 108 139 138 169 168 107 106 137 136 167 166 
        105 104 135 134 165 164 103 102 133 132 163 162 101 100 131 130 161 160 99  98  
        129 128 159 158 97  96  127 126 157 156 95  94  125 124 155 154 93  92  123 122 
        153 152 91  90  121 120 151 150 181 180 211 210 241 240 183 182 213 212 243 242 
        185 184 215 214 245 244 187 186 217 216 247 246 189 188 219 218 249 248 191 190 
        221 220 251 250 193 192 223 222 253 252 195 194 225 224 255 254 197 196 227 226 
        257 256 199 198 229 228 259 258 201 200 231 230 261 260 203 202 233 232 263 262 
        205 204 235 234 265 264 207 206 237 236 267 266 297 296 327 326 357 356 295 294 
        325 324 355 354 293 292 323 322 353 352 277 276 307 306 337 336 275 274 305 304 
        335 334 273 272 303 302 333 332 271 270 301 300 331 330 361 360 391 390 421 420 
        363 362 393 392 423 422 365 364 395 394 425 424 383 382 413 412 443 442 385 384 
        415 414 445 444 387 386 417 416 447 446 477 476 507 506 537 536 475 474 505 504 
        535 534 473 472 503 502 533 532 455 454 485 484 515 514 453 452 483 482 513 512 
        451 450 481 480 511 510 541 540 571 570 601 600 543 542 573 572 603 602 545 544 
        575 574 605 604 563 562 593 592 623 622 565 564 595 594 625 624 567 566 597 596 
        627 626 657 656 687 686 717 716 655 654 685 684 715 714 653 652 683 682 713 712 
        637 636 667 666 697 696 635 634 665 664 695 694 633 632 663 662 693 692 631 630 
        661 660 691 690 721 720 751 750 781 780 723 722 753 752 783 782 725 724 755 754 
        785 784 727 726 757 756 787 786 729 728 759 758 789 788 731 730 761 760 791 790 
        733 732 763 762 793 792 735 734 765 764 795 794 737 736 767 766 797 796 739 738 
        769 768 799 798 741 740 771 770 801 800 743 742 773 772 803 802 745 744 775 774 
        805 804 747 746 777 776 807 806 837 836 867 866 897 896 835 834 865 864 895 894 
        833 832 863 862 893 892 831 830 861 860 891 890 829 828 859 858 889 888 827 826 
        857 856 887 886 825 824 855 854 885 884 823 822 853 852 883 882 821 820 851 850 
        881 880 819 818 849 848 879 878 817 816 847 846 877 876 815 814 845 844 875 874 
        813 812 843 842 873 872 811 810 841 840 871 870 901 900 931 930 961 960 903 902 
        933 932 963 962 905 904 935 934 965 964 907 906 937 936 967 966 909 908 939 938 
        969 968 911 910 941 940 971 970 913 912 943 942 973 972 915 914 945 944 975 974 
        917 916 947 946 977 976 919 918 949 948 979 978 921 920 951 950 981 980 923 922 
        953 952 983 982 925 924 955 954 985 984 927 926 957 956 987 986 58  89  88  118 
        149 148 178 209 208 238 269 268 298 329 328 358 389 388 418 449 448 478 509 508 
        538 569 568 598 629 628 658 689 688 718 749 748 778 809 808 838 869 868 898 929 
        928 958 989 988
    ] def

    % Lookup pixels for enabled modules from modmap
    /pixs 864 array def
    /j 0 def
    0 1 mods length 1 sub {
        /i exch def
        mods i get 1 eq {
            pixs j modmap i get put
            /j j 1 add def
        } if
    } for
    /pixs [ pixs 0 j getinterval {} forall 28 29 280 281 311 457 488 500 530 670 700 677 707 ] def

    % Return the arguments
    <<
    /ren //renmaximatrix
    /pixs pixs
    /opt options
    >>

    dontdraw not //renmaximatrix if

    end

} bind def
/maxicode dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER maxicode--

% --BEGIN ENCODER azteccode--
% --DESC: Aztec Code
% --EXAM: This is Aztec Code
% --EXOP: format=full
% --RNDR: renmatrix
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/azteccode {

    20 dict begin

    /options exch def
    /barcode exch def

    /dontdraw false def
    /format (unset) def    % full, compact or rune
    /readerinit false def
    /layers -1 def
    /eclevel 23 def
    /ecaddchars 3 def
    /raw false def
    /parse false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
 
    /layers layers cvi def
    /eclevel eclevel cvr def
    /ecaddchars ecaddchars cvi def

    % Parse ordinals of the form ^NNN to ASCII
    parse {
        /msg barcode length string def
        /j 0 def
        barcode
        { % loop
            (^) search {
                dup msg exch j exch putinterval
                length j add 1 add /j exch def
                pop
                dup 0 3 getinterval cvi msg exch j 1 sub exch put
                dup length 3 sub 3 exch getinterval
            } {
                dup msg exch j exch putinterval
                length j add /j exch def
                /barcode msg 0 j getinterval def
                exit
            } ifelse 
        } loop
    } if

    % Convert from input into message bitstream
    /msgbits () def 
    format (rune) ne raw and {/msgbits barcode def} if 
    format (rune) ne raw not and {  % Simple autoencoder from input to bitstream using byte mode only

        % Determine the character count
        /barlen barcode length def
        barlen 31 le {
            (00000) 5 string copy dup barlen 2 5 string cvrs
            dup length 5 exch sub exch putinterval
            /cc exch def
        } {
            (0000000000000000) 16 string copy dup barlen 31 sub 2 16 string cvrs
            dup length 16 exch sub exch putinterval
            /cc exch def
        } ifelse
        /cclen cc length def

        % Create the bitstream as byte_mode_id character_count data_bytes
        /msgbits 5 cclen add barlen 8 mul add string def
        msgbits 0 (11111) putinterval
        msgbits 5 cc putinterval
        0 1 barlen 1 sub {
            /i exch def
            (00000000) 8 string copy dup barcode i get cvi 2 8 string cvrs dup length 8 exch sub exch putinterval 
            msgbits 5 cclen add i 8 mul add 3 -1 roll putinterval
        } for

    } if

    % Lookup the most appropriate symbol specification 
    /metrics [
        [ (rune)     0 0    0  6 ]  % Special metric for rune symbols
        [ (compact)  1 1   17  6 ] [ (full)     1 1   21  6 ] [ (compact)  2 0   40  6 ]
        [ (full)     2 1   48  6 ] [ (compact)  3 0   51  8 ] [ (full)     3 1   60  8 ]
        [ (compact)  4 0   76  8 ] [ (full)     4 1   88  8 ] [ (full)     5 1  120  8 ]
        [ (full)     6 1  156  8 ] [ (full)     7 1  196  8 ] [ (full)     8 1  240  8 ]
        [ (full)     9 1  230 10 ] [ (full)    10 1  272 10 ] [ (full)    11 1  316 10 ]
        [ (full)    12 1  364 10 ] [ (full)    13 1  416 10 ] [ (full)    14 1  470 10 ]
        [ (full)    15 1  528 10 ] [ (full)    16 1  588 10 ] [ (full)    17 1  652 10 ]
        [ (full)    18 1  720 10 ] [ (full)    19 1  790 10 ] [ (full)    20 1  864 10 ]
        [ (full)    21 1  940 10 ] [ (full)    22 1 1020 10 ] [ (full)    23 0  920 12 ]
        [ (full)    24 0  992 12 ] [ (full)    25 0 1066 12 ] [ (full)    26 0 1144 12 ]
        [ (full)    27 0 1224 12 ] [ (full)    28 0 1306 12 ] [ (full)    29 0 1392 12 ]
        [ (full)    30 0 1480 12 ] [ (full)    31 0 1570 12 ] [ (full)    32 0 1664 12 ]
    ] def

    /i 0 def
    { % loop
        /m metrics i get def
        /frmt m 0 get def                          % Format of the symbol
        /mlyr m 1 get def                          % Data layers
        /icap m 2 get def                          % Reader initialisation capable
        /ncws m 3 get def                          % Total of codewords
        /bpcw m 4 get def                          % Bits per codeword
        /numecw ncws eclevel mul 100 div ecaddchars add ceiling cvi def
        msgbits length 0 eq {/numecw 0 def} if     % Error correction codewords 
        /numdcw ncws numecw sub def                % Data codewords
        /okay true def
        format (unset) ne format frmt ne and {/okay false def} if
        readerinit icap 1 ne and {/okay false def} if
        layers -1 ne layers mlyr ne and {/okay false def} if 
        msgbits length bpcw div ceiling cvi numdcw gt {/okay false def} if
        okay {exit} if
        /i i 1 add def
    } loop
    /layers mlyr def
    /format frmt def

    % Expand message bits into codewords avoiding codewords with all zeros or all ones
    /allzero {dup length (000000000000) 0 3 -1 roll getinterval eq} bind def
    /allones {dup length (111111111111) 0 3 -1 roll getinterval eq} bind def
    /cws ncws array def
    /m 0 def /c 0 def
    {
        msgbits length m le {exit} if
        msgbits length m sub bpcw ge {
            /cwb msgbits m bpcw 1 sub getinterval def        % All but last bit
            /cwf msgbits m bpcw add 1 sub 1 getinterval def  % Last bit
            cwb allzero {/cwf (1) def /m m 1 sub def} if     % Flip last bit to avoid zeros
            cwb allones {/cwf (0) def /m m 1 sub def} if     % Flip last bit to avoid ones
            % Concatinate the bits 
            12 string dup 0 cwb putinterval 
            dup bpcw 1 sub cwf putinterval
            0 bpcw getinterval
            /cwb exch def
        } {  %  Final codeword
            /cwb msgbits m msgbits length m sub getinterval def
            /cwb (111111111111) 12 string copy dup 0 cwb putinterval 0 bpcw getinterval def
            cwb allones {cwb cwb length 1 sub (0) putinterval} if  % Prevent all ones
        } ifelse
        % Conversion of binary data into byte array
        /cw 0 def
        0 1 bpcw 1 sub {
            /i exch def
            /cw cw 2 bpcw i sub 1 sub exp cvi cwb i get 48 sub mul add def
        } for
        cws c cw put
        /m m bpcw add def 
        /c c 1 add def
    } loop    
    /cws cws 0 c getinterval def

    % Reed-Solomon algorithm
    /rscodes {

        /rspm exch def
        /rsgf exch def
        /rsnc exch def
        /rscws exch def

        % Calculate the log and anti-log tables
        /rsalog [ 1 rsgf 1 sub { dup 2 mul dup rsgf ge {rspm xor} if } repeat ] def
        /rslog rsgf array def
        1 1 rsgf 1 sub {dup rsalog exch get exch rslog 3 1 roll put} for

        % Function to calculate the product in the field
        /rsprod {
            2 copy 0 ne exch 0 ne and {
                rslog exch get exch rslog exch get add rsgf 1 sub mod rsalog exch get
            } {
                pop pop 0
            } ifelse
        } bind def

        % Generate the coefficients
        /coeffs [ 1 rsnc {0} repeat ] def
        1 1 rsnc {
            /i exch def 
            coeffs i coeffs i 1 sub get put
            i 1 sub -1 1 {
                /j exch def
                coeffs j coeffs j 1 sub get coeffs j get rsalog i get rsprod xor put
            } for 
            coeffs 0 coeffs 0 get rsalog i get rsprod put
        } for

        % Extend the input with the error correction values
        /nd rscws length def
        /rscws [ rscws {} forall rsnc {0} repeat 0 ] def
        0 1 nd 1 sub {
            /k exch rscws exch get rscws nd get xor def 
            0 1 rsnc 1 sub {
                /j exch def 
                rscws nd j add rscws nd j add 1 add get k coeffs rsnc j sub 1 sub get rsprod xor put
            } for 
        } for

        % Return all but the last codeword
        rscws 0 rscws length 1 sub getinterval

    } bind def

    % Create the codewords and bit string for the mode
    format (full) eq {
        /mode layers 1 sub 11 bitshift cws length 1 sub add def
        readerinit {/mode mode 2#1000000000000000 or def} if
        /mode [
            mode 2#1111000000000000 and -12 bitshift
            mode 2#0000111100000000 and -8 bitshift
            mode 2#0000000011110000 and -4 bitshift
            mode 2#0000000000001111 and
        ] def
        /mode mode 6 16 19 rscodes def 
    } if
    format (compact) eq {
        /mode layers 1 sub 6 bitshift cws length 1 sub add def
        readerinit {/mode mode 2#10000000 or def} if 
        /mode [
            mode 2#11110000 and -4 bitshift
            mode 2#00001111 and
        ] def
        /mode mode 5 16 19 rscodes def
    } if
    format (rune) eq {
        /mode barcode cvi def
        /mode [
            mode 2#11110000 and -4 bitshift
            mode 2#00001111 and
        ] def
        /mode mode 5 16 19 rscodes def
        /mode [mode {2#1010 xor} forall] def  % Invert alternate bits
    } if
    /modebits mode length 4 mul string def
    0 1 modebits length 1 sub {modebits exch (0) putinterval} for
    0 1 mode length 1 sub {
        /i exch def
        modebits mode i get 2 4 string cvrs dup length 4 exch sub 4 i mul add exch putinterval 
    } for

    % Extend the data codewords with error correction codewords to create the bit string for the data
    /rsparams [
        [] [] [] [] [] [] 
        [ 64 67 ]      % 6-bit codewords 
        []
        [ 256 301 ]    % 8-bit codewords
        [] 
        [ 1024 1033 ]  % 10-bit codewords
        []
        [ 4096 4201 ]  % 12-bit codewords
    ] def
    /cws cws ncws cws length sub rsparams bpcw get {} forall rscodes def
    format (full) eq {
        /databits layers layers mul 16 mul layers 112 mul add string def 
    } {
        /databits layers layers mul 16 mul layers 88 mul add string def 
    } ifelse
    0 1 databits length 1 sub {databits exch (0) putinterval} for
    0 1 ncws 1 sub { 
        /i exch def
        databits cws i get 2 bpcw string cvrs 
        dup length bpcw exch sub bpcw i mul add databits length ncws bpcw mul sub add 
        exch putinterval 
    } for

    % Move to a point in the cartesian plane centered on the bullseye
    /cmv {size mul sub mid add} bind def

    % Move to a bit position within a layer
    /lmv {
        /lbit exch def
        /llyr exch def
        /lwid fw llyr 4 mul add def
        /ldir lbit 2 idiv lwid idiv def
        ldir 0 eq {  % Top
            lwid 1 sub 2 idiv neg 1 add lbit 2 idiv lwid mod add 
            fw 1 sub 2 idiv llyr 2 mul add lbit 2 mod add
            cmv
        } if
        ldir 1 eq {  % Right
            fw 2 idiv llyr 2 mul add lbit 2 mod add
            lwid 1 sub 2 idiv 1 sub lbit 2 idiv lwid mod sub
            cmv
        } if
        ldir 2 eq {  % Bottom
            lwid 2 idiv neg 1 add lbit 2 idiv lwid mod add neg
            fw 2 idiv llyr 2 mul add lbit 2 mod add neg
            cmv
        } if
        ldir 3 eq {  % Left
            fw 1 sub 2 idiv llyr 2 mul add lbit 2 mod add neg
            lwid 2 idiv 1 sub lbit 2 idiv lwid mod sub neg
            cmv
        } if
    } bind def

    % Create the pixel map
    % For full symbols we disregard the reference grid at this stage
    format (full) eq {/fw 12 def} {/fw 9 def} ifelse
    /size fw layers 4 mul add 2 add def 
    /pixs [size size mul {-1} repeat] def
    /mid size 1 sub 2 idiv size mul size 1 sub 2 idiv add def

    % Data layers
    /i 0 def
    1 1 layers {
        /layer exch def
        0 1 fw layer 4 mul add 8 mul 1 sub {
            /pos exch def
            pixs layer pos lmv databits databits length i sub 1 sub get 48 sub put
            /i i 1 add def
        } for
    } for

    % For full symbols expand the pixel map by inserting the reference grid
    format (full) eq {
        /fw 13 def
        /size fw layers 4 mul add 2 add layers 10.5 add 7.5 div 1 sub cvi 2 mul add def
        /mid size size mul 2 idiv def
        /npixs [size size mul {-2} repeat] def
        0 16 size 2 idiv {
            /i exch def
            0 1 size 1 sub {
                /j exch def
                npixs size 2 idiv neg j add i cmv     [size 2 idiv j add i add 1 add 2 mod] putinterval
                npixs size 2 idiv neg j add i neg cmv [size 2 idiv j add i add 1 add 2 mod] putinterval
                npixs i size 2 idiv neg j add cmv     [size 2 idiv j add i add 1 add 2 mod] putinterval
                npixs i neg size 2 idiv neg j add cmv [size 2 idiv j add i add 1 add 2 mod] putinterval
            } for
        } for 
        /j 0 def
        0 1 npixs length 1 sub {
            /i exch def
            npixs i get -2 eq {
                npixs i pixs j get put
                /j j 1 add def
            } if
        } for
        /pixs npixs def
    } if

    % Finder pattern
    /fw fw 2 idiv def
    fw neg 1 fw {
        /i exch def
        fw neg 1 fw {
            /j exch def
            pixs i j cmv
            i abs j abs gt {i abs} {j abs} ifelse 1 add 2 mod
            put
        } for
    } for

    % Orientation bits
    [ [ fw 1 add neg   fw             1 ] [ fw 1 add neg   fw 1 add       1 ]
      [ fw neg         fw 1 add       1 ] [ fw 1 add       fw 1 add       1 ]
      [ fw 1 add       fw             1 ] [ fw 1 add       fw neg         1 ]
      [ fw             fw 1 add       0 ] [ fw 1 add       fw 1 add neg   0 ]
      [ fw             fw 1 add neg   0 ] [ fw neg         fw 1 add neg   0 ]
      [ fw 1 add neg   fw 1 add neg   0 ] [ fw 1 add neg   fw neg         0 ]
    ] {pixs exch {} forall 3 1 roll cmv exch put} forall

    % Mode ring
    format (full) eq {
        /modemap [ 
            [-5  7] [-4  7] [-3  7] [-2  7] [-1  7] [ 1  7] [ 2  7] [ 3  7] [ 4  7] [ 5  7]
            [ 7  5] [ 7  4] [ 7  3] [ 7  2] [ 7  1] [ 7 -1] [ 7 -2] [ 7 -3] [ 7 -4] [ 7 -5]
            [ 5 -7] [ 4 -7] [ 3 -7] [ 2 -7] [ 1 -7] [-1 -7] [-2 -7] [-3 -7] [-4 -7] [-5 -7]
            [-7 -5] [-7 -4] [-7 -3] [-7 -2] [-7 -1] [-7  1] [-7  2] [-7  3] [-7  4] [-7  5]
        ] def
    } {
        /modemap [
            [-3  5] [-2  5] [-1  5] [ 0  5] [ 1  5] [ 2  5] [ 3  5]
            [ 5  3] [ 5  2] [ 5  1] [ 5  0] [ 5 -1] [ 5 -2] [ 5 -3]
            [ 3 -5] [ 2 -5] [ 1 -5] [ 0 -5] [-1 -5] [-2 -5] [-3 -5]
            [-5 -3] [-5 -2] [-5 -1] [-5  0] [-5  1] [-5  2] [-5  3]
        ] def
    } ifelse
    0 1 modemap length 1 sub {
        /i exch def
        pixs modemap i get {} forall cmv modebits i get 48 sub put
    } for

    <<
    /ren //renmatrix
    /pixs pixs
    /pixx size
    /pixy size
    /height size 2 mul 72 div
    /width size 2 mul 72 div
    /opt options
    >>

    dontdraw not //renmatrix if

    end

} bind def
/azteccode dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER azteccode--

% --BEGIN ENCODER codeone--
% --DESC: Code One
% --EXAM: Code One
% --EXOP: version=B
% --RNDR: renmatrix
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/codeone {

    20 dict begin

    /options exch def
    /barcode exch def

    /dontdraw false def
    /version (unset) def
    /encoding (ascii) def
    /raw false def
    /parse false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /stype version 0 1 getinterval (S) eq def
    stype {/raw true def} if

    % Parse ordinals of the form ^NNN to ASCII
    parse {
        /msg barcode length string def
        /j 0 def
        barcode
        { % loop
            (^) search {
                dup msg exch j exch putinterval
                length j add 1 add /j exch def
                pop
                dup 0 3 getinterval cvi msg exch j 1 sub exch put
                dup length 3 sub 3 exch getinterval
            } {
                dup msg exch j exch putinterval
                length j add /j exch def
                /barcode msg 0 j getinterval def
                exit
            } ifelse 
        } loop
    } if

    /barlen barcode length def

    raw {/encoding (raw) def} if

    encoding (raw) eq {
        /cws barlen array def
        /i 0 def /j 0 def
        { % loop
            i barlen eq {exit} if
            /cw barcode i 1 add 3 getinterval cvi def
            cws j cw put
            /i i 4 add def
            /j j 1 add def
        } loop
        /cws cws 0 j getinterval def
    } if

    encoding (ascii) eq {
        /cws barlen 2 mul array def
        /i 0 def /j 0 def
        { % loop
            i barlen eq {exit} if
            /char barcode i get def
            char 48 ge char 57 le and i barlen 1 sub lt and {
                barcode i 1 add get dup 48 ge exch 57 le and {  % Digit pair
                    cws j barcode i 2 getinterval cvi 130 add put
                    /i i 2 add def
                    /j j 1 add def
                } {  % Singular digit
                    cws j char 1 add put
                    /i i 1 add def
                    /j j 1 add def
                } ifelse
            } { char 127 le {  % ASCII
                cws j char 1 add put
                /i i 1 add def
                /j j 1 add def
            } {  % Extended ASCII
                cws j 235 put
                cws j 1 add char 127 sub put
                /i i 1 add def
                /j j 2 add def
            } ifelse } ifelse
        } loop
        /cws cws 0 j getinterval def
    } if

    % Basic metrics for the each symbol
    %     ver    row col dcol dcws rscw rsbl  ro ri rl
    /metrics [
        [ (A)     16  18   16   10   10    1   4 99  6 ]
        [ (B)     22  22   20   19   16    1   4 99  8 ]
        [ (C)     28  32   28   44   26    1   4 22 11 ]
        [ (D)     40  42   36   91   44    1   4 16 16 ]
        [ (E)     52  54   48  182   70    1   4 22 22 ]
        [ (F)     70  76   68  370  140    2   4 22 31 ]
        [ (G)    104  98   88  732  280    4   6 21 47 ]
        [ (H)    148 134  120 1480  560    8   6 20 69 ]
        [ (S-10)   8  11   10    4    4    1  99 99 99 ]
        [ (S-20)   8  21   20    8    8    1  99 99 99 ]
        [ (S-30)   8  31   30   12   12    1  99 99 99 ]
        [ (T-16)  16  17   16   10   10    1  99 99 99 ]
        [ (T-32)  16  33   32   24   16    1  99 99 99 ]
        [ (T-48)  16  49   48   38   22    1  99 99 99 ]
    ] def

    % Select metrics of an appropriate symbol
    /i 0 def
    { % loop
        /m metrics i get def
        /vers m 0 get def           % Version of symbol
        /rows m 1 get def           % Rows in symbol
        /cols m 2 get def           % Columns in symbol
        /dcol m 3 get def           % Data columns in symbol
        /dcws m 4 get def           % Data codewords in symbol
        /rscw m 5 get def           % Error correction codewords 
        /rsbl m 6 get def           % Error correction blocks
        /riso m 7 get def           % Riser offset
        /risi m 8 get def           % Riser interval
        /risl m 9 get def           % Riser length
        /dcpb dcws rsbl idiv def    % Data codewords per block
        /ecpb rscw rsbl idiv def    % Error codewords per block
        /okay true def
        version (unset) ne version vers ne and {/okay false def} if  % The version must match that supplied
        cws length dcws gt {/okay false def} if
        okay {exit} if
        /i i 1 add def
    } loop

    % Extend cws to ncws codewords by addition of pad characters
    stype not {
        /cws [ cws aload pop dcws cws length sub {129} repeat ] def
    } if

    % De-interleave the codewords into blocks
    /cwbs rsbl array def  % Array of data codeword blocks
    /ecbs rsbl array def  % Array of error correction blocks
    0 1 rsbl 1 sub {
        /i exch def
        /cwb dcpb array def 
        0 1 dcpb 1 sub {
            /j exch def
            cwb j cws j rsbl mul i add get put
        } for 
        cwbs i cwb put
    } for

    % Log and anti-log tables and function to calculate product in the field
    /gf stype {32} {256} ifelse def
    /gf-1 gf 1 sub def
    /pm stype {37} {301} ifelse def
    /rsalog [ 1 gf-1 { dup 2 mul dup gf ge {pm xor} if } repeat ] def
    /rslog gf array def
    1 1 gf-1 {dup rsalog exch get exch rslog 3 1 roll put} for
    /rsprod {
        2 copy 0 ne exch 0 ne and { 
            rslog exch get exch rslog exch get add gf-1 mod rsalog exch get
        } {
            pop pop 0
        } ifelse
    } bind def

    % Generate the coefficients for the Reed-Solomon algorithm
    /coeffs [ 1 ecpb {0} repeat ] def
    0 1 ecpb 1 sub {
        /i exch def 
        coeffs i 1 add coeffs i get put
        i -1 1 {
            /j exch def
            coeffs j coeffs j 1 sub get coeffs j get rsalog i get rsprod xor put
        } for 
        coeffs 0 coeffs 0 get rsalog i get rsprod put
    } for
    /coeffs coeffs 0 coeffs length 1 sub getinterval def

    % Reed-Solomon algorithm to derive the error correction codewords
    0 1 cwbs length 1 sub {
        /i exch def
        /rscws [ cwbs i get aload pop ecpb {0} repeat ] def
        0 1 dcpb 1 sub {
            /m exch def
            /k rscws m get def
            0 1 ecpb 1 sub {
                /j exch def
                rscws m j add 1 add coeffs ecpb j sub 1 sub get k rsprod rscws m j add 1 add get xor put
            } for
        } for
        ecbs i rscws dcpb ecpb getinterval put
    } for

    % Extend codewords with the interleaved error correction codes
    /cws [ cws aload pop rscw {0} repeat ] def
    0 1 rscw 1 sub {
        /i exch def
        cws dcws i add ecbs i rsbl mod get i rsbl idiv get put
    } for

    % Module matrix for layout of the codewords
    /mmat dcws rscw add stype {5} {8} ifelse mul array def
    /r 0 def /c 0 def
    0 stype {2} {1} ifelse cws length 1 sub {
        /i exch def
        stype not {
            (00000000) 8 string copy dup cws i get 2 8 string cvrs
            dup length 8 exch sub exch putinterval [ exch {48 sub} forall ]
            dup 0 4 getinterval /top exch def
            4 4 getinterval /bot exch def
        } {
            (00000) 5 string copy dup cws i get 2 5 string cvrs
            dup length 5 exch sub exch putinterval [ exch {48 sub} forall ]
            /c1 exch def
            (00000) 5 string copy dup cws i 1 add get 2 5 string cvrs
            dup length 5 exch sub exch putinterval [ exch {48 sub} forall ]
            /c2 exch def
            /top [ c1 0 3 getinterval aload pop c2 0 2 getinterval aload pop ] def
            /bot [ c1 3 2 getinterval aload pop c2 2 3 getinterval aload pop ] def
        } ifelse
        mmat r dcol mul c add top putinterval
        mmat r 1 add dcol mul c add bot putinterval
        /c c top length add def
        c dcol eq {/c 0 def /r r 2 add def} if
    } for

    % Create bitmap and add finder patterns
    /mmv {cols mul add} bind def
    /pixs [ rows cols mul {-1} repeat ] def

    % Centre pattern
    /artifact [
        {cols {0} repeat} bind 
        {cols {1} repeat} bind 
        {0   cols 2 sub {1} repeat   0} bind 
        {0 1 cols 4 sub {0} repeat 1 0} bind 
        {cols 1 sub 2 idiv {-1} repeat 1 cols 1 sub 2 idiv {-1} repeat} bind 
        {cols 1 sub 2 idiv {-1} repeat 0 cols 1 sub 2 idiv {-1} repeat} bind 
        {1   cols 2 sub {0} repeat   1} bind 
        {1 0 cols 4 sub {1} repeat 0 1} bind 
    ] def
    /cpat <<
        /A (121343)
        /B (12134343)
        /C (12121343)
        /D (1213434343)
        /E (1212134343)
        /F (1212121343)
        /G (121213434343)
        /H (121212134343)
        /S (56661278)
        /T (5666666666127878)
    >> vers 0 1 getinterval get def
    pixs 0 rows cpat length sub 2 idiv mmv 
    [ cpat {artifact exch 49 sub get exec} forall ] putinterval

    % Risers
    0 1 risl 1 sub {
        /i exch def
        riso risi cols 1 sub {
            /j exch def
            [ 1 i 12 mod 0 eq {1} {0} ifelse ] dup
            pixs j i mmv
            3 -1 roll putinterval
            i risl 1 sub ne {
                pixs cols j sub 2 sub rows i sub 1 sub mmv 
                3 -1 roll putinterval
            } {pop} ifelse
        } for
    } for

    % Black dots
    <<
        /A [ [12 5] ]
        /B [ [16 7] ]
        /C [ [26 12] ]
        /D []
        /E [ [26 23] ]
        /F [ [26 32] [70 32] [26 34] [70 34] ]
        /G [ [27 48] [69 48] ]
        /H [ [26 70] [66 70] [106 70] [26 72] [66 72] [106 72] ]
        /S-10 []
        /S-20 [ [10 4] ]
        /S-30 [ [15 4] [15 6] ]
        /T-16 [ [8 10] ]
        /T-32 [ [16 10] [16 12] ]
        /T-48 [ [24 10] [24 12] [24 14] ]
    >> vers get {pixs exch aload pop mmv 1 put} forall

    % Place the modules onto a pixel map between alignment patterns
    /j 0 def
    0 1 pixs length 1 sub {
        /i exch def
        pixs i get -1 eq {
            pixs i mmat j get put
            /j j 1 add def
        } if
    } for

    % Return the arguments
    <<
    /ren //renmatrix
    /pixs pixs
    /pixx cols
    /pixy rows
    /height rows 72 div 1.5 mul
    /width cols 72 div 1.5 mul
    /opt options
    >>

    dontdraw not //renmatrix if

    end

} bind def
/codeone dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER codeone--

% --BEGIN ENCODER gs1-cc--
% --REQUIRES micropdf417 pdf417--
% --DESC: GS1 Composite 2D Component
% --EXAM: (01)95012345678903(3103)000123
% --EXOP: ccversion=b cccolumns=4
% --RNDR: renmatrix
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
dup /pdf417 dup /uk.co.terryburton.bwipp findresource put
dup /micropdf417 dup /uk.co.terryburton.bwipp findresource put
begin
/gs1-cc {
    
    20 dict begin            % Confine variables to local scope

    /options exch def  % We are given an option string
    /barcode exch def  % We are given a barcode string

    /dontdraw false def
    /ccversion (a) def
    /cccolumns -1 def
    /lintype () def
    /linwidth -1 def
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
 
    /cccolumns cccolumns cvi def
    /linwidth linwidth cvi def

    % Select columns based on linear type
    cccolumns -1 eq {
        <<
            /ean13                  4
            /upca                   4
            /ean8                   3
            /upce                   2
            /gs1-128
                ccversion (c) ne {4} {linwidth 52 sub 17 idiv} ifelse
            /databaromni            4
            /databarstacked         2
            /databarstackedomni     2
            /databartruncated       4
            /databarlimited         3
            /databarexpanded        4
            /databarexpandedstacked 4
        >> lintype get /cccolumns exch def 
    } if

    % Expand ordinals of the form ^NNN to ASCII
    /expand {
        /in exch def
        /out in length string def
        /j 0 def
        in
        { % loop
            (^) search {
                dup out exch j exch putinterval
                length j add 1 add /j exch def
                pop
                dup 0 3 getinterval cvi out exch j 1 sub exch put
                dup length 3 sub 3 exch getinterval
            } {
                dup out exch j exch putinterval
                length j add /j exch def
                out 0 j getinterval exit
            } ifelse 
        } loop
    } bind def
 
    % Parse out AIs
    /ais [] def
    /aival 2 dict def
    barcode dup length 1 sub 1 exch getinterval
    {  % loop
        dup () eq {exit} if
        (\)) search pop
        exch pop
        exch (\() search {
            exch pop exch 3 1 roll 
        } { 
            () 3 1 roll
        }  ifelse
        [ ais aload pop counttomark 2 add index ] /ais exch def
        aival 3 1 roll expand put
    } loop
    pop
    
    % Method selection
    /isupper {dup 65 ge exch 90 le and} bind def  % A-Z
    /isnum0  {dup 48 ge exch 57 le and} bind def  % 0-9
    /isnum1  {dup 49 ge exch 57 le and} bind def  % 1-9
    {  % common exit
    
        % (10/11/17)...
        ais length 1 ge {
            ais 0 get (10) eq ais 0 get (11) eq or ais 0 get (17) eq or {
                -1 (10) exit
            } if
        } if

        % (90){0-3 digits not starting 0}{upper alpha}...
        ais length 1 ge {
            ais 0 get (90) eq {
                /v aival (90) get def
                v length 1 ge {
                   v 0 get isupper {
                       0 (11) exit
                   } if
                } if
                v length 2 ge {
                   v 0 get isnum1
                   v 1 get isupper and {
                       1 (11) exit
                   } if
                } if
                v length 3 ge {
                    v 0 get isnum1
                    v 1 get isnum0 and
                    v 2 get isupper and {
                        2 (11) exit
                    } if
                } if
                v length 4 ge {
                    v 0 get isnum1
                    v 1 get isnum0 and
                    v 2 get isnum0 and
                    v 3 get isupper and {
                        3 (11) exit
                    } if
                } if
            } if
        } if

        % Freeform
        -1 (0) exit
    
    } loop
    /method exch def
    /npre exch def

    /fnc1 -1 def /lnumeric -2 def /lalphanumeric -3 def /liso646 -4 def

    /tobin {
        string dup length 1 sub 0 exch 1 exch {1 index exch 48 put} for
        dup 3 -1 roll 2 2 index length string cvrs dup length 2 index length exch sub exch putinterval 
    } bind def
 
    /alpha <<
        65 1 90 {dup 65 sub 5 tobin} for
        48 1 57 {dup 4 add 6 tobin} for
        fnc1 (11111)
    >> def

    /numeric <<
        0 1 119 {
            dup (00) 2 string copy dup 3 -1 roll 11 2 string cvrs
            dup length 2 exch sub exch putinterval 
            dup 0 get 65 eq {dup 0 94 put} if 
            dup 1 get 65 eq {dup 1 94 put} if 
            exch 8 add
            (0000000) 7 string copy dup 3 -1 roll 2 7 string cvrs 
            dup length 7 exch sub exch putinterval
        } for
        lalphanumeric (0000)
    >> def
 
    /alphanumeric <<
        48 1 57 {dup 43 sub 5 tobin} for
        fnc1 (01111)
        65 1 90 {dup 33 sub 6 tobin} for
        42 (111010)
        44 1 47 {dup 15 add 6 tobin} for
        lnumeric (000)
        liso646 (00100)
    >> def
    
    /iso646 <<
        48 1 57 {dup 43 sub 5 tobin} for
        fnc1 (01111)
        65 1 90 {dup 1 sub 7 tobin} for
        97 1 122 {dup 7 sub 7 tobin} for
        33 (11101000)
        34 (11101001)
        37 1 47 {dup 197 add 8 tobin} for
        58 1 63 {dup 187 add 8 tobin} for
        95 (11111011)
        32 (11111100)
        lnumeric (000)
        lalphanumeric (00100)
    >> def

    method (10) eq {  % TODO: fixme
        ais 0 get (11) eq ais 0 get (17) eq or {
            aival ais 0 get get
            dup 0 2 getinterval cvi 384 mul exch
            dup 2 2 getinterval cvi 1 sub 32 mul exch
            4 2 getinterval cvi add add 
            (0000000000000000) 16 string copy dup 3 -1 roll 2 16 string cvrs
            dup length 16 exch sub exch putinterval
            [ 1 0
              4 -1 roll {48 sub} forall
              ais 0 get (11) eq {0} {1} ifelse
            ] /cdf exch def
            /ais ais 1 ais length 1 sub getinterval def
        } {
            /cdf [ 1 0  1 1 ] def
        } ifelse
        ais length 0 ne {
            ais 0 get (10) eq {
                /gpf [ aival (10) get {} forall ] def
                ais length 1 gt {/gpf [ gpf aload pop fnc1 ] def} if  % TODO: check
                /ais ais 1 ais length 1 sub getinterval def
            } {
                /gpf [fnc1] def  % TODO: check
            } ifelse
        } {
            /cdf [ cdf aload pop 0 0 0 0 0 1 1 1 1 ] def
            /gpf [] def
        } ifelse
        /mode (numeric) def
    } if

    method (11) eq {
        /cdf [ 1 1 ] def
        /ai90 aival (90) get def
        npre 1 add ai90 length ne {
            ai90 npre 1 add ai90 length npre sub 1 sub getinterval
        } {
            ()
        } ifelse
        /ai90rem exch def
        /nalpha 0 ai90rem {dup 65 ge exch 90 le and {1 add} if} forall def
        /nnums  0 ai90rem {dup 48 ge exch 57 le and {1 add} if} forall def
        /mode nalpha nnums gt {(alpha)} {(numeric)} ifelse def
        nalpha nnums add ai90rem length ne {/mode (alphanumeric) def} if
        /cdf [
            cdf aload pop
            mode (alphanumeric) eq {0} if   
            mode (numeric) eq {1 0} if   
            mode (alpha) eq {1 1} if   
        ] def
        /ais1 ais length 1 gt {ais 1 get} {-1} ifelse def
        ais1 (21) eq ais1 (8004) eq or { 
            /cdf [ cdf aload pop ais1 (21) eq {1 0} {1 1} ifelse ] def
        } {
            /cdf [ cdf aload pop 0 ] def
        } ifelse
        /nval npre 0 ne {ai90 0 npre getinterval cvi} {0} ifelse def
        (BDHIJKLNPQRSTVXZ) ai90 npre 1 getinterval search {
            length exch pop exch pop
            /aval exch def
        } {
            pop /aval -1 def
        } ifelse 
        nval 31 lt aval -1 ne and {
            (00000) 5 string copy dup nval 2 5 string cvrs
            dup length 5 exch sub exch putinterval
            [ exch {48 sub} forall ] /nbits exch def
            (0000) 4 string copy dup aval 2 4 string cvrs
            dup length 4 exch sub exch putinterval
            [ exch {48 sub} forall ] /abits exch def
            /cdf [
                cdf aload pop 
                nbits aload pop
                abits aload pop
            ] def
        } {
            (0000000000) 10 string copy dup nval 2 10 string cvrs
            dup length 10 exch sub exch putinterval
            [ exch {48 sub} forall ] /nbits exch def
            (00000) 5 string copy dup ai90 npre get 65 sub 2 5 string cvrs
            dup length 5 exch sub exch putinterval
            [ exch {48 sub} forall ] /abits exch def
            /cdf [
                cdf aload pop
                1 1 1 1 1
                nbits aload pop
                abits aload pop
            ] def
        } ifelse
        mode (numeric) eq {
            /gpf [ ai90rem {} forall ais length 1 gt {fnc1} if ] def
        } {
            /encs mode (alpha) eq {alpha} {alphanumeric} ifelse def
            /in [ ai90rem {} forall ais length 1 gt {fnc1} if ] def
            /out in length 6 mul array def
            /j 0 def
            0 1 in length 1 sub {
                in exch get encs exch get 
                dup [ exch {48 sub} forall ] out exch j exch putinterval
                length j add /j exch def
            } for
            /cdf [
                cdf aload pop 
                out 0 j getinterval aload pop
            ] def
            /gpf [] def
            ais length 1 gt mode (alpha) ne or {/mode (numeric) def} if
        } ifelse
        /ais ais 1 ais length 1 sub getinterval def
        ais length 0 ne {
            ais1 (21) eq ais1 (8004) eq or {
                /gpf [
                    gpf aload pop
                    aival ais1 get {} forall
                ] def
                /ais ais 1 ais length 1 sub getinterval def
                ais length 0 ne {/gpf [gpf aload pop fnc1] def} if
            } if
        } if
    } if

    method (0) eq {
        /cdf [ 0 ] def
        /gpf [] def
        /mode (numeric) def
    } if

    % Pre-defined fixed length data field AIs
    % any AI whose prefix is not included in this table must be
    % terminated with "FNC1", even if it's fixed length
    /aifixed 23 dict def
    [
        0 1 4 {} for
    ] {
        (00) 2 string copy dup dup 1 5 -1 roll 48 add put aifixed 3 1 roll put
    } forall
    [
        11 1 20 {} for
        23
        31 1 36 {} for
        41
    ] {
        10 2 string cvrs dup aifixed 3 1 roll put
    } forall

    % Append the remaining AI data
    0 1 ais length 1 sub {
        /i exch def
        /ai ais i get def
        /val aival ai get def
        gpf length ai length add val length add array
        dup 0 gpf putinterval
        dup gpf length ai [ exch {} forall ] putinterval
        dup gpf length ai length add val [ exch {} forall ] putinterval
        /gpf exch def
        i ais length 1 sub ne aifixed ai 0 2 getinterval known not and {  % Append FNC1
            gpf length 1 add array
            dup 0 gpf putinterval
            dup gpf length fnc1 put
            /gpf exch def
        } if
    } for

    % Calculate the number of bits remaining to the next valid symbol size
    /rembits {
        /used exch def
        ccversion (c) ne {  % cc-a or cc-b
            <<
            /a [
                [167 138 118 108 88 78 59]
                [167 138 118  98 78]
                [197 167 138 108 78]
            ]
            /b [
                [ 336  296 256 208 160 104  56]
                [ 768  648 536 416 304 208 152 112  72 32]
                [1184 1016 840 672 496 352 264 208 152 96 56]
            ]
            >> ccversion get cccolumns 2 sub get /bitcaps exch def
            -1 bitcaps {dup used ge {exch} if pop} forall
            dup -1 ne {used sub} if
        } {
            << /c -1 >> ccversion get pop  % Assert cc-c
            /m used 8 div ceiling cvi dup 6 idiv 5 mul exch 6 mod add def
            m   40 le               {8 } if
            m   41 ge m  160 le and {16} if
            m  161 ge m  320 le and {32} if
            m  321 ge               {64} if
            /eccws exch def
            /m m eccws add 3 add def
            /c linwidth 52 sub 17 idiv def
            m c idiv 90 gt {/c c 1 add def} if
            /r m c div ceiling cvi def
            /tgt c r mul eccws sub 3 sub dup 5 idiv 6 mul exch 5 mod add 8 mul def
            used 8296 le {tgt used sub} {-1} ifelse
        } ifelse
        dup -1 eq {  % Upgrade CC-A to CC-B or CC-B to CC-C to fit
            pop
            ccversion (a) eq {
                /ccversion (b) def
            } {
                ccversion (b) eq lintype (gs1-128) eq and {
                    /ccversion (c) def
                    /cccolumns linwidth 52 sub 17 idiv def
                } {
                    /ccversion -1 def
                } ifelse
            } ifelse 
            used rembits
        } if
    } bind def

    /encode {
        dup /raw ne {exch get} {pop} ifelse
        [ exch {48 sub} forall ]
        dup length exch
        gpfenc exch j exch putinterval
        /j exch j add def
    } bind def

    % Pre-compute alphanumeric and numeric runlengths and position of next ISO646-only characters
    /numericruns [ gpf length {0} repeat 0 -1 ] def
    /alphanumericruns [ gpf length {0} repeat 0 ] def
    /nextiso646only [ gpf length {0} repeat 9999 ] def
    gpf length 1 sub -1 0 {
        /i exch def
        gpf i get
        (00) 2 string copy
        dup 0 gpf i get dup fnc1 eq {pop 94} if put 
        i gpf length 1 sub lt {dup 1 gpf i 1 add get dup fnc1 eq {pop 94} if put} if
        numeric exch known {
            numericruns i numericruns i 2 add get 2 add put
        } {
            numericruns i 0 put
        } ifelse
        dup alphanumeric exch known {
            alphanumericruns i alphanumericruns i 1 add get 1 add put
        } {
            alphanumericruns i 0 put
        } ifelse
        dup iso646 exch known exch alphanumeric exch known not and {
            nextiso646only i 0 put
        } {
            nextiso646only i nextiso646only i 1 add get 1 add put
        } ifelse
    } for
   
    % Encode the general purpose field
    /gpfenc 8296 array def
    /i 0 def /j 0 def
    {  % loop
        i gpf length eq {exit} if
        {  % not a loop but common exit point
    
            mode (numeric) eq {
                i gpf length 2 sub le {
                    2 string 
                    dup 0 gpf i get dup fnc1 eq {pop 94} if put
                    dup 1 gpf i 1 add get dup fnc1 eq {pop 94} if put
                    dup numeric exch known {
                        numeric encode
                        /i i 2 add def
                        exit
                    } if
                    pop
                    lalphanumeric numeric encode 
                    /mode (alphanumeric) def
                    exit
                } {
                    gpf i get dup 48 lt exch 57 gt or {
                        lalphanumeric numeric encode
                        /mode (alphanumeric) def
                        exit
                    } if
                    /rem cdf length j add rembits def
                    rem 4 ge rem 6 le and {  % C1 + 1 into 4 to 6 bits
                        (000000) 6 string copy 0 rem getinterval
                        dup gpf i get 47 sub 2 4 string cvrs
                        dup length 4 exch sub exch putinterval /raw encode
                        /i i 1 add def
                        exit
                    } {  % C1.FNC1
                        2 string dup 0 gpf i get put dup 1 94 put numeric encode 
                        /i i 1 add def
                        exit
                    } ifelse
                } ifelse
            } if
    
            mode (alphanumeric) eq {
                gpf i get fnc1 eq {
                    fnc1 alphanumeric encode
                    /i i 1 add def
                    exit
                } if
                gpf i get dup iso646 exch known exch alphanumeric exch known not and {
                     liso646 alphanumeric encode
                     /mode (iso646) def
                     exit
                } if
                numericruns i get 6 ge {
                    lnumeric alphanumeric encode
                    /mode (numeric) def
                    exit
                } if
                numericruns i get dup 4 ge exch i add gpf length eq and {
                    lnumeric alphanumeric encode
                    /mode (numeric) def
                    exit
                } if
                gpf i get alphanumeric encode
                /i i 1 add def
                exit
            } if
    
            mode (iso646) eq {
                gpf i get fnc1 eq {
                    fnc1 iso646 encode
                    /i i 1 add def
                    exit
                } if
                numericruns i get 4 ge nextiso646only i get 10 ge and {
                    lnumeric iso646 encode
                    /mode (numeric) def
                    exit
                } if
                alphanumericruns i get 5 ge nextiso646only i get 10 ge and {
                    lalphanumeric iso646 encode
                    /mode (alphanumeric) def
                    exit
                } if
                gpf i get iso646 encode
                /i i 1 add def
                exit
            } if
    
        } loop
    } loop
    /gpf gpfenc 0 j getinterval def

    % Create pad
    /pad cdf length gpf length add rembits array def
    pad length 0 gt {
        0 5 pad length 1 sub {  % Fill with 00100
            /i exch def
            pad i [ 0 0 1 0 0 ] 0 pad length i sub 5 2 copy gt {exch} if pop getinterval putinterval 
        } for 
        mode (numeric) eq {  % Prefix shift from numeric to ASCII
            /pad [ 0 0 0 0 pad aload pop ] 0 pad length getinterval def
        } if
        mode (alpha) eq {  % Prefix FNC1
            /pad [ 1 1 1 1 1 pad aload pop ] 0 pad length getinterval def
        } if
    } if

    % Concatinate fields
    /bits [
        cdf aload pop
        gpf aload pop
        pad aload pop
    ] def

    ccversion (a) eq {
        /pwr928 [
            [ 0 0 0 0 0 0 1 ]
            68 {7 array} repeat
        ] def
        1 1 68 {
            /j exch def
            /v 0 def
            6 -1 1 {
                /i exch def
                /v pwr928 j 1 sub get i get 2 mul v 928 idiv add def
                pwr928 j get i v 928 mod put 
            } for   
            pwr928 j get 0 pwr928 j 1 sub get 0 get 2 mul v 928 idiv add put
        } for
        /cws [ 28 {0} repeat ] def
        /b 0 def /c 0 def
        {  % loop
            b bits length eq {exit} if
            /bs bits b 69 bits length b sub 2 copy gt {exch} if pop getinterval def
            /bsl bs length def
            /cs cws c bsl 10 idiv 1 add getinterval def
            /csl cs length def
            0 1 bsl 1 sub {
                /i exch def
                0 1 csl 1 sub {
                    /j exch def
                    cs j 2 copy get
                    pwr928 i get j 7 add csl sub get
                    bs bsl i sub 1 sub get
                    mul add put
                } for
            } for
            csl 1 sub -1 1 {
                /i exch def
                cs i 1 sub 2 copy get cs i get 928 idiv add put
                cs i 2 copy get 928 mod put
            } for 
            /b b bsl add def
            /c c csl add def
        } loop
        /cws cws 0 c getinterval def
        /barcode cws length 4 mul string def
        0 1 cws length 1 sub {
            /i exch def
            (^   ) 4 string copy dup cws i get 10 4 string cvrs
            dup length 4 exch sub exch putinterval
            barcode i 4 mul 3 -1 roll putinterval
        } for
        options (dontdraw) true put
        options (cca) true put
        options (columns) cccolumns put
        /args barcode options //micropdf417 exec def
    } if

    ccversion (b) eq {
        /barcode bits length 8 idiv string def
        0 1 barcode length 1 sub {
            /i exch def
            bits i 8 mul 8 getinterval 0 exch {add 2 mul} forall 2 idiv
            barcode exch i exch put
        } for
        options (dontdraw) true put
        options (ccb) true put
        options (columns) cccolumns put
        /args barcode options //micropdf417 exec def
    } if

    ccversion (c) eq {
        /barcode bits length 8 idiv string def
        0 1 barcode length 1 sub {
            /i exch def
            bits i 8 mul 8 getinterval 0 exch {add 2 mul} forall 2 idiv
            barcode exch i exch put
        } for
        options (dontdraw) true put
        options (ccc) true put
        options (columns) cccolumns put
        /args barcode options //pdf417 exec def
    } if

    args
    dontdraw not //renmatrix if

    end

} bind def
/gs1-cc dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER gs1-cc--

% --BEGIN ENCODER ean13composite--
% --REQUIRES ean13 micropdf417 pdf417 gs1-cc--
% --SUGGESTS ean5 ean2--
% --DESC: EAN-13 Composite
% --EXAM: 331234567890|(99)1234-abcd
% --EXOP: includetext
% --RNDR: renlinear renmatrix
/setpacking where {pop currentpacking true setpacking} if
2 dict
dup /ean13 dup /uk.co.terryburton.bwipp findresource put
dup /gs1-cc dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/ean13composite {

    20 dict begin            % Confine variables to local scope

    /options exch def
    /barcode exch def

    /dontdraw false def
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    % Split the linear and composite parts
    barcode (|) search {
        /linear exch def
        pop
        /comp exch def
    } {
        pop
    } ifelse

    gsave

    options (lintype) (ean13) put
    options (inkspread) (0) put
    options (dontdraw) true put

    % Plot the linear part
    linear options //ean13 exec //renlinear exec

    % Plot the separator
    -1 72 rmoveto <<
        /ren //renmatrix
        /pixs [
            0 1  93 {0} repeat  1 0
            1 0  93 {0} repeat  0 1
            0 1  93 {0} repeat  1 0
        ]
        /pixx 97
        /pixy 3
        /height 6 72 div
        /width 97 72 div
        /opt options
    >> //renmatrix exec

    % Plot the 2D part
    -2 6 rmoveto comp options //gs1-cc exec //renmatrix exec

    grestore

    end

} bind def
/ean13composite dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER ean13composite--

% --BEGIN ENCODER ean8composite--
% --REQUIRES ean8 micropdf417 pdf417 gs1-cc--
% --SUGGESTS ean5 ean2--
% --DESC: EAN-8 Composite
% --EXAM: 12345670|(21)A12345678
% --EXOP: includetext
% --RNDR: renlinear renmatrix
/setpacking where {pop currentpacking true setpacking} if
2 dict
dup /ean8 dup /uk.co.terryburton.bwipp findresource put
dup /gs1-cc dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/ean8composite {

    20 dict begin            % Confine variables to local scope

    /options exch def
    /barcode exch def

    /dontdraw false def
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    % Split the linear and composite parts
    barcode (|) search {
        /linear exch def
        pop
        /comp exch def
    } {
        pop
    } ifelse

    gsave

    % Get the result of encoding with ean8 and gs1-cc
    options (lintype) (ean8) put
    options (inkspread) (0) put
    options (dontdraw) true put

    % Plot the linear part
    linear options //ean8 exec //renlinear exec

    % Plot the separator
    -1 72 rmoveto <<
        /ren //renmatrix
        /pixs [
            0 1  65 {0} repeat  1 0
            1 0  65 {0} repeat  0 1
            0 1  65 {0} repeat  1 0
        ]
        /pixx 69
        /pixy 3
        /height 6 72 div
        /width 69 72 div
        /opt options
    >> //renmatrix exec

    % Plot the 2D part
    comp options //gs1-cc exec
    dup (pixx) get 69 exch sub 6 rmoveto
    //renmatrix exec

    grestore

    end

} bind def
/ean8composite dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER ean8composite--

% --BEGIN ENCODER upcacomposite--
% --REQUIRES upca micropdf417 pdf417 gs1-cc--
% --SUGGESTS ean5 ean2--
% --DESC: UPC-A Composite
% --EXAM: 01600033610|(99)1234-abcd
% --EXOP: includetext
% --RNDR: renlinear renmatrix
/setpacking where {pop currentpacking true setpacking} if
2 dict
dup /upca dup /uk.co.terryburton.bwipp findresource put
dup /gs1-cc dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/upcacomposite {

    20 dict begin            % Confine variables to local scope

    /options exch def
    /barcode exch def

    /dontdraw false def
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    % Split the linear and composite parts
    barcode (|) search {
        /linear exch def
        pop
        /comp exch def
    } {
        pop
    } ifelse

    gsave

    options (lintype) (ean13) put
    options (inkspread) (0) put
    options (dontdraw) true put

    % Plot the linear part
    linear options //upca exec //renlinear exec

    % Plot the separator
    -1 72 rmoveto <<
        /ren //renmatrix
        /pixs [
            0 1  93 {0} repeat  1 0
            1 0  93 {0} repeat  0 1
            0 1  93 {0} repeat  1 0
        ]
        /pixx 97
        /pixy 3
        /height 6 72 div
        /width 97 72 div
        /opt options
    >> //renmatrix exec

    % Plot the 2D part
    -2 6 rmoveto comp options //gs1-cc exec //renmatrix exec

    grestore

    end

} bind def
/upcacomposite dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER upcacomposite--

% --BEGIN ENCODER upcecomposite--
% --REQUIRES upce micropdf417 pdf417 gs1-cc--
% --SUGGESTS ean5 ean2--
% --DESC: UPC-E Composite
% --EXAM: 0121230|(15)021231
% --EXOP: includetext
% --RNDR: renlinear renmatrix
/setpacking where {pop currentpacking true setpacking} if
2 dict
dup /upce dup /uk.co.terryburton.bwipp findresource put
dup /gs1-cc dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/upcecomposite {

    20 dict begin            % Confine variables to local scope

    /options exch def
    /barcode exch def

    /dontdraw false def
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    % Split the linear and composite parts
    barcode (|) search {
        /linear exch def
        pop
        /comp exch def
    } {
        pop
    } ifelse

    % Define the separator
    /sep <<
        /ren //renmatrix
        /pixs [
            0 1  49 {0} repeat  1 0
            1 0  49 {0} repeat  0 1
            0 1  49 {0} repeat  1 0
        ] 
        /pixx 53
        /pixy 3
        /height 6 72 div
        /width 53 72 div
        /opt options
    >> def

    gsave

    options (lintype) (upce) put
    options (inkspread) (0) put
    options (dontdraw) true put

    % Plot the linear part
    linear options //upce exec //renlinear exec

    % Plot the separator
    -1 72 rmoveto <<
        /ren //renmatrix
        /pixs [
            0 1  49 {0} repeat  1 0
            1 0  49 {0} repeat  0 1
            0 1  49 {0} repeat  1 0
        ]
        /pixx 53
        /pixy 3
        /height 6 72 div
        /width 53 72 div
        /opt options
    >> //renmatrix exec

    % Plot the 2D part
    -2 6 rmoveto comp options //gs1-cc exec //renmatrix exec

    grestore

    end

} bind def
/upcecomposite dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER upcecomposite--

% --BEGIN ENCODER databaromnicomposite--
% --REQUIRES databaromni micropdf417 pdf417 gs1-cc--
% --DESC: GS1 DataBar Omnidirectional Composite
% --EXAM: (01)03612345678904|(11)990102
% --EXOP:
% --RNDR: renlinear renmatrix
/setpacking where {pop currentpacking true setpacking} if
2 dict
dup /databaromni dup /uk.co.terryburton.bwipp findresource put
dup /gs1-cc dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/databaromnicomposite {

    20 dict begin            % Confine variables to local scope

    /options exch def
    /barcode exch def

    /dontdraw false def
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    % Split the linear and composite parts
    barcode (|) search {
        /linear exch def
        pop
        /comp exch def
    } {
        pop
    } ifelse

    gsave

    options (lintype) (databaromni) put
    options (linkage) true put
    options (inkspread) (0) put
    options (dontdraw) true put

    % Plot the linear part
    linear options //databaromni exec
    dup (sbs) get /linsbs exch def
    dup (bhs) get 0 get 72 mul /linheight exch def
    //renlinear exec

    % Plot the separator
    /sepfinder {
        /fp exch def
        fp 1 fp 12 add {
            /i exch def
            bot i get 0 eq {
                bot i 1 sub get 1 eq {
                    1
                } {
                    sep i 1 sub get 0 eq {1} {0} ifelse
                } ifelse
            } {
                0
            } ifelse
            sep exch i exch put
        } for
        /f3 [1 1 1 1 1 1 1 1 1 0 1 1 1] def
        true 0 1 12 {dup bot exch fp add get exch f3 exch get eq and} for {
            % Right shifted module for value 3 finder
            sep fp [ 0 0 0 0 0 0 0 0 0 0 1 0 0 ] putinterval
        } if
    } bind def
    mark
    0 linsbs {1 index 1 eq {{0}} {{1}} ifelse repeat} forall
    counttomark 1 sub array astore /bot exch def pop pop
    /sep [ bot {1 exch sub} forall ] def
    sep 0 [0 0 0] putinterval
    sep sep length 4 sub [0 0 0 0] putinterval
    18 sepfinder 64 sepfinder
    0 linheight rmoveto <<
        /ren //renmatrix
        /pixs sep
        /pixx sep length
        /pixy 1
        /height 1 72 div
        /width sep length 72 div
        /opt options
    >> //renmatrix exec

    % Plot the 2D part
    -5 1 rmoveto comp options //gs1-cc exec //renmatrix exec

    grestore

    end

} bind def
/databaromnicomposite dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER databaromnicomposite--

% --BEGIN ENCODER databarstackedcomposite--
% --REQUIRES databaromni databarstacked micropdf417 pdf417 gs1-cc--
% --DESC: GS1 DataBar Stacked Composite
% --EXAM: (01)03412345678900|(17)010200
% --EXOP:
% --RNDR: renlinear renmatrix
/setpacking where {pop currentpacking true setpacking} if
2 dict
dup /databarstacked dup /uk.co.terryburton.bwipp findresource put
dup /gs1-cc dup /uk.co.terryburton.bwipp findresource put
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/databarstackedcomposite {

    20 dict begin            % Confine variables to local scope

    /options exch def
    /barcode exch def

    /dontdraw false def
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    % Split the linear and composite parts
    barcode (|) search {
        /linear exch def
        pop
        /comp exch def
    } {
        pop
    } ifelse

    gsave

    options (lintype) (databarstacked) put
    options (linkage) true put
    options (inkspread) (0) put
    options (dontdraw) true put

    % Plot the linear part
    linear options //databarstacked exec
    dup (pixs) get 0 2 index (pixx) get getinterval /bot exch def
    dup (pixy) get /linheight exch def
    //renmatrix exec

    % Plot the separator
    /sepfinder {
        /fp exch def
        fp 1 fp 12 add {
            /i exch def
            bot i get 0 eq {
                bot i 1 sub get 1 eq {
                    1
                } {
                    sep i 1 sub get 0 eq {1} {0} ifelse
                } ifelse
            } {
                0
            } ifelse
            sep exch i exch put
        } for
        /f3 [1 1 1 1 1 1 1 1 1 0 1 1 1] def
        true 0 1 12 {dup bot exch fp add get exch f3 exch get eq and} for {
            % Right shifted module for value 3 finder
            sep fp [ 0 0 0 0 0 0 0 0 0 0 1 0 0 ] putinterval
        } if
    } bind def
    /sep [ bot {1 exch sub} forall ] def
    sep 0 [ 0 0 0 0 ] putinterval
    sep sep length 4 sub [ 0 0 0 0 ] putinterval
    18 sepfinder
    0 linheight rmoveto <<
        /ren //renmatrix
        /pixs sep
        /pixx sep length
        /pixy 1
        /height 1 72 div
        /width sep length 72 div
        /opt options
    >> //renmatrix exec

    % Plot the 2D part
    1 1 rmoveto comp options //gs1-cc exec //renmatrix exec

    grestore

    end

} bind def
/databarstackedcomposite dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER databarstackedcomposite--

% --BEGIN ENCODER databarstackedomnicomposite--
% --REQUIRES databaromni databarstackedomni micropdf417 pdf417 gs1-cc--
% --DESC: GS1 DataBar Stacked Omnidirectional Composite
% --EXAM: (01)03612345678904|(11)990102
% --EXOP:
% --RNDR: renlinear renmatrix
/setpacking where {pop currentpacking true setpacking} if
2 dict
dup /databarstackedomni dup /uk.co.terryburton.bwipp findresource put
dup /gs1-cc dup /uk.co.terryburton.bwipp findresource put
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/databarstackedomnicomposite {

    20 dict begin            % Confine variables to local scope

    /options exch def
    /barcode exch def

    /dontdraw false def
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    % Split the linear and composite parts
    barcode (|) search {
        /linear exch def
        pop
        /comp exch def
    } {
        pop
    } ifelse

    gsave

    options (lintype) (databarstackedomni) put
    options (linkage) true put
    options (inkspread) (0) put
    options (dontdraw) true put

    % Plot the linear part
    linear options //databarstackedomni exec
    dup (pixs) get 0 2 index (pixx) get getinterval /bot exch def
    dup (pixy) get /linheight exch def
    //renmatrix exec

    % Plot the separator
    /sepfinder {
        /fp exch def
        fp 1 fp 12 add {
            /i exch def
            bot i get 0 eq {
                bot i 1 sub get 1 eq {
                    1
                } {
                    sep i 1 sub get 0 eq {1} {0} ifelse
                } ifelse
            } {
                0
            } ifelse
            sep exch i exch put
        } for
        /f3 [1 1 1 1 1 1 1 1 1 0 1 1 1] def
        true 0 1 12 {dup bot exch fp add get exch f3 exch get eq and} for {
            % Right shifted module for value 3 finder
            sep fp [ 0 0 0 0 0 0 0 0 0 0 1 0 0 ] putinterval
        } if
    } bind def
    /sep [ bot {1 exch sub} forall ] def
    sep 0 [ 0 0 0 ] putinterval
    sep sep length 4 sub [ 0 0 0 0 ] putinterval
    18 sepfinder
    0 linheight rmoveto <<
        /ren //renmatrix
        /pixs sep
        /pixx sep length
        /pixy 1
        /height 1 72 div
        /width sep length 72 div
        /opt options
    >> //renmatrix exec

    % Plot the 2D part
    1 1 rmoveto comp options //gs1-cc exec //renmatrix exec

    grestore

    end

} bind def
/databarstackedomnicomposite dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER databarstackedomnicomposite--

% --BEGIN ENCODER databartruncatedcomposite--
% --REQUIRES databaromni databartruncated micropdf417 pdf417 gs1-cc--
% --DESC: GS1 DataBar Truncated Composite
% --EXAM: (01)03612345678904|(11)990102
% --EXOP:
% --RNDR: renlinear renmatrix
/setpacking where {pop currentpacking true setpacking} if
2 dict
dup /databartruncated dup /uk.co.terryburton.bwipp findresource put
dup /gs1-cc dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/databartruncatedcomposite {

    20 dict begin            % Confine variables to local scope

    /options exch def
    /barcode exch def

    /dontdraw false def
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    % Split the linear and composite parts
    barcode (|) search {
        /linear exch def
        pop
        /comp exch def
    } {
        pop
    } ifelse

    gsave

    options (lintype) (databartruncated) put
    options (linkage) true put
    options (inkspread) (0) put
    options (dontdraw) true put

    % Plot the linear part
    linear options //databartruncated exec
    dup (sbs) get /linsbs exch def
    dup (bhs) get 0 get 72 mul /linheight exch def
    //renlinear exec

    % Plot the separator
    /sepfinder {
        /fp exch def
        fp 1 fp 12 add {
            /i exch def
            bot i get 0 eq {
                bot i 1 sub get 1 eq {
                    1
                } {
                    sep i 1 sub get 0 eq {1} {0} ifelse
                } ifelse
            } {
                0
            } ifelse
            sep exch i exch put
        } for
        /f3 [1 1 1 1 1 1 1 1 1 0 1 1 1] def
        true 0 1 12 {dup bot exch fp add get exch f3 exch get eq and} for {
            % Right shifted module for value 3 finder
            sep fp [ 0 0 0 0 0 0 0 0 0 0 1 0 0 ] putinterval
        } if
    } bind def
    mark
    0 linsbs {1 index 1 eq {{0}} {{1}} ifelse repeat} forall
    counttomark 1 sub array astore /bot exch def pop pop
    /sep [ bot {1 exch sub} forall ] def
    sep 0 [0 0 0] putinterval
    sep sep length 4 sub [0 0 0 0] putinterval
    18 sepfinder 64 sepfinder
    0 linheight rmoveto <<
        /ren //renmatrix
        /pixs sep
        /pixx sep length
        /pixy 1
        /height 1 72 div
        /width sep length 72 div
        /opt options
    >> //renmatrix exec

    % Plot the 2D part
    -5 1 rmoveto comp options //gs1-cc exec //renmatrix exec

    grestore

    end

} bind def
/databartruncatedcomposite dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER databartruncatedcomposite--

% --BEGIN ENCODER databarlimitedcomposite--
% --REQUIRES databarlimited micropdf417 pdf417 gs1-cc--
% --DESC: GS1 DataBar Limited Composite
% --EXAM: (01)03512345678907|(21)abcdefghijklmnopqrstuv
% --EXOP:
% --RNDR: renlinear renmatrix
/setpacking where {pop currentpacking true setpacking} if
2 dict
dup /databarlimited dup /uk.co.terryburton.bwipp findresource put
dup /gs1-cc dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/databarlimitedcomposite {

    20 dict begin            % Confine variables to local scope

    /options exch def
    /barcode exch def

    /dontdraw false def
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    % Split the linear and composite parts
    barcode (|) search {
        /linear exch def
        pop
        /comp exch def
    } {
        pop
    } ifelse

    gsave

    options (lintype) (databarlimited) put
    options (linkage) true put
    options (inkspread) (0) put
    options (dontdraw) true put

    % Plot the linear part
    linear options //databarlimited exec
    dup (sbs) get /linsbs exch def
    dup (bhs) get 0 get 72 mul /linheight exch def
    //renlinear exec

    % Plot the separator
    mark
    1 linsbs {1 index 0 eq {{1}} {{0}} ifelse repeat} forall
    counttomark 1 sub array astore /sep exch def pop pop
    sep 0 [0 0 0] putinterval
    sep sep length 4 sub [0 0 0 0] putinterval
    0 linheight rmoveto <<
        /ren //renmatrix
        /pixs sep
        /pixx sep length
        /pixy 1
        /height 1 72 div
        /width sep length 72 div
        /opt options
    >> //renmatrix exec

    % Plot the 2D part
    comp options //gs1-cc exec 
    dup (pixx) get 72 exch sub 1 rmoveto 
    //renmatrix exec

    grestore

    end

} bind def
/databarlimitedcomposite dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER databarlimitedcomposite--

% --BEGIN ENCODER databarexpandedcomposite--
% --REQUIRES databarexpanded micropdf417 pdf417 gs1-cc--
% --DESC: GS1 DataBar Expanded Composite
% --EXAM: (01)93712345678904(3103)001234|(91)1A2B3C4D5E
% --EXOP:
% --RNDR: renlinear renmatrix
/setpacking where {pop currentpacking true setpacking} if
2 dict
dup /databarexpanded dup /uk.co.terryburton.bwipp findresource put
dup /gs1-cc dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/databarexpandedcomposite {

    20 dict begin            % Confine variables to local scope

    /options exch def
    /barcode exch def

    /dontdraw false def
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    % Split the linear and composite parts
    barcode (|) search {
        /linear exch def
        pop
        /comp exch def
    } {
        pop
    } ifelse

    gsave

    options (lintype) (databarexpanded) put
    options (linkage) true put
    options (inkspread) (0) put
    options (dontdraw) true put

    % Plot the linear part
    linear options //databarexpanded exec
    dup (sbs) get /linsbs exch def
    dup (bhs) get 0 get 72 mul /linheight exch def
    //renlinear exec

    % Plot the separator
    /sepfinder {
        /fp exch def
        fp 1 fp 12 add {
            /i exch def
            bot i get 0 eq {
                bot i 1 sub get 1 eq {
                    1
                } {
                    sep i 1 sub get 0 eq {1} {0} ifelse
                } ifelse
            } {
                0
            } ifelse
            sep exch i exch put
        } for
    } bind def
    mark
    0 linsbs {1 index 1 eq {{0}} {{1}} ifelse repeat} forall
    counttomark 1 sub array astore /bot exch def pop pop
    /sep [ bot {1 exch sub} forall ] def
    sep 0 [0 0 0] putinterval
    sep sep length 4 sub [0 0 0 0] putinterval
    [  % Finder pattern module positions
        18 98 bot length 13 sub {} for
        69 98 bot length 13 sub {} for
    ] {sepfinder} forall 
    0 linheight rmoveto <<
        /ren //renmatrix
        /pixs sep
        /pixx sep length
        /pixy 1
        /height 1 72 div
        /width sep length 72 div
        /opt options
    >> //renmatrix exec

    % Plot the 2D part
    1 1 rmoveto comp options //gs1-cc exec //renmatrix exec

    grestore

    end

} bind def
/databarexpandedcomposite dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER databarexpandedcomposite--

% --BEGIN ENCODER databarexpandedstackedcomposite--
% --REQUIRES databarexpanded databarexpandedstacked micropdf417 pdf417 gs1-cc--
% --DESC: GS1 DataBar Expanded Stacked Composite
% --EXAM: (01)00012345678905(10)ABCDEF|(21)12345678
% --EXOP: segments=4 
% --RNDR: renmatrix renlinear
/setpacking where {pop currentpacking true setpacking} if
2 dict
dup /databarexpandedstacked dup /uk.co.terryburton.bwipp findresource put
dup /gs1-cc dup /uk.co.terryburton.bwipp findresource put
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/databarexpandedstackedcomposite {

    20 dict begin            % Confine variables to local scope

    /options exch def
    /barcode exch def

    /dontdraw false def
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    % Split the linear and composite parts
    barcode (|) search {
        /linear exch def
        pop
        /comp exch def
    } {
        pop
    } ifelse

    gsave

    options (lintype) (databarexpandedstacked) put
    options (linkage) true put
    options (inkspread) (0) put
    options (dontdraw) true put

    % Plot the linear part
    linear options //databarexpandedstacked exec
    dup (pixs) get 0 2 index (pixx) get getinterval /bot exch def
    dup (pixy) get /linheight exch def
    //renmatrix exec

    % Plot the separator
    /sepfinder {
        /fp exch def
        fp 1 fp 12 add {
            /i exch def
            bot i get 0 eq {
                bot i 1 sub get 1 eq {
                    1
                } {
                    sep i 1 sub get 0 eq {1} {0} ifelse
                } ifelse
            } {
                0
            } ifelse
            sep exch i exch put
        } for
    } bind def
    /sep [ bot {1 exch sub} forall ] def
    sep 0 [ 0 0 0 ] putinterval
    sep sep length 4 sub [ 0 0 0 0 ] putinterval
    [  % Finder pattern module positions
        19 98 bot length 13 sub {} for
        70 98 bot length 13 sub {} for
    ] {sepfinder} forall 
    0 linheight rmoveto <<
        /ren //renmatrix
        /pixs sep
        /pixx sep length
        /pixy 1
        /height 1 72 div
        /width sep length 72 div
        /opt options
    >> //renmatrix exec

    % Plot the 2D part
    bot 0 get 0 eq {2} {0} ifelse 1 rmoveto
    comp options //gs1-cc exec //renmatrix exec

    grestore

    end

} bind def
/databarexpandedstackedcomposite dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER databarexpandedstackedcomposite--

% --BEGIN ENCODER gs1-128composite--
% --REQUIRES code128 gs1-128 micropdf417 pdf417 gs1-cc--
% --DESC: GS1-128 Composite
% --EXAM: (00)030123456789012340|(02)13012345678909(37)24(10)1234567ABCDEFG
% --EXOP: ccversion=c
% --RNDR: renlinear renmatrix
/setpacking where {pop currentpacking true setpacking} if
2 dict
dup /gs1-128 dup /uk.co.terryburton.bwipp findresource put
dup /gs1-cc dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/gs1-128composite {

    20 dict begin            % Confine variables to local scope

    /options exch def
    /barcode exch def

    /dontdraw false def
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    % Split the linear and composite parts
    barcode (|) search {
        /linear exch def
        pop
        /comp exch def
    } {
        pop
    } ifelse

    gsave

    options (inkspread) (0) put
    options (dontdraw) true put

    % Dummy plot of linear part with CC-A to get width
    options (linkagea) true put
    linear << options {} forall >> //gs1-128 exec
    (sbs) get 0 exch {add} forall /linwidth exch def

    % Create 2D part and determine type
    options (lintype) (gs1-128) put
    options (linwidth) linwidth put
    comp options //gs1-cc exec /compsym exch def
    compsym (pixx) get 99 eq {(a)} {(c)} ifelse /linktype exch def 

    % Plot linear part
    linktype (a) eq {
        options (linkagea) true put
        options (linkagec) false put
    } {
        options (linkagea) false put
        options (linkagec) true put
    } ifelse
    linear << options {} forall >> //gs1-128 exec
    dup (sbs) get /linsbs exch def
    dup (bhs) get 0 get 72 mul /linheight exch def
    //renlinear exec

    % Plot the separator
    mark
    1 linsbs {1 index 0 eq {{1}} {{0}} ifelse repeat} forall
    counttomark 1 sub array astore /sep exch def pop pop
    0 linheight rmoveto <<
        /ren //renmatrix
        /pixs sep
        /pixx sep length
        /pixy 1
        /height 1 72 div
        /width sep length 72 div
        /opt options
    >> //renmatrix exec

    % Plot the 2D part
    linktype (a) eq {
        /s linwidth 2 sub 11 idiv def
        /p s 9 sub 2 idiv def
        /x s p sub 1 sub 11 mul 10 add p 0 eq {2 add} if 99 sub def
        x 1 rmoveto
    } {
        -7 1 rmoveto 
    } ifelse

    compsym //renmatrix exec

    grestore

    end

} bind def
/gs1-128composite dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER gs1-128composite--

% --BEGIN ENCODER hibccode39--
% --REQUIRES code39--
% --DESC: HIBC Code 39
% --EXAM: A123BJC5D6E71
% --EXOP: includetext
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /code39 dup /uk.co.terryburton.bwipp findresource put
begin
/hibccode39 {

    20 dict begin                 % Confine variables to local scope

    /options exch def       % We are given an option string
    /barcode exch def       % We are given a barcode string

    /dontdraw false def
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /textxoffset 0 def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /textxoffset textxoffset cvr def

    /barlen barcode length def

    /barchars (0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%) def

    /barcode barlen 2 add string dup 1 barcode putinterval def
    barcode 0 43 put

    /checksum 0 def
    0 1 barlen {
        /i exch def
        % Lookup the encoding for the each barcode character
        barcode i 1 getinterval barchars exch search
        pop                                  % Discard true leaving pre
        length /indx exch def                % indx is the length of pre
        pop pop                              % Discard seek and post
        /checksum checksum indx add def
    } for
    barcode barlen 1 add barchars checksum 43 mod get put

    /text barlen 4 add string def
    text 0 42 put
    text 1 barcode putinterval
    text barlen 2 add barcode barlen 1 add get dup 32 eq {pop 95} if put
    text barlen 3 add 42 put

    % Get the result of encoding with code39
    options (dontdraw) true put
    options (includecheck) false put
    /args barcode options //code39 exec def

    args (txt) [ [text textxoffset textyoffset textfont textsize] ] put
    args (textxalign) (center) put
    args (opt) options put
    args
 
    dontdraw not //renlinear if

    end

} bind def
/hibccode39 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER hibccode39--

% --BEGIN ENCODER hibccode128--
% --REQUIRES code128--
% --DESC: HIBC Code 128
% --EXAM: A123BJC5D6E71
% --EXOP: includetext
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /code128 dup /uk.co.terryburton.bwipp findresource put
begin
/hibccode128 {

    20 dict begin                 % Confine variables to local scope

    /options exch def       % We are given an option string
    /barcode exch def       % We are given a barcode string

    /dontdraw false def
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /textxoffset 0 def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /textxoffset textxoffset cvr def

    /barlen barcode length def

    /barchars (0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%) def

    /barcode barlen 2 add string dup 1 barcode putinterval def
    barcode 0 43 put

    /checksum 0 def
    0 1 barlen {
        /i exch def
        % Lookup the encoding for the each barcode character
        barcode i 1 getinterval barchars exch search
        pop                                  % Discard true leaving pre
        length /indx exch def                % indx is the length of pre
        pop pop                              % Discard seek and post
        /checksum checksum indx add def
    } for
    barcode barlen 1 add barchars checksum 43 mod get put

    /text barlen 4 add string def
    text 0 42 put
    text 1 barcode putinterval
    text barlen 2 add barcode barlen 1 add get dup 32 eq {pop 95} if put
    text barlen 3 add 42 put

    % Get the result of encoding with code128
    options (dontdraw) true put
    /args barcode options //code128 exec def

    args (txt) [ [text textxoffset textyoffset textfont textsize] ] put
    args (textxalign) (center) put
    args (opt) options put
    args
 
    dontdraw not //renlinear if

    end

} bind def
/hibccode128 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER hibccode128--

% --BEGIN ENCODER hibcdatamatrix--
% --REQUIRES datamatrix--
% --DESC: HIBC Data Matrix
% --EXAM: A123BJC5D6E71
% --EXOP:
% --RNDR: renmatrix
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
dup /datamatrix dup /uk.co.terryburton.bwipp findresource put
begin
/hibcdatamatrix {

    20 dict begin                 % Confine variables to local scope

    /options exch def       % We are given an option string
    /barcode exch def       % We are given a barcode string

    /dontdraw false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /barlen barcode length def

    /barchars (0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%) def

    /barcode barlen 2 add string dup 1 barcode putinterval def
    barcode 0 43 put

    /checksum 0 def
    0 1 barlen {
        /i exch def
        % Lookup the encoding for the each barcode character
        barcode i 1 getinterval barchars exch search
        pop                                  % Discard true leaving pre
        length /indx exch def                % indx is the length of pre
        pop pop                              % Discard seek and post
        /checksum checksum indx add def
    } for
    barcode barlen 1 add barchars checksum 43 mod get put

    % Get the result of encoding with datamatrix
    options (dontdraw) true put
    /args barcode options //datamatrix exec def

    args (opt) options put
    args
 
    dontdraw not //renmatrix if

    end

} bind def
/hibcdatamatrix dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER hibcdatamatrix--

% --BEGIN ENCODER hibcpdf417--
% --REQUIRES pdf417--
% --DESC: HIBC PDF417
% --EXAM: A123BJC5D6E71
% --EXOP:
% --RNDR: renmatrix
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
dup /pdf417 dup /uk.co.terryburton.bwipp findresource put
begin
/hibcpdf417 {

    20 dict begin                 % Confine variables to local scope

    /options exch def       % We are given an option string
    /barcode exch def       % We are given a barcode string

    /dontdraw false def
    /columns 2 def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /columns columns cvi def

    /barlen barcode length def

    /barchars (0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%) def

    /barcode barlen 2 add string dup 1 barcode putinterval def
    barcode 0 43 put

    /checksum 0 def
    0 1 barlen {
        /i exch def
        % Lookup the encoding for the each barcode character
        barcode i 1 getinterval barchars exch search
        pop                                  % Discard true leaving pre
        length /indx exch def                % indx is the length of pre
        pop pop                              % Discard seek and post
        /checksum checksum indx add def
    } for
    barcode barlen 1 add barchars checksum 43 mod get put

    % Get the result of encoding with pdf417
    options (dontdraw) true put
    options (columns) columns put
    /args barcode options //pdf417 exec def

    args (opt) options put
    args
 
    dontdraw not //renmatrix if

    end

} bind def
/hibcpdf417 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER hibcpdf417--

% --BEGIN ENCODER hibcmicropdf417--
% --REQUIRES micropdf417--
% --DESC: HIBC MicroPDF417
% --EXAM: A123BJC5D6E71
% --EXOP:
% --RNDR: renmatrix
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
dup /micropdf417 dup /uk.co.terryburton.bwipp findresource put
begin
/hibcmicropdf417 {

    20 dict begin                 % Confine variables to local scope

    /options exch def       % We are given an option string
    /barcode exch def       % We are given a barcode string

    /dontdraw false def
    /columns 2 def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /columns columns cvi def

    /barlen barcode length def

    /barchars (0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%) def

    /barcode barlen 2 add string dup 1 barcode putinterval def
    barcode 0 43 put

    /checksum 0 def
    0 1 barlen {
        /i exch def
        % Lookup the encoding for the each barcode character
        barcode i 1 getinterval barchars exch search
        pop                                  % Discard true leaving pre
        length /indx exch def                % indx is the length of pre
        pop pop                              % Discard seek and post
        /checksum checksum indx add def
    } for
    barcode barlen 1 add barchars checksum 43 mod get put

    % Get the result of encoding with micropdf417
    options (dontdraw) true put
    options (columns) columns put
    /args barcode options //micropdf417 exec def

    args (opt) options put
    args
 
    dontdraw not //renmatrix if

    end

} bind def
/hibcmicropdf417 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER hibcmicropdf417--

% --BEGIN ENCODER hibcqrcode--
% --REQUIRES qrcode--
% --DESC: HIBC QR Code
% --EXAM: A123BJC5D6E71
% --EXOP:
% --RNDR: renmatrix
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
dup /qrcode dup /uk.co.terryburton.bwipp findresource put
begin
/hibcqrcode {

    20 dict begin                 % Confine variables to local scope

    /options exch def       % We are given an option string
    /barcode exch def       % We are given a barcode string

    /dontdraw false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /barlen barcode length def

    /barchars (0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%) def

    /barcode barlen 2 add string dup 1 barcode putinterval def
    barcode 0 43 put

    /checksum 0 def
    0 1 barlen {
        /i exch def
        % Lookup the encoding for the each barcode character
        barcode i 1 getinterval barchars exch search
        pop                                  % Discard true leaving pre
        length /indx exch def                % indx is the length of pre
        pop pop                              % Discard seek and post
        /checksum checksum indx add def
    } for
    barcode barlen 1 add barchars checksum 43 mod get put

    % Get the result of encoding with qrcode
    options (dontdraw) true put
    /args barcode options //qrcode exec def

    args (opt) options put
    args
 
    dontdraw not //renmatrix if

    end

} bind def
/hibcqrcode dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER hibcqrcode--

% --BEGIN ENCODER hibccodablockf--
% --REQUIRES codablockf--
% --DESC: HIBC Codablock F
% --EXAM: A123BJC5D6E71
% --EXOP:
% --RNDR: renmatrix
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
dup /codablockf dup /uk.co.terryburton.bwipp findresource put
begin
/hibccodablockf {

    20 dict begin                 % Confine variables to local scope

    /options exch def       % We are given an option string
    /barcode exch def       % We are given a barcode string

    /dontdraw false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /barlen barcode length def

    /barchars (0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%) def

    /barcode barlen 2 add string dup 1 barcode putinterval def
    barcode 0 43 put

    /checksum 0 def
    0 1 barlen {
        /i exch def
        % Lookup the encoding for the each barcode character
        barcode i 1 getinterval barchars exch search
        pop                                  % Discard true leaving pre
        length /indx exch def                % indx is the length of pre
        pop pop                              % Discard seek and post
        /checksum checksum indx add def
    } for
    barcode barlen 1 add barchars checksum 43 mod get put

    % Get the result of encoding with codablockf
    options (dontdraw) true put
    /args barcode options //codablockf exec def

    args (opt) options put
    args
 
    dontdraw not //renmatrix if

    end

} bind def
/hibccodablockf dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER hibccodablockf--

% --END TEMPLATE--

%%EndProcSet
%%BeginProcSet: 8r.enc 0 0
% File 8r.enc  TeX Base 1 Encoding  Revision 2.0  2002-10-30
%
% @@psencodingfile@{
%   author    = "S. Rahtz, P. MacKay, Alan Jeffrey, B. Horn, K. Berry,
%                W. Schmidt, P. Lehman",
%   version   = "2.0",
%   date      = "27nov06",
%   filename  = "8r.enc",
%   email     = "tex-fonts@@tug.org",
%   docstring = "This is the encoding vector for Type1 and TrueType
%                fonts to be used with TeX.  This file is part of the
%                PSNFSS bundle, version 9"
% @}
% 
% The idea is to have all the characters normally included in Type 1 fonts
% available for typesetting. This is effectively the characters in Adobe
% Standard encoding, ISO Latin 1, Windows ANSI including the euro symbol,
% MacRoman, and some extra characters from Lucida.
% 
% Character code assignments were made as follows:
% 
% (1) the Windows ANSI characters are almost all in their Windows ANSI
% positions, because some Windows users cannot easily reencode the
% fonts, and it makes no difference on other systems. The only Windows
% ANSI characters not available are those that make no sense for
% typesetting -- rubout (127 decimal), nobreakspace (160), softhyphen
% (173). quotesingle and grave are moved just because it's such an
% irritation not having them in TeX positions.
% 
% (2) Remaining characters are assigned arbitrarily to the lower part
% of the range, avoiding 0, 10 and 13 in case we meet dumb software.
% 
% (3) Y&Y Lucida Bright includes some extra text characters; in the
% hopes that other PostScript fonts, perhaps created for public
% consumption, will include them, they are included starting at 0x12.
% These are /dotlessj /ff /ffi /ffl.
% 
% (4) hyphen appears twice for compatibility with both ASCII and Windows.
%
% (5) /Euro was assigned to 128, as in Windows ANSI
%
% (6) Missing characters from MacRoman encoding incorporated as follows:
%
%     PostScript      MacRoman        TeXBase1
%     --------------  --------------  --------------
%     /notequal       173             0x16
%     /infinity       176             0x17
%     /lessequal      178             0x18
%     /greaterequal   179             0x19
%     /partialdiff    182             0x1A
%     /summation      183             0x1B
%     /product        184             0x1C
%     /pi             185             0x1D
%     /integral       186             0x81
%     /Omega          189             0x8D
%     /radical        195             0x8E
%     /approxequal    197             0x8F
%     /Delta          198             0x9D
%     /lozenge        215             0x9E
%
/TeXBase1Encoding [
% 0x00
 /.notdef /dotaccent /fi /fl
 /fraction /hungarumlaut /Lslash /lslash
 /ogonek /ring /.notdef /breve
 /minus /.notdef /Zcaron /zcaron
% 0x10
 /caron /dotlessi /dotlessj /ff
 /ffi /ffl /notequal /infinity
 /lessequal /greaterequal /partialdiff /summation
 /product /pi /grave /quotesingle
% 0x20
 /space /exclam /quotedbl /numbersign
 /dollar /percent /ampersand /quoteright
 /parenleft /parenright /asterisk /plus
 /comma /hyphen /period /slash
% 0x30
 /zero /one /two /three
 /four /five /six /seven
 /eight /nine /colon /semicolon
 /less /equal /greater /question
% 0x40
 /at /A /B /C
 /D /E /F /G
 /H /I /J /K
 /L /M /N /O
% 0x50
 /P /Q /R /S
 /T /U /V /W
 /X /Y /Z /bracketleft
 /backslash /bracketright /asciicircum /underscore
% 0x60
 /quoteleft /a /b /c
 /d /e /f /g
 /h /i /j /k
 /l /m /n /o
% 0x70
 /p /q /r /s
 /t /u /v /w
 /x /y /z /braceleft
 /bar /braceright /asciitilde /.notdef
% 0x80
 /Euro /integral /quotesinglbase /florin
 /quotedblbase /ellipsis /dagger /daggerdbl
 /circumflex /perthousand /Scaron /guilsinglleft
 /OE /Omega /radical /approxequal
% 0x90
 /.notdef /.notdef /.notdef /quotedblleft
 /quotedblright /bullet /endash /emdash
 /tilde /trademark /scaron /guilsinglright
 /oe /Delta /lozenge /Ydieresis
% 0xA0
 /.notdef /exclamdown /cent /sterling
 /currency /yen /brokenbar /section
 /dieresis /copyright /ordfeminine /guillemotleft
 /logicalnot /hyphen /registered /macron
% 0xB0
 /degree /plusminus /twosuperior /threesuperior
 /acute /mu /paragraph /periodcentered
 /cedilla /onesuperior /ordmasculine /guillemotright
 /onequarter /onehalf /threequarters /questiondown
% 0xC0
 /Agrave /Aacute /Acircumflex /Atilde
 /Adieresis /Aring /AE /Ccedilla
 /Egrave /Eacute /Ecircumflex /Edieresis
 /Igrave /Iacute /Icircumflex /Idieresis
% 0xD0
 /Eth /Ntilde /Ograve /Oacute
 /Ocircumflex /Otilde /Odieresis /multiply
 /Oslash /Ugrave /Uacute /Ucircumflex
 /Udieresis /Yacute /Thorn /germandbls
% 0xE0
 /agrave /aacute /acircumflex /atilde
 /adieresis /aring /ae /ccedilla
 /egrave /eacute /ecircumflex /edieresis
 /igrave /iacute /icircumflex /idieresis
% 0xF0
 /eth /ntilde /ograve /oacute
 /ocircumflex /otilde /odieresis /divide
 /oslash /ugrave /uacute /ucircumflex
 /udieresis /yacute /thorn /ydieresis
] def


%%EndProcSet
%%BeginProcSet: texps.pro 0 0
%!
TeXDict begin/rf{findfont dup length 1 add dict begin{1 index/FID ne 2
index/UniqueID ne and{def}{pop pop}ifelse}forall[1 index 0 6 -1 roll
exec 0 exch 5 -1 roll VResolution Resolution div mul neg 0 0]/Metrics
exch def dict begin Encoding{exch dup type/integertype ne{pop pop 1 sub
dup 0 le{pop}{[}ifelse}{FontMatrix 0 get div Metrics 0 get div def}
ifelse}forall Metrics/Metrics currentdict end def[2 index currentdict
end definefont 3 -1 roll makefont/setfont cvx]cvx def}def/ObliqueSlant{
dup sin S cos div neg}B/SlantFont{4 index mul add}def/ExtendFont{3 -1
roll mul exch}def/ReEncodeFont{CharStrings rcheck{/Encoding false def
dup[exch{dup CharStrings exch known not{pop/.notdef/Encoding true def}
if}forall Encoding{]exch pop}{cleartomark}ifelse}if/Encoding exch def}
def end

%%EndProcSet
%%BeginProcSet: special.pro 0 0
%!
TeXDict begin/SDict 200 dict N SDict begin/@SpecialDefaults{/hs 612 N
/vs 792 N/ho 0 N/vo 0 N/hsc 1 N/vsc 1 N/ang 0 N/CLIP 0 N/rwiSeen false N
/rhiSeen false N/letter{}N/note{}N/a4{}N/legal{}N}B/@scaleunit 100 N
/@hscale{@scaleunit div/hsc X}B/@vscale{@scaleunit div/vsc X}B/@hsize{
/hs X/CLIP 1 N}B/@vsize{/vs X/CLIP 1 N}B/@clip{/CLIP 2 N}B/@hoffset{/ho
X}B/@voffset{/vo X}B/@angle{/ang X}B/@rwi{10 div/rwi X/rwiSeen true N}B
/@rhi{10 div/rhi X/rhiSeen true N}B/@llx{/llx X}B/@lly{/lly X}B/@urx{
/urx X}B/@ury{/ury X}B/magscale true def end/@MacSetUp{userdict/md known
{userdict/md get type/dicttype eq{userdict begin md length 10 add md
maxlength ge{/md md dup length 20 add dict copy def}if end md begin
/letter{}N/note{}N/legal{}N/od{txpose 1 0 mtx defaultmatrix dtransform S
atan/pa X newpath clippath mark{transform{itransform moveto}}{transform{
itransform lineto}}{6 -2 roll transform 6 -2 roll transform 6 -2 roll
transform{itransform 6 2 roll itransform 6 2 roll itransform 6 2 roll
curveto}}{{closepath}}pathforall newpath counttomark array astore/gc xdf
pop ct 39 0 put 10 fz 0 fs 2 F/|______Courier fnt invertflag{PaintBlack}
if}N/txpose{pxs pys scale ppr aload pop por{noflips{pop S neg S TR pop 1
-1 scale}if xflip yflip and{pop S neg S TR 180 rotate 1 -1 scale ppr 3
get ppr 1 get neg sub neg ppr 2 get ppr 0 get neg sub neg TR}if xflip
yflip not and{pop S neg S TR pop 180 rotate ppr 3 get ppr 1 get neg sub
neg 0 TR}if yflip xflip not and{ppr 1 get neg ppr 0 get neg TR}if}{
noflips{TR pop pop 270 rotate 1 -1 scale}if xflip yflip and{TR pop pop
90 rotate 1 -1 scale ppr 3 get ppr 1 get neg sub neg ppr 2 get ppr 0 get
neg sub neg TR}if xflip yflip not and{TR pop pop 90 rotate ppr 3 get ppr
1 get neg sub neg 0 TR}if yflip xflip not and{TR pop pop 270 rotate ppr
2 get ppr 0 get neg sub neg 0 S TR}if}ifelse scaleby96{ppr aload pop 4
-1 roll add 2 div 3 1 roll add 2 div 2 copy TR .96 dup scale neg S neg S
TR}if}N/cp{pop pop showpage pm restore}N end}if}if}N/normalscale{
Resolution 72 div VResolution 72 div neg scale magscale{DVImag dup scale
}if 0 setgray}N/psfts{S 65781.76 div N}N/startTexFig{/psf$SavedState
save N userdict maxlength dict begin/magscale true def normalscale
currentpoint TR/psf$ury psfts/psf$urx psfts/psf$lly psfts/psf$llx psfts
/psf$y psfts/psf$x psfts currentpoint/psf$cy X/psf$cx X/psf$sx psf$x
psf$urx psf$llx sub div N/psf$sy psf$y psf$ury psf$lly sub div N psf$sx
psf$sy scale psf$cx psf$sx div psf$llx sub psf$cy psf$sy div psf$ury sub
TR/showpage{}N/erasepage{}N/copypage{}N/p 3 def @MacSetUp}N/doclip{
psf$llx psf$lly psf$urx psf$ury currentpoint 6 2 roll newpath 4 copy 4 2
roll moveto 6 -1 roll S lineto S lineto S lineto closepath clip newpath
moveto}N/endTexFig{end psf$SavedState restore}N/@beginspecial{SDict
begin/SpecialSave save N gsave normalscale currentpoint TR
@SpecialDefaults count/ocount X/dcount countdictstack N}N/@setspecial{
CLIP 1 eq{newpath 0 0 moveto hs 0 rlineto 0 vs rlineto hs neg 0 rlineto
closepath clip}if ho vo TR hsc vsc scale ang rotate rwiSeen{rwi urx llx
sub div rhiSeen{rhi ury lly sub div}{dup}ifelse scale llx neg lly neg TR
}{rhiSeen{rhi ury lly sub div dup scale llx neg lly neg TR}if}ifelse
CLIP 2 eq{newpath llx lly moveto urx lly lineto urx ury lineto llx ury
lineto closepath clip}if/showpage{}N/erasepage{}N/copypage{}N newpath}N
/@endspecial{count ocount sub{pop}repeat countdictstack dcount sub{end}
repeat grestore SpecialSave restore end}N/@defspecial{SDict begin}N
/@fedspecial{end}B/li{lineto}B/rl{rlineto}B/rc{rcurveto}B/np{/SaveX
currentpoint/SaveY X N 1 setlinecap newpath}N/st{stroke SaveX SaveY
moveto}N/fil{fill SaveX SaveY moveto}N/ellipse{/endangle X/startangle X
/yrad X/xrad X/savematrix matrix currentmatrix N TR xrad yrad scale 0 0
1 startangle endangle arc savematrix setmatrix}N end

%%EndProcSet
%%BeginProcSet: color.pro 0 0
%!
TeXDict begin/setcmykcolor where{pop}{/setcmykcolor{dup 10 eq{pop
setrgbcolor}{1 sub 4 1 roll 3{3 index add neg dup 0 lt{pop 0}if 3 1 roll
}repeat setrgbcolor pop}ifelse}B}ifelse/TeXcolorcmyk{setcmykcolor}def
/TeXcolorrgb{setrgbcolor}def/TeXcolorgrey{setgray}def/TeXcolorgray{
setgray}def/TeXcolorhsb{sethsbcolor}def/currentcmykcolor where{pop}{
/currentcmykcolor{currentrgbcolor 10}B}ifelse/DC{exch dup userdict exch
known{pop pop}{X}ifelse}B/GreenYellow{0.15 0 0.69 0 setcmykcolor}DC
/Yellow{0 0 1 0 setcmykcolor}DC/Goldenrod{0 0.10 0.84 0 setcmykcolor}DC
/Dandelion{0 0.29 0.84 0 setcmykcolor}DC/Apricot{0 0.32 0.52 0
setcmykcolor}DC/Peach{0 0.50 0.70 0 setcmykcolor}DC/Melon{0 0.46 0.50 0
setcmykcolor}DC/YellowOrange{0 0.42 1 0 setcmykcolor}DC/Orange{0 0.61
0.87 0 setcmykcolor}DC/BurntOrange{0 0.51 1 0 setcmykcolor}DC
/Bittersweet{0 0.75 1 0.24 setcmykcolor}DC/RedOrange{0 0.77 0.87 0
setcmykcolor}DC/Mahogany{0 0.85 0.87 0.35 setcmykcolor}DC/Maroon{0 0.87
0.68 0.32 setcmykcolor}DC/BrickRed{0 0.89 0.94 0.28 setcmykcolor}DC/Red{
0 1 1 0 setcmykcolor}DC/OrangeRed{0 1 0.50 0 setcmykcolor}DC/RubineRed{
0 1 0.13 0 setcmykcolor}DC/WildStrawberry{0 0.96 0.39 0 setcmykcolor}DC
/Salmon{0 0.53 0.38 0 setcmykcolor}DC/CarnationPink{0 0.63 0 0
setcmykcolor}DC/Magenta{0 1 0 0 setcmykcolor}DC/VioletRed{0 0.81 0 0
setcmykcolor}DC/Rhodamine{0 0.82 0 0 setcmykcolor}DC/Mulberry{0.34 0.90
0 0.02 setcmykcolor}DC/RedViolet{0.07 0.90 0 0.34 setcmykcolor}DC
/Fuchsia{0.47 0.91 0 0.08 setcmykcolor}DC/Lavender{0 0.48 0 0
setcmykcolor}DC/Thistle{0.12 0.59 0 0 setcmykcolor}DC/Orchid{0.32 0.64 0
0 setcmykcolor}DC/DarkOrchid{0.40 0.80 0.20 0 setcmykcolor}DC/Purple{
0.45 0.86 0 0 setcmykcolor}DC/Plum{0.50 1 0 0 setcmykcolor}DC/Violet{
0.79 0.88 0 0 setcmykcolor}DC/RoyalPurple{0.75 0.90 0 0 setcmykcolor}DC
/BlueViolet{0.86 0.91 0 0.04 setcmykcolor}DC/Periwinkle{0.57 0.55 0 0
setcmykcolor}DC/CadetBlue{0.62 0.57 0.23 0 setcmykcolor}DC
/CornflowerBlue{0.65 0.13 0 0 setcmykcolor}DC/MidnightBlue{0.98 0.13 0
0.43 setcmykcolor}DC/NavyBlue{0.94 0.54 0 0 setcmykcolor}DC/RoyalBlue{1
0.50 0 0 setcmykcolor}DC/Blue{1 1 0 0 setcmykcolor}DC/Cerulean{0.94 0.11
0 0 setcmykcolor}DC/Cyan{1 0 0 0 setcmykcolor}DC/ProcessBlue{0.96 0 0 0
setcmykcolor}DC/SkyBlue{0.62 0 0.12 0 setcmykcolor}DC/Turquoise{0.85 0
0.20 0 setcmykcolor}DC/TealBlue{0.86 0 0.34 0.02 setcmykcolor}DC
/Aquamarine{0.82 0 0.30 0 setcmykcolor}DC/BlueGreen{0.85 0 0.33 0
setcmykcolor}DC/Emerald{1 0 0.50 0 setcmykcolor}DC/JungleGreen{0.99 0
0.52 0 setcmykcolor}DC/SeaGreen{0.69 0 0.50 0 setcmykcolor}DC/Green{1 0
1 0 setcmykcolor}DC/ForestGreen{0.91 0 0.88 0.12 setcmykcolor}DC
/PineGreen{0.92 0 0.59 0.25 setcmykcolor}DC/LimeGreen{0.50 0 1 0
setcmykcolor}DC/YellowGreen{0.44 0 0.74 0 setcmykcolor}DC/SpringGreen{
0.26 0 0.76 0 setcmykcolor}DC/OliveGreen{0.64 0 0.95 0.40 setcmykcolor}
DC/RawSienna{0 0.72 1 0.45 setcmykcolor}DC/Sepia{0 0.83 1 0.70
setcmykcolor}DC/Brown{0 0.81 1 0.60 setcmykcolor}DC/Tan{0.14 0.42 0.56 0
setcmykcolor}DC/Gray{0 0 0 0.50 setcmykcolor}DC/Black{0 0 0 1
setcmykcolor}DC/White{0 0 0 0 setcmykcolor}DC end

%%EndProcSet
TeXDict begin @defspecial

 /pgfH{/pgfheight exch def 0.75 setlinewidth [] 0 setdash /pgfshade
{pgfA} def /pgfdir { dup 0 moveto dup 5 index lineto } bind def} bind
def

 /pgfV{/pgfheight exch def 0.75 setlinewidth [] 0 setdash /pgfshade
{pgfA} def /pgfdir { dup 0 exch moveto dup 5 index exch lineto } bind
def} bind def

 /pgfA{ /pgfdiff 8 index round cvi 8 index round cvi sub 2 mul 1 add
def 2 index 6 index sub pgfdiff div 2 index 6 index sub pgfdiff div
2 index 6 index sub pgfdiff div pgfheight 9 index 9 index 9 index 14
index pgfdiff { 3 index 3 index 3 index setrgbcolor pgfdir stroke 4
-1 roll 7 index add 4 -1 roll 6 index add 4 -1 roll 5 index add 4 -1
roll .5 sub } repeat mark 15 1 roll cleartomark exch pop }bind def

 /pgfR1{ newpath dup dup dup 0 360 arc clip newpath dup /pgfendx exch
def /pgfendy exch def 0.875 setlinewidth [] 0 setdash /pgfshade {pgfR}
def /pgfstartx exch def /pgfstarty exch def /pgfdiffx pgfendx pgfstartx
sub def /pgfdiffy pgfendy pgfstarty sub def dup /pgfdomb exch def }bind
def

 /pgfR2{ newpath 0.5 add pgfcircx pgfcircy 3 2 roll 0 360 arc setrgbcolor
fill pop}bind def

 /pgfR{ /pgfdiff 8 index round cvi 8 index round cvi sub 4 mul 1 add
def /pgfcircx pgfstartx 9 index pgfdiffx pgfdomb div mul add def /pgfcircy
pgfstarty 9 index pgfdiffy pgfdomb div mul add def /pgfcircxe pgfstartx
8 index pgfdiffx pgfdomb div mul add def /pgfcircye pgfstarty 8 index
pgfdiffy pgfdomb div mul add def /pgfxstep pgfcircxe pgfcircx sub pgfdiff
div def /pgfystep pgfcircye pgfcircy sub pgfdiff div def 2 index 6
index sub pgfdiff div 2 index 6 index sub pgfdiff div 2 index 6 index
sub pgfdiff div 8 index 8 index 8 index 13 index pgfdiff { 3 index
3 index 3 index setrgbcolor pgfcircx pgfcircy 2 index 0 360 arc closepath
stroke 4 -1 roll 6 index add 4 -1 roll 5 index add 4 -1 roll 4 index
add 4 -1 roll .25 sub /pgfcircx pgfcircx pgfxstep add def /pgfcircy
pgfcircy pgfystep add def } repeat mark 14 1 roll cleartomark exch
pop }bind def

  /pgfsc{}bind def/pgffc{}bind def/pgfstr{stroke}bind def/pgffill{fill}bind
def/pgfeofill{eofill}bind def/pgfe{a dup 0 rlineto exch 0 exch rlineto
neg 0 rlineto closepath}bind def/pgfw{setlinewidth}bind def/pgfs{save
pgfpd 72 Resolution div 72 VResolution div neg scale magscale{1 DVImag
div dup scale}if pgfx neg pgfy neg translate pgffoa .setopacityalpha}bind
def/pgfr{pgfsd restore}bind def userdict begin/pgfo{pgfsd /pgfx currentpoint
/pgfy exch def def @beginspecial}bind def /pgfc{newpath @endspecial
pgfpd}bind def /pgfsd{globaldict /pgfdelta /delta where {pop delta}
{0} ifelse put}bind def/pgfpd{/delta globaldict /pgfdelta get def}bind
def /.setopacityalpha where {pop} {/.setopacityalpha{pop}def} ifelse
/.pgfsetfillopacityalpha{/pgffoa exch def /pgffill{gsave pgffoa .setopacityalpha
fill 1 .setopacityalpha newpath fill grestore}bind def /pgfeofill{gsave
pgffoa .setopacityalpha eofill 1 .setopacityalpha newpath eofill grestore}bind
def}bind def /.pgfsetstrokeopacityalpha{/pgfsoa exch def /pgfstr{gsave
pgfsoa .setopacityalpha stroke grestore}bind def}bind def /pgffoa 1
def /pgfsoa 1 def end

 systemdict /pdfmark known{userdict /?pdfmark systemdict /exec get
put}{userdict /?pdfmark systemdict /pop get put userdict /pdfmark systemdict
/cleartomark get put}ifelse

 /DvipsToPDF{72.27 mul Resolution div} def/PDFToDvips{72.27 div Resolution
mul} def/BPToDvips{72 div Resolution mul}def/BorderArrayPatch{[exch{dup
dup type/integertype eq exch type/realtype eq or{BPToDvips}if}forall]}def/HyperBorder
{1 PDFToDvips} def/H.V {pdf@hoff pdf@voff null} def/H.B {/Rect[pdf@llx
pdf@lly pdf@urx pdf@ury]} def/H.S {currentpoint HyperBorder add /pdf@lly
exch def dup DvipsToPDF 72 add /pdf@hoff exch def HyperBorder sub /pdf@llx
exch def} def/H.L {2 sub dup/HyperBasePt exch def PDFToDvips /HyperBaseDvips
exch def currentpoint HyperBaseDvips sub /pdf@ury exch def/pdf@urx
exch def} def/H.A {H.L currentpoint exch pop vsize 72 sub exch DvipsToPDF
HyperBasePt sub sub /pdf@voff exch def} def/H.R {currentpoint HyperBorder
sub /pdf@ury exch def HyperBorder add /pdf@urx exch def currentpoint
exch pop vsize 72 sub exch DvipsToPDF sub /pdf@voff exch def} def

 /pgf1{gsave exec 1.0 pgfw 2.00002 0.0 moveto -6.00006 4.00005 lineto
-3.00003 0.0 lineto -6.00006 -4.00005 lineto pgffill  grestore} bind
def

 /pgf2{gsave exec 1.0 pgfw 0.8 pgfw [ ] 0.0 setdash 1 setlinecap 1
setlinejoin -3.00003 4.00005 moveto -2.75002 2.50002 0.0 0.24998 0.75
0.0 curveto 0.0 -0.24998 -2.75002 -2.50002 -3.00003 -4.00005 curveto
pgfstr  grestore} bind def

 /pgf3{gsave exec 1.0 pgfw [ ] 0.0 setdash 0.0 -5.00005 moveto 0.0
5.00005 lineto pgfstr  grestore} bind def

 /pgf4{gsave exec 1.0 pgfw [ ] 0.0 setdash -3.00003 -5.00005 moveto
0.0 -5.00005 lineto 0.0 5.00005 lineto -3.00003 5.00005 lineto pgfstr
 grestore} bind def

 /pgf5{gsave exec 1.0 pgfw [ ] 0.0 setdash -2.00002 -5.00005 moveto
1.0 -3.00003 1.0 3.00003 -2.00002 5.00005 curveto pgfstr  grestore}
bind def

 /pgf6{gsave exec 1.0 pgfw [ ] 0.0 setdash -4.50003 -5.00005 moveto
0.49998 0.0 lineto -4.50003 5.00005 lineto pgfstr  grestore} bind def

 /pgf7{gsave exec 1.0 pgfw -2.50002 0.0 translate [ ] 0.0 setdash 3.00003
0.0 moveto 3.00003 1.65689 1.65689 3.00003 0.0 3.00003 curveto -1.65689
3.00003 -3.00003 1.65689 -3.00003 0.0 curveto -3.00003 -1.65689 -1.65689
-3.00003 0.0 -3.00003 curveto 1.65689 -3.00003 3.00003 -1.65689 3.00003
0.0 curveto closepath gsave pgffc pgffill grestore gsave pgfsc pgfstr
grestore newpath  grestore} bind def

 /pgf8{gsave exec 1.0 pgfw [ ] 0.0 setdash 1.0 0.0 moveto -5.00005
3.00003 lineto -11.00012 0.0 lineto -5.00005 -3.00003 lineto closepath
gsave pgffc pgffill grestore gsave pgfsc pgfstr grestore newpath  grestore}
bind def
 
@fedspecial end
%%BeginFont: Utopia-Regular
%!PS-AdobeFont-1.0: Utopia-Regular 001.001
%%CreationDate: Wed Oct 2 19:10:38 1991
%%VMusage: 32987 39879
%% Utopia is a registered trademark of Adobe Systems Incorporated.
11 dict begin
/FontInfo 10 dict dup begin
/version (001.001) readonly def
/Notice (Copyright (c) 1989, 1991 Adobe Systems Incorporated. All Rights Reserved.Utopia is a registered trademark of Adobe Systems Incorporated.) readonly def
/FullName (Utopia Regular) readonly def
/FamilyName (Utopia) readonly def
/Weight (Regular) readonly def
/ItalicAngle 0 def
/isFixedPitch false def
/UnderlinePosition -100 def
/UnderlineThickness 50 def
end readonly def
/FontName /Utopia-Regular def
/Encoding StandardEncoding def
/PaintType 0 def
/FontType 1 def
/FontMatrix [0.001 0 0 0.001 0 0] readonly def
/FontBBox{-158 -250 1158 890}readonly def
currentdict end
currentfile eexec
D9D66F633B846A989B9974B0179FC6CC445BC06347FF71900AC8FEAE3B716D52
C1AC4E5DCF4EFC3B9121F09CAB0C4BE35FD0740E08C853EF201BBFF011DE2163
790FADCD67A15500D3F87E2616B7DEEBFB3934B09CF7B8BE9B945D2638887F73
1C3214D790EBA3065BF944D77DD51978CB663398285895D774586FDDD6A7467E
B1BAC83EC766EDE0FF34D07C6E315D7B79B205EDE798A08FD0D9CD4A1307FDE8
7F57AE7A32759AAE66C77C6127F65D92BCCE74ED784372E34CC835BC789BDEA2
9E27574D388B2CEB1DB127C190624246F4991BA418137BEC72C8CF7830DCEA26
E13BC7F0CDDAE283F10C1FDCD1B46ED2C4BF3526E9DD2FD5DD021D1116D3D9B4
44188211B1332E1BE656BCD0DC7C6D7F23ED03F9A42FD10B79980768710365EB
A8E211AC8936893AA9318E20D297C730A6A626FECA9E5F91E1E0B5992698A7F3
F8BEB86C9BD1B318CB141ACCA92730554DB8F57A8A21370C885A2F6612188DF1
0200D203FB6B33556F21DADE387C352EB80799C9BFA76FC4192381FF39AD0FDD
883D39690055E6A12477D408452D16B726E759BFE286CF62450D5683C4EB0845
EE3B21D7D64E100CCE7A2B86926828DDDDCFAFBF3861F98324538A0799F67E49
72B96013BF16E190839B9D1DF92A8B6A610468110B7CBF1C24CD2CB1E994CCC2
4BA3DF5753B81CBCB3B71C63FFB17B3B47E949C570D03A4B162E12ACB36EA11A
22733406532DB9FF39B2B2DE58B270277E7B1C3E1A460CF4B6FF063F5CF37F5E
AC709027E0FCEC1B27227D8A49D0664C6FB0178976D6EB5B09B4F47B5E94D782
25FC9D56FD8EFD97D514EB2ECC5630ADD87D6ABA98B19DC1AB262AB9A8C979C0
59A76953EC55333F7800EE9330B7FCCD8C3BC325658816EA542654337DA7D3C0
407058CC4601BA7B6C6B2DA0E376F7D94DED19271029E32844351B475FA30E37
2D98E7D5E6340A878CEA0811FFF598E5E1617F2D13066E7640416BBA886DDF0A
E9B8A56119CE61E57FA8A6309245DF8BC6CCA7CEA55FDE2D7B6CD06E8C118928
1EE6CB47A4B7D7E38CEBED3A0D1F2639BFF76FAFACC17476D13F4CB31FBEBF15
89252E409F16ED56EC1DEAB4F330B7659E93AD217785061D581BC8FAA0851486
654C51CA8472E0FF71158D1D3285ED72ED927B7F750F99BEE45F5C77300D0411
A3D81B0A9C8F5865B057F75E8D97E77958D3502994B90340EF5362A99D9750D7
14286B362186F0715DA5C6039DE18044B8E67EB1152D6C0DC98D0E36E6D3C331
C817257F4D3CAF8AE438EB03B04E8597046197D67105121CD8F5DCBBABCA9FC6
55EC17EBF96D17329B7C8BE8F7D3062E20E83FA6AF45A0C932B5E6EFB4DBB928
E4511768F708A03FA8BEA26BEBE94936A426DB77A8E800BF093CF53914B71382
019AC58ACA79B9DF64946EA241C84569F2A13CE8AEC335F6B5DE8C00317AC6EE
983987246EB7659537AD0F945CEB9EAC541E02AE257377258E81CFE33CB66A9B
EB514F04CA9AB516CCAFE56EB0324AB192EBDDA61E0792EC1857BCC062666338
0089C3A9FDEB405DCF235A497AC316B132B3476551DCEBA0560C18F1BF84F1E0
1467DE59252B169861541BD6774161EA8F9035787CA842050E2089AAEED6F37B
2D12BCF5E67293A1F71DF87589FD22D5F72B9C91CCF4019F97356DEBC9B82C93
BD0040BBCEB10CF8F607E0F7863C43D7F6A91917EBD66730DBD642DAB8769849
47384FFFB4994ECF216FFA8140397695EE5AD63F1156720A01BBFB15AA24FDB8
2F2A8F541C7FC860E03F5E4DE80BCF6891263C142159D5879CA0A1883A9B6C50
CBDA9CF0C97E761E354C39527F070E680B42E6732896B10E6A7600184B156ACF
57BD9A98F613FC166F47C3D1C4E5E02BAB648D74B078EE3F0D8148D981451BD3
918C71284E6154BEDF8D66BA1261A7459F64F133445F9BE19A2C48B1FE1D06B1
845AB18E2E5C17B77C48FBAE7AA98424BA0F90F689216F31EFABC25D4EC37767
C5A4BD9210AB9F0D3385717E8980C7F6C021061CC213ECEDD34548605F3FF29F
B92FEF1C849AFF8AD297F7A4259C35B7B9B679A509FB97F10F2BA3521085B1D5
104D43AFAED420272E0DB15AAF65567BAB2B030932584E4DE6150645266166F9
0B425322481A2BBB01ECAD3E011D365BE2C51E7612B0969A218662A8F3154F6D
56FACD9D11622AFBE969803421F6C2614896A0C03C341334FA8107BADB87B94F
160A7C59ACEEC8AEDD38E5A3DC178A67A00DF37806BDA55B79CD9D2D26A22AAB
35C0BDAF27422A084E2950E90E37F7B347B28EFCB28BE019FB924B0583462D8F
44FF2045DC65CA3C0F7C8169C6F76D8CADAFA86782ADF1D8B89C3A32EFA39C9D
654A6CBFF8C2B2319440728B74EBDBE7A952FA584C475CEE1BB7128A8E143C89
3E933FF2AAEF340EA1D0794EC48800B64C7682FAB484948D1AB28292C31ADA55
12256946F41A6A9F0A54178AE5A5DEBC033F675E2D9F0691C1D8993B422BB3D4
1222D40754524F4550C07AA2B7E4F1CF360FE98885DD6AEA8EEC99E208991584
85E0D8BBD44659B72F57E4B64198FD91DF08CFF41516112ACB0A383AF517A423
682A1F2EB1D8CF4F650EB4C109E377B9C011F1860F37C8C940A8EA49D8407CA5
E0EB5A9A5060FD20F77AA5039D013CD4914B8AF9A19324330D2FA91D8273D004
6F9CE53BA9ED147C11CBA82C6F93583006289544091C02061CA00527AC37B881
EE4DEC3279785B68529E545232C74B7B92C79D1328B3BB5FCB8686EA2EF7DB42
2443EB3A0A77D9947363FD2089D3535C22C033E1FB1F743CA70D2BA279B9BA97
C33EB4175AD60E1DF6D624C68FAD9D861C22F49A15294FE781EB7F88B9759429
AF61BD632DB25014F77384077BAAD6D640F4E68BE69D536D99057E30AC1DE53A
E408F50D70E043ED92C4CB1D4BB8F81A771C78B52D93E520F1D4FB24F36EBA83
317681EC513BE2FA134A6A570E5DC317F28C77E3DC116C16A6156E529B6D950E
53B749093E6E6ABC003FB2B4EDE8D8F2B9DE99E89CDAFCB5B352CA1A2DAF7765
D08F7D4F2DBED85F10A4E88344E590353EC4D8A7868932C807802FE4D9C51C18
CEE0FA1DDAFB91C39EB10682F8DC836C8D0187CA337D8FA4BF4D13E49C837A41
7C604CC5A3149EAA98FA27E9041575AD1FB8CC1EFD748994A5A39053EC3FDD18
E99528808E4E7563CD6CEFF0B9DB4D2F6E8F21ED917C49C7460B1E0F996E99C8
169626A4FC4E93B51A058888867FB0085BAC95E033F4E43812AA0AB34BD8D1A6
90B62C70F185D81252489FE18C488CCF3D13A7D2321820E835A135D142EE632A
929339012CC94E2FB30C2C5417B15580711B3D54B80AD13C0DEE8FEC454E0F55
204FB97C73F5BA4AF9443709BFC03B3CA25354F9298A753B418B65D9ED2E4C25
E75CD6015C07E38A1580CC9FA8FD4E4A589E513001CD131D8C3302A322A2995D
6FFE71195A098E27D06BB45DA78C45E48DAFAA5694FCA0EBCDB14737D97D22AF
A04E2D38F1A3425B0A49BA247EAB528D32240921D69F40FBC0BD4866050FB5C6
31A1BFDBE91A4CB4A5B415FDD84D10576A1EB0E86C827FE9F9EA22D89AA4BC75
443B397F4D91A1822E261A98B3A6FEDF19889B0FE75B388B2CEF6CBE31EA08F7
F11871A42414DBA0084200CD64C30CC6ED3805063583D0432F4279001DF60083
C17D7521A66C5641F709520E2732205A06EB133075BEE28E766EB952410B714D
9697419EC93132D6B6A8C020E9BBD0BC9AD0B51EA0F1DBBC1304D9DD51780903
DF9B8193750D8C057C4920D6FF45DBF1F057F7F848F18195B58CB4A19CD9C505
0670AE3B269F9A5FFE74001A90F1D23596900CC529C952A553DC49F8EC14DE67
DCD7ED8D1C9336021ADDBADDCA9B1DD2F323BB8C2988EE6D9EFF9BAC7A854FD7
0F227CF3588A6FB51EA4D4DC78AF7ED6A43154B10A3980CED79AB500634BF670
E36429A3C6134B8F1F6C94347B1633DE328DA8866E52676C6B890F0DEEFD209A
23F24B710D6557921404D7752284017A32DCFE9C9883B5B500432C2AF2E86BA8
1FCA46A98046766790498352B8DF1BE2FC719C674CE98E5B029DA47528021C55
AF6FEC994BF84EF30C19160226F7EAB323AF32A8238AAFBF407D06A0F341A749
CF1BED3A1B716862C87B57096DBADF2EEA6638BC224AD97CE9B52FEFC20B40E8
AC307BFEBC5D94818B4ACA36291E9C1A2833C4CBF92C14107B5BB2D8EE2E8738
919CB10D14764F52E95197F8CCA8D4F024AC6C3BA887D3530B1BB0722BB25F5D
00014EB39A7827CDC8A28C2DE17A37E05FCEEABC50D3DAEF27125F0BD88B1191
701FC8CE423B023D2952DCAC3FB02FD446A0D1D89B75A8680D21822D89DE1E71
4E5F5DB63112DC134D23DCA5B19420A1E854267512E5FC0B1640E48266186151
D3D3BFFEC620EA3F8F5C9B1CA9579729FC9947403463B45765CA5E764AB7EB1B
5021B67B0F3DD5ABF995D9B881B628689F546805A25A8046E0B65CB1F71F5D66
6D68E6489C4957F418BB6A2120A6C46237572B6241990D5C2F624E2116FE1871
36E1E88150ACC1B234C05831F242B8B5A0C964E52E882D5A9C97FB60C1B9316F
6547DA94157E5179DBEF08703AB0FDCF8FD86AE935A68FC203225294A8B1A421
E5A19A9A23729C0574B452A3AAE697FA35C4C44B11571BD6C6FB6B97270E30E1
C1640AD437E97AEE0923C67DEE322258EB8E4A1A87B04295F92690E7A0F10941
DE3D985DFBAE3A93BA78F8905E02EC0BBB77A594725F90A185CAAA0865CBD438
0EF02EA079623BA19E1E3DA321910FEA27E80EA2BEEB9DA40442E648D1381E7C
200432890ED73861DB240EF439972F5736A0004F25CA8ED297E14FAC048C3E1C
547E8F1798A67DEB9FD654EF7675674258E1DB4DE49C91A533B409D23CA7793F
8CECB267A4E45379231BF12FB534F789AC693C7DF6E181CD771FD6428906B464
57E63CB272124859B4EBBEE603CF3E5E6612650CE2CEAF2D85E9B5AE090C2E12
AD5B36A2E1D0BD1C80A7EA057D586AC7EBF6977DFA36E04018ADB8CAD7CB4556
AE25FD1CAA1C2DCC3FC63AD91F90D2080B1F5141BB36961681DEDCE2E5A2C5F6
1D16D6C29221315BE64A36FA87330423DE1F7C66FF78472D0DC979A56B8576F8
DCC57912FA2BF0762C92C615342EE03DB7F57A095D1049EC99B807221DC07110
AF0F33B22A78DAC36BD68AA64D6F0F58AC93378B7615AB908F2E91AEFD4FA345
F24C6CA64CE8D6D86274FF80178652EEA96F4EF8754DC5424C119C3065E49324
5D4BC6FF937BD700E7EB3616EAFB540C7477B6CF0E76FE0A9305DE4283D9697D
03E8F24AB8F294F688526394295FF55EC7BB9535B0EC5B8335AB45782942F0B0
98675BC1099BD4ED00A4577A5F8723668C15315CCCF6ECCD272B15F19F8A0460
7136395A43557F187CCE23C443FD00DC5B1BBB163A6E6A9700BF8BCB30DF6E62
F4C107661E5A0CF705D4388F2C21C839A5CF1C41FAB7DD75E6E8AFC57CDD6C9C
3F8B72C6F78648D24473A7B68D6253F41785BBBDC5EA25310AA43C6F3862E1DA
154D3B99092C8C0BF68FEB5933FC7E42B85EE5EB5336501C69BCC4C6ECBCAD58
5F1C85215B8ED2A0047BFF2651A9D83D24A5D3E7CAA8B56EA39D0B17C5A2FFBC
5E40D2852E8CDA5FD95E4633E090E4608181A825002C0A7D6D9CAAC5284BC70C
2229F8E6C6C3C349692C5537F8E5596DD33471DE42A26223ABC9E046AEE88652
C5ACB06B9F3E73138E54EC4EE878D748C3134D3F10A4EE2ED540CED767D66333
EA9C1C3213DB9E576B4862C7AC76F1F7914260980E857C5A0099EA06E67AF880
21700C55247EBD70966E05A5178C737025193E18617F6B1B60CE1C347E0D906F
6741585C9E0A80B293AD5DEDF0222EB39B164563635AE9154DAB0A9643ED2168
CD64263D957EABB769C5544D35E27563D8F6D8A2EB659F0F1E31451418D38805
58A74E6059199C7C8CFE9373FBF5F92161605354674E86264A28C739CD02A8BE
BC5D65AD8C33D26996232C76C89C047E4646E48CCB5D49286DE4D9E501237FCD
5F7DD882644EC037E53EA6A522172763BD0222B2522B9E47D4B5ED5AA95944ED
7488115D2ECC45B61357FF08D62D1AA17E47BD8261F3981F49F5CA06DA6254C5
F26A3B404BA9076E85A632B55DCE8AA70243C88CBFE93404B296F2CF38B5F687
46727AC1027BDB1C51B0AC40A49FE82A00329C607B752081B299555E725DD0BD
B90C60A5D8EBED7726AEFC9DB0B056B9D9EBFF754428AE15D0E5F89F88C9ECE9
CAE16E02FC8F9CA96B2772BA8BA14BC2C4DC81E7F182DFCC19793EDF9C53C00D
98CC24F7A4E9FDA6D4CCD41C434C6D8792B4FFD115846BF9BED2A2B2D1537251
2DC75C6FFE8A1B016AFD3655F65576C6BC9545728E0CF66BF4F1DD580A9B0D04
F36C733EFF49721731B6A16CA2E5EAB5D394770CF0767557D12E63220BA4F147
11BCB4E235E3D7C77FB860707C0F4C75DFC9FFE0E7AC4599CC9D7FFDC9846F2B
53DDA2F5CE9E6EBFB23BE9C9E5CBF19AA56713FCF06F1F8DB37F9448D57154DD
5639480C7F60D3830085F580998F9E08DF9278DD4743F3E44BC2571F46E81CE3
2530B02636A1132331CA9897E6CA75CDB2D6A33D9F309FDBEE7B1B2AE5EF188F
32E1124C35E1F29AB9CA61F6B0E2446527C15C0AE79753FA55D01E5F51974FB9
E2D79AC4B8DC7D425DD53A85DB1633A6EDA118E5516096E31DD043EEA2E77B77
691670FE8977957788F26272576C6C58DE357E02A437B6F5D524E99EAD5794B2
8C88DD46AE4B8F436EAFB5B3332F06CB1DE98A964603B10AF1733FFEA9165CD1
5E4D39A6BAF9C116D813482171527B68D18B90A52FEBA904810C8A2370C67E21
DB0F7153101F9AA02D6CA9890203800FA9CFE1823431E43B9DB5CB6647F57D44
7FA1492D6F08905B0C0BA6C712219E1C77D413A3467204C19A9B5936FCD23F51
8D05ECCAA6CD1A2F8ACB2AB32B6FD323FB68ADFB7558DD95315D77CFA554093C
01A178909ED28566C527C855E0A7DD3F1EF740E9F390E9C2228F313A09E284BB
E73C5DE2A19DF3A1EE8AD25993B623627EEABBDC2EB1FC9FB4939F47275F12CE
7D2CACE19A46B9E1B59954F706105E0753E931402C8FFBF26EB6CC1E820CF9FF
390FBC63630A5BC3AAF1E722604701C8E87755EA87E116CA765476AC20DB3ECC
698A6A7471A0CED5D72159664D2E9107C046E30E15C1651991947CC743CD6634
2E59D026592DC9689FE77C7C772DEFE63B027A4C34483285227C71E5E11AA360
4E20229D1F7745CB403966EC4CC47F64A27195E992B3C0530E4A8B18DAB231CF
BDFAD42BF9622D058F575C72F4931887387A29309A408384909782E3BEFC59CC
C2DCE833CA1E5CA81BD76CD8B9BFBA9853BE90F93C5B508C906762197B88ECE8
7F0B0E07265570EA404F5202B8BC39F53DD1E74267CF7A1A470877B9202B54B0
97D787E04A8BD48187D195677F46DA314850D21041D6B62B8BC293A7C4A3659B
2190F68AC8DDD315850235A4C88D0D78143E57F05756B1E7F8281FE40CC2D3DD
29A58D195FFA8C5137AAC2B6FE22D9B992FF3092CAFC7CB68B2B95FC65593230
F1EA08E9DE6E29C0B90BF479BB5CBE06D7640C916F0646E6A662B7342EFDC939
8900960AA871806B6DC6C0755BB11D15A49B6E46EA4AC7004C28C4F83B3D9968
CC188F2A7E2311CD90EE1B261542210BB1211BFDC49CB8187059B0BB02206E43
1D2AE3252986DC5CC51C50D814FE8F31A5FD35F936C2D0011A2EB5FCE3AA4857
093BE509548C8CB5EE5DD2EFAFC07D580672520638D95F366CE98A4083B015F3
C1C75BF591A8779A9C8C0D176F3154E8757A2EFF09352105928BC9155AB8A938
67E65955AC795819F1FD8DA05FBBBFEFF0CC8AB9F1D4F3131E5B9BF0ACC2E5A5
7DA125514FF6FCAF49174FD7BE86ABD340FBD316F01DB500E7069435C6D85040
96A4CBFE226E486CAFE072D904571A3E4B1228687795ED6B0BE7AA2E0CB5105D
D5EEDC5C91896E1D44892309E2F12284965A6E2F7097EDA7CA98CF87DED25650
7C3D9DB10B94E445EFDE8E05878EA3E2D3CD5C5CEDEFB9E2B4D158D8C7DCD2F7
AB1688100C3C8F318BD30B3B2BEA749A4A0F3DBA016DE77FA2080A431D26349C
5B4D3FE55B1B17DBE1B7FD3DDC309CF4D92F1E3379E1A86B004BAC5C0B20E59E
BC70BA9C7A27BA1140C4AF794D8BEFC0740231310A1FD2EE477CE2F6A4CF1BDE
5E6F73DE072361A0A5560B986A5D8440AE0BAB2954367738D6EB53D9EDEB84D2
910B6942315A996B1553EBD742C0D55E062CDFD926CB40467CAC70826675A096
3BB30EFC61EE57556261FB9B094AF3751539E549972C9700F4262663EA271ECD
A46875458A4CE9865F20902D518FA881C188C73839970E08C60A947C4AB3AF21
33E37EEFCCCAEB5C29E4B0EC68D832FA64BB8AE556827F6629028DCA320BB0B4
FA830EBF2DB1B19899E4BFB7CD72332A94805EF5B9528F74398354904FBB0C33
E7137E263FE4F4035408EA20DC17BD88CAEFF9E91BE38E09B2481E18D862988E
9AA94618AD02F7F4D34139075A954A86FA56411853799313A87BCF63D0272976
70C041A6AB23ADCAFF0844E6F53B698E44D0441B5B3B3D5BA21C13E993258AB8
BE1D1E1072269730BBF674F2BF93F607F2A6111ECEFD61D4CD7536797E374B57
A9FE35D29BE03248C27648D2F5E122F0B3D75219EC727967C9BAF9285B44C868
9D5B67DCE3413EA24500D6CC61B4FFA86ABF3A8F45BFB5024C82520EA29D8C79
61EB7578D137C406794D81CE720041F866C1737B8F6AC4ADF03F41D0D31D8359
BA72C7A05B4D38CD15CF80474EEBD3B4BBD51A3356517CEB717A2301CA0EF161
FE27B6F1ED06354390CFD7FD6BBFE1C493A0C241888353DEFD82978DF8CAA2BF
8319CDABBD20308DA0643B71607DB02675B7229E7250D70DAE34F1BD017C133F
C84F1B8F837496E7079E67D49E4765B2DCEDC2EED02D4F01B22CEE83EBBD96DD
66B9C57165868AE7041F52C6FCFA66B3CB9147B4E8FD0B5CC21E8DEA115F44F8
3695223FA201DABED86CA522CD41651B2E3485025E4A06D552AC956394291130
D6A020D750794DD38094B1D8848C8AAD50F72046E03CB498968DBCAA3B4FA1F2
404FDE6A688D54C3791DBD08FFCC6A97D67BF30E87D529AA4D7A7CA966B9A208
F4F8F34A3D944E41D2BF4AF14A10366B881EDC25BA1981AF3EB63DA601708926
12AC33EAFCF1749802BF674E3EE4105EE64ACD54392512B07ACCCCD0CECA5DD4
2B6371B7253116233BD5E7486983FCC401A7CAF81DBFDDD3C2C3ED86B7FFED8A
D3BDB4FCD0B170F7F1BDCC7E2D17FD076B552F9BA6A9E841B690681B5781B2E0
9D1F7690339D9D5E2C3BD391A5FB028B527D2ADA82D5A08D2B8669B7E3C0BDF0
E76955DE7FB0A049B65CCCEB40F233E5009E78A80CC70597029FFEF1BD2C3777
173781646AFCD7B820B61D3BC1768E2269CAF2E1BE66BF597E052FB41B332D50
C01753440528A18CF021042D232A618B6EF086A6030AF4FDA23DE67CF0B86296
B2EC2877AECBBC3B36CC73F1179C33AE3607F6909BCBF51B15F83F9CB05009CB
51B1BD144183C76DB63A1431BBBA50D6CE14C890F4B19235CF735AF3E4C5A217
D0CE4E363296282315C85CCD7D80DCD129CC43A12864E6F2FC8F7FAEF0419DF5
64D0A340E10969CF694C3691ABAC54FE402799EBEF38211CC8F005173D78CA38
0FA816B0DA4689320B7D9239E05CB2BE4392E3F257A3E0F10982F784F3A3FB34
2EAE8915DF2E4F2275FE245E7DC87700D807E5DEAA00BBEEBE28FA21C4A9F6E2
5F8DBD9FFB89E4BD348399B53CDCBE89F50E73A172DED8E7972AEEACC0F30BEF
EA09D3F553F7F9D60B39A6E2E19ECF4626600B1B4995E8F1D29562137FE66155
6ABB7CF3A2EA202925C97D6488843BED6A1FEE0EA9BAA92D247FD825B080ADF0
C83FC95EFF339ACD699FF660C4F661767B9DB3A7E88502064F0F544C00B58BDC
C61435087ED55E9C7B38CB2D16EE61FC25482A27A33908DD9F35F1E444F8722F
16649E8E88491C8FE98C73D10BE217E38E9D2C00B939B1A480A7A6199531224D
D5987EC19F69036CCE6AD7358E0B4920959F61D0BA242F5FE84E969A1CD9797E
04B2755AEFC27EF109CF9304A27E5DF23966A7C11DBB1D0A2674586BDB2C047F
DEDC66AF81BA696E57D6808C87C1C30C92B472A7D6D91ADD22EFD62C688C2020
A7E40D6CC9DDDAE81F0C74A692A0F41C99AEE4F87DBDAD53FA38EE97DF584C04
653CEF8BAC7F1EC8F491AF5F4F83EC1B6D3A0C7977BDD8E51A96CF68C0DC8618
9081E5FE567F01CF59F9E7DD2648B81EE7391CD44510AC0D5DADEBFF56BDEBD8
1C5E635907F44A78999DBFF6A2D5407E3381810B4233C58E0E688758B3A52B5E
428EBB2E15B1C4B9371E39055E86180C4F03A47E29FB09B3FFA0A5A8673B0ADD
671B749B3E40EF10819E7BBDD79D0ADB6BC0929270AE8B041C30D6EC47514E58
7534A02FF180FA791E1C7672AB569D76906E068C3FB4A783537FB7990AD4CAF4
3C30DF7E927764CAC582CDFA4BB5D779D7D5E059D026A5A2D984BBABDDF51561
CB05C5DD5762FB1E1F0C0EB21FE2F395A07C07D1D997596CF62D37B22F02D7B3
4E45D34D6C167253AEC391108C245FB007C9B73BEFAD5CD15FE4F0AC7542360C
97A9F78E45BE3409866E5F27DF6EBDAEB2A26C9B94BC55280755346351BB05B0
1048F35A06A1F5D8579CAAE0F9CFCB7E8EA54543D1ED620E1FC4A54BB577F401
B4E0A6F90D80BBCE8C0358792AF8E1A188961A3A75B15151088234AA85D6936B
E1D7428906B4E3F71E34CC06A77F40268B3687AEB6732739D950D9D96CE713BA
9FF873875A278318464DEC411621E9D5B691C7BFFDCD992A1AB06F6E9CF61B34
34316C38140C7053E7E2E1C2D56080FF461339D47F8526985F34BB6ED3959809
070C13B7B121F33AFDC43F5A07B108A9740DB0311AF7E840DD41B2DBBD70DEAA
A63DC107C8076D2B8A73C45D0BC05A5D96B99730B6296B964C5693ABE477D988
7A5FA165BF3A57314D093F366E647473B70A0413CF956BF363221DE0036EC1D5
72158E61C1795E67C92BA481D6FE87D930EF306D5169784104D47C790A34DA55
F5BD80D2A7174890A850EAAA5D3FA5F8372BBCC220A07DA9D0A45EDB6820373A
057CD51586165BA4905DDD347E345580657BA148929EEE3E769D7B210627F595
9E9E8660BEAC130B388197CF60DB3C4B4057C180A38C9C2A00E355B760B2702C
EB125CA8C4FFB2A027E20C08AEA455BC1900FA6A835A13AD64A3ABC635EA42C8
431E1663A0DEADB64E79683C9BA39855B405559ECB8E35904087FF29ED9D9EA1
B964D9664344634DA3B3B488E5B34B510AD9412ADF209F371D29F1C15E21C6A6
3129ACF3A94449524487D1D8A49E1E169DB5712B963BAC4DB0931F3335C60EC7
73D5C913AEC151B7AF64413554B035FEC2C92E7DBFE4659DEE1A2D64C613B623
8347EB74948A27E54329B65E14F38CFF2C03D1366AB81F3057209621D56596E6
D3C83569717B312A6526465A59DBF46A3597376DCFC1E520A6D03C302FD0F071
B0ACD796F9FBA63171D385F2B5DC90549C4E3BD8927F0F45F5DF738749470BAD
6CCE589769E311B9707847B339AF3764AFDC6C3F57E2EDD9A85A491CE456704E
E82559C1B3BE2377B973838DE15304E755B0621D41F6EF2A377C38725CA01FC8
5E56B456A32408A4F2447409D52B998ACEAE00EC642263D72488534B7188F86B
DE60D7C04D4E537A84DE04CB996E6A60DF21FF1D07A24695E9936FB3D191B8BA
ECA943A1A09F6CD3C1F80E16710B1E0F996E99C811A024ED5DFA053659BECAC5
D67AF75106F90BB48A78AB1E974EAA940E61F96A985AC1D1C695DCA489D00757
2CFD80C2CD83A6AD6F6B9040FD8BA12A6D79BA378BCBDA94196D7D2F56A63424
511A342EEFC4AB610A9E9FC66B4FC575F719495B093B200D686B2FD1CE00BF56
956B7852740F90F9FEE49775A177B1DD3787D67017DDD6763148DE245C958C7A
AF1DF0CC73E8DC3A6E5ADF4234D758870081F43B9874F39B58C069C4CCB40EEA
A33FD7F23007364351DD594C5823C69C2A72D49CFFC1680596FC5FC24785A138
D33D480EB5CBB7DCAAFC273843839F95D74E29FD991894A43F953AAEB3F88256
04B2DAB482E0AE736F249C368CD05D9E3CBB82C4B1CEE106241C8BE038ADD1FA
7291B28FB3DC5A4974EF35BF3E7002F6E0E5B3B0B41EDEAB29245E76AEF10762
61C7F8956569878AE83877F890F11BEE9E8EF083B0ABA3D952A28DE0E3DB5973
DCA196CB3BBC82789E4CCEA3547369BB8470ACCA3F46D971A023FA425DE303C1
30282353C8510C426305C029BA8D4A7B959425D3ABDBB7A8231066888CC3CA13
3567D66FE5A92F13B904C2F2ABFA02872B43D624DD5CA3CD438FF04A5101ADA1
33E6B4D9FA354EACCBAE27F49E64F40A500F0468CB1395A056C61B39BDBBA618
623BF93D601775417964DAA7C36DA23BF759B4EF8ECBADE725699AC246596307
41BC6EB8CB686DC29F72CF0033ED02981894B16F882D61DE400B87B8B404150F
9971C05FF15EE71DF84C1BD49625FCDA10A6E1095C82DD1A689B73E0F389BBC0
187F92D1565EEE35A7F1FC8925B61594F22850E95BCB88E5E7CDC5261A110F15
994C9AB6466F1241525495EB47D7F275A86C3ABAAB2C30211526149152516A56
DC80A7FDA9E219BF417B48A70A5C602752ED6DAB8619663C9B56A5ABA92382A0
18730BBDCCCF0B00A13BE4FD1BF9B9DADFB60ECD4A434A9567FC7F960FDA5A36
F9AFAC5784F865AB1C4F3540E1232B7450224F38435CAD506842A1BF43767CB7
0F3893AD51247F0A0E0EBC2D1D76F6F27FA8FD69E8D4BFB8A36390B933EE9616
30FAC179898DE54B5E758CBEBC020CD669E69D1D799FA7083E06552D6F7AB9EB
7EF47E63C1AA9BA2354D945360D56B2BD38300D97653324B87BF1868F8F5FC43
C66D1201EC8D18CE02BDE094F6DAFCFA2AA0728F29CBB1D2B68ADFC699F8EF1A
B1C01687618D744FB1911BDF0791A1CF1C676E89619AEC6AC60E66C0FF3E3847
3AF1774DB7B3E16C92BDC9A505C29FE16D5149291F617F1E8ACCB5AF5658688B
FDCF05D4F7089B2EBFCCC853808E0E439DC953843CAC52DF1D582BD048898FC2
D0959219F0A2A3A047780E1AF46700A734A8B476D93133D0E8BEDB76494BB5B7
F436B45783F16680A7B8249EA0419C3A9D9E729F60656D2F7EA10BAD6ED1ADC2
EDE0778C2D79BEADD9216BBD7FA6411890A404D807E5DEAA00BBEE8777310E86
7E41A65AF71DC0162DBB5F167C7C690DB088FC074EC22330E805050A501908AA
9B41FB0B6058E7081FCA73BF68563189854E300B8C703BD3AACF4C48C3701D97
9146855D0C78E6592B6CB5F75F00A82803323AA57BA4D359979ED6128DBB0E96
61F4DAFE326FEB9F8D311D69EAA4F69547DDF7A259E0754BB606F8A54DB677EF
963FB2B686242AC878816CF1CA5BC0EDFCF123E6F568BB316157335EE3B7EE5B
21C2A367C0A2B9880B6F3AF2347FA0AB917247805FBFCF4BD99EB2B03AD08564
E8817A2469907F28405BD7A407A477D22B828CEAC7030EA3FCD58D4FF37A28F7
7FFCCA2F2F4EED77BA4069E6B5D1060ACF6E288F3D4D7AC6BB7F6C3F6731BA04
818B813F2BA07B3CCCB2CB624861707D2B98701285BE1D62BE5C88B3EB467ED0
FDBC78FF1530CD175D620C631A6A6B4C953CC469EE4AC1F2C37FBD7738852005
CBCDD843B0514647A73E3FA24C9748A7AC91636FC4CCA7AA0C10EBCBB6ABA955
C083FE02559A20CC76544EDE1A76036C48B927BA455D92BB9E556B6F07D62235
FA6DF1F8D8830E90974945FD13C063D76F57F6B3D6B347ABFA9C7CC75905BBB6
AFEF76F1453760FE201E2EF620A914F7591A917EF4F706C495338DA64B503F47
D6DE2BE915C0BFA49801737B21184AE0770B646870EE9E4D5B2FC43A9AF6198C
5ADA9F804B1FDE8EFDA89A333354B9BAA8E2EC86585C4E734C7A280367BD8CD1
73B765E456D085F3907DBFA705BCA8BCFB49F5589A34F86B434C1FA9AFF3A721
DE8728528B25A2DD182D52760F97296A35EEEE950C771A0071E9233E96E10580
C7D92917A1510A015DA9043DCB7969E989EDB98FBA90295153CC0D45C7A4FE58
3D8E2238032927090A537538EB656C3523C4E936246EA496906315572579C7C8
86E727FBFC3F49B48968F6474E76B1327BDB9D640B989E0752A84E2C3B31437D
B73F8982F2C051BFBCA0987DEC8B3BF8693E257CB084DC6D992D40CEA1FFF5BF
7742165F6CA7174C44DF8C52B4A927A4374B81944E671E40441D29E047309D2C
5FC751FED7B30BF9837AD04DAB9A7B6FA2998613971B7D73F483C3B35D92E472
84A9C1F349215580CB71C657B1E67FA2C431ED3DEFC714AC2D98DE543AB1E21A
A53F953AAE344855464338C313575624E0B68A91E543F4B22532C69BC902D62D
72AB72D305FF59E61C363026AED884DC7088B6E19AAC64FB308D17FE254436F6
3898436C131841B0AD43D54BB3FBB695A7B3025203AAB5A10A2B5ABCBEDB9E6C
9FFF1E628A4492B040535AF9B3C73D34077A744FAE4C0B3F4AE0D30CB554FA4F
A3F1EE7D5ED4200E9066088BB0BE904C8C573FB6562A358B725EB5B234F8766C
1EB096665AEBABC13BA01A2A26047B73943EECC6444299A80B52DBA76F0527DF
B6C4F064356262151C538557C2B6F3501CCA2718941B56FF77B9E5CE43A22506
339E6CD7200BF484799EAF202DF62A8032BF41918C3A57069968F28A864F4201
EE43282AFBC985303BC9728E851BF74903F21EB964660C8514E89F7488E96BB0
2CB95E986BB717F43B7EFA90AAE7983B92C9C0AB16E69779550F4D475F6D9FCF
D069AB8418559A2B63019ACCEC1F2370AB48CDA99AF3EBE57F7A2DF6A8A48B02
21A22FF81B1C12F4D3F46F88F245BEC22B6F7B7851F01C7D889628B7120F10A4
06989DE25209114BC28D91C0DE5E166A456019466D1BDB79609BB317D7DEDDC4
F29F4E2841BB5DEDAC6E63253EB0E8D6A8926C540557375B385C7228C8D06108
B1EE930E35A370366D61110B97D8C6E82B90175D2DCD289526F46D48A9703982
1FC627D732CA4124DF19076E7F5D46D564C29ADECA18B58921E7043C8D6972A5
4D9B212B01BD104BC09EC3FD313CEFAE314C544D267033D798A5463F40BACEC1
446C1BF2EED56C7F29E0397BC467786EF949F5BC306920286D0AA66F1388D280
37705B2335FA88A1DA7F5A78A2776C29F7CDCE5B3532A437D0BCE23C1EE263CA
DC2430057A933D1909E8116F56DCCC047CA745A0F3603A7A401CBA6F2E26E77F
9361B49FD30DB6CCE4B8214DC90A63D07B06A5F525F7C41204DC42B779B930F3
55CC5FF6A8357295BC99E9432BF51A45D34F0D798DEA847807417E674A0C4614
BD45114CEF4F5B039FC909B1DF83798216B83A7E5BD97DED3DF5C59538FB1535
A8844260AFB429F2C16C6CC746C7FD03F682F4B729C3BF1DDA4743C26DAEC952
53A1463B5F7A126116EA222F49EBACA0BD4542437DC746146CE1427C1F2D7A19
41F724105CDB58B023EE43695C30DA27FA37D1B8099319110C98D8F37BCDF747
F2FCAF26AEC6ECF51410DE7432A6F21784DDD90032AB4A0D59792BD5B046AB31
DD07699E20E374E43D5425782B7DAE4650DED9A9BEEA6A40B5CD3537F3C2BFC5
63F3534DFF36D9BAA022D850FE170430C28F5ABB30A7BA1798A3C62DA8A189C0
0C6C510805D27BA6298F423903904652E8E2D559473C095357BE06B386CB2083
CAD24CB09557071C2782F6B54FA59A9CDA2748393877F4ADC46E8B65AA3FB1E9
6AF50A668765103D72E1DB227E809187E1CBAA5849E1CAA8387DF10D38BF68DD
BBA09648EA6ABAF67F1B5832F236EB2708612FAE2D03AC7F54B9BE7618BB8595
087EDE3B29835BFE8B9DBB646E9872319E1DA7B5F0372710EDCBD8CF691632E7
FC3C91E1CA4F54F3D00AB65E22396FD3CF76798DE4DE4449CDF26B72961E71C9
5DF04C7A174DDB69AAC10DC5EDEAE48FD2943553ECA8380621CD804D7188AAE4
57B53E05980BCA4C356AD0C4422DDD35541F3EF6540771056F8EC08D67A7AE41
A1024E15093A675AAB02AE841E908746773C15AEB54E6C1AC8A05CD9078DA976
B0716C90081DC079D2756D88C04100ADD0BB49BE832B07F47415D7395D9B4CBA
21A1D278F63B96273CE415EB9497B68A664A2EAF79A8029EB2B4651FE24E36D4
DFE0E8A0937C93AD6D235D765764F8F8CEE8EC825922A44630509872A04CCAC7
73DECFA90C6C475AB96D0AD704047A22EB41D36C9A1FE1F5573B3982DDF6F317
0F2BA79FB1387267567622D25599E435493A4A532CD4E933481579A81850D1FE
ABA4937C91FC8E0A76C03DDF9E41D661608500880ABFD5D5924C7F2EC5BED426
4332CDB0418A7A33C67B42B1D17F0A53EEE55B1F2A0F4ABB3A75DC66117D97C3
3DEE58927EA265E671BB43440C1DD2CFB217E502566AD8925F0291E89BCBB5E0
C19CD13D4688D64581CA398189816D2FC3A2755B20655E5D8460556555AEFA48
DE017D28B8CC768521E6D051959D299A28F6418502E44C7F21CFDB4A45122272
72A7C8FAC910780E4BB104D24BBE74933D9F55A3C0B1DBD472B05B8D4C1D3A10
B4E4DBBD8E4FE0C83043CE86BB4EBA709D7155A5FFA0879E0B58DE4DC0BFD245
5D805E6B389E9AF0ED97ED04688D373C811E28A2F80FE75DAC6592CD1C3ACF66
BD26539D2A1B3515FFBFA7EC89A867D9F4D8F0157220083298DADD4428D1A15F
6AAFBF9803736485F771F6A3AE881C26257D4F18816D2F3289F882359C085FD1
6E2B4494DB545A33D71D842F1A12AA4EDCB5F04E6C992CBCCD8ACD743593ED47
7BA5DF06AC4B5FC348B1AB1A703D9BA5E62E2072B79C908A3E814A3FDF408DD8
6A0A79FDB6B6C9265FF53B3A35251F2C3C507EDC9F059874C296FEA8137BC877
93C58352BC25354BF00192DE48723C7F49FDF1C5B0608914E631724ACC22E4E5
7786ABA08129139D16375C196C885E1B1BFAE0A58CEC159A1AF2649DAB32EEF8
B36C69725E49C690E4B74550E77CF36C578AAB6D6F0B69FBDAC5700252621E26
49C807338A9FFA7AA11B3B0C741A482D270DCD255EC43694E92916F8B130F39C
BF697B639E6A51C6A2A7F53BA69A5AEE7AEB5FD7C14F24A52BFF14F02513C49C
D8197294B4B5E1AED74DFABE80B4149808582E28316935C8DCAF0A70A3553E9D
F2F71114AFA9A26AE6B71120BF4D8EC7726AE8EFEC9B28F7F70E5BFD53329AB5
D834D2CE0259D837A4ADC7CF0D52278792B323CFCC559368D49D05E2BB1F20E2
9C0D51B59F2108E985637812A679DA63D3DE2FF2323EC38871D19F46B8618D90
255B4734BF470CA11D66808B09B5357922F21ADC1E717FC2FD5D0CF7D58BFF95
6AE551881551C57F308EC81D8B381F26C7F64307A6BC5527A588B391731B36BA
247D9DB6991F79648774795D634ADD6E1A57A897CFCFD03C5891133FF52F7A2E
C8ACDCE8006496746D1A63D08C46836425A2E04E5BB04F02ED20F5ED6BADEEB1
1FEE5182CFB4F78B7460E2C97D7D47DB9ED6A99093C0E34E84D7D65FE3A32091
E88F7F7D1FB215F54418AA332A13ACC11B83B8214F60B72C43C4227714546A44
85ADF97C923BD00A918BD4351D3A8F8264E01E9702FF97965D7C31E451FCAE18
97BD0829B61A369BDDC74BF535D3BFE9A6C9EC93C9CF04E746D8A572FA245C3A
17D2CDBD5038FD2A6DBD668B84CB670E7FBD84A139CAC79A4823081F1F60D9CB
9B37D9C4860AA2E141DAF3DD95E2F0BCAE5BD5115D047E7BFE4E2EE6F2FA4710
96826FB5870E19553DE338B57BEBC40795106D1E8886B9717EA36CE69EEFDE47
7A6F59D6C07CC478C5A0030896B6297E2F89972091F7E21FCF813A8B2ABF7415
CDFF51CB8EF45E48E47E1D7A71E79BC1421893ACF54411B67F502423DCEBF4FE
79B072DD47F15B3519E728C17C0482B7F6BA10C76A9A79AB4B37720AD5F09296
A1D6AED87E71E3F816B84A893B2422AD5CB551D08BA7BF774854972A2829E74A
B6C9E48CF55802FA5BBA0337FC269F7DEC7D7B9A399571FAAC2821C29AD82FE8
3906259EBFAAB914B6A2E2DC1F9A631238A00786F56EFE91B314C5C39C951B16
80D81601F1764367050E84C68218CB7AB1AA19741DB2D4F72D9311A9D7FB7B49
EC9902D2DEF6C80EB188D6A6C3782BCE00F35E670CB7C349F0946D8AF794D6CC
46F62DD8267FC7A17A3298DA3DD39E58F2FFF9D0C78AF8D60B34214BCB6E2A14
2EE7051B20741F3480791A6EDB620572D24FC8819DE73B551B2A06639E540302
580B9DB623662B12AAEAC1F41867B7DDB29ABBB04D3DBFA0F51488A6D4649CCB
CE187740ACBA76E49D70C38AFE9C0A4C0559E87FF00664C6528656819F4CD9C5
8725BAA9C0431D04B7A7CD4F0730DEFFF9848BD8CD19123B06883679A395EC8B
3EC570580C2227BF66DB74F53FB6E3DD9BE5CB7ADBD8CFB69FBF84386D1B43F0
E4D2CDA7865149CF85589BFCC4DCC1F3932949DDCBA2C693831EB545DC0C1237
B57A52B3FE1F44305746851B6F1913DA26E3811D97F21FE16CED8BBCA26234DD
DE5918D0878EFE1F7838A963E984ACF95436ECAB41A86D2579DB251557737366
A0862FC696A444558D1ADAD2868A296645353AA71D73D35D3C737904956F37D4
74DB7B67102D8FA5D6CC4D0FB39D42765D09D503A5EBA1AE134F30DCEBC3E083
25D6C41D13F38C9A07EB6BF47F988650455C3AFCC2E7749EAB4EBC57FC9BA9B0
FA1DADAE961F49D589629A25B4245EB8217AC6DC35B6F5F0D6750BE09A8F8F03
679CC2A167CE5611397D4A89E12896AD5B39E30E735879E87BD64D3E35669898
1804CFF177D10F8B02354882FD3AC3A6E6A1D9F35393A3CE540D87963CC9C01A
2EFF2966161D0165C7053B0E3CC4F5C98BEF8D4C9052E4A4BEF4DA98EB33FC6D
54F0A6A71BCCC90ED8F7382BB99C9F643D9A4198CE2D58054C39CC9319A11984
810CBC80A5090FB667DF1A2F538C5E8C979B5E56A2D58F698BE652AABAA434F6
3C095A9D1BC8801012974F43CD83002091BE7B6A9EF9F2864CDF2B9942FA2636
694FD798648FB87584725A5C21AA79ADF57CD9EA276FE4638B30830CB8137F71
A6979FA7F580C8CB401A2366D68944E8987CA16407E11CE330276863F483E4C2
F189BF20D8539C8551EA611091A16AB3B9F505268996EA539D99576618652ADF
C9D54BA030D709ED451D4290739C9F85316447B3462E03FFB5287554A1175640
B2B735E8D62CD4B96F9A23A4D2269D6374F7B4A27961E7DF1ACB59A0B2228298
C075926005B8F032FA01BCF53AF32342268AECFAF0EA59B5D58A218BF9A7D0D1
5B4C53F46EB99D2385795B696150E338BD7DCFF161DB9B4CBAB6A43D5850B1A6
4DB18F98AE80B7B295D8B5BAE25398DFE8B552C73B8EE37867D86B421BA4A882
A4FD21932A299098EE5ADB24811C3388C616DD0650FBF97B84DBB5C1CD77ED56
19F590A90D3EFEAB8AC55C8FE6F3E03E8D4DE640146F75BE691EA83DF3281370
1ED376266FE5B9A5CAEF4880C4B7050FC53DD12DB83DD85ABEBFD10F53557183
2FDF215D3A0A4D7F2120FA092AC05162082D3CDB8326A1B74A0BC17F9791DA85
C9E129560D3E686354580B0F5A31F6040842E8998DBE9F725A48C9AE7845E6AD
86C15CFBB07E54C60736F5F5BDAFB176495A43E53815FC52A916B66B67AA1DC7
42BF4AB489C1D8A49179C11EA1B47F04A4EC559781B57B994E51E04F6D86B42C
7667DCFE0EE26118A3A05E8D0E6E8C36E1E8169AA5A9706E9EC3B4B989FAFAC8
9DF9A5302844AE67F109E8B36E33F3D69F7765D3A11EC6580F74D4BBDF9D4011
1C0A909D4FCBDB7A0C022792B5941F12FF79BD59CDE908010FADB8ACA0C7FC36
A3DDB51CFB41449C58DF7E216A19B194F49E6EF2DC30CDD35FF4E4FA6DF9C677
02984DF3A3D8D1D13167B49185A30C3B7D316FA6AB9FC877531FC6ECB1AAB50F
7C0BC86E76A7050CC2C5C8BCDC7CB2298F1C8134BB2D85AF13AEB11F124184C1
EAEBC811BCAA5199A3B920E627EE71DB3A14BA2F1040DB8FA585EDB1166F33F0
748A5AFF019A8B411D1E51B569FF768094C0C3D6EF613EA0BFE6AE9E076B15D0
08327EB23A73CA915EC040A949B1BF94E78219F7E54DAB8153F623C609606348
795FC91CB2D1CFD58933BA1DCC782947DE8014187C6E02020674CBF277AA170F
8332FBF6CF2EE99DD785644845A0B4BAFD4714429641D4CD6B6D08E6CB29A231
099923C1310DE4020B86D7D5D0F60C5395E215B883C09910B9FC524F322B5C18
601BA0CB57B328112065DE8B1B8159F8070C21935EBD2FE56A5C0E9A56D344F4
EA5BE99B5F9CBA25239F90D7430C0B9DE4760E342BBD1CB860730D5E8FED095E
081AE6608A256D37C1CD80EA0C1C664EEF0148541BA5D9F865C926BB6C5ED8A8
6253178C8845E1320F940AB05391A0B70760142C1A65515D8BC9F5AA34EB84E0
0D8DB2AECEA00C72DF78D27C90BA9B72C1B548D11009E7902415741E4559B64B
E78082F97D20F836FA77D39013E61A114EBEF69FDA4BCFBD9E7E757C811DABBF
6787458B355250B75E6E90E28D8007DA6179C264E60D6AE35FFC8E1BF74389A2
213BEF4D79CCE365A92233ACA4E29002410D567AC9C9797E120DA702486A4441
5F235BD059099ED826BA1C232C89E9BD629A5ED0B429E01DBD6DC507DF946180
458259C8CDCE3E276E3ABA6711CD33AD7EA2E803082A133F88BF567FD309DFEA
AA
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
%%EndFont 
%%BeginFont: Utopia-Bold
%!PS-AdobeFont-1.0: Utopia-Bold 001.001
%%CreationDate: Wed Oct 2 18:24:56 1991
%%VMusage: 33079 39971
%% Utopia is a registered trademark of Adobe Systems Incorporated.
11 dict begin
/FontInfo 10 dict dup begin
/version (001.001) readonly def
/Notice (Copyright (c) 1989, 1991 Adobe Systems Incorporated. All Rights Reserved.Utopia is a registered trademark of Adobe Systems Incorporated.) readonly def
/FullName (Utopia Bold) readonly def
/FamilyName (Utopia) readonly def
/Weight (Bold) readonly def
/ItalicAngle 0 def
/isFixedPitch false def
/UnderlinePosition -100 def
/UnderlineThickness 50 def
end readonly def
/FontName /Utopia-Bold def
/Encoding StandardEncoding def
/PaintType 0 def
/FontType 1 def
/FontMatrix [0.001 0 0 0.001 0 0] readonly def
/FontBBox{-155 -250 1249 916}readonly def
currentdict end
currentfile eexec
D9D66F633B846A989B9974B0179FC6CC445BC06347FF71900AC8FEAE3B716D52
C1AC4E5DCF4EFC3B9121F09CAB0C4BE35FD0740E08C853EF201BBFF011DE2163
790FADCD67A15500D3F87E2616B7DEEBFB3934B09CF7B8BE9B945D2638887F73
1C3214D790EBA3065BF944D77DD51978CB663398285895D774586FDDD6A7467E
B1BAC83EC766EDE0FF34D07C6E315D7B79B205EDE798A08FD0D9CD4A1307FDE8
7F57AE7A32759AAE66C77C6127F65D92BCCE74ED784372E34CC835BC789BDEA2
9E27574D388B2CEB1DB127C190624246F4991BA418137BEC72C8CF7830DCEA26
E13BC7F0CDDAE283F10C1FDCD1B46ED2C4BF3526E9DD2FD5DD021D1116D3D9B4
44188211B1332E1BE656BCD0DC7C6D7F23ED03F9A42FD10B79980768710365EB
A8E211AC8936893AA9318E20D297C730A6A626FECD20651E6159D498F85DEA98
038CD78953484C2AB6579DE0F8455DBC490B5E1656B45A31736E5E2BF50B8F31
267E916812FA4661B391CCF31C1CEF974E371009854CCC04B88163FDD69DFF46
307B783974C408286274E78CEFDD99FB253F6040F96E4DFB000EF00A93CC110A
AFEDBCB7E9DAFDB19E29736CA84017FBA4C48D67F617A0937229695652772391
0B47379ADCE97C1A2272E8ECE87A1E0B35CFC9400B90A330FDDC52494432E48A
07A5427237AE7DCEBA59F06395833B628C8BF425A38348523AB24EE529E70F6D
E36B4FCA848B48F5D18F20D88818239EA04A1D52164110F10A861C7B7AA87786
3787FA2BB85BEF178696D7433F83886F07FE61A11DF621C607226F24F7EDBCE7
EF8B9A9C547562D02F4CD5A7C1C4E9CF749B6E8484911EB05DC8C54A020A5376
9746976D0F3E7C6D7D6D03D38DAE94B64AE7BCB30EA45A64C8A37114EA85F851
5E5F96B454764A111B571111C7198992EA306160E302F1BC74EBD30F86678687
F7FC00E9E3CDE46A18A27D24305A3C595197D22DF748F133F070C630ABB6DC81
263ECD7E72539CE014BDF4B6F329B383570C09CE92278ECC0B38FA0BF876EBEF
458119485A6A70B3C82D9CF63A2EA37E776AF51DD37736854F8CFF11413C0061
18E2A555443444908D6E49D23F564B971C26A335C7A93634622FDC1D98982CE1
CF21854B959F0E1C248D4355FD3C3479B6FD320669A68F8B4E14BE7C83F37CD3
2978597FA3D1316AFBBC16678C2C59B38A74E29B9E7D4BEF828A51B13E71DF2C
C78DC0518AD29137C8DC053AD6D86747DC82DFD3366CBFCD581044AE5B23B88A
25842ED0050BE19E7F538EDAF1128614873F52B8FE20E16DEF21E3D2FB51713F
DB39D6C3E8B60AC7B4A83F38D6C3283AA890E5C5D4462D0CDA1D49DEB5221D7D
759291FD43C594074033868359A9CB523210CF1A2479FCCC7401AC1BBBA29A0C
F8449C165FECC03856CB08DA710B6DE98A17CA615483CEDBDBD9C2F47D84B562
1745DBAEB9560610DAA89F9D6EE68F8DFD8D0E136CF2B9B44D86E9064DDBA73D
4AD2AECB1F576EE1254970C70643BAACDEE7682FACB396AF64E102AD05E9141A
2A2B04760E9C6C61639B9E43B6D719F2431580556CCDFEF253C0B613B9BCFAD5
ACE01883440C3C61D2BF098A3823E734AAC86926CEEBD235D1F3E05CA0A67A4F
22C2D72A793CE08FC5937B4D7FC5E77105598B3AB259EEE0DA4D7517CF10172A
9CF549FC86FE3C79A1FE96E5ECBD1897E78765DAB8AF93587203554CB8008AB9
1561F7B489D2FA6D444F54CAFFB3F32607B0397165B14A96E463419831E50ED8
52C7FD7AD1C180A15DF66BCBEFF9437D80C0D133CBD3D25CCDEB37EDC5EB7AE3
056796B5DCFA1D8E053EBD8F16D47D7DB5B76D891228F344E7BD6EED033C8096
25340DEA0324A9ACA7AC7A3F8A6AB960365CAA37BAACE5B78B259A06BD7EB2FE
CD07DFD572394B49D184DD233FCDEBB2918B95470DB2B2105085D1A8E08B4917
D4DC3E7ED37B25286FCBB1F8B2FD6A4B950D485F880314EC964BFCE136797BF6
A2592730C9AA45A68D436C41CFAB8C3F360BC188F311A107CC4B9D012D9FB773
CAD49843D26127C572FA90C64CB932323C4D302D38619D46DD42291FE4C18F63
35C9AA3D95BB4CA5D12440DA36BF7F264F9CD0A984184AF757886F3AEA4D5440
B88F8027C7FCD0FFAB183250BA953457E019E1F784C772FC0E92F4903CCF3745
C585115062B065C19B8D8F6C4E8DF0CE9E2D4D10F4DF40E6E7A6C024EA7BFACB
9700745AF3B8FDB294536FD027A1EC162CB45AF8954BCC9519DA3F3907F526A5
FD94C653A8B020A85B7209F2B1DD4F8F7243E2639526CBAA42B7D688E3A2DA62
797474023613535B7BAD9B7D603F14F884E46A9FBE724F18869698207C358C9A
77369E5A7AF7CB0ABE2E10D764440E4EAF0ABE5EBD545CCECC92327FE0080C2F
6E3F39704FD9828C28CEAD9F7D32759409068CE066973DBC2A54AAE89F2AA39E
48F3B09002EDC17DE7F6E2B26AC994783DEC7C9029469ABA16E5E09932ED878C
6ED51132D6BD87E9BD0F7EA14ADAC93671972B4ED1993DBF217EFCCD59E2F40D
F39D0144B18CB1196A546CD9C09ED409A37537ECF2F0DA63D0C9F66EE8050BCE
EE70A9FF467394B83CA932CF055B38014BC35053A71C5D4237AA13773B2EAEB8
3C10111CB99C17B06FE4E385E858EF5E53A7069222755EDBBFAC7A615C5D7E2F
E528C867E6501F47A6655530E4D7C0544A95E1027273D3B6295E5E09A7116AA1
19ABE7A95D11A05CE124A4DA134FDE8B541498841D40C0005D42964B815C450E
ADB73EB0A3ADD0117B57CA6C1B8CAE93785364A5FAC3238391122AE40EF53D21
EA94D8B6C386D3A49B2DF1EA184A04054B776605E330BB86B00CEF62AE32E563
4273F0F52762C3D147F3351F5A2A231850268DFB766415BF7DACC125867ADCC5
43733D0EFAD93F82C524B6F6DD58771160CF7D5B7E947CAF49A78C129AD2F44F
BFE7BC03A0FAFA64951B61206C2FAE0C70EBFC01D84D117BE1577B3523C4D956
A9545E3F5BBEC5725EFB6BE037AA2EB13907B12ECDD92C2F1BF0A0CDD8747745
A81FDC253703ACA50578F18DD929B61766B8AFA03089FB649627965D2B38AEDD
345014ACD40C64A7150D6C438BD3958C62CD9E9D9385ADF543EF115AA3D597D9
78800823824AF2D2433BE8CC4164B7B169AA673E858A5781F2DA4132D377D8F9
B8CC698A7CD5FD23225272B2C64B15C435EE7673139B09CDFE586694B31014CF
CA5DCC4CB9CE015D3978A2DC6A243508117CA2D05701B26ED741F16B65FA76D8
BD28B2DD24D6D731C47D63D1DE6028D00EE5713A61ADBA639151D67648F058B8
C64D85C92EE8EE8993FEE04F7CB6C9AF6D6EA95B6E5D82C460B4122E88E548D2
1CCBEA889B474050AA5E3416BCE3E21FCEEF31A4E7A39AB615F9544205300A82
325156B81553747E715CA1F39BCD71C5DDA1D8B75EB87C838592437246E9D34F
34D5D2C66316332821CECFCCA1D3C1D0CC831CC5C9941473A39F7660BB98FEB8
9FDF2C8B3557871330BBF3F2015140689F97C9CCD0C24ECBCF2673F719095012
E2C303DA63FD11310CB2B5A40E473C8A13323EA8BA2F8E28F6B259E348145C5C
A8416C53CB94E22ADE20BA6AA4A502B650765F30403153553EBCBD4942E49D92
5EDE01A7354BDBD38514EA1ACE4E1360839C743A935E34F05EA975E6F8521F35
DD3F47B32DD671AF645A0906A7708DE607B8ECA12177CDFB7FD6380FBC4E3367
DE4DB71320EF4FE96FEA4B022D1570F87A7B88C84105CCA8AB43DFFCC5B4094D
5522FEBBB550CE6B36B0EB95DCCBF4D7E5F4040495FF6A82E1A276ED5AA7BAE1
FB05FFD75D816D485292064A72284DDEF9A3FB572B3F4280C882E28743825823
FD09366A2DAC8A552F644065408A5B5D8CFB67D6D601955C1F6454FE6D2A1A68
C78C48DD46D9E3EFFD1BFFA4CC1A889E9E90C0F6C7621C2CF263A742D20DDE30
77669796D33103FB585E7A0FFBA9D2D79C6009EF69746AC2EA46D178F6E553C9
DDDFC11F715B13533232E0DB77CEFD43A177C3C86C0F60A86F578E0ECFC41002
EDE3E495DEF6D2ACE460FD145E769D4E888DC89585BE48B5D409A5324476F65E
EEFE02FCE0C00964E1E28AFBC7303174A65A17A45A4B814C017B85915CA903CB
0A562167BA13E6DCF11C448EAB9E0E630978C455A76FDD11281E726886A75650
C3A34741728D4C9E7D4EC37FD55D817532EE73D71324E055FEC4576102A8E4C3
8DABAF6F07FF8C59813EB4D97EDFF1E936D6830F69A2E02F242EB8A0F4EB0567
3EF5FFF783C485E6D42BF180DB09A9D3CEC8CD393E8E2CC71A79355FA757821A
73DA0FADD3E5CF52DF4AE41B665172A82B6CDB91F8A569CFE3CAAB2FF2767E68
001FDB7D48100859F148EEA9BF96A500D68B8823227A3879412434C48AA355F2
7B3F6460DD3D0968AAE3EDD486DB3E317251D15A9B58023A57E70F241619ADD0
E214686928C77FC9CA9F48730A14DFE82FCDA6CB7795D77D73BE01187D075731
4FF1D97CCF149F388749375D92AA336AE0A2A60A0D4C3F62BBFBF31361E2ECEF
B861ADFEA2884D315F5657A57A332D820CF07CC6DFC9037D44CBE74A030A9BF4
A30AA8B00932108EDDDE2609D60C353CC00483AD73DD94AFCA2A907E2A7E8180
271AF335CBE16973BC40976C850581ECEA211D96979CF5DCFD325D6FAAC3C1E3
3502D306C2BC7D11D7DA737251C9CC94A76072808165DA500C271AB7ABDC397E
50AD5675DE5B6C8B552E90ECFA42B5C7D786A0AFE6EAE3C5DEF64D7D71D4886B
6DC6C0755BB11D15A49B6E46EA4AC7004C28C4F0A6B1EFDF3F1F38595A9D0508
540809826AABDB64A05FB14DC056111CB7AC5C950A094675061A2EA6327EF9A4
7E03424E2ADE506C2DA472B40593A1A0EBF797FDC60127017BCD103ED7A1B9C2
DA8172A2FA4CEFFEC1C424B7DB601E061573D68D72AD03F99E12BDCF13C96F6F
977E4ABAEC539741F8B9AE4A760282014794C77C664953C121628DE7E98B50ED
83A538251EE4BEC3C1F456B7822D4FF21F4A9096EF22C1454CBE8536D87EB591
E845639E32C569B568C3206034708F56E0B3FD16612DD54F9205008079F0A921
13C51CFC8184199228DA74D15AEC89927DD97CC731752B86F48F41F12E5B950A
1914915DDF1AEB1166327F296E625D4B1EB9009DBE28E54C5F0F31AA17BBA499
22824A46B82761939CD9378E07FB898E46B308B00F079E154138B2BEB54B4E0E
C547CD0C796B113E7B1D6467EEB0F05F00E0BBD8688E470D0EDDE64660B7E635
2B01A2D3ED2E2259D3D475234E4ABD28D431B5B9C93A2D183E19FB1FCEFDACE8
356F6C295B3A462E6A34DC95A52BEF29D97E1DEF73E106008165D0AD909BF65C
B0907A668A3D44A2B6234468B01FE407640D4BEF7B1B58BDC257216651F81F5F
358F2B05CDDDD8AE32B1AF866D8ED64E248A778C6205B891C4C6CDF22EBA8031
40E60C7B9D4E37BC2DB3FA36EEA39BBDB25258FDA3443D89D569742D7E55FA5F
F17B14F02996F048A31C490394DB7C454EB8026F89F98AE88D413C9D96DB07AA
3441DB017F99163B8751E078517F53DA675076CA51E39A8EB919276C9E58EA59
668CBC92E00685E959E47DB19A6202D34EACF2CDF306EEE9D5A5056D778888DF
E3E204F73620FC4532B2AA063771E4B122317B6480D0992597C141D070C1F2D0
A021E2F49359244D0B3DB3BD806AEB5DB053A2EAB9C1838FF7E92558E579AB39
BB806B025A328979CD3ECC03193CCE50E1E3D04E6AC046A27FD671D4E41598D5
D5A1281CAA541FD111E46F966E5811ADAB0817E30355417DE7352BF4EFD81A55
7979E47029EFB4604097EBD8F6CC5AFEBD239A3D5991D65CD3995E27D36EEE73
B405CEB46BE11E0099EB81FD1E13877EA2DED6026CC8FDE8F35C619C52AA0610
3FC7819A23AE97938041C5B93BCC2935CD222EF8E88AF68611022E50AAB2F5E2
97AC77B38AE5BB11041285306CEA07F6FDB19C96E93026642726491790448917
BA68A99A531B7F830EE5A48EFCB71AD21E5C3F611F1390624C034C3499739EF2
3FAF2766D726F866555DABBE326957B6CDF4491E783B389678BE876895F9762E
CB5E7566E858B2CC7CEFD34C4EF05B4266A8E8C2FFD57C9E2AB4B0184BFA16A3
3873DAAFD6BD37D712082BB86B4B6F63D03ABE4EA4BD6E305998E6B31FF4E002
ADD86B025FE51BBF1F3FAA1BF233ACC1269066827B3285B53255A22E903A1C4E
266C1674AC65D3FA8E23714E23B756B70A07D9E50E9DE7F30D85383B90F2428E
A9890962512B1F637A398B71BA7ED9C45279FD9054D4E210DA837B1DA798FFA9
B26E4613AB2F7270C4C7E67C946531DFC47FCB83408D7360F553CF1E4CA70D8F
7F571155B0B4C07ACE01B1171B34FDC93E30471EDD5CB4F89760806834AAB075
B838381397EA67CF7018A565B949A2710058926158D71518E5AE3E658FF770C9
03FCEF817A460AA7F620A75EB38D5DE6FC97ECF8A055EAE81C4F6EAAB676E726
AF4FC3484E2BF5090D1108CDBCE3B5FF82B4A73B2626C6853E971023125E7BD6
CA24C7D6880C6631D06C6A720656EAF13ED8C4B7172A4816ACE276C6EC7D7DBD
85B3F20D6A771C948FD5F508EF4BD42CE5148E2E8D8E48B4FC25654C717CF34D
C2F53F6C106FE77848500E40D7B936DDC5A6EA04FCECBBD3164EFBF2FAB31218
12083672FD2C0AEA6475261730CBE72D83A5FAF1E78F3D400DDEDEFAD9D535B5
8A264455D81D673DF286F55D0945E904B323DEF03F109494A0F043F08FF4907D
9F84A6479C638FE616B4FE4C5815E0FFF7BD1B056B3C9F9B6E101053958976A0
AFAA3A368900381C4B7FFAC3699255CF4475D4C58B14E3CF5CB04E41F044E4C3
F50A6787E6E91140E84E969A1CD9797E07C9942FE7911315A671A7FA88213B6B
BE42354627EC7CA53942A986553BCED34EC348D74B48198CE6A6F02EF71DB3E9
057FD5699036377F1A56B30B7DFF743E4AB7D4B341497762025380E1B198684A
193D5360D5D8614C297F86BBFC331B68FABD159BAF2503A3671BE8A61E09D515
2F89FDFD66939DCC2A7AD2D7F9612ED54542E6D545F970B7D38E51CC300DBC81
9EBA8F680CCD3A9BA1DE350ADD345519DDAA7CC90CB9815BE1F9E6BBC11B3F5C
ADB3D3F07FA22570732DACE2E77E29E65CD3BA19EBB913E320F9F732ED1D2D1E
7D8E99C362534E0C4CFD2CDD6C52BAD1A162F15593442E0A5C72D038B3A6EFE7
5E4A4C72088A48D2F5B92469B9DCD98A026E851575D661F33430B0FD14719BD5
B35C8698826725806A395D1F42AC25F034ADCA9ECD0E32E3F84FD29BBFAAFAEA
9E385293938E36177AFB66C416BB8BB76D7B4DC643BD36443DC1D33DBA241ED0
4026E0F07F9B9EEBE0FF6F7ECDB6AB022B4187126B5B9183EBF5CDC9101ECE9F
B5B5FF1E703D35EDF9B5D97807C80F9AC28DFDB14365B551D57A1B6E99B21774
4A7795F1FE875E869969F26534190AC03C53A0FF11DB5BC4BBEB772F7E5FFF4A
9205E23B5C52CB34EB733D8412578965BABF45A003B819B9161E1A7788B838D9
1CB21DBD6DF622DB506EE5C4EF7D426640589F5FBC0F8D94A9ED738FD30EBFD8
E947A08E8D7E1FD0425F69398053B16D2D7BF0BBBB51D1369EC18B8B1BF27E2C
E1B4BEFD744FB6B8A5AEEF3ACA6185FEEF6C72FB12456AF63F31572A0A32125F
A4E52FFFE690A0DAE7FDFF47966DEEB30371349E9100A9FE4DB5B47A23C7165E
044DFF009718877DA7599DD2BF15C0A15C076DC98B9B2252610E36B304030ADA
3FC6DE822ABE5E8BD451129C37AA8E8B62D0BFDE7F75049FC2FE51803018B6D7
7980A0CD8D71BA01CA74E1565B380CFC395E5A83351D6FE24AEF92A3CFC7C92C
4A5E96679ABA01577DA5F3FD6A5FE1A4F802F0B56D5462F2538DA5635A231BC8
A19667240FBC800AF55577D929DC9CC20CDCA7C1C2F18259B887199F7C2BD390
F3AB2CEDFDFC2FCEF1CAD9228F9C69F0AED07885347B262FC98BF0433251979F
60F4610AF210FB43B8284794F9DC98EEE5BEA32C08D89F85FBEE99D21B63F154
BED027C8F864EDE764F559C59D40F48DF92AC063F61C9FD180E823EFDBF79DE6
CE8A9243E3A6694863DA19BD085E72B643A82E7A3E03D2AD9612CAD8576375CB
E0F6110C74792B1DD7DF94DC4B1771EB33D6EEBCCBA265C64D8FC0AF87FDC916
DD8A23AD2C2B0B8C70D65C679200B4246119D340C1CBB2D87BFD0328F3254E39
EC3FB76FB03603D723916CAF8BBDBB60397FC1F518A6EF511A722DA19C6432FE
475121A2742804BACC73DC5FB7D2145C4A2EDD2DAA76D0EE727E2F54D5060E74
6F2AE90F8002F3DEB82BFE11A83C22F6D5E628767888D2CBC596B632A6DFA87C
8B777884B8C240A5225891318D12DA59625C437D4FB83C8DB826151D6682C68F
3DA790DB9C708B0954C987F4125F89B7AD80EF30580404AF3F1486AEDF87C0FB
55956DB3CF497F4BF7578BA6BAEC8F9511FD6997557282EC4820B21149E3BFED
CC903DB6FE4117618F3507B73F6F2406264A96A8F46425303554BA06AE21DCC8
4EB946AB44666D0FCAC857329089E9CABAF3E3700773BEE7AF66F6690AE70C87
83D631F14D39C211DFE461067245D8D36B8FFDD0ED59380E334AA80630F4F619
7AECFF92062FC9639D8B212D48B43ADD0B58AE75FB1238E423874D699C96AC44
11B52396E2B59392973197C59257053072FF7B29CDC48A757579771C747A148E
329B63394AFD15061F26283F54AB3145948F1B79DCA8B54B457DF7CA71D121B9
4CEBA1AFEFB34810B84618153B5AD5110736FAC80C15D977AEF21758314AF80A
E4C165D14749E768C869BBC6250EAC587FB71E82D1A537C64CA1068205E243B3
B6D09310900529177263931D89F1AC203D27769276BCD118CB0842C30EC7E3EB
3B237DF5AB6383F6EF08DD9F520F03D751F0A495337B94F9C6D091BA434323F1
7D9178D3168225CBD20F2AC475B6A2FD005EEB9C6336F2FFF46556D23F6931E6
4F2420F600A2C861DFD8DC8BE88EB1F24B493BC707D442D4D153235E5476F4F5
0E9C11F153F1CA2481C23A34DBD0E603260A277AEC1F51A50C46EA1D3541474D
DA50B41E8B79C0C2431B550BD933DAB881E253CB5FA4D2E650B4B4BE281A9816
EA5AE9328797F26B0B58973E9B91158E1FB4FAD9C602EADB2B70E64D445AD62E
A3F2BFDF7C552A11782700242755B37D4D61C2AA87090D06AA74CAC58C571B9E
7C4DE3F401EF19FB8B7257ACB0E7925D153D2B4D8B77ED9B6D23D9780E228D80
321F848C1A517FB560E8CF2264C6E6879648256634352707B1BA6A2C8564C3FD
4EFD8B851BC1CF1B702A3F7F504B188412207693DE75B3EDBBC9D27F6D857C07
9FB592328AC9F7D9E12AF96BBA81E22133A947415FA2D308CFC6BB9B3190B65B
2E16C49EA31641D173A95B7E3D72C20A2D0F916F0646E6A662B7342EFDC93989
00960AA872B14485D0652DDAB0DBCD892E14691647CE5A30AE4430B80DE20F0B
23FBFA40063D732B220C4BEEFA8FDEC4B0D8C4C43891DB721193CA8D8BA50560
FD20035EA67DDFA7CD0851B1F67AAD0CDD55D1763351DB8CC0A26ECDEDFCFF15
5040BE949F274C11721D6C17C014043D2DA87EC36E3B8759C8B0D8BE31AE6D10
BAB7E555A07608F5C24057D08722664F8BC46D0D0EDE710AD9B605F7DA46E09A
DBC3B595BCBE2E6A1DFAC98500AF16B6918D1E915A618D59BFCD726A2D4D28C4
76440E12A4831790D580F8EFB7563D2A48332AD619A11D41BF10A09BEF3238B1
C546C312C17F64D10BC3DFC288D984E1878BC0D22452607BC8A5FD08F1A6FD82
72E092082164BBC236C600741CC035665DD98E2652F8497F2B33F66FA7585BA4
0A28D7D5EFF8F0EA9913249C6F1EC310FA0E94990B24D3BCBCE4FFD0FCF382C6
34DB5A4EC045418E4EBCC6DF78337122FBBD14B7F2355EF3F5984013A2ECCB4A
9D15D665F6BEFD474D48E58E0D1105B9C1FDAA4FFB0A7C6FFE3A2DB30EFBC3E7
739FF06606C0CA674D1778D6F2FE1D28D12580AFFD41A9EE20974F54CE9C94DF
68240F0E8CE9FFA112ABB23E071B488884D6A12C9D36FC4BED6E915EE0A8F816
2C84F10082B7B59D87C6C801B144AF82BBFEEFEBB92545F3FBA4841B57AE36E8
40144F9F053FFA5B36CEF1F23E201B2B0DE3AB7BE3B1233D611CF806A9A3DC22
F5491361DC79D56CCA9362047A08122B61640415A4C2D85B6BB00AFABA2ADBD5
746D9F589D8D612BFD6BA877D13440CA60E5F3D5A27CC284946E38ED3FF0CF2E
847A5A09ECD0CEFE72D5328776F8B18AE7FDEEFAC30CA73F6E157727BB83318A
FD9C78AC2A3BBC523AB43469304B444A1AF803E9D84192525D19ABADE6974F7E
2F72F9824B14110163351C68BA717530A5482FACFD91D0DF4174E8C4A4D32FCB
82BA0F846091B1EEE859A2E5B61802C1180D4BB2157CA4719B2B44B23C1D26A3
B34DAE03FCC094AD56261CE82744B775FBD9C4D1A9053A130F22372E1AB2DEF8
B54FE048EAD231F4F535263A3000E71AF0C8A5779169F0062F223326989D261A
69F2EA795142AC1439DF470DD104809EEAC0EB54EC3AF001ACCC0284DC5A9506
320FC44AF71165712FF47DE406D3A4C99E82CB0863CA1DEAA1F5B56DC9260693
5E231AB657C7363FA5FD95D94F53B82154C0096DC1680435B965ACCD8EE39082
BF85D26CB12B69E599809D29631E16085DB94B57A71E9E3F517883C6F187B933
8561B425E7C98310BBA39C677B62E23C18E76C24C8D0A899F621F93B115D445A
E0E389B956FE336E74CB629FCCDA7A8FC446D1AE282466FC08F9F2D919812BE5
1E73B242CEAD5FE7561A14EBB1BBB062FC33328E197499549BE182154ECF786F
FBB998B5176574204A324D1EB820BD02D1E04BC0D21882DCCBB1C5CEC739A140
201151B085053EE97FC6E1CB89FF20C1D356EF78C814B5F3A25D43CEDE61378C
0DA0107758FBFA88369D09B16C0B0ACC8EC61A29623CB12869CD13B257128A82
3F5173A4D3E8D949825FCFFD89AEFBE6D032C78ED779C50CBF147AA9AA5D9363
57A6E5E41FCD770F3088CE2CDCDD24DE122BA636130C2C87A6E5DD3F0288488F
D9DF5122E22208EDB456E4768548F9ECAD31E7B1B93CB19002589DFAE6B65D09
3BECED84207F0828675A52381FCD22FA7701FEF7CBE50F25897B460436FE0FFF
032E3F0B911BA296C9ED48008CA599132EEB0C7442A609729AC7B539B5834684
FC5FF765788E07DDA0D9CC97D99BFAEFDDE3B34B15C7BBABC1A07A8941233D4E
37F5032BA97186822632FE73D8DB835C0C0896B5AFEE6655AE0A7C828B655AC8
AE5044348296E5AE4D159DA667468783A3D0BEC44FB11C6A5F57151CA106C61B
97483486C2B1C2176168419DC4178F8DDF866552A788EE6EDCEF59DD4EB182C3
159DB1F9B65E818E0B6BFC8969DA9B9F097ABCD7FEFC4C6FF0D374BE439C16ED
CAF80B9174C3EA3942259302F0D34C0B2BC69E721972CF98BEB9381DC53B7E17
27CB1D0388D1AC7D84215B083EFFDC5720D0014FE37EB2945D2D70773458A05A
90620EAC5FEC2823BCD4B50D7DB2172E79937D8732A776CAF7E12FEE710F4C85
9CBF3D382D4B5F4393914AA8DD889C9895DE4B9BC8677207D2D28182A3329A3E
4EFE5B16E4A87B148845E0A68F61FE3254E951B3178BAFE9DE406D76D4ADD804
A96FCAEFE9C645818DD70AF98BE67351F6681C206F6BC9160EE28354B883893B
11463A579CA89F7AD2D113E771FA86C422C84196C58C41C8DBB3869B74C23700
286DAB56E321F133F90A056593AEBE8A6A32DF7DAEDABA4741F36C0D2177032A
533009BEDC6CA9CB8507F621F46178C258FB1C5FEC227566DFAAFF475C493957
82E68839A667A03EA906FB20E0221B84423F47BF7D3C14CA769B126E85E93C02
69A831E47B7741A1DC91334DED6FD2DB2638B1682A1DB12C77945193BB6A1A59
DAE602CCB5F4EF782DD071B9BBAB2F79DD6C18BF7C03B407AAF88101E509FDD3
BCEA9F6B616B8A129363F2FAED4B00F36F1E6178611E141DA5EBD85432DE769E
865C50667D3365E788075B1980A3B526B9894E81EF053E19A16E5A1B13F5F9C5
F900C70C8A72397F0D49871ACA63A81162857A629C256FA52B444F710A2E8F0D
C40BA485E050DF880CC0381ADF48E6B8F7AB62305E92A7B0A2CEB87A0352F216
FCEC8EEDAE37B9487532034F3088E7E62BBF7DE3E8A909519A6E6DDB1BCD49A1
CFC4E44ED5ED059A2440412E36264D6396094E612D5D3A2FAF640777520D5C9B
7C3D6E3A79CEB0DA5B1CB838AE79C66892472BDFAD334ABFC728EBEB251D6213
5B9CFF91A00005A88CD39230CB7C2EECCE113F08C2A5366F8716DC013CD7CDEF
8DF37863F7FBAF39D5E8D18A56D8A703B4F469068B96F5CBAED59FF3A7B2BB57
3A78C2718627B3E553438CE5407BD7269B214B11114FB55009F57004735DA36B
2DA1636E1226A5379A07ED03CD9D0BE8BD53FC72B19EEC3801E8B95103753BA5
3A79CA6D169981E20624CFD8174FBD0EAE86BE53F82DDE3E1E15E7DC77946CAD
5B4AEA0A32BCC33C7A3AF53D8378656857D0120E3A7D99026A671F835090166D
11C29A11464F1019C1694A3B200ED115142AD2229CC525B3959BA702BAD15A22
BBAE11B6FBA2A8F09826DAF852EA86ABA85207B891F1B5FFFC0FD200B1E5505E
76416F585AA478E7BA57A2A5EC3F63FD50009042207C2929AC7E5E93DFF138BB
D745F701B26B273704AF5EFA05311F128C0632BB310B4D67130AD5D81C629433
79656EBBFE92AAF7B9974717BBE92D68243E70FC5254FBECFC5BF94399FA7BB5
9CEE7BDDD46DC573758C6F8B77220B5EE8053F6C8BECC640C0B7DCB35E06D651
1A1FE8C8175B6E9E729853C94305B6A96D485116485CA7BF8536E8F77506EAEE
DC01DDA40C6160AECE0E60AB6E9B136995C6877399A918E9B3F7243E6F8595CB
89056E5F22EDD1663C9C52F8123918F4063848E0979256C50146A59A1D9CC288
47EF3EB7990382871A603BF2F838849C88EFF0A2B149AC2D1EAE8AB6BA338B42
295DC133A8066D4787337A8E6387F618F0110F6BD828DB856AB599FF28220D0A
0FB84993AC83956FB619700EAFF1D0613F4BF412AC53CF592732676BAB5DC36A
5BA7D1F3D3358B58CCFB2931ACEA8370CC200035285FFFABEA64E68235028EAA
9BE5536BF522E82E0EF8EE347E1393B79D040241B776C9FE5BDADABD8F38121A
0DD051549B051FD68E769E3B953F5CBD04481D4B2CC68D5DE5AC61673AEECBCF
014BC05D9002E4E9FAD0E4A4171CD1E8B6225D4BCD3CA540FE2F6CDDB4797354
66D02AB54E24E629E8E9F53270924253393309612325BF91BFDB8E110EC66AEF
8A2305F2F5776EFDF80945A8945019C6E41100B48235C77DFF8099DB950C42EE
460061D2F053EA5BC5F27C466E96650F5BE3E79DFEDC41D73C3CA0D0FACA0A14
FF5BE27B6B899657E0D3369386542622875EC85DC0FF2F2A3C91B71D70101568
38AFCA33988BB89AD31FD507898531923EB5119EA42A7F80A484E3AB15F1FB38
35A131AA16D12D510A4030961E73257FF7801EAB503825AC5540345C96B87327
4130FFEE96993EF8609764A5D5D12C8A353E71A430F8601AAF936686A0ACDBE8
87E6642EB1C895D3B47194AC4C678013B0EC2EDDCCD95F33501238095EC3F4FD
F79C67195291052CCBB1D518A147160E1162D5DA1A3524C31F388DBB586866AB
1CFB06FD0375B8B86A773802AFE7A81459BC33E28520EC6BEBE90752EED27958
C63FD48D65A26BF73C3D71F56BCA97F37493F605FCA4962A133199C8CC8F8473
71E2C0AE2637BED75CABEED365E7BD8890F005A257FDC7005AC501DA226CCB4C
2CD7D957EEE8A6A13029D6C619574B082EC0486587296CAB75B90A63C34FDF45
487BB583205E353421D320C7CFB8EC1606EE440DB396444968ABC645FE1B15B9
FC4691467C8A06B2A078CF868BF7A8FA92E1ACA277D4D1C2DAB0E229C3711281
74D4C3BA3077C7D50B2B19A819868E1CA8BAC09603F5B993783402B68282EB32
F4C4170029328F697850C47FE146C742769F930972FF5135EEA84B615A670289
ED91D23406609C2B005B8C3B96B92F27D9BD7147D65DE6FAEDD4219D2A40C6E1
260FC7B3F22426546309E28162B287C42650AF5530644DAB9EFC011D71E5554E
CABB6DE267937F2824C0E3CA4E929A19D83BFBD72CB1A0F0D49638A5146DC646
F4FB8E0923323881F8192C7B9E6CA0DA33AAD51FF6FE1471AEFB4523FF61CE68
6A4BC8082E1FCC05529176267987DA90E94318FEF337CB255110F27F6A74C5D2
ED38E8B0FD2DDFEED9ACA1C8BF3D030198DFEB45E270B4B11398AC2CBAA14620
88EB2191C20BEB15FC9EFDA318623BF9A292B4841227EFBC46F5CEDE1017644D
E078B06A960B1F2714B9A0B71095DC46408D6B0B060DC236103070309B59E9F0
A3196CDEB6F8A8868DC5926C8B0DF7277D9915D1605BB6751414CCA4903AAE31
30A474CFB9617377EE62FE71387C37770956C7ABFC57BAF1D5BC740154092CBA
0FDE2F772C940C9A31FB09D91F4524E2BF44FE985DB7AA022C8AC40BF04F5E64
FAF88030D8B48B490B7E5D2346A4D05CEE4812B5AEE7B24667C69C85886A9ADA
33D4834EF73DEE858A0A61E71B6507B1AF12CF3179D82BE1CB0075AB8E98EC33
441A3F41ECF649A5991D3A25FB4D368172B31491F659A7BCEF7DFF1C34A8BAAE
863FBC6E056EC2522784CE457BCBF7621551D0FCEA286084BF560889DEFD3633
1B9FABA5CF088B1A79BA3923E41FBEDA82
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
%%EndFont 
%%BeginFont: Fourier-Math-Symbols
%!PS-AdobeFont-1.0: Fourier-Math-Symbols 001.004
%%CreationDate: Fri Jan 7 18:46:05 2005
%%VMusage: 120000 150000
11 dict begin
/FontInfo 14 dict dup begin
/version (001.004) readonly def
/Notice (Copyright 2003-2004, GUTenberg) readonly def
/FullName (Fourier-Math-Symbols) readonly def
/FamilyName (Fourier-Math-Symbols) readonly def
/ItalicAngle -15 def
/isFixedPitch false def
/UnderlinePosition -17 def
/UnderlineThickness 3 def
/Weight (Regular) readonly def
end readonly def
/FontName /Fourier-Math-Symbols def
/Encoding 256 array
0 1 255 {1 index exch /.notdef put} for
dup 44 /arrowdblboth put
dup 54 /negationslash put
dup 161 /minus put
dup 163 /multiply put
dup 197 /plus put
dup 198 /equal put
readonly def
/PaintType 0 def
/FontType 1 def
/FontMatrix [ 0.0010000 0 0 0.0010000 0 0 ] readonly def
/FontBBox {-34 -960 1001 847} readonly def
currentdict end
currentfile eexec
D9D66F633B846A989B9974B0179FC6CC445BCF7C3C3333173232E3FDBFF43949
1DB866C39088C203DC22FDC758584860EC7BB67FDA28CC6208249060E18FAB32
204779B5C03C0493BBBBC95CF02692CC4DEAA8D2EA90B5C2E64374E92BCB8501
429B8FAE4A76C0C6B76D6FF7CF9A7D5EDFBCA0E959541C59BD05B7DE43D25D53
FC3DDA6EF0C2743978A6D03E19CCED4A11F2EA4BCC3110BE8B8D9E2772361969
C19258EFAFDC276CB1ADE9208A941A36D18F9FB1C33DEF76AA315DDB07D441AB
0467A1BF50AD0DE4F98225ADD1F93634005664EC4D3A79AAE931F7496D4AD122
EAEBCBFB4D4AC1B8D85E9CBE4ABB2225405A9DA5AB44E12A710451885D4FADD8
C3F48A838573A733544D6AD3B5C7B3E16F8F777F1DD842F33638F7D57C0C9212
0C6560A06445FFE43730EC1895E85874440C56BF079DCF6C249978AEC565369E
E2DE0A62595334A70543753553A4D58895F84C9627524042C4B480C4654D6578
67B2C0CC4A43523BABBF2E8BB693003339A7DD77148E4C146BF5A7AA602A3908
5300B7C1798206E16AAEC1262E3B1DD7325659679A19229F75B0A7BF816E1594
68BE15C3F762C51595E7902AAB117057F4EB1316DC1C507B857AC1B1BE38123E
4AB0CC69F0C42D92081FEAC1259E24E696131A9170053DED6CE28A4D407AE241
675620191E5953CB96967BF04CE1DCB7B9089849FE477F73ADDA94B72632B5C3
E4B12701C044D3B666DB24E45DF8FB89C5DA53188D7C588C1F9DCE353F3D357C
212D5E0CE43B242313912CB809EA23E8158049754D5A9129419949A7C79BB1C5
17FD49A1E5FC3A4095D91E472B31D7A788DB3D0D0778C6D96F68C849FD58496A
9F820DA8C2E98BA0DB5D0EDD60D0A5EF062D122D5B440DEEF97172CA0DA38AC6
D8AE16E16E62C3A99D3B1DF9F1BEA90163879CEA5BA341CB947DFB0C41B08B06
946F9C8A754B9FD193F9EB60CF81B8343A759E5D9641BCE58C2D8C0BF5CBB461
88E32829BBBEEF6E1C8A713A3A614565A4A9AFDD566D081CE2954D486E275D41
3BB9DCEF1E66E7EC178E370757EC626E6E82D294BF3E83ECC0782DC63E319DD4
CF867F340449A0A245430C101F3E5DB92CD828ECD21A2B602F26E72FEB38368F
DC03123FA421EEA747607B26A3030C048BD160A39735FB6B8836B8B5A4D2AA84
96C5E265C58458246B1452B308A022655587FDF933817766BE8A1E6C29DC4365
DC1ED202CBD81E0339EC4C3C57B054EADA2C699385B3CD763CA06787E96684BF
86F7BBA7009447D8D50167498735295CFFA5358D068EA503BEBC2D3A7EEDE760
BBC03394A6B01B1AEC021C9F06834D1CDE5DED19A5A1F909707EE75149C1E85C
43E89D5BB040691BF271E7CE517B6DEE4FBD0A7527663821751D303B8516162B
1B4F9E185AFB45B50CCE99E8BBAB37565932F299515DE769A7EB3F617BF5A7C2
AE55DF6CA1AC3187B2A102CC585C335FB2F3EDE0A9BFBB4A3F024368DDC7B27B
B9558F2826E82E6AC11EE03DFDBD7EF0691CB6D84154BC136EF30C4EF45ED129
75ED9E3B7798F1139CE732F3328EF899DD5928C077AD2FAE5700EC56F9B226B8
1B61C78CA16F9520484C67E1DDF93D9754144D17289F0F82C28E8C5B867003CF
47D248B270CF107E8F04BE0AF42738FADFCD4D72A14E5E58DE419A0EE0006961
D81C6CB1D05726380C216B10EE4FC5A0F7C58204EBBA6599EAA868FDD18966A0
A315F41EDEBF76CA5958F1D7923F0D105795CE1B4E3653AF383836967504BD07
608091D104F8B2E8113F018E0630F1F2D50A079B531CC78142C98E865D302C02
BA9A0A115C07869CD4E876562F8185B0AF954BDAD363B98363DFADA50A840D5C
CCEABD770009CE4C12D032A291E36315196327F6AC9265454217CBB3CE3F2CE4
BD43579F99D77CEFC0EA5EE97F171CAE946290EAB6F0734932CD6E0607639F3D
FBC3057D6D9E5E19EDC3908E2F94C53F431F7A02320B8A3425467B006F7D51BE
0B54DDFCF2EAB0E3CCE7CDE047E12C58A9F8C603B09EA28957209D4C82A43DB6
955CA29627A045BAB1C0FDF77208E43DC7A99CE58722D7C9376978F99CDBA2EE
DCEBBCEF455DD2BEC148655887CFC3379E27B9EEBFEB600A8B542E5B358F1B6B
618231CCCE690665604D1DFE84073574382E77A1C0C84E6F0A74957E6E535F20
7AC06BC39C0706F2BE09BA492ACC
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
%%EndFont 
%%BeginFont: Utopia-Italic
%!PS-AdobeFont-1.0: Utopia-Italic 001.001
%%CreationDate: Wed Oct 2 18:58:18 1991
%%VMusage: 34122 41014
%% Utopia is a registered trademark of Adobe Systems Incorporated.
11 dict begin
/FontInfo 10 dict dup begin
/version (001.001) readonly def
/Notice (Copyright (c) 1989, 1991 Adobe Systems Incorporated. All Rights Reserved.Utopia is a registered trademark of Adobe Systems Incorporated.) readonly def
/FullName (Utopia Italic) readonly def
/FamilyName (Utopia) readonly def
/Weight (Regular) readonly def
/ItalicAngle -13 def
/isFixedPitch false def
/UnderlinePosition -100 def
/UnderlineThickness 50 def
end readonly def
/FontName /Utopia-Italic def
/Encoding StandardEncoding def
/PaintType 0 def
/FontType 1 def
/FontMatrix [0.001 0 0 0.001 0 0] readonly def
/FontBBox{-166 -250 1205 890}readonly def
currentdict end
currentfile eexec
D9D66F633B846A989B9974B0179FC6CC445BC06347FF71900AC8FEAE3B716D52
C1AC4E5DCF4EFC3B9121F09CAB0C4BE35FD0740E08C853EF201BBFF011DE2163
790FADCD67A15500D3F87E2616B7DEEBFB3934B09CF7B8BE9B945D2638887F73
1C3214D790EBA3065BF944D77DD51978CB663398285895D774586FDDD6A7467E
B1BAC83EC766EDE0FF34D07C6E315D7B79B205EDE798A08FD0D9CD4A1307FDE8
7F57AE7A32759AAE66C77C6127F65D92BCCE74ED784372E34CC835BC789BDEA2
9E27574D388B2CEB1DB127C190624246F4991BA418137BEC72C8CF7830DCEA26
E13BC7F0CDDAE283F10C1FDCD1B46ED2C4BF3526E9DA8165ADF55799A329EB45
40E811F9140E5296B391A61903BC09B76E7BCF96FA1EA22ACBA9ED962E9BC596
BB22E4A514A5C551107BC74BACBFE55ABADEB1741C20BD80A186E49DD89CE033
CA0ACA0D0D4188B8A6FB40C265A88804443A7E912005A6BFD10EBB43315F7A9E
E8C24321131DDDAE6572BE67DE42C5969688AC1D7EB97887D783F63658AABEB1
FA4C2F625E6B6205D3EEC1C5E2FE8C29BD88FDF52802F3F5BACE6AA2007FC0FA
B6CE66673C1D698F51457AB1343CCCEC0D2FD0383BE98493902021E1A27B71A9
0BD0DC94B4C46825738C15B5E101C68813E1F8C8B19311648DF09363FCEF679C
E691E13CE96DDD1455A75181706F41EA2E0A6A4C870F7D3726547BAD35E0EE54
7F91EFEB803E93D1A9BA74A332EE4E56CDB48AC36A47B9B555997C7A58C3A16C
8D71BE01432D88B842B5D9ACAD19FFF7EC88B4E66036D2735311AA323BDD69D6
8CF32F9AA7781A2146E04D71C54044218DE26A4EFEAF67EFD04E4ADE1D7FE2DB
61A465957450E623CA58FC49FA2236C0BA3E81E9A9FA8909261A4A092AC9640C
08CB2AF3BC1E92E578086556ABF6A1F739582230AF46D4C184714197545BE932
1FE1F05FA46478BEB38010C2FAE84145D367FA53B10F42B7B7BA76B427210475
71E67A52D8EADC847639F0BE7F280F35EDBE34C7FFD9907E796F373015965E1C
FF36F43C653EA3F23B76FC2ECEF9EC19D5BC245369A690C280DAF9F3D8401A08
95D0FC1C3F0C033AE23062A80A3B8A944F642986A878A0284CEFB15CEDEA1347
503E912ABA4ACE8A95BCD78139D76D47338A12454E8EEF04C9C1D76EE6241223
CB549E4FB8EA5AF614080C521FA33ED6C5B3D01C6CB3A508CA54B9879760E3AB
70FBF4B6FBBD0D22303767870BBC148F162AEA0C7463D3E93301A1FE221A1097
75FC35F8A9EE809D91A3260DFED0D26D4820CEE6FCC32800B52FAA6ACA197C20
C86493E1CDFD279490276188EC0EB344E5D2C11E6053A3C9838538E8D490E67B
EA7A77D900709AC40652D0836E0A99B0CC21C1178718AF1AB3F843C5476E3F28
77F7E6509EFC968C1A61E3A5B412A7C21AB713BE68492F9316E816E4A1EBB873
A2BAC866DB19F0CF0362D32A57E5E911B5391C8D5513665633A36D20A9B9F3FE
B05E7F6A0CADC18E7635F141AB733A8599C94A0E2E15810AF7ED7C65A1323BA9
15C10F731D9B152E3217DB0EDF2A084E48162ABED4300CAE6B1D1503E232D5E8
EAF654E11E3ECA1B860FEC9D65A72254E20A8084D81A9A9BC7A19BAB5C24EFC8
C9A30593BEF14C816643443DE8E5A0ED740E2F54127E8A7797BF18900D500C4C
D18CB01EE268EB94F5F5BAACBB59F9CA0BC7FD7E452F1CE506264DE797E9568D
F576F5BBB786C196FEE1CB05A36BD543E555845FDD88F7F0CEA771794450CA54
3604E9C6B7DAB76C265EE3EC9771C14214146902336820F95B281A775C87B679
963A4CB614D511140375419BFADD9640A3005ED53136967509626BB2CB63542E
F1E7D545AF6ADBB674BC51830D3C63F9E69818D7AB8488D8C344654CD5B91CF4
1FA045451587F02FE4E5403E2EFA610E4B920460032FF71CD16FA03EE41D8E4F
23B71DE6C221F4BCACB39F4A584B933A0FBCB62B46EB851DBA2D895D9D351BF5
739DB03B6614FA4D477BB64332BA41E5B61A8115CF0DD55E9C0051138043054B
714A3AF816C5E0DF808A075EF3FBB29906CF1124A4E0DF06208281FEEDE8251D
FE4C56AD3BCA093B8670D02EF282C3AD477225866C7E44D4E1C72D6CD3ACA356
B4C9CDF8D31920899D52D5B75958E2843ADED5163BDB11717FE7446A0FCE728B
DEF3CCA5C368CB4049D69B9ABC11CC000962CF66987B20BF381D94A2DF316CBE
4C5F6434ADAB0958C607E7F42216440D949549315DD15D74761F38A615BC8007
72F15E98F91DF932DDED7BD32D33FA77D390ABD3FB4FE6BA8E8BC434AF4C9637
B2464CF8C3DB5FA0B27E7CE34A122055DBC4CDE04666356027644FE5B7CA424D
2450D625FE73C06054A38A5EB38EFD8067C4900E427295A254FEF9352A59A041
DCB1283ADC30DB82B18206BA8984959E1F80F904567EFCB1F3262D98E5397C79
645EE32785F06F68F45A87AD77420373BF14AA2F33B09F3627289EDECB023136
1D03BF91C5C213A951CE172A42579B4268F98A9D54B9F2AFB3B9D2B58A91DB55
ACAA88C5E5640AAB59DA1B39F06B94C76B462B0C1FB266DAA8559A5E2D642080
533686E07C885CA56EFE600C1725778C99A04E8283DC9CD1C81B97F52C029E80
80C2992CBBF2D3BE71C9771CB880E1C73D66DCB01FBDA0F71F4DF0A725C10A8C
4A87987FCF9508264937DDC1A13F7AD88FC8C73B78F1F05708A9F23F2C763735
96FD03E549F00F59BF602BB7E94DBFA07DFDECE92D3164A445804A23475AE5CC
6409D151712EC628DBE6D3D63A4208E827A9C0689A97BEAB0BDD7CE3D15A87D1
94E995D3321EFC589F4C9FAC50C40F772CFA2CD7977455CB374C463E05BC17AA
594BFFE78D628646F19EA66137C294A763353B56A1667E12B07C65D7A3AC11D7
6E7D13A6BA2BD79AE15C366B9580053E170CBDA9FF1FCDED21415DF29E5C800A
4BE346E55753145228592B9404CB511C1740E408D52ABC832CD22E6C0CEDB39B
CADCFDDEC74AA72AD9117A7251E4EF96AEFE87ED5F034EB3E50C086A48AD0AE9
89CAC7E93A298D8629B9DA09B7BDDDEC71DA87379ADB3697247465DAB3B3AD58
A64A7EDE97DB40ADF9BF6A01FCEF21C8A85807CD9FB7F4EA79A4FA7E464B288F
4E357567483BE56C115F78C66D154289775711FD6B227B4AD3899981FC284F21
B29864E25F128ED3E300019C29BF5D63B3F886BE3D0060F7877DBB01DE96C797
33A7C25E1ACF22A8AC8BC0CFDB3AC2A846C7C441801EA775F787F360FEDD2623
381B55D3E3B7C208155167687F288458EF44094361671FBCB6978D0373A62E80
9EC639C5FA4C656EEA8A476F27A11A44B88C6D36B9B29938D592AE68560CEA1F
17BD5804FB48E2EAB9CE383B7C5DD3601DF743E6A30FE67FB424B30517B787EA
B33A3D99F7EB318A827C2455060A8B7D9F3DF7A42DCC7A6AC0D3B59376A783FC
932723D090FCCF6D6AD3D7626C815C96ADF3328894170336AF06A06E4D4EAF26
03F2816FC35BAA6A016806561B8B817FB726ECB9505606DEDD149C2FFE360443
196FC3AC5A0F31A7A69B4DF404F9BFF91D9D898C2112E57A905AB33F862B50B4
84F5CF44D3276A699F0080549FBEAEF5266C9D7697D1A37550B239E8E03BB332
67804C0E12B52CFF2855B262475A394526697146787A65B7CC2838D459DDE4F7
FC3990EDD9AF54F2A08D4211E9807848162327AAD1781C2F7D2BCC49A0640C3F
953BB493A168E4BB97194637FA076C7C3047DC79D429F332BB2B96525190CA68
D573AE2E597FC6F6EEF3C85EA64D0A0F1449D3E0C5802CD3D730F0AA1EEE0E3E
1E91394F7262127896C6BD13559E917EEB82E0C305033FFB21FD4553ADA546F8
EEB0DD8710F6B7E81E85279742380EE8DF0014B81829312A10DA410D4163A220
49428812234F3A7E73E9B60B295EF28667593C84AC956C6B588703FCD4DEF3DC
97A4EC40CDE174513BBF688CEEBE7DE00AC57C8E903021EF5E341FE631A9252E
EA258E096AFE70E80E36ACB5A26FC5AB99A7BA6240BA2099F86694C6EF16ACA3
F4FAC768807EB0971DF92A6EAA407F880B655188F228A32D238BEA91EF4AB201
40B910D2342C13A68A51424BFA9567D44CF677169D7286470B2D2435D0FA3388
52F0FB5D6F5145C5D18DB0448E38EDEE4C99357F45013E3BC0C8019FDA86FF7F
AB3D80A74DD371CBFDADD69B70EAF5D173E95CD7826754D24575C2E872B464F8
5D970F48BBE05EF9F3644BF261AC5557A602E9F3D03481D718F43F1A325AA977
6B01468C96730BFD3AA68BE86A071CEE8AC85E4D8C212487DB9B912FECC14506
F7B86496FCC802402D904B71BE1E3C82E052415FAEEDEA7AA4C08E327ED027B8
2C21C593C2475A17FE87D6136DC7A27C5A51513DF56A762C1A267CF8EE45482C
C6D0C1FA50290A4953D578D01878C314A6C529D9EAB7CB510007B115A10547AD
1E2B4F577239843C7A48C88FF651A5008A5CA90923D36B31583A21AE892CEC51
E6312F4FF2D03DEA8AE7515C103CEEBE1D10B9E35E31A379EC8CEB253887FE85
0F28C2C1364F50EEACB407056E03DA4AE6A7E9B84BB557C31F53FD248AACC1D2
39AD1AB2CAC1ACA70D25766949D3616A7D7772C11406E63B7A8395F625881F7B
855EB546DD22E4E7B7A470706DAD0FEFCF8388F80B0C2D370052D99AE2935F81
AE1AE673AEFBAB1B81CDBBE480F77455387FF62516C1FDF11EC8385B0DD8DDAD
33982999F24CAD87FF91AF084A8D82C5E27C88BA1C774F96B668A0539A7CCC8C
A2635DD7C68D33D662DAE00DB6142573FC98C140F437DAE50160FAF0FEA64230
1B1B17F37F02168BE1020ADF5271790B899F9846C53E338163F9637ABC87A1AD
2EADACC64E36B786187031FD31AFD6F672CA3E85C67806FEB29D9652FFD7F213
2C6836FB4DDAE119E0CFDE12AF9ED23B6D2498717340724BC6282813505A3420
750F7BAB3DC30C0E964B04D635FF06345108910A5DE1AF58CAF1B2432FC8030D
476935CC338FDC7107A17454A4B4119BDD6B39E62BBA99FDEC7E09901B75D1AE
ADA050F5F28207671D7AFCE3E143672B580A76C34590309DB8E9EE69C2543701
144ABDF4136154C6D639CEB6F892AD5EC136764ADE01A1FE6FD901F6DACD88AD
99A2848F6E1DEC6633245EC6F1CF349C23BBAEE305AFA3C915E9733EC2613294
4A99320F6DC3A0DBEA41F63C43338F5F95A83E0776B7320CB5D2226F3F70FBAE
2C17A7CD431BB67ECCDBC90E18F783B575909F63082625AF6F4FCC08204980C3
09EE1925987F2D63018DB158A5EF039C8EC2FB1B63D184BB6986CFB32B816B08
D28EB2D6CF6BBFE584D8CB7B1A9C9B87C1B2416306A4DAE94854900604490F63
F287B8AA80E1EE8040D6B50F7F393A62B18B3FE2953465E8717C6BF111E66FC6
7EF66017F7187FFA281F6F4B4A86855063934C57240DF8F67B12B9E87A57BF96
D6E7F5A31866735EB19B1D690E0261F99247C04B5602F5AC48A6AC5F13A0E81A
40097EF75602A24EF55CA0E776E107548BA0551C93FBD68E47B39D597D0E93CD
1A1490784231EA6CC08DFD08CA2F1AA4C3597C6064099C2134B46322F7D9C991
4D5E90A767C21C4F8026D143EFC02ED8BD1AC2B96AB6B0BC37A237CB438A90EE
9BDDB4707F7B2CB0366A3C531F1CECE34D3AD3C00456908D00199B1D1F70C589
B66EEDD50D77DC8B7962C7065959E797BC3C0265D82C9C1870786514AE926C86
F2C563C52C7A1061AC84461E2C304FE949C88E75570DC876A06C08D11140AE66
D2038048E1672945A22893BAD39B99FEF5CEF5B4636A092BBCCE746311191E6D
BAD7D7931CD41A199C0540918C423894772473365C39F4F5C39DF384C9B2E9E9
B02718F8B388CD74EA7913344913FF04137C706B0CC0594F38666C04257A52FD
FFE8A2ABA03204A5D5FB63E2DA10DBDA6B00149B2EBDCB7F954CE4EDD9144793
AA8A51537E856D9729BAFB508171CF4136782135AD855B2DEAD016259387A291
71C53EAB7079FE2C27A1156D8117269B06CE8816AA5C60503F4DD682DCBC9FA5
E2B7BF4CF375C71B56B74D876A7ADCC2A73404ED483ECEFF71015C675257F65B
680EDE50AF9CFBC1927EC79174F5DF3E23DD994111A1E886DD01B10C294F251B
63D63202142E5939F7FBD5EF880C3BB93408A9673A266A92070292F29ACAC9E3
A94461DDCC6AD812F7ACA40FB9F315354852A9E33D2472F41110CB02E02E8F54
83BFD76EB96A6754C18AD8E48FFE92F26FEAEFF237C87BC644ADBC404D407A61
5FF8E547CFEDDEE9FFE5B3708A5F3190AD0D6A291F1BCB58B87ECB47D332E1EC
792DCE3CDD9131A694717442D5FB7A55A92D21A732A3C0D17ED355DB2C812ED8
BFA0AE8260E2314C6426D14B6D6CAD6F0F434CACC51EF77879A07A0E468A39D9
CF7BF40992AB476E5FB6FFFC5B17C0E5AB69FFC184DC0454EC85DA80EED3E72D
803879CDCFDD329DB77A88E49E0C7C69B2FCA8B9FA761422D7F6B00718499445
65FCFA0EC338B03E485F9E76EFE6A15D906E10A388D2404EFAAF8BE15144694C
04BAA5591FE1DECD1E4F9D187666E9D9BD19DE0CFCFC70378F14C1A85988F4B8
BCA7E7802EC666A13D951EE81BAE2428B464D0954FADBF202718B9E449F1E32B
00231C24AF6B13AA2DBE1D96D9F2E76DCB30A352F141B900026BF8DD2459F4FA
21FDF0DC77CA484F3D198B275CB03D69456FACD2D960F20A6F51493F93FE87AC
239CC1518E2AA15C483A7EF38F9CEC2C82D2E717A506A42D7389A5CB63CCDAC7
19BDB54D6148B60BCC727F95104BD638AFE367C4D548C25F5724CA6B3611F7BD
528445BE15F1AD747A6B386466E5133763A31172C84952F9251E3D4C5999D9EE
C967EB4A062917CF1B3F637B66B671B72B90A3F63EEF5726CCFC7EB064FA0A09
51AF9054EBD75A24F253AE76ED68CE8954EAA105F827FDB5338ED7125F77E281
FF269C7CD93331FF3003541A3AF71B2CBAA48C2A1EA402400A25A680F3356FF0
5D3926FD7A989A3BD8FE0C4D073414332B622EB79AA023A7C4DC99234AA8AF98
5A3B29BE85D1DF560E07090A1576E5ECC2ABC3DA2BA5A84706696878E08B9597
7A9FD29C5C3DA5F9D1A2030FA717CCEC0D2F8C41AD3D05EC7FBE23E396AF3355
F900B9940DC6832B188A69CC02A1D4F78540427039372ED22C944CF66C930F00
44985ABD6D01915A184EF265A031282BFAE32BB0F952DA93232AF1C02B1E1AFC
564DCEF51473A037050CC252C6F2F2A59249A4ED1726DBAB2BFB7CE4EEFC7994
56C98F9608E52F06734E1E65B374C48561F8D07FAA68A887F6E213E8B7FBA1C4
47A40084861ABB860C1527F95DCD176281C69B748067DF9ADFAE7362ED6329DC
F0ADADCBF77272CB757A3E5FD42AFA2D7D2B653878DE992133B5B6017B0E3A02
996C15700D8D60F1B84CF1ADAEE6F1BE238B28CA18B3E5E929B1D801A8E04BF7
72BBA4BAC2FB745BD36C91B34553F117C0508C3820E1613A6CE706DB904B2DA7
C5F38BB099A90AA17AD20C60BED2DD1BC98172D7D2565B25C9D900BDD9AF3542
4D3FB3D3EA12EE6370E093DC61E106D8768C7E435E17A6D6AFDF832B7F36AA67
E42ADD4EBEB5DFF1ED55052F79B8FC23A4D4209ED49D597F4A756905C11D1665
C7CD5562F3FDD502B5622919C9C72A93E959DEE755DBD314B20F92276E565521
4FF23E77374C15DBD178C0D0DD1901FB65008C02ADD526477F40B8CF21C7535A
7E5C6F41AA4F2768C2988B90AC8CD7D2B01A9238DDC172B3EF41E45F7F61CC55
FC0E4E7437D9AE5D06BC917B840F30789E58198535EE91FBDF5C784B9F4DACA2
371F0ADDEA7A46AE14E612FBE839EBEFF3550A06EE6C0F733B312E0315E7E139
5AFF438365C3842528BF3209DA0DC5F800DA7293E6657C1E4D3BD913CCA55772
AF93680A2C71EEBF9EEE1E32306A3110AF1695F0EF665B906D6FE6BF97BC5954
48C01FCB02786BE8A446B245F47CD6599AF701C6F9F47337DAB2E7907229C1CC
F68177BA68FB0D4438E8EB55E2B63149512E7D7086371BD17F67C4CC7442BD03
6ADF9993888C0CD5DECDD2FAC3A1CB71BC1CFBD3A47E8E634BA4A9DD44D88E29
195BD05545B04A55A8E6155201DCDEBE9637FC8BD3E97F899CAA8CCD61D12AF9
7EC75B289FDE9B405E97EDA7F1A25BB7E76F241FB2138533B46ECB6460A281A8
3D128B7FEF549FD1B85A72B552E19DA041CA771677AFFA0AD9DA6CACBF81512D
E7097570DC6BD22ABCD07180A8849721E70FCD0E8BDB7DE18B9A1E9FE0D796AA
4A74877AB52380E940882556AF84FF7538DC0F88230A116296B8822859820EF0
41145D24CE3B8037ACBDAFBF843352364E71310604E2B7F8074C8E860FE100A0
12CE9760152204F2C059649AB4520DD6104F7801FCD5B367227DCB2EEF7F9CE2
D1861E6F65132FB9C2DFCE777B796FAC4E0C555571DD7106BCFB1FCFB2F96FD4
0D8CEFA73EF2AAEA385C1811F240BB7390D7AC278FB9B8E12EEB2F3726FE5F23
D28A6201A92B2B059D79E572DCE4593ED8F26C8913042F79E7688002CF330146
F527C15BCD1E51A5DB39C4E969E6C988D4CDC749F64D137112DBF6CDF550A5B3
52646F1755393491165E0FD2E3D266F23B16ACA6D225C3AE77028087DC1CA2B5
8074773209A2B9E4FBE99E3E3F33966C88C8B16C274D81DBD3AEA3213C04275C
60FFEB2A1C9A41078FDB6C1C5A80A3139ECC56B9807509A2ACA73353748A2478
F0CBC596AA5AFC07CCE9CC1E440B26B3EF75AB951D7437FD1180626BE72180DE
DB9CFC98C33F37E0080D8B12B256913E51205404B85F46723D4B856D8709ED7D
F6AAD0A5B019AE9D790ADFC839F37B2F668A6D2D3E002F30135A03DA486A6DA3
99622A65C07D4FBCBBBD0BD6FB2632997A2C32D8AADE8AD171268B38732E83AF
2E7CD81AEC947E562AE2D639FC5B137FFA1FF16CF5F460C5467E337496EB8E64
885E305FB06C893007C1471F59C8EF9FFE382FA91478D7EDC6EBCD2AF0E7CA4B
0B8145DCE37760AE698E50BA40F4B9E6455253D6347C27783E0EA9331F16AFA9
EB41B47AC6F6A01E8F20B87775CEF5B903E169D9F0819DF9554C1930B248ADC9
438B0B46A283EE09BBD61FF65A82401F255748AC91E527260337F6BE5F34FDC1
6734B024B2778D7D132EE9CCACF1BAAFA2320FEFD72B3D0D16E9D6F78DA3AF91
6D2694CAB80AFEE37A4119FB6F71300BBACD744F573703E58E3D4CFBB67294BF
840AFE537D10C1CA04279C3DBD5CCA6D737976FB879005788A5B02B0876B05FF
B9324B165539944EDBDE40B8532A91218119C663985C88C2CC97274C6E5C562E
643F42D81EF6EAF9B9BBF19FC748664D0DF3DA8274590B3DD20DAE542F83EDD8
58EF57F9251FA9B46D55451033CEEAB4C26E0E782B0347B8613BCDCBCC845E0B
9CBB39B011705F372F6BA8AB1704B75AF3C6DD2E488A3F223DA6E0BAE2DC59A6
4B9A8A99F13E8E3C68DF31124075CEF134845C1C6ACFCFCD20E316FB1049C3C9
4D1FDA5CD85C0BC7E0F7819110E6FEDED3D4FC762880B58EAA1239CFEA92B161
2C93B39CA0EC149530E0A6BD4B0B7CCEB6C94093D442FCC40EA91D7552FB9F92
5B15B116114334B4587DC49759734D8F2C3F14B42E6CE764710D5A18C430D823
C0D02DCD20ACD00A2049924A4FF460F4C78E76B39CA2C53DE6D7CBD846886EF1
FDFDCB41A5F16158B384C50C1A25745B99FF2A8AAF47133EE33A97176088011D
844407E073A5E4D9C69292796CEAB8DBADB8285609EC2E6FA0B479470A2C8FCB
78BE1E61152547BEBB470582CA2CFF479CD42C08B09A786718CCB9E60C45C5BC
6D811086BD1C9C8F5231EFF7AD6BB8A6EA43246C75C163DE15C666FC35C45610
C9B6D345482550B6A528591EF322A79D86B85F405C931D4E9A16DBDB861B8DA4
D9C9ACE7AB3E0E2D4F355357DEBA8CB89756E1BF3B0E54BE1646896F47313008
F064E4969A133789BDC0714CF6A0CFA08D6CD724D33850DB237D0E6DFD31CE5C
E7DD7C645161BC58263EC51545C868EFD492758723120100EBC372FA938A8960
410C68A8F8286A93A160C80B229984B5A71663B8B06479B4C390D8A62E19B631
C784DECC1A9C16C16605F166CD48F80B0D4E666F59281BEE87B1BC100B05D19D
49478C5A8B6C54FFADC53E04338CF41FF3AB4BAB2914514DAA2B9120A36E398C
83E1DE18E8B15DC7EAE62416D0D3A21CF71D1A6DD4A7D875D08E57DD928042A9
55D68A53069962CD137D86C3665FFFDB790D02CA7E173E513BD9AFAF88FEC8BC
584A6FD3303189FBB2092EAF5F5E73E3AAB8445069CF60C5F01079E5CA266DD6
FC539FA7609E763295FC92A53AEA31BF31E331AFDEFDE65E02A9B083D7D26281
2F0495FC898F22ECF1B999219FB9F412831915925DBB3F6895C5DA9EC4F34A90
311E65E6B31A74DB8E89EDB70D927B84BD249B9E520CEEF7DAA362747A7ABB81
D4BFCF8453386A0DCB8D0CF788A0F551EF84312EE6952ACF0B77A4AE07AFA442
3177A9CD0A9C4133E11170FC0EC032AED2902073A5FBF9F5834F6FEBFD65FBF0
934765641CCC530C796555994F54C3C420B230CA49FC058275A863EBFFED2F57
28D8C696E180904792FA416C0AD7D6ABB4C4E94B5A824858998E0D5866174740
839E9FF40CE841FF305ABE69C6447542F65B42DB0AFA84D519AAE30009258010
511F8767D8ED7A01FFCBF033A71F812A2451DD23803038663AEF3ABB186893B9
555BF3362241A2AEB1DE5FBABBC4BE4D042DBFB11D2EEAD0C34F6D9E86917785
25BEE7E980B2C430E7ECC1897FA5B2BD6FDFB38BE88C5D8327815B85FEAC2796
F8F476030C01C6D753284B57EF7E58F7B02743BA6BFDF69BCD688348E082ECC0
1A0DF12F8A41F797C273AC40B5DF6DB27C986B82D1F5F8F83B3B3BF3AF51455B
476CE9C69240725B84F0E3912F0F6E6C7F7A2A258236B10FAF06FF03EAEFA8BD
89D5720185846B15647ED6C5EE5714245B97FD00EC344D5E1CC791748AA7E65C
825C78C9C864E22D5DE7DB950F38798D568CB20B986F4661B9EC5A438A2E00C2
E03FA054E79F14D95371DE9A1C4D7638F4CE6A8EC279E6FF817FBE22F8195BB2
63D0FCF3135BE7D6C6BCC0D2A250570293D5FA8AD4FFAF85013B5C542094E9AA
0BD388AF18619A92DFA740AFDFDFE2E7C1A98D30F85D2BDF068FC4679E9EEA77
4EF4D5FBC8031BB14D7743D9743EA1285E1DEE8764FF1822562B017191B363F9
9E40C5CB60B711CB20EDDF233229D7D638CE4CE1D9FB301B2DD9B8F01FE8DAC2
3D6366E798CDEF8BD9F3DBA16D9452129BD2EE07556CBE5A90898A2C8A3F5556
89C473848C07DA61797AF521C06B9C953786E1FD8100B17CF4B79077E60BBF8E
F47E09F7D3D2DED749E8700C7C21723D3785F01077572B7FB2E6E02BA2398BF6
E747FE74C8CB887DD2708DFC10CC50B9BF382CB9A08F5C023C7C9FD4AAC76491
93843D5BDE75F932A3990180DABFAD5FE48F59AAC8AAD437639E26F1AC160106
F0BC37CA239C077A3C99621D36E660EEF434E5E1DE877FE10F64FCBE15DEB7E0
C94CAF9E0477CEB2F38EA0D70AFE3B6468AA01991FA723C5F229A5E696575F24
0FAC5E8807FDC9765F40D1A093ACFFFA73FEB72F415F7452F92602D95B9E56CD
1A08F628F6978FC3EB06C4AA230DBAC8CA9B20B3E47EEF53A23FF0284FB2C2F1
47140AC48B22EF9CE0DC02BBBC81D7C21FFF383781EB3707429558C6AD317F78
E19A81DA0D93D081DB07E4B50F3B2D61233FCDEBB2918B9493EB3DAC7D62D092
E4C2476717C69595485CE83DD36E58B2A10AC955F9B504269E3B61A25C0272C7
D475E97498231721AA2526C352765C2A369760C80B1EB4D0C19AE5074B66BC3E
69BC8F88892E4E293B4DD50768B563FCA7F5BF3CFE8EB4E8755777C731F81457
091DCF77BEA31A6026A9B1641EDD2C434F6A5852008405820D60624118E4F06E
C150A9757AB9BD29D52E159FD3D9F87A669570E9D8F30C72FF6864BEBA2D061F
0A6A5D9A56FC49F32A1A155750EBE4FC0E633A5A98A43AB2F8053E008607A184
13B952B637DAE2D3D55CD48A2B2B0BE0300E376F08B0CA56233D1FDF4026AF86
D1C560CE9776CC9238FC748FCDADAAA2E6A7F26A9EC31D398864F679B02DE3E2
CAFC0D836880B0949188E24F6D3E7F5AF2739A941A61607A24556AAC5FBD1CBC
8ABB760490B259D576E9F20595821B83285821B451468707D49D48C231196E41
B71E4A2FB836363C0E47D7757A3C584035925CE35F534F65EEB8533D74EAB85B
4BAAD387EC166599EC7A582B119B5CE444D3D4F850CD49E7B8B8124ADBDD3EF3
8FCE7D1C60E1D319AAFF313EDAB83D3C7980B21CC161BCFB7025B28D5E73189F
4CD14EA61BA6CF53C32DACCF7663C05482F55C4F8AD1A7B1837474E715D70C3A
B17354FAF32D48543B886310188989B50BB4633D527D1E395B9A05CF921A2613
B998F70CE5FEBD4D0F9CD1964BFB9B4BAB0E71BA43662ADC4572B8C383C1D7DB
53F0D5026CCBA3CC0047C676D98BA7CE5F52403E3A376879E10E15CEED592596
9B0A9F9A0EAC101E350C3B9A036E0830998185E5FF15CD2E4093B37E26941D73
46118135323FAABCD01D3C5E6684E4970426904B7528E8FE8CCF5A3B5FFDA7C0
8BBF81E1A9DA29D3A15C5008FC59DC03922FE2FB220F4F1F9DE9D90E8E98E2A8
CE6805A198229866DFBFAAED538A2F8958055E2D228FE1F6A67DD6D12C163EBF
2D1A1A7B33A46396F550B0E1B4E7DFB2CCBCC20F890167383E5685F1A20D36EF
5AF5D1224F64F7C3EB1E9141FB
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
%%EndFont 
TeXDict begin 39158274 55380987 1000 600 600 (ex12p91.dvi)
@start /Fa 145[37 8[31 36 100[{ TeXBase1Encoding ReEncodeFont }3
59.5759 /Utopia-Regular rf /Fb 187[54 47 44 44 65[{
 TeXBase1Encoding ReEncodeFont }4 68.7422 /Utopia-Regular
rf /Fd 204[51 51 51 2[26 46[{ TeXBase1Encoding ReEncodeFont }4
91.6562 /Utopia-Bold rf /Fe 57[66 66 33[66 1[66 106[0
9[92 44[{}6 91.6562 /Fourier-Math-Symbols rf /Ff 134[43
47 7[54 2[84 109[{ TeXBase1Encoding ReEncodeFont }4 91.6562
/Utopia-Italic rf /Fh 22[47 47 7[48 102[46 2[46 56 32
40 36 54 56 53 57 85 26 2[27 1[48 1[47 55 45 55 48 16[55
70 2[52 1[32 32 4[71 63 59 58 5[24 2[49 49 49 49 49 49
49 49 49 42 24 36 24 2[32 32 25 36[56 2[{
 TeXBase1Encoding ReEncodeFont }49 91.6562 /Utopia-Regular
rf /Fi 135[57 5[48 1[68 6[35 3[57 1[54 29[69 10[31 62
6[62 62 49[{ TeXBase1Encoding ReEncodeFont }11 109.987
/Utopia-Bold rf end
%%EndProlog
%%BeginSetup
%%Feature: *Resolution 600dpi
TeXDict begin
%%PaperSize: A4
 end
%%EndSetup
%%Page: 1 1
TeXDict begin 1 0 bop 0 0 a
SDict begin [/Producer (dvips + Distiller)/Title ()/Subject ()/Creator
(LaTeX with hyperref package)/Author ()/Keywords () /DOCINFO pdfmark
end
 0 0 a 0 0 a
SDict begin /product where{pop product(Distiller)search{pop pop pop
version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
grestore}if}{pop}ifelse}{pop}ifelse}if end
 0 0 a 0 TeXcolorgray
-8 -481 a
SDict begin H.S end
 -8 -481 a -8 -481 a
SDict begin H.R end
 -8 -481 a -8 -481 a
SDict begin [/View [/XYZ H.V]/Dest (page.1) cvn /DEST pdfmark end
 -8
-481 a Black 0 TeXcolorgray Black 0 TeXcolorgray 0 -189
a
tx@Dict begin  gsave STV CP T /ps@rot 0 def grestore  end
 0 -189 a 0 -189 a
tx@Dict begin  gsave STV CP T /ps@refangle 0.  def grestore  end
 0 -189 a 0 -189 a
tx@Dict begin  gsave STV CP T /ps@rot 0 def grestore  end
 0 -189 a 0 -189
a
SDict begin [/PageMode /UseOutlines/Page 1/View [/Fit] /DOCVIEW pdfmark
end
 0 -189 a 0 -189 a
SDict begin [ {Catalog}<<>> /PUT pdfmark end
 0 -189 a 0 -189 a
SDict begin H.S end
 0 -189 a 0 -189
a
SDict begin 14.5 H.A end
 0 -189 a 0 -189 a
SDict begin [/View [/XYZ H.V]/Dest (Doc-Start) cvn /DEST pdfmark end
 0 -189 a 100 x Fi(Ex)o(er)n(cice)24
b(12)e(p)h(91)f(:)0 105 y Fh(On)e(a)g(les)g(points)i(A)703
106 y(\()735 105 y(1)12 b(;)19 b(3)888 106 y(\))940 105
y(et)i(B)1109 106 y(\()1141 105 y Fe(\241)p Fh(1)12 b(;)19
b(7)1360 106 y(\))1413 105 y(dans)g(le)i(r)n(ep\350r)n(e)2011
106 y(\()2043 105 y(O)12 b(;)20 b(I,J)2259 106 y(\))2292
105 y(.)p 0 TeXcolorgray 0 TeXcolorgray 1528 1854 a

 1528
1854 a 1528 1854 a


 pgfo

 save

 0 setgray

 0.3985 pgfw

 save

 1 setlinecap

 1 setlinejoin

 save

 0.75 setgray

 -68.0326 -68.0326 moveto

 -68.0326 -68.03256 moveto

 192.75903 -68.03256 lineto

 -68.0326 -56.6938 moveto

 192.75903 -56.6938 lineto

 -68.0326 -45.35504 moveto

 192.75903 -45.35504 lineto

 -68.0326 -34.01628 moveto

 192.75903 -34.01628 lineto

 -68.0326 -22.67752 moveto

 192.75903 -22.67752 lineto

 -68.0326 -11.33876 moveto

 192.75903 -11.33876 lineto

 -68.0326 0.0 moveto

 192.75903 0.0 lineto

 -68.0326 11.33876 moveto

 192.75903 11.33876 lineto

 -68.0326 22.67752 moveto

 192.75903 22.67752 lineto

 -68.0326 34.01628 moveto

 192.75903 34.01628 lineto

 -68.0326 45.35504 moveto

 192.75903 45.35504 lineto

 -68.0326 56.6938 moveto

 192.75903 56.6938 lineto

 -68.0326 68.03256 moveto

 192.75903 68.03256 lineto

 -68.0326 79.37132 moveto

 192.75903 79.37132 lineto

 -68.0326 90.71008 moveto

 192.75903 90.71008 lineto

 -68.0326 102.04884 moveto

 192.75903 102.04884 lineto

 -68.0326 113.3876 moveto

 192.75903 113.3876 lineto

 -68.0326 124.72636 moveto

 192.75903 124.72636 lineto

 -68.0326 136.06512 moveto

 192.75903 136.06512 lineto

 -68.0326 147.40388 moveto

 192.75903 147.40388 lineto

 -68.0326 158.74265 moveto

 192.75903 158.74265 lineto

 -68.0326 170.0814 moveto

 192.75903 170.0814 lineto

 -68.0326 181.42017 moveto

 192.75903 181.42017 lineto

 -68.0326 192.75893 moveto

 192.75903 192.75893 lineto

 -68.03256 -68.0326 moveto

 -68.03256 192.75903 lineto

 -56.6938 -68.0326 moveto

 -56.6938 192.75903 lineto

 -45.35504 -68.0326 moveto

 -45.35504 192.75903 lineto

 -34.01628 -68.0326 moveto

 -34.01628 192.75903 lineto

 -22.67752 -68.0326 moveto

 -22.67752 192.75903 lineto

 -11.33876 -68.0326 moveto

 -11.33876 192.75903 lineto

 0.0 -68.0326 moveto

 0.0 192.75903 lineto

 11.33876 -68.0326 moveto

 11.33876 192.75903 lineto

 22.67752 -68.0326 moveto

 22.67752 192.75903 lineto

 34.01628 -68.0326 moveto

 34.01628 192.75903 lineto

 45.35504 -68.0326 moveto

 45.35504 192.75903 lineto

 56.6938 -68.0326 moveto

 56.6938 192.75903 lineto

 68.03256 -68.0326 moveto

 68.03256 192.75903 lineto

 79.37132 -68.0326 moveto

 79.37132 192.75903 lineto

 90.71008 -68.0326 moveto

 90.71008 192.75903 lineto

 102.04884 -68.0326 moveto

 102.04884 192.75903 lineto

 113.3876 -68.0326 moveto

 113.3876 192.75903 lineto

 124.72636 -68.0326 moveto

 124.72636 192.75903 lineto

 136.06512 -68.0326 moveto

 136.06512 192.75903 lineto

 147.40388 -68.0326 moveto

 147.40388 192.75903 lineto

 158.74265 -68.0326 moveto

 158.74265 192.75903 lineto

 170.0814 -68.0326 moveto

 170.0814 192.75903 lineto

 181.42017 -68.0326 moveto

 181.42017 192.75903 lineto

 192.75893 -68.0326 moveto

 192.75893 192.75903 lineto

 pgfstr

 restore

 save

 0.5 setgray

 -68.0326 -68.0326 moveto

 -68.0326 -68.0326 moveto

 192.75903 -68.0326 lineto

 -68.0326 -45.35506 moveto

 192.75903 -45.35506 lineto

 -68.0326 -22.67752 moveto

 192.75903 -22.67752 lineto

 -68.0326 0.0 moveto

 192.75903 0.0 lineto

 -68.0326 22.67752 moveto

 192.75903 22.67752 lineto

 -68.0326 45.35506 moveto

 192.75903 45.35506 lineto

 -68.0326 68.0326 moveto

 192.75903 68.0326 lineto

 -68.0326 90.71013 moveto

 192.75903 90.71013 lineto

 -68.0326 113.38766 moveto

 192.75903 113.38766 lineto

 -68.0326 136.0652 moveto

 192.75903 136.0652 lineto

 -68.0326 158.74274 moveto

 192.75903 158.74274 lineto

 -68.0326 181.42027 moveto

 192.75903 181.42027 lineto

 -68.0326 -68.0326 moveto

 -68.0326 192.75903 lineto

 -45.35506 -68.0326 moveto

 -45.35506 192.75903 lineto

 -22.67752 -68.0326 moveto

 -22.67752 192.75903 lineto

 0.0 -68.0326 moveto

 0.0 192.75903 lineto

 22.67752 -68.0326 moveto

 22.67752 192.75903 lineto

 45.35506 -68.0326 moveto

 45.35506 192.75903 lineto

 68.0326 -68.0326 moveto

 68.0326 192.75903 lineto

 90.71013 -68.0326 moveto

 90.71013 192.75903 lineto

 113.38766 -68.0326 moveto

 113.38766 192.75903 lineto

 136.0652 -68.0326 moveto

 136.0652 192.75903 lineto

 158.74274 -68.0326 moveto

 158.74274 192.75903 lineto

 181.42027 -68.0326 moveto

 181.42027 192.75903 lineto

 pgfstr

 restore

 save

 1.49442 pgfw

 0 0 1 setrgbcolor

 -68.0326 0.0 moveto

 189.12263 0.0 lineto

 pgfstr

 save

 [1.0 0.0 0.0 1.0 189.12263 0.0 ] concat

 save 3.63638 0.0 moveto -2.18182 2.9091 lineto 0.0 0.0 lineto -2.18182
-2.9091 lineto pgffill restore

 restore

 restore

 save

 0 setgray

 -68.0326 1.59404 moveto

 -68.0326 -1.59404 lineto

 pgfstr

 save

 save

 [1.0 0.0 0.0 1.0 -74.90688 -12.66429 ] concat

 pgfs



 0 setgray
 1528 1854 a Fe(\241)p Fh(3)1528 1854
y


 pgfr

 restore

 restore

 restore

 save

 0 setgray

 -45.35506 1.59404 moveto

 -45.35506 -1.59404 lineto

 pgfstr

 save

 save

 [1.0 0.0 0.0 1.0 -52.22934 -12.66429 ] concat

 pgfs



 0 setgray
 1528 1854 a Fe(\241)p Fh(2)1528 1854 y


 pgfr

 restore

 restore

 restore

 save

 0 setgray

 -22.67752 1.59404 moveto

 -22.67752 -1.59404 lineto

 pgfstr

 save

 save

 [1.0 0.0 0.0 1.0 -29.5518 -12.66429 ] concat

 pgfs



 0 setgray
 1528 1854 a
Fe(\241)p Fh(1)1528 1854 y


 pgfr

 restore

 restore

 restore

 save

 0 setgray

 0.0 1.59404 moveto

 0.0 -1.59404 lineto

 pgfstr

 save

 save

 [1.0 0.0 0.0 1.0 -2.91708 -12.66429 ] concat

 pgfs



 0 setgray
 1528 1854 a Fh(0)1528 1854
y


 pgfr

 restore

 restore

 restore

 save

 0 setgray

 22.67752 1.59404 moveto

 22.67752 -1.59404 lineto

 pgfstr

 save

 save

 [1.0 0.0 0.0 1.0 19.76042 -12.66429 ] concat

 pgfs



 0 setgray
 1528 1854 a Fh(1)1528 1854 y


 pgfr

 restore

 restore

 restore

 save

 0 setgray

 45.35506 1.59404 moveto

 45.35506 -1.59404 lineto

 pgfstr

 save

 save

 [1.0 0.0 0.0 1.0 42.43796 -12.66429 ] concat

 pgfs



 0 setgray
 1528 1854 a Fh(2)1528
1854 y


 pgfr

 restore

 restore

 restore

 save

 0 setgray

 68.0326 1.59404 moveto

 68.0326 -1.59404 lineto

 pgfstr

 save

 save

 [1.0 0.0 0.0 1.0 65.1155 -12.66429 ] concat

 pgfs



 0 setgray
 1528 1854 a Fh(3)1528 1854 y


 pgfr

 restore

 restore

 restore

 save

 0 setgray

 90.71013 1.59404 moveto

 90.71013 -1.59404 lineto

 pgfstr

 save

 save

 [1.0 0.0 0.0 1.0 87.79303 -12.66429 ] concat

 pgfs



 0 setgray
 1528 1854 a Fh(4)1528
1854 y


 pgfr

 restore

 restore

 restore

 save

 0 setgray

 113.38766 1.59404 moveto

 113.38766 -1.59404 lineto

 pgfstr

 save

 save

 [1.0 0.0 0.0 1.0 110.47057 -12.66429 ] concat

 pgfs



 0 setgray
 1528 1854 a Fh(5)1528 1854 y


 pgfr

 restore

 restore

 restore

 save

 0 setgray

 136.0652 1.59404 moveto

 136.0652 -1.59404 lineto

 pgfstr

 save

 save

 [1.0 0.0 0.0 1.0 133.1481 -12.66429 ] concat

 pgfs



 0 setgray
 1528 1854 a Fh(6)1528
1854 y


 pgfr

 restore

 restore

 restore

 save

 0 setgray

 158.74274 1.59404 moveto

 158.74274 -1.59404 lineto

 pgfstr

 save

 save

 [1.0 0.0 0.0 1.0 155.82564 -12.66429 ] concat

 pgfs



 0 setgray
 1528 1854 a Fh(7)1528 1854 y


 pgfr

 restore

 restore

 restore

 save

 0 setgray

 181.42027 1.59404 moveto

 181.42027 -1.59404 lineto

 pgfstr

 save

 save

 [1.0 0.0 0.0 1.0 178.50317 -12.66429 ] concat

 pgfs



 0 setgray
 1528 1854 a Fh(8)1528
1854 y


 pgfr

 restore

 restore

 restore

 save

 1.49442 pgfw

 0 0 1 setrgbcolor

 0.0 -68.0326 moveto

 0.0 189.12263 lineto

 pgfstr

 save

 [0.0 1.0 -1.0 0.0 0.0 189.12263 ] concat

 save 3.63638 0.0 moveto -2.18182 2.9091 lineto 0.0 0.0 lineto -2.18182
-2.9091 lineto pgffill restore

 restore

 restore

 save

 0 setgray

 1.59404 -68.0326 moveto

 -1.59404 -68.0326 lineto

 pgfstr

 save

 save

 [1.0 0.0 0.0 1.0 -19.04839 -71.68495 ] concat

 pgfs



 0 setgray
 1528 1854 a Fe(\241)p Fh(3)1528 1854 y


 pgfr

 restore

 restore

 restore

 save

 0 setgray

 1.59404 -45.35506 moveto

 -1.59404 -45.35506 lineto

 pgfstr

 save

 save

 [1.0 0.0 0.0 1.0 -19.04839 -49.0373 ] concat

 pgfs



 0 setgray
 1528 1854
a Fe(\241)p Fh(2)1528 1854 y


 pgfr

 restore

 restore

 restore

 save

 0 setgray

 1.59404 -22.67752 moveto

 -1.59404 -22.67752 lineto

 pgfstr

 save

 save

 [1.0 0.0 0.0 1.0 -19.04839 -26.35976 ] concat

 pgfs



 0 setgray
 1528 1854 a Fe(\241)p Fh(1)1528
1854 y


 pgfr

 restore

 restore

 restore

 save

 0 setgray

 1.59404 0.0 moveto

 -1.59404 0.0 lineto

 pgfstr

 save

 save

 [1.0 0.0 0.0 1.0 -11.134 -3.65236 ] concat

 pgfs



 0 setgray
 1528 1854 a Fh(0)1528 1854 y


 pgfr

 restore

 restore

 restore

 save

 0 setgray

 1.59404 22.67752 moveto

 -1.59404 22.67752 lineto

 pgfstr

 save

 save

 [1.0 0.0 0.0 1.0 -11.134 18.99527 ] concat

 pgfs



 0 setgray
 1528 1854 a Fh(1)1528
1854 y


 pgfr

 restore

 restore

 restore

 save

 0 setgray

 1.59404 45.35506 moveto

 -1.59404 45.35506 lineto

 pgfstr

 save

 save

 [1.0 0.0 0.0 1.0 -11.134 41.6728 ] concat

 pgfs



 0 setgray
 1528 1854 a Fh(2)1528 1854 y


 pgfr

 restore

 restore

 restore

 save

 0 setgray

 1.59404 68.0326 moveto

 -1.59404 68.0326 lineto

 pgfstr

 save

 save

 [1.0 0.0 0.0 1.0 -11.134 64.38022 ] concat

 pgfs



 0 setgray
 1528 1854 a Fh(3)1528
1854 y


 pgfr

 restore

 restore

 restore

 save

 0 setgray

 1.59404 90.71013 moveto

 -1.59404 90.71013 lineto

 pgfstr

 save

 save

 [1.0 0.0 0.0 1.0 -11.134 87.02788 ] concat

 pgfs



 0 setgray
 1528 1854 a Fh(4)1528 1854 y


 pgfr

 restore

 restore

 restore

 save

 0 setgray

 1.59404 113.38766 moveto

 -1.59404 113.38766 lineto

 pgfstr

 save

 save

 [1.0 0.0 0.0 1.0 -11.134 109.73529 ] concat

 pgfs



 0 setgray
 1528 1854 a Fh(5)1528
1854 y


 pgfr

 restore

 restore

 restore

 save

 0 setgray

 1.59404 136.0652 moveto

 -1.59404 136.0652 lineto

 pgfstr

 save

 save

 [1.0 0.0 0.0 1.0 -11.134 132.41283 ] concat

 pgfs



 0 setgray
 1528 1854 a Fh(6)1528 1854 y


 pgfr

 restore

 restore

 restore

 save

 0 setgray

 1.59404 158.74274 moveto

 -1.59404 158.74274 lineto

 pgfstr

 save

 save

 [1.0 0.0 0.0 1.0 -11.134 155.09036 ] concat

 pgfs



 0 setgray
 1528 1854 a Fh(7)1528
1854 y


 pgfr

 restore

 restore

 restore

 save

 0 setgray

 1.59404 181.42027 moveto

 -1.59404 181.42027 lineto

 pgfstr

 save

 save

 [1.0 0.0 0.0 1.0 -11.134 177.7679 ] concat

 pgfs



 0 setgray
 1528 1854 a Fh(8)1528 1854 y


 pgfr

 restore

 restore

 restore

 -68.0326 -68.0326 moveto

 -68.0326 -68.0326 moveto

 -68.0326 192.75903 lineto

 192.75903 192.75903 lineto

 192.75903 -68.0326 lineto

 closepath

 192.75903 192.75903 moveto

 clip

 newpath

 save

 1.99255 pgfw

 1 0 0 setrgbcolor

 -113.38766 340.16301 moveto

 -113.38766 340.16301 -112.56438 338.51643 -112.24818 337.88403 curveto

 -111.93198 337.25163 -111.42488 336.23747 -111.10869 335.60507 curveto

 -110.79248 334.97267 -110.2854 333.9585 -109.96921 333.3261 curveto

 -109.653 332.6937 -109.14592 331.67952 -108.82973 331.04713 curveto

 -108.51352 330.41473 -108.00644 329.40056 -107.69025 328.76817 curveto

 -107.37402 328.13577 -106.86696 327.12161 -106.55075 326.4892 curveto

 -106.23454 325.8568 -105.72748 324.84265 -105.41127 324.21025 curveto

 -105.09506 323.57782 -104.58798 322.56366 -104.27179 321.93127 curveto

 -103.9556 321.29889 -103.4485 320.28471 -103.13231 319.65231 curveto

 -102.81613 319.01993 -102.30904 318.00575 -101.99283 317.37335 curveto

 -101.67664 316.74095 -101.16956 315.72678 -100.85335 315.09438 curveto

 -100.53716 314.46198 -100.03006 313.4478 -99.71385 312.81541 curveto

 -99.39766 312.18301 -98.89058 311.16885 -98.57437 310.53645 curveto

 -98.25818 309.90405 -97.7511 308.8899 -97.4349 308.25749 curveto

 -97.1187 307.62508 -96.61162 306.61093 -96.29541 305.97853 curveto

 -95.9792 305.34613 -95.47212 304.33195 -95.15593 303.69955 curveto

 -94.83972 303.06715 -94.33263 302.05298 -94.01645 301.4206 curveto

 -93.70026 300.7882 -93.19316 299.77402 -92.87697 299.14163 curveto

 -92.56078 298.50923 -92.05368 297.49506 -91.73749 296.86266 curveto

 -91.42128 296.23026 -90.91422 295.21611 -90.598 294.5837 curveto

 -90.2818 293.95128 -89.77473 292.93712 -89.45853 292.30473 curveto

 -89.1423 291.67233 -88.63524 290.65817 -88.31903 290.02577 curveto

 -88.00284 289.39339 -87.49576 288.37921 -87.17955 287.74681 curveto

 -86.86336 287.11441 -86.35628 286.10023 -86.04007 285.46783 curveto

 -85.72388 284.83543 -85.21678 283.82126 -84.90057 283.18887 curveto

 -84.5844 282.55647 -84.0773 281.5423 -83.76111 280.90991 curveto

 -83.44493 280.27751 -82.93784 279.26335 -82.62163 278.63094 curveto

 -82.30544 277.99854 -81.79834 276.98439 -81.48215 276.35199 curveto

 -81.16594 275.71957 -80.65886 274.70541 -80.34267 274.07301 curveto

 -80.02646 273.44061 -79.51938 272.42644 -79.20319 271.79405 curveto

 -78.88698 271.16165 -78.3799 270.14748 -78.06369 269.51509 curveto

 -77.74748 268.88269 -77.2404 267.86852 -76.92421 267.23611 curveto

 -76.608 266.60371 -76.10092 265.58955 -75.78473 264.95715 curveto

 -75.46852 264.32474 -74.96144 263.31058 -74.64525 262.67819 curveto

 -74.32904 262.04579 -73.82196 261.03163 -73.50577 260.39923 curveto

 -73.18959 259.76685 -72.6825 258.75267 -72.36629 258.12027 curveto

 -72.0501 257.48787 -71.54301 256.4737 -71.2268 255.8413 curveto

 -70.9106 255.2089 -70.40352 254.19472 -70.08731 253.56233 curveto

 -69.77112 252.92993 -69.26404 251.91576 -68.94783 251.28337 curveto

 -68.63164 250.65097 -68.12456 249.6368 -67.80835 249.0044 curveto

 -67.49216 248.372 -66.98508 247.35785 -66.66887 246.72545 curveto

 -66.35266 246.09302 -65.84558 245.07887 -65.52939 244.44647 curveto

 -65.21318 243.81407 -64.70609 242.7999 -64.38991 242.1675 curveto

 -64.07372 241.53511 -63.56662 240.52094 -63.25043 239.88855 curveto

 -62.93423 239.25615 -62.42714 238.24197 -62.11095 237.60957 curveto

 -61.79474 236.97717 -61.28766 235.96301 -60.97147 235.33061 curveto

 -60.65526 234.6982 -60.14818 233.68404 -59.83199 233.05164 curveto

 -59.51576 232.41925 -59.0087 231.40509 -58.69249 230.77269 curveto

 -58.37628 230.14029 -57.86922 229.12613 -57.55301 228.49373 curveto

 -57.23682 227.86131 -56.72974 226.84715 -56.41353 226.21475 curveto

 -56.09734 225.58235 -55.59024 224.56818 -55.27403 223.93578 curveto

 -54.95786 223.30339 -54.45076 222.28922 -54.13457 221.65683 curveto

 -53.81839 221.02443 -53.3113 220.01025 -52.99509 219.37785 curveto

 -52.6789 218.74545 -52.1718 217.73131 -51.85559 217.09889 curveto

 -51.5394 216.46648 -51.03232 215.45233 -50.71613 214.81993 curveto

 -50.39992 214.18752 -49.89284 213.17336 -49.57664 212.54095 curveto

 -49.26044 211.90857 -48.75336 210.8944 -48.43715 210.26201 curveto

 -48.12094 209.62961 -47.61386 208.61543 -47.29767 207.98303 curveto

 -46.98146 207.35063 -46.47438 206.33647 -46.15819 205.70407 curveto

 -45.84198 205.07166 -45.33488 204.05748 -45.0187 203.4251 curveto

 -44.7025 202.79271 -44.19542 201.77855 -43.87923 201.14613 curveto

 -43.56303 200.51375 -43.05595 199.49959 -42.73975 198.86719 curveto

 -42.42354 198.23476 -41.91647 197.22061 -41.60027 196.58821 curveto

 -41.28406 195.95581 -40.77698 194.94164 -40.46077 194.30923 curveto

 -40.14458 193.67685 -39.6375 192.66267 -39.32129 192.03029 curveto

 -39.0051 191.39789 -38.49802 190.38371 -38.18181 189.75131 curveto

 -37.86562 189.11891 -37.35852 188.10475 -37.04231 187.47235 curveto

 -36.72612 186.83994 -36.21904 185.82579 -35.90283 185.19337 curveto

 -35.58664 184.56097 -35.07954 183.54681 -34.76337 182.91441 curveto

 -34.44717 182.28201 -33.94008 181.26785 -33.62389 180.63547 curveto

 -33.3077 180.00307 -32.8006 178.98889 -32.4844 178.35649 curveto

 -32.1682 177.72409 -31.66112 176.70993 -31.34492 176.07751 curveto

 -31.02872 175.44511 -30.52164 174.43094 -30.20543 173.79855 curveto

 -29.88922 173.16617 -29.38214 172.15198 -29.06595 171.51959 curveto

 -28.74974 170.8872 -28.24268 169.87305 -27.92647 169.24063 curveto

 -27.61026 168.60822 -27.1032 167.59407 -26.78699 166.96167 curveto

 -26.47078 166.32925 -25.9637 165.3151 -25.64749 164.6827 curveto

 -25.33131 164.05031 -24.82422 163.03613 -24.50803 162.40375 curveto

 -24.19185 161.77135 -23.68475 160.75717 -23.36855 160.12477 curveto

 -23.05234 159.49237 -22.54526 158.47821 -22.22905 157.84581 curveto

 -21.91286 157.2134 -21.40578 156.19923 -21.08957 155.56683 curveto

 -20.77338 154.93443 -20.2663 153.92027 -19.95009 153.28786 curveto

 -19.6339 152.65547 -19.1268 151.64131 -18.81061 151.00893 curveto

 -18.4944 150.37653 -17.98732 149.36235 -17.67113 148.72995 curveto

 -17.35492 148.09755 -16.84784 147.08339 -16.53165 146.45097 curveto

 -16.21544 145.81857 -15.70834 144.8044 -15.39217 144.17201 curveto

 -15.07596 143.53963 -14.56886 142.52544 -14.25269 141.89305 curveto

 -13.9365 141.26067 -13.4294 140.24649 -13.1132 139.61409 curveto

 -12.797 138.98167 -12.28993 137.96753 -11.97372 137.33513 curveto

 -11.6575 136.70271 -11.15044 135.68855 -10.83423 135.05615 curveto

 -10.51804 134.42377 -10.01096 133.40959 -9.69475 132.7772 curveto

 -9.37856 132.1448 -8.87148 131.13063 -8.55527 130.49823 curveto

 -8.23907 129.86583 -7.73198 128.85167 -7.41577 128.21925 curveto

 -7.09958 127.58685 -6.5925 126.5727 -6.27629 125.94029 curveto

 -5.9601 125.30789 -5.453 124.29372 -5.13681 123.66132 curveto

 -4.82063 123.02893 -4.31354 122.01477 -3.99734 121.38239 curveto

 -3.68115 120.74997 -3.17406 119.73581 -2.85786 119.10341 curveto

 -2.54166 118.47101 -2.03458 117.45685 -1.71838 116.82443 curveto

 -1.40218 116.19203 -0.89508 115.17786 -0.57889 114.54547 curveto

 -0.2627 113.91307 0.24437 112.8989 0.56055 112.26651 curveto

 0.87674 111.63412 1.38383 110.61995 1.70003 109.98753 curveto

 2.01624 109.35513 2.52333 108.34099 2.83952 107.70857 curveto

 3.15573 107.07617 3.66281 106.06201 3.979 105.42961 curveto

 4.2952 104.79721 4.80228 103.78305 5.11847 103.15067 curveto

 5.43466 102.51826 5.94176 101.50409 6.25797 100.87169 curveto

 6.57416 100.23929 7.08124 99.22513 7.39745 98.59271 curveto

 7.71364 97.96031 8.22072 96.94615 8.53693 96.31375 curveto

 8.85312 95.68135 9.3602 94.66718 9.67642 94.03477 curveto

 9.99261 93.40239 10.4997 92.38823 10.8159 91.75583 curveto

 11.1321 91.12343 11.63918 90.10927 11.95537 89.47687 curveto

 12.27158 88.84445 12.77866 87.8303 13.09485 87.19789 curveto

 13.41106 86.56549 13.91815 85.55132 14.23434 84.91893 curveto

 14.55054 84.28653 15.05763 83.27235 15.37381 82.63997 curveto

 15.69 82.00758 16.1971 80.99341 16.51329 80.361 curveto

 16.82951 79.72859 17.3366 78.71443 17.65279 78.08203 curveto

 17.969 77.44963 18.47606 76.43547 18.79227 75.80305 curveto

 19.10847 75.17067 19.61554 74.15651 19.93175 73.52412 curveto

 20.24796 72.89171 20.75504 71.87755 21.07124 71.24515 curveto

 21.38744 70.61275 21.89452 69.59859 22.21072 68.96617 curveto

 22.52692 68.33377 23.034 67.31961 23.3502 66.68721 curveto

 23.6664 66.05481 24.1735 65.04063 24.48969 64.40823 curveto

 24.80588 63.77585 25.31297 62.76167 25.62917 62.12927 curveto

 25.94534 61.49689 26.45244 60.48273 26.76865 59.85031 curveto

 27.08484 59.21791 27.59192 58.20377 27.90813 57.57135 curveto

 28.22433 56.93893 28.73141 55.92477 29.0476 55.29239 curveto

 29.36382 54.65999 29.8709 53.64581 30.18709 53.01343 curveto

 30.5033 52.38104 31.01038 51.36687 31.32657 50.73445 curveto

 31.64278 50.10205 32.14987 49.08789 32.46606 48.45549 curveto

 32.78227 47.82309 33.28937 46.80891 33.60555 46.17651 curveto

 33.92174 45.54413 34.42882 44.52997 34.74501 43.89757 curveto

 35.06122 43.26517 35.5683 42.251 35.8845 41.6186 curveto

 36.20071 40.98619 36.70778 39.97205 37.02399 39.33963 curveto

 37.34018 38.70723 37.84726 37.69307 38.16347 37.06067 curveto

 38.47966 36.42827 38.98674 35.4141 39.30296 34.7817 curveto

 39.61916 34.1493 40.12624 33.13513 40.44244 32.50273 curveto

 40.75864 31.87035 41.26572 30.85617 41.58192 30.22377 curveto

 41.89812 29.59137 42.4052 28.57721 42.7214 27.9448 curveto

 43.0376 27.3124 43.5447 26.29823 43.86089 25.66585 curveto

 44.17708 25.03345 44.68417 24.01927 45.00035 23.38689 curveto

 45.31654 22.7545 45.82364 21.74033 46.13983 21.10791 curveto

 46.45605 20.47551 46.96313 19.46135 47.27933 18.82895 curveto

 47.59554 18.19655 48.10262 17.18237 48.41881 16.54997 curveto

 48.73502 15.91759 49.2421 14.90341 49.55829 14.27101 curveto

 49.8745 13.63863 50.38158 12.62447 50.69778 11.99207 curveto

 51.01399 11.35965 51.52106 10.34549 51.83727 9.71309 curveto

 52.15346 9.08069 52.66054 8.06653 52.97675 7.43413 curveto

 53.29294 6.80173 53.80003 5.78755 54.11623 5.15515 curveto

 54.43242 4.52277 54.93951 3.50859 55.2557 2.87619 curveto

 55.57188 2.2438 56.07898 1.22961 56.39519 0.59723 curveto

 56.71138 -0.03514 57.21846 -1.04932 57.53468 -1.6817 curveto

 57.85088 -2.31409 58.35796 -3.32826 58.67416 -3.96065 curveto

 58.99036 -4.59306 59.49744 -5.60722 59.81363 -6.23961 curveto

 60.12984 -6.87201 60.63692 -7.88618 60.95311 -8.51859 curveto

 61.26932 -9.15099 61.77641 -10.16515 62.0926 -10.79755 curveto

 62.40881 -11.42996 62.91591 -12.44414 63.23209 -13.07652 curveto

 63.54828 -13.70891 64.05537 -14.72308 64.37155 -15.35548 curveto

 64.68776 -15.98787 65.19485 -17.00203 65.51105 -17.63445 curveto

 65.82726 -18.26685 66.33432 -19.281 66.65053 -19.9134 curveto

 66.96674 -20.54582 67.4738 -21.55997 67.79001 -22.19237 curveto

 68.1062 -22.82478 68.6133 -23.83896 68.9295 -24.47134 curveto

 69.2457 -25.10373 69.75278 -26.1179 70.06898 -26.7503 curveto

 70.38518 -27.38269 70.89226 -28.39687 71.20847 -29.02927 curveto

 71.52466 -29.66168 72.03174 -30.67584 72.34795 -31.30824 curveto

 72.66415 -31.94064 73.17123 -32.9548 73.48744 -33.58722 curveto

 73.80362 -34.2196 74.31071 -35.23376 74.62689 -35.86615 curveto

 74.9431 -36.49857 75.45018 -37.51273 75.76639 -38.14513 curveto

 76.0826 -38.77753 76.58968 -39.79169 76.90587 -40.42409 curveto

 77.22208 -41.0565 77.72916 -42.07068 78.04535 -42.70306 curveto

 78.36156 -43.33545 78.86864 -44.34962 79.18483 -44.98203 curveto

 79.50104 -45.61441 80.00813 -46.62859 80.32433 -47.26099 curveto

 80.64053 -47.8934 81.1476 -48.90755 81.4638 -49.53996 curveto

 81.78001 -50.17236 82.28708 -51.18651 82.60329 -51.81892 curveto

 82.9195 -52.45134 83.42657 -53.4655 83.74278 -54.09789 curveto

 84.05896 -54.73027 84.56606 -55.74445 84.88225 -56.37685 curveto

 85.19843 -57.00923 85.70552 -58.0234 86.02173 -58.6558 curveto

 86.33792 -59.28822 86.845 -60.30238 87.16122 -60.93478 curveto

 87.47742 -61.56718 87.9845 -62.58136 88.3007 -63.21376 curveto

 88.6169 -63.84615 89.12398 -64.8603 89.44019 -65.4927 curveto

 89.75638 -66.1251 90.26346 -67.13927 90.57965 -67.77167 curveto

 90.89587 -68.40408 91.40295 -69.41823 91.71915 -70.05063 curveto

 92.03535 -70.68304 92.54245 -71.69722 92.85863 -72.3296 curveto

 93.17482 -72.96199 93.68192 -73.97617 93.9981 -74.60857 curveto

 94.3143 -75.24095 94.8214 -76.25513 95.13759 -76.88753 curveto

 95.4538 -77.51994 95.96088 -78.5341 96.27707 -79.1665 curveto

 96.59328 -79.7989 97.10034 -80.81305 97.41655 -81.44548 curveto

 97.73276 -82.07788 98.23984 -83.09204 98.55605 -83.72443 curveto

 98.87225 -84.35683 99.37932 -85.371 99.69553 -86.00339 curveto

 100.01172 -86.63577 100.5188 -87.64995 100.835 -88.28235 curveto

 101.1512 -88.91476 101.65828 -89.92892 101.97449 -90.56133 curveto

 102.2907 -91.19373 102.79778 -92.2079 103.11398 -92.8403 curveto

 103.43016 -93.47269 103.93726 -94.48686 104.25345 -95.11925 curveto

 104.56964 -95.75165 105.07672 -96.76581 105.39294 -97.39822 curveto

 105.70914 -98.03062 106.21622 -99.04477 106.53241 -99.67719 curveto

 106.84862 -100.30959 107.3557 -101.32376 107.67189 -101.95615 curveto

 107.9881 -102.58853 108.49518 -103.6027 108.81137 -104.2351 curveto

 109.12758 -104.8675 109.63467 -105.88167 109.95087 -106.51407 curveto

 110.26707 -107.14648 110.77415 -108.16064 111.09035 -108.79305 curveto

 111.40656 -109.42545 111.91364 -110.4396 112.22983 -111.07202 curveto

 112.54604 -111.70442 113.36932 -113.35098 113.36932 -113.35098 curveto

 pgfstr

 restore

 22.67752 68.0326 moveto

 pgfstr

 save

 save

 [1.0 0.0 0.0 1.0 26.38329 71.73836 ] concat

 pgfs



 0 setgray
 1528 1854 a Fh(A)1528
1854 y


 pgfr

 restore

 restore

 save

 1.49442 pgfw

 22.67752 68.0326 moveto

 25.06859 70.42366 lineto

 20.28644 65.64151 lineto

 22.67752 68.0326 lineto

 20.28644 70.42366 lineto

 25.06859 65.64151 lineto

 pgfstr

 restore

 -22.67752 158.74274 moveto

 pgfstr

 save

 save

 [1.0 0.0 0.0 1.0 -33.48474 147.25406 ] concat

 pgfs



 0 setgray
 1528 1854 a Fh(B)1528 1854 y


 pgfr

 restore

 restore

 save

 1.49442 pgfw

 -22.67752 158.74274 moveto

 -20.28644 161.1338 lineto

 -25.06859 156.35165 lineto

 -22.67752 158.74274 lineto

 -25.06859 161.1338 lineto

 -20.28644 156.35165 lineto

 pgfstr

 restore

 45.35506 22.67752 moveto

 pgfstr

 save

 save

 [1.0 0.0 0.0 1.0 49.06082 26.60445 ] concat

 pgfs



 0 setgray
 1528 1854 a Fh(C)1528
1854 y


 pgfr

 restore

 restore

 save

 1.49442 pgfw

 45.35506 22.67752 moveto

 47.74612 25.06859 lineto

 42.96397 20.28644 lineto

 45.35506 22.67752 lineto

 42.96397 25.06859 lineto

 47.74612 20.28644 lineto

 pgfstr

 restore

 79.37135 -45.35506 moveto

 pgfstr

 save

 save

 [1.0 0.0 0.0 1.0 83.07712 -41.64928 ] concat

 pgfs



 0 setgray
 1528 1854 a Fh(D)1528 1854 y


 pgfr

 restore

 restore

 save

 1.49442 pgfw

 79.37135 -45.35506 moveto

 81.76242 -42.96397 lineto

 76.98027 -47.74612 lineto

 79.37135 -45.35506 lineto

 76.98027 -42.96397 lineto

 81.76242 -47.74612 lineto

 pgfstr

 restore

 restore

 newpath

 restore

 pgfc


 0 2572 a
SDict begin H.S end
 0 2572 a
0 2572 a
SDict begin 17.39995 H.A end
 0 2572 a 0 2572 a
SDict begin [/View [/XYZ H.V]/Dest (Item.1) cvn /DEST pdfmark end
 0 2572 a 0 TeXcolorgray 118
2734 a Fd(1.)p 0 TeXcolorgray 51 w Ff(x)297 2749 y Fb(A)363
2734 y Fe(6\306)f Ff(x)498 2749 y Fb(B)546 2734 y Fh(,)i(donc)g(la)f
(dr)o(oite)g(\()r(AB\))h(admet)e(une)h(\351quation)f(du)h(type)26
b Ff(y)f Fe(\306)17 b Ff(m)7 b(x)19 b Fe(\305)14 b Ff(p)7
b Fh(.)244 2911 y Ff(m)21 b Fe(\306)448 2843 y Ff(y)495
2858 y Fb(B)555 2843 y Fe(\241)c Ff(y)686 2858 y Fb(A)p
442 2888 293 6 v 444 2979 a Ff(x)494 2994 y Fb(B)555
2979 y Fe(\241)d Ff(x)686 2994 y Fb(A)762 2911 y Fe(\306)888
2843 y Fh(7)e Fe(\241)g Fh(3)p 855 2888 254 6 v 855 2979
a Fe(\241)p Fh(1)g Fe(\241)g Fh(1)1136 2911 y Fe(\306)1262
2843 y Fh(4)p 1229 2888 115 6 v 1229 2979 a Fe(\241)p
Fh(2)1370 2911 y Fe(\306)17 b(\241)p Fh(2.)244 3088 y(La)k(dr)o(oite)e
(\()r(AB\))i(admet)f(donc)g(une)g(\351quation)g(du)g(type)25
b Ff(y)g Fe(\306)17 b(\241)r Ff(x)i Fe(\305)14 b Ff(p)7
b Fh(.)244 3250 y(C)o(omme)25 b(A)g(appar)q(tient)d(\340)i(cette)h(dr)o
(oite)n(,)f(ses)h(coor)n(donn\351es)f(v\351r)q(i\002ent)f(l)o
('\351quation)g(pr\351c\351dente)n(,)i(c)m('est-)244
3395 y(\340-dir)n(e)g Ff(y)564 3410 y Fb(A)629 3395 y
Fe(\306)17 b(\241)p Fh(2)r Ff(x)880 3410 y Fb(A)940 3395
y Fe(\305)d Ff(p)7 b Fh(.)244 3557 y(On)20 b(obtient)e(donc)j(3)16
b Fe(\306)h(\241)p Fh(2)12 b Fe(\243)g Fh(1)g Fe(\305)i
Ff(p)122 b Fe(,)114 b Fh(3)17 b Fe(\306)g(\241)p Fh(2)12
b Fe(\305)i Ff(p)121 b Fe(,)114 b Fh(5)17 b Fe(\306)i
Ff(p)7 b Fh(.)244 3719 y(La)21 b(dr)o(oite)e(\()r(AB\))i(admet)f(donc)g
(pour)g(\351quation)k Ff(y)h Fe(\306)17 b(\241)p Fh(2)r
Ff(x)i Fe(\305)12 b Fh(5.)0 3759 y
SDict begin H.S end
 0 3759 a 0 3759 a
SDict begin 17.39995 H.A end

0 3759 a 0 3759 a
SDict begin [/View [/XYZ H.V]/Dest (Item.2) cvn /DEST pdfmark end
 0 3759 a 0 TeXcolorgray 118 3898 a
Fd(2.)p 0 TeXcolorgray 49 w Fh(La)21 b(\002gur)n(e)e(est)h(au-dessus)n
(.)244 4060 y(P)o(uisque)c(C)j(appar)q(tient)c(\340)i(la)g(dr)o(oite)f
(\()r(AB\),)j(ses)e(coor)n(donn\351es)g(v\351r)q(i\002ent)f(l)o
('\351quation)g(pr\351c\351dente)n(,)h(c)m('est-)244
4205 y(\340-dir)n(e)25 b Ff(y)563 4220 y Fb(C)632 4205
y Fe(\306)17 b(\241)p Fh(2)r Ff(x)882 4220 y Fb(C)947
4205 y Fe(\305)12 b Fh(5.)244 4367 y(On)20 b(obtient)e(donc)26
b Ff(y)995 4382 y Fb(C)1064 4367 y Fe(\306)17 b(\241)p
Fh(2)12 b Fe(\243)g Fh(2)g Fe(\305)g Fh(5)17 b Fe(\306)g
Fh(1.)244 4529 y(L)-12 b('or)n(donn\351e)20 b(du)g(point)f(C)k(est)d
(1.)0 4567 y
SDict begin H.S end
 0 4567 a 0 4567 a
SDict begin 17.39995 H.A end
 0 4567 a 0 4567 a
SDict begin [/View [/XYZ H.V]/Dest (Item.3) cvn /DEST pdfmark end
 0 4567
a 0 TeXcolorgray 118 4708 a Fd(3.)p 0 TeXcolorgray 49
w Fh(La)h(\002gur)n(e)e(est)h(au-dessus)n(.)244 4870
y(P)o(uisque)c(D)h(appar)q(tient)d(\340)j(la)f(dr)o(oite)g(\()r(AB\),)h
(ses)g(coor)n(donn\351es)f(v\351r)q(i\002ent)g(l)o('\351quation)f
(pr\351c\351dente)n(,)i(c)m('est-)244 5015 y(\340-dir)n(e)25
b Ff(y)563 5030 y Fb(D)638 5015 y Fe(\306)17 b(\241)p
Fh(2)r Ff(x)888 5030 y Fb(D)957 5015 y Fe(\305)12 b Fh(5.)244
5192 y(On)20 b(obtient)e(donc)j Fe(\241)p Fh(2)16 b Fe(\306)h(\241)p
Fh(2)12 b Fe(\243)i Ff(x)1414 5207 y Fb(D)1484 5192 y
Fe(\305)e Fh(5)115 b Fe(,)f Fh(2)r Ff(x)2033 5207 y Fb(D)2108
5192 y Fe(\306)17 b Fh(5)12 b Fe(\305)g Fh(2)114 b Fe(,)i
Ff(x)2751 5207 y Fb(D)2826 5192 y Fe(\306)2919 5124 y
Fh(7)p 2919 5169 49 6 v 2919 5260 a(2)2978 5192 y(.)244
5415 y(L)-12 b('abscisse)21 b(du)f(point)f(D)i(est)1288
5347 y(7)p 1288 5392 V 1288 5483 a(2)1347 5415 y(.)p
0 TeXcolorgray 0 5892 4016 2 v 0 6013 a(2)49 5984 y Fa(nde)1928
6013 y Fh(1/)p 0 TeXcolorgray 2039 6013 a
SDict begin H.S end
 2039 6013 a
0 TeXcolorgray Fh(1)p 0 TeXcolorgray 2088 5951 a
SDict begin H.R end
 2088
5951 a 2088 6013 a
SDict begin [/Color [1 0 0]/H /I/Border [0 0 0]BorderArrayPatch/Subtype
/Link/Dest (page.1) cvn H.B /ANN pdfmark end
 2088 6013 a 0 TeXcolorgray 1216 w
Fh(Ann\351e)g(2013-2014)p 0 TeXcolorgray eop end
%%Trailer

userdict /end-hook known{end-hook}if
%%EOF
