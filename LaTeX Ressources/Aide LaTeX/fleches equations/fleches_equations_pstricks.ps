%!PS-Adobe-2.0
%%Creator: dvips(k) 5.997 Copyright 2017 Radical Eye Software
%%Title: fleches_equations_pstricks.dvi
%%CreationDate: Thu Mar 15 14:22:38 2018
%%Pages: 1
%%PageOrder: Ascend
%%BoundingBox: 0 0 596 842
%%DocumentFonts: Utopia-Bold Utopia-Regular Fourier-Math-Letters
%%+ Utopia-Italic Fourier-Math-Symbols
%%DocumentPaperSizes: a4
%%EndComments
%DVIPSWebPage: (www.radicaleye.com)
%DVIPSCommandLine: dvips -o fleches_equations_pstricks.ps
%+ fleches_equations_pstricks.dvi
%DVIPSParameters: dpi=600
%DVIPSSource:  TeX output 2018.03.15:1522
%%BeginProcSet: tex.pro 0 0
%!
/TeXDict 300 dict def TeXDict begin/N{def}def/B{bind def}N/S{exch}N/X{S
N}B/A{dup}B/TR{translate}N/isls false N/vsize 11 72 mul N/hsize 8.5 72
mul N/landplus90{false}def/@rigin{isls{[0 landplus90{1 -1}{-1 1}ifelse 0
0 0]concat}if 72 Resolution div 72 VResolution div neg scale isls{
landplus90{VResolution 72 div vsize mul 0 exch}{Resolution -72 div hsize
mul 0}ifelse TR}if Resolution VResolution vsize -72 div 1 add mul TR[
matrix currentmatrix{A A round sub abs 0.00001 lt{round}if}forall round
exch round exch]setmatrix}N/@landscape{/isls true N}B/@manualfeed{
statusdict/manualfeed true put}B/@copies{/#copies X}B/FMat[1 0 0 -1 0 0]
N/FBB[0 0 0 0]N/nn 0 N/IEn 0 N/ctr 0 N/df-tail{/nn 8 dict N nn begin
/FontType 3 N/FontMatrix fntrx N/FontBBox FBB N string/base X array
/BitMaps X/BuildChar{CharBuilder}N/Encoding IEn N end A{/foo setfont}2
array copy cvx N load 0 nn put/ctr 0 N[}B/sf 0 N/df{/sf 1 N/fntrx FMat N
df-tail}B/dfs{div/sf X/fntrx[sf 0 0 sf neg 0 0]N df-tail}B/E{pop nn A
definefont setfont}B/Cw{Cd A length 5 sub get}B/Ch{Cd A length 4 sub get
}B/Cx{128 Cd A length 3 sub get sub}B/Cy{Cd A length 2 sub get 127 sub}
B/Cdx{Cd A length 1 sub get}B/Ci{Cd A type/stringtype ne{ctr get/ctr ctr
1 add N}if}B/CharBuilder{save 3 1 roll S A/base get 2 index get S
/BitMaps get S get/Cd X pop/ctr 0 N Cdx 0 Cx Cy Ch sub Cx Cw add Cy
setcachedevice Cw Ch true[1 0 0 -1 -.1 Cx sub Cy .1 sub]{Ci}imagemask
restore}B/D{/cc X A type/stringtype ne{]}if nn/base get cc ctr put nn
/BitMaps get S ctr S sf 1 ne{A A length 1 sub A 2 index S get sf div put
}if put/ctr ctr 1 add N}B/I{cc 1 add D}B/bop{userdict/bop-hook known{
bop-hook}if/SI save N @rigin 0 0 moveto/V matrix currentmatrix A 1 get A
mul exch 0 get A mul add .99 lt{/QV}{/RV}ifelse load def pop pop}N/eop{
SI restore userdict/eop-hook known{eop-hook}if showpage}N/@start{
userdict/start-hook known{start-hook}if pop/VResolution X/Resolution X
1000 div/DVImag X/IEn 256 array N 2 string 0 1 255{IEn S A 360 add 36 4
index cvrs cvn put}for pop 65781.76 div/vsize X 65781.76 div/hsize X}N
/dir 0 def/dyy{/dir 0 def}B/dyt{/dir 1 def}B/dty{/dir 2 def}B/dtt{/dir 3
def}B/p{dir 2 eq{-90 rotate show 90 rotate}{dir 3 eq{-90 rotate show 90
rotate}{show}ifelse}ifelse}N/RMat[1 0 0 -1 0 0]N/BDot 260 string N/Rx 0
N/Ry 0 N/V{}B/RV/v{/Ry X/Rx X V}B statusdict begin/product where{pop
false[(Display)(NeXT)(LaserWriter 16/600)]{A length product length le{A
length product exch 0 exch getinterval eq{pop true exit}if}{pop}ifelse}
forall}{false}ifelse end{{gsave TR -.1 .1 TR 1 1 scale Rx Ry false RMat{
BDot}imagemask grestore}}{{gsave TR -.1 .1 TR Rx Ry scale 1 1 false RMat
{BDot}imagemask grestore}}ifelse B/QV{gsave newpath transform round exch
round exch itransform moveto Rx 0 rlineto 0 Ry neg rlineto Rx neg 0
rlineto fill grestore}B/a{moveto}B/delta 0 N/tail{A/delta X 0 rmoveto}B
/M{S p delta add tail}B/b{S p tail}B/c{-4 M}B/d{-3 M}B/e{-2 M}B/f{-1 M}
B/g{0 M}B/h{1 M}B/i{2 M}B/j{3 M}B/k{4 M}B/w{0 rmoveto}B/l{p -4 w}B/m{p
-3 w}B/n{p -2 w}B/o{p -1 w}B/q{p 1 w}B/r{p 2 w}B/s{p 3 w}B/t{p 4 w}B/x{
0 S rmoveto}B/y{3 2 roll p a}B/bos{/SS save N}B/eos{SS restore}B end

%%EndProcSet
%%BeginProcSet: pstricks.pro 0 0
% $Id: pstricks.pro 446 2017-04-19 11:40:55Z herbert $
%
%% PostScript prologue for pstricks.tex.
%% Version 1.24, 2016/04/22
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%
%
% Define the follwing gs-functions if not known, eg when using distiller
%
systemdict /.setopacityalpha known not {/.setopacityalpha { pop } def } if
systemdict /.setblendmode known not {/.setblendmode { pop } def } if
systemdict /.setshapealpha known not {/.setshapealpha { pop } def } if
%
/tx@Dict 200 dict def 				% the main PSTricks dictionary
tx@Dict begin
/ADict 25 dict def				% The arrow dictionary
/CM { matrix currentmatrix } bind def
/SLW /setlinewidth load def
/CLW /currentlinewidth load def
/CP /currentpoint load def
/ED { exch def } bind def
/L /lineto load def
/T /translate load def
/TMatrix { } def
/RAngle { 0 } def
/Sqrt { dup 0 lt { pop 0 } { sqrt } ifelse } def  % return 0 for negative arguments 
/Atan { /atan load stopped { pop pop 0 } if } def % return 0 if atan not known
/ATAN1 {neg -1 atan 180 sub } def		% atan(x) (only one parameter)
/Div { dup 0 eq { pop } { div } ifelse } def  	% control the division
/Log { dup 1e-20 lt { pop -1e30 }{ log } ifelse } def % control the log
/tan { dup cos abs 1.e-10 lt 
  { pop 1.e10 } 				% return 1.e10 as infinit
  { dup sin exch cos div } ifelse 		% default sin/cos
} def
/Tan { dup sin exch cos Div } def 		% sin(x)/cos(x) x in degrees
/Acos {dup dup mul neg 1 add dup 0 lt {		% arc cos, returns 0 when negative root
  pop pop 0 }{ sqrt exch atan} ifelse } def
/Acos2 { 2 dict begin 
  /x ED /y ED
  y abs 1.0e-20 lt { 1.0e30 } if
  x y div 
  dup dup mul neg 1 add dup 0 lt {		% arc cos needs two values x,y
  pop pop 0 }{ sqrt exch atan} ifelse 
  y 0 lt { 180 add } if
} def
/NET { neg exch neg exch T } def	      	% change coordinate system to the negative one		
/Pyth { dup mul exch dup mul add sqrt } def   	% Pythagoras, expects 2 parameter
/Pyth2 {					% Pythagoras, xA yA xB yB
  3 -1 roll 		% xA xB yB yA
  sub			% xA xB yB-yA
  3 1 roll 		% yB-yA xA xB
  sub			% yB-yA xA-xB
  Pyth } def
/PtoC { 2 copy cos mul 3 1 roll sin mul } def % Polar to Cartesian
/PtoCab { dup cos 4 -1 roll mul 3 1 roll sin mul } def % Polar to Cartesian (Ellipse) a b phi-> x y 
%/Rand { rand 4294967295 div } def		% a real random number
/Rand { rand 2147483447 div } def		% a real random number between 0 and 1
%----------------- hv added 20050516 ---------------
/PiDiv2 1.57079632680 def
/Pi 3.14159265359 def 
/TwoPi 6.28318530718 def
/Euler 2.71828182846 def 
%/e Euler bind def
%
/RadtoDeg { 180 mul Pi div } bind def 		% convert from radian to degrees
/DegtoRad { Pi mul 180 div } bind def 		% viceversa
%
/startGlobal { true setglobal globaldict begin } bind def
/endGlobal { end false setglobal } bind def
/pssetRGBcolor /setrgbcolor load def
/pssetCMYKcolor /setcmykcolor load def
/pssetGraycolor /setgray load def
%
%----------------- hv end---------------------------
/PathLength@ { /z z y y1 sub x x1 sub Pyth add def /y1 y def /x1 x def } def
%
/PathLength { 
  flattenpath /z 0 def 
  { /y1 ED /x1 ED /y2 y1 def /x2 x1 def }
  { /y ED /x ED PathLength@ } 
  {} 
  { /y y2 def /x x2 def PathLength@ }
  /pathforall load stopped { pop pop pop pop } if 
  z 
} def
%
/STP { .996264 dup scale } def			% BP/PT scaling
/STV { SDict begin normalscale end STP  } def	% 
%
/DashLine {
    dup 0 gt
    { /a .5 def PathLength exch div }
    { pop /a 1 def PathLength } ifelse
    /b ED % pattern should fit evenly in b
    dup /X ED % pattern array
    0 get /y ED % length of first black segment
    /z 0 X {add} forall def % length of the full pattern
    %% Computation of the scaling factor as described by van Zandt:
    b a .5 sub 2 mul y mul sub z Div round
    z mul a .5 sub 2 mul y mul add b exch Div
    %%%% scaling factor on stack.
    /z ED %% now, z is the scaling factor
    false % for the length test below
    X { z mul } forall X astore %% modification TN 04-08-07
    %%% Checking whether at least one dash in X has positive length:
    {0 gt or} forall
    { X 1 a sub y mul }
    { [ 1 0 ] 0 }
    ifelse
    setdash stroke
} def
%
/DotLine { 
  /b PathLength def 
  /a ED /z ED /y CLW def 
  /z y z add def 
  a 0 gt { 
    /b b a div def 
  }{ 
    a 0 eq { 
      /b b y sub def 
    }{ a -3 eq { 
      /b b y add def } if 
    } ifelse 
  } ifelse 
  [ 0 b b z Div round Div dup 0 le { pop 1 } if ] 
  a 0 gt { 0 }{ y 2 div a -2 gt { neg }if } ifelse 
  setdash 1 setlinecap stroke 
} def
%
/SymbolLine {   % on stack [ x y x y ...
  counttomark 					% number of elements
  2 div cvi /n ED     				% n pairs
  /YA ED /XA ED					% the start point
  n 1 sub { 
    /YB ED /XB ED
    /XLength XB XA sub def
    /YLength YB YA sub def
    /PAngle YLength XLength Atan def
    /XYLength XLength YLength Pyth def
    %% for negative SymStep we calculate the distance 
    SymStep 0 lt 
      { %XYLength SymStep div abs cvi 
        /nSym SymStep abs cvi def } 
      { /nSym XYLength SymStep div cvi def }
    ifelse
    0.5 setflat
    /Shift Symbol stringwidth pop 2 div def 
    /deltaX XLength nSym div def
    /deltaY YLength nSym div def
    curveticks 
      { XA YA moveto }
      { XA Shift sub YA Shift sub moveto }
    ifelse 
    nSym { 
      gsave 
      curveticks 
        { PAngle 180 sub CorrAngle sub tickAngle add /rotAngle ED  
          currentpoint translate rotAngle rotate 
          0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
          SymbolLinewidth setlinewidth stroke
        }
        { 
          rotateSymbol { PAngle 180 sub CorrAngle sub rotate } if
          Symbol show 
        }
      ifelse 
      grestore 
      deltaX deltaY rmoveto
    } repeat
    /YA YB def /XA XB def
  } repeat 
  curveticks 
    { XA YA moveto }
    { XA Shift sub YA Shift sub moveto }
  ifelse 
  gsave 
  curveticks 
    { PAngle 180 sub CorrAngle sub tickAngle add /rotAngle ED  
      XA YA translate rotAngle rotate 
      0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
      SymbolLinewidth setlinewidth stroke
    }
    { 
      rotateSymbol { PAngle 180 sub CorrAngle sub rotate } if
      Symbol show 
    }
  ifelse 
  grestore
  pop 				% delete the mark symbol
} def
%
/LineFill { % hv ------------ patch 7 -------------
  gsave 
  abs /hatchWidthInc ED
  abs /hatchSepInc ED
  abs CLW add /a ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform pathbbox 
  /y2 ED 
  a Div ceiling cvi /x2 ED /y1 ED 
  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clipType   % must be defined in pstricks.tex: clip -- eoclip 
  newpath 
  2 setlinecap 
  systemdict
  /setstrokeadjust known { true setstrokeadjust } if 
  x2 x1 sub 1 add { 
    x1 a mul y1 moveto 0 y2 rlineto stroke 
    /x1 x1 1 add 
      hatchWidthInc 0 gt { CLW add } if 
    def 
    hatchSepInc 0 gt hatchWidthInc 0 gt or { 
      /a a hatchSepInc add def
      CLW hatchWidthInc add SLW 
    } if
  } repeat 
  grestore 
  pop pop } def
%
/DotFill {%	 on stack: dot radius
  /dotRadius ED
  abs CLW add /a ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform 
  pathbbox % llx lly urx ury of smallest bounding box
  /y2 ED /x2 ED /y1 ED /x1 ED 
  y2 y1 sub a div 2 add cvi /Ny ED
  x2 x1 sub a div 2 add cvi /Nx ED
  clipType   % must be defined in pstricks.tex: clip -- eoclip 
  newpath 
  /yA y1 dotRadius add CLW add def
  /xA0 x1 dotRadius add CLW add def
  Ny {
     /xA xA0 def
     Nx { 
       newpath 
       xA yA dotRadius 0 360 arc 
       SolidDot { gsave fill grestore } if 
       stroke
       xA a add /xA ED
     } repeat
     yA a add /yA ED
  } repeat
  grestore
} def
%
/PenroseFill {%	 on stack: scaling factor
  /Scale ED
%  1 exch div round /penroseFactor ED 
%  a 0 dtransform round exch round exch
%  2 copy idtransform 
%  exch Atan rotate 
%  idtransform pop /a ED 
%  .25 .25 itransform pathbbox 
%  /y2 ED 
%  a Div ceiling cvi /x2 ED /y1 ED 
%  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clip 
  newpath 
gsave
  220 150 translate
  Scale dup scale
  systemdict /setstrokeadjust known { true setstrokeadjust } if 
  /I/S/L/W/G/+/Z/F/E/D[/def/exch/for{E D}/add{s E get mul}
 { Z -36.2001 1 33 }{25 E S rlineto}{/q Z dup q G E q 1 + G}{Z 2 2}]{cvx def}forall
  [0 72 1008 {dup sin E cos }F ]1 setlinejoin/s W{/a W{/b I 10{/i I 4{/m I moveto
  i m +/j I 10{/l Z b m l + G a l G sub s m get div .2 + floor .3 + 25
  mul j l + S rmoveto}F i L j L stroke }F}F}F}F 
  grestore 
%  pop pop 
} def
%
/PenroseFillA {%  on stack: scaling factor, border color, kite color, dart color
  /Scale ED
  Scale dup scale
  /border_colour ED 
  /kite_colour ED 
  /dart_colour ED
  clip 
  newpath 
  gsave
  100 100 translate
  6 
  Scale 1 lt { 1 Scale dup add div mul cvi } if %%%%   Number of iterations
  10					%%%%   Long side length in millimeters
  /border_width { L 0.06 mul }def		%%%%   Choose the scalefactor for the borders
  /L exch 25.4 div 72 mul def		%%%%   Conversion: mm -> inches -> points
  /f{-1 5 sqrt add 2 div}bind def		%%%%   The reciprocal of the golden ratio
  /l{L f mul}bind def			%%%%   Short side length l = L*f
  /Ll{L l add}bind def			%%%%   Ll =  L + l
  /c{36 cos L mul}bind def		%%%%   c  =  L*cos(36)
  /s{36 sin L mul}bind def		%%%%   s  =  L*sin(36)
  /draw_tile { 0 0 moveto c s lineto 0 lineto gsave closepath gsave fill grestore
	     0 setlinewidth stroke grestore border_colour stroke } bind def
  /half_kite { dup dup 0 gt{ 1 sub gsave f f neg scale -36 rotate half_dart
			   Ll 0 translate 144 rotate kite grestore }
	      		 { kite_colour L draw_tile }ifelse
	     pop } bind def
  /half_dart { dup dup 0 gt{ 1 sub gsave f f scale half_kite
			   -144 rotate Ll neg 0 translate half_dart grestore }
	      		 { dart_colour l draw_tile }ifelse
  	     pop } bind def
  /kite{ gsave half_kite 1 -1 scale half_kite grestore }bind def
  border_width setlinewidth  1 setlinejoin  1 setlinecap
%  450 0 translate  
  dup f exch neg exp dup scale
  5 {kite 72 rotate } repeat stroke 
  grestore
} def
%
%
/TruchetFill { %	 on stack: scaling factor
  10 dict begin
  dup dup scale
  1 exch div round /penroseFactor ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform pathbbox 
  /y2 ED 
  a Div ceiling cvi /x2 ED /y1 ED 
  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clip 
  newpath 
  systemdict
  /setstrokeadjust known { true setstrokeadjust } if 
  /ma a neg def
  /ha a 2 div def 
  /mha ha neg def
  /tile { 
    rand dup 2 idiv 2 mul eq { 90 rotate } if
    mha mha moveto ha mha lineto
    ha ha lineto mha ha lineto
%    closepath .1 setlinewidth stroke
    contents
  } def
  /contents{ 
    0 ha moveto ha 0 lineto
    0 mha moveto mha 0 lineto
%    1 setlinewidth stroke
  } def
  /dotiling {
    f ma mul a f a mul { 
      /i exch def
      f ma mul a f a mul { 
        /j exch def
        gsave i j translate
        tile stroke grestore
      } for
    } for
  } def
%
  /f 3 def 
  5 srand dotiling 
  end % local user dict
} def
%
/BeginArrow { 
  ADict begin 			% hold it local, for end see EndArrow
  /@mtrx CM def 
  gsave 
  2 copy T 
  2 index sub neg exch 
  3 index sub exch Atan 
  rotate newpath 
} def
%
/EndArrow { @mtrx setmatrix CP grestore end } def % end the ADict
%
/Arrow { 
  CLW mul add dup 
  2 div /w ED 
  mul dup /h ED 
  mul /a ED 
  { 0 h T 1 -1 scale } if 
  w neg h moveto 
  0 0 L w h L w neg a neg rlineto 
  gsave fill grestore 
} def
%
/ArrowD { % the sides are drawn as curves (hv 20071211)
  CLW mul add dup 
  2 div /w ED 
  mul dup /h ED 
  mul /Inset ED 
  { 0 h T 1 -1 scale } if % changes the direction
% we use y=w/h^2 * x^2 as equation for the control points
% for the coordinates the arrow is seen from top to bottom
% the bottom (tip) is (0;0)
  w neg h moveto % lower left of >
  w 9 div 4 mul neg h 3 div 2 mul
  w 9 div neg       h 3 div  
  0 0 curveto    % tip of >
  w 9 div        h 3 div  
  w 9 div 4 mul  h 3 div 2 mul
  w h curveto % upper left of >
  w neg Inset neg rlineto % move to x=0 and inset
  gsave fill grestore 
} def 
%
/Tbar { 
  CLW mul add /z ED 
  z -2 div CLW 2 div moveto 
  z 0 rlineto stroke 
  0 CLW moveto 
} def
%
/Bracket { 
  CLW mul add dup CLW sub 2 div 
  /x ED mul CLW add /y ED /z CLW 2 div def 
  x neg y moveto 
  x neg CLW 2 div L x CLW 2 div L x y L stroke 
  0 CLW moveto 
} def
%
/RoundBracket { 
  CLW mul add dup 2 div 
  /x ED mul /y ED /mtrx CM def 
  0 CLW 2 div T x y mul 0 ne { x y scale } if 
  1 1 moveto 
  .85 .5 .35 0 0 0 curveto 
  -.35 0 -.85 .5 -1 1 curveto 
  mtrx setmatrix stroke 0 CLW moveto 
} def
%
/SD { 0 360 arc fill } def
%
/EndDot { % DS is the dot size 
  { /z DS def } { /z 0 def } ifelse  	% outer or inner dimen 
  /b ED 				% the color definition
  0 z DS SD 
  b { 0 z DS CLW sub SD } if 
  0 DS z add CLW 4 div sub 
  moveto 
} def
%
/Shadow { [ { /moveto load } { /lineto load } { /curveto load } {
  /closepath load } /pathforall load stopped { pop pop pop pop CP /moveto
  load } if ] cvx newpath 3 1 roll T exec } def
%
/NArray { % holds the coordinates and on top of stack the showpoints boolean
  /showpoints ED 
  counttomark 2 div dup cvi /n ED  	% n 2 div on stack 
  n eq not { exch pop } if		% even numbers of points? delete one
  ] aload /Points ED 
  showpoints not { Points aload pop } if
%    { ] aload /Points ED } 
%    { n 2 mul 1 add -1 roll pop } ifelse	% delete the mark symbol 
} def
%
/Line { 
  NArray n 0 eq not 
    { n 1 eq { 0 0 /n 2 def } if ArrowA /n n 2 sub def 
      n { Lineto } repeat 
      CP 4 2 roll ArrowB L pop pop 
    } if 
} def
%
/LineToYAxis {
  /Ox ED		% Save the x origin value 
  NArray            % all x-y pairs on stack
  n { 2 copy moveto % go to current point
    Ox exch Lineto   % line to y-axis
    pop             % delete old x-value
  } repeat
} def
%
/LineToXAxis{
  /Oy ED		% Save the y origin value 
  NArray		% all x-y pairs on stack
  n 0 eq not
    { n 1 eq { 0 0 /n 2 def } if
      ArrowA
      /n n 2 sub def
      CP 2 copy moveto pop Oy Lineto
      n { 2 copy moveto pop Oy Lineto } repeat
      CP
      4 2 roll
      ArrowB
      2 copy moveto pop Oy
      L
      pop pop } if
} def
%
/Arcto { 
  /a [ 6 -2 roll ] cvx def 
  a r 
  /arcto load stopped { 5 } { 4 } ifelse { pop } repeat 
  a 
} def
%
/CheckClosed { 
  dup n 2 mul 1 sub index eq 2 index n 2 mul 1 add index eq
  and { pop pop /n n 1 sub def } if 
} def
%
/Polygon { 
  NArray n 2 eq { 0 0 /n 3 def } if 
  n 3 lt 
    { n { pop pop } repeat } 
    { n 3 gt { CheckClosed } if 
      n 2 mul -2 roll 
      /y0 ED /x0 ED /y1 ED /x1 ED  
      x1 y1 
      /x1 x0 x1 add 2 div def 
      /y1 y0 y1 add 2 div def 
      x1 y1 moveto 
      /n n 2 sub def 
      n { Lineto } repeat 
      x1 y1 x0 y0 6 4 roll Lineto
      Lineto pop pop closepath } ifelse 
} def
%
/SymbolPolygon {   % on stack [ x y x y ...
  counttomark 					% number of elements
  2 add /m ED
  2 copy m 2 roll				% copy last two
  m 2 div cvi /n ED    				% n pairs
  /YA ED /XA ED					% the start point
  n 1 sub { 
    /YB ED /XB ED
    /XLength XB XA sub def
    /YLength YB YA sub def
    /PAngle YLength XLength Atan def
    /XYLength XLength YLength Pyth def
    /nSym XYLength SymStep Div cvi def
    /Shift Symbol stringwidth pop 2 Div def 
    /deltaX XLength nSym Div def
    /deltaY YLength nSym Div def
    XA Shift sub YA Shift sub moveto 
    nSym { 
      gsave rotateSymbol { PAngle 180 sub CorrAngle sub rotate } if
      Symbol show 
      grestore 
      deltaX deltaY rmoveto
    } repeat
%    XB Shift sub YB Shift sub moveto Symbol show
    /YA YB def /XA XB def
  } repeat 
  pop	% delete the mark symbol
} def
%
/Diamond { 
  /mtrx CM def 
  T rotate 
  /h ED 
  /w ED 
  dup 0 eq { pop } { CLW mul neg 
    /d ED 
    /a w h Atan def 
    /h d a sin Div h add def 
    /w d a cos Div w add def } ifelse 
  mark w 2 div h 2 div w 0 0 h neg w neg 0 0 h w 2 div h 2 div 
  /ArrowA { moveto } def 
  /ArrowB { } def 
  false Line 
  closepath mtrx setmatrix } def
%
/Triangle { 
  /mtrx CM def 
  translate 
  rotate /h ED 2 div /w ED 
  dup CLW mul /d ED 
  /h h d w h Atan sin Div sub def 
  /w w d h w Atan 2 div dup cos exch sin Div mul sub def 
  mark 
  0 d w neg d 0 h w d 0 d 
  /ArrowA { moveto } def 
  /ArrowB { } def 
  false 
  Line 
  closepath 
  mtrx
% DG/SR modification begin - Jun.  1, 1998 - Patch 3 (from Michael Vulis)
% setmatrix } def
  setmatrix pop 
} def
% DG/SR modification end
%
/CCA { 
  /y ED /x ED 
  2 copy y sub /dy1 ED 
  x sub /dx1 ED 
  /l1 dx1 dy1 Pyth def 
} def
%
/CC { 
  /l0 l1 def 
  /x1 x dx sub def 
  /y1 y dy sub def 
  /dx0 dx1 def 
  /dy0 dy1 def 
  CCA 
  /dx dx0 l1 c exp mul dx1 l0 c exp mul add def 
  /dy dy0 l1 c exp mul dy1 l0 c exp mul add def 
  /m dx0 dy0 Atan dx1 dy1 Atan sub 2 div cos abs b exp a mul dx dy Pyth Div 2 div def 
  /x2 x l0 dx mul m mul sub def
  /y2 y l0 dy mul m mul sub def 
  /dx l1 dx mul m mul neg def 
  /dy l1 dy mul m mul neg def 
} def
%
/IC { 
  /c c 1 add def 
  c 0 lt { /c 0 def } { c 3 gt { /c 3 def } if } ifelse 
  /a a 2 mul 3 div 45 cos b exp div def 
  CCA 
  /dx 0 def 
  /dy 0 def 
} def
%
/BOC { IC CC x2 y2 x1 y1 ArrowA CP 4 2 roll x y curveto } def
/NC { CC x1 y1 x2 y2 x y curveto } def
/EOC { x dx sub y dy sub 4 2 roll ArrowB 2 copy curveto } def
/BAC { IC CC x y moveto CC x1 y1 CP ArrowA } def
/NAC { x2 y2 x y curveto CC x1 y1 } def
/EAC { x2 y2 x y ArrowB curveto pop pop } def
%
/OpenCurve { 
  NArray n 3 lt 
    { n { pop pop } repeat } 
    { BOC /n n 3 sub def n { NC } repeat EOC } ifelse 
} def
%
/CurvePath { 
  %% for negative SymStep we calculate the distance 
  SymStep 0 lt { gsave PathLength SymStep div abs /SymStep ED grestore } if
  0.5 setflat
  flattenpath /z 0 def /z0 0 def
  { /y1 ED /x1 ED /y2 y1 def /x2 x1 def 
    x1 Shift sub y1 Shift sub moveto 
    gsave 
    curveticks 
      { x1 y1 translate startAngle rotate 
        0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
        SymbolLinewidth setlinewidth stroke      
      }
      { startAngle rotate Symbol show }
    ifelse 
    grestore /z0 z def }
  { /y ED /x ED PathLength@ z z0 sub SymStep ge {
      x Shift sub y Shift sub moveto 
      gsave 
      curveticks 
        { y yOld sub x xOld sub Atan 180 sub CorrAngle sub /rotAngle ED  
          x y translate rotAngle rotate 
          0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
          SymbolLinewidth setlinewidth stroke
        }
        { 
          rotateSymbol { y yOld sub x xOld sub Atan 180 sub CorrAngle sub rotate } if        
          Symbol show 
        }
      ifelse 
      grestore /z0 z def } if 
    /yOld y def /xOld x def } 
  {} %% the lineto part
  { /y y2 def /x x2 def PathLength@ 
    x Shift sub y Shift sub moveto 
    gsave
    curveticks 
      { y yOld sub x xOld sub Atan 180 sub /rotAngle ED  
        x y translate rotAngle rotate 
        0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
        SymbolLinewidth setlinewidth stroke
      }
      { 
        x Shift sub y Shift sub moveto 
        rotateSymbol { y yOld sub x xOld sub Atan 180 sub CorrAngle sub rotate } if        
        Symbol show 
      }
    ifelse 
    grestore
  }
  pathforall 
%  curveticks 
%   { gsave 
%     x y translate rotAngle rotate 
%     0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
%     SymbolLinewidth setlinewidth stroke grestore
%   } if
  z 
} def
%
/OpenSymbolCurve { 
  OpenCurve
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/AltCurve { 
  { false NArray n 2 mul 2 roll 
    [ n 2 mul 3 sub 1 roll ] aload
    /Points ED 
    n 2 mul -2 roll } 
  { false NArray } ifelse 
  n 4 lt { n { pop pop } repeat } { BAC /n n 4 sub def n { NAC } repeat EAC } ifelse 
} def
%
/AltOpenSymbolCurve { 
  AltCurve
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/ClosedCurve { 
  NArray n 3 lt 
    { n { pop pop } repeat } 
    { n 3 gt { CheckClosed } if 
      6 copy n 2 mul 6 add 6 roll 
      IC CC x y moveto n { NC } repeat 
      closepath pop pop 
    } ifelse 
} def
%
/ClosedSymbolCurve { 
  ClosedCurve
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/CalcBezierSpline {%  Christoph Bersch
  10 dict begin
  /getX { Points exch 2 mul get } def
  /getY { Points exch 2 mul 1 add get } def
  /n Points length 1 sub 2 idiv def
  /GetFirstControlPoints {
    /x n array def
    /tmp n array def
    /b 2 def
    x 0 rhs 0 get b div put
    1 1 n 1 sub {
      /i exch def
      tmp i 1 b div dup 4 1 roll put
      i n 1 sub lt { 4 }{ 3.5 } ifelse exch sub /b exch def
      x i rhs i get x i 1 sub get sub b div put
    } for
    1 1 n 1 sub {
      n exch sub
      dup dup x exch 1 sub 2 copy 6 2 roll
      get 3 1 roll tmp exch get
      exch x exch get mul sub
      put	
    } for
    x
  } def
  % 
  n 1 eq {
    0 getX 2 mul 1 getX add 3 div
    0 getY 2 mul 1 getY add 3 div
    exch dup 3 1 roll 2 mul 0 getX sub
    exch dup 3 1 roll 2 mul 0 getY sub
    [ 0 getX 0 getY 7 3 roll 1 getX 1 getY ] /outPoints exch def
  } {
    /outPoints 6 n mul 2 add array def
    0 1 n {
      dup dup 6 mul dup 1 add
      outPoints exch 5 -1 roll getY put
      outPoints exch 3 -1 roll getX put
    } for
    /rhs n array def
    1 1 n 2 sub {
      rhs exch dup dup getX 4 mul exch 1 add getX 2 mul add put
    } for
    rhs 0 0 getX 1 getX 2 mul add put
    rhs n 1 sub dup getX 8 mul n getX add 2 div put
    GetFirstControlPoints
    1 1 n 2 sub {
      rhs exch dup dup getY 4 mul exch 1 add getY 2 mul add put
    } for
    rhs 0 0 getY 1 getY 2 mul add put
    rhs n 1 sub dup getY 8 mul n getY add 2 div put
    GetFirstControlPoints
    0 1 n 1 sub {
      /i exch def
      2 copy
      i get outPoints 6 i mul 3 add 3 -1 roll put
      i get outPoints 6 i mul 2 add 3 -1 roll put
      2 copy
      i n 1 sub lt {
        i 1 add get i 1 add getY 2 mul exch sub outPoints 6 i mul 5 add 3 -1 roll put
        i 1 add get i 1 add getX 2 mul exch sub outPoints 6 i mul 4 add 3 -1 roll put
      }{
        n 1 sub get n getY add 2 div outPoints 6 n 1 sub mul 5 add 3 -1 roll put
        n 1 sub get n getX add 2 div outPoints 6 n 1 sub mul 4 add 3 -1 roll put
      } ifelse
    } for
    pop pop
  } ifelse
  outPoints
  end
} def
/Spline {
  /showpoints ED
  counttomark 2 div dup cvi /n ED
  n eq not { exch pop } if
  ] /Points ED
  n 1 gt {
    CalcBezierSpline
    mark exch aload pop
    ArrowA
    n 2 sub {
      6 2 roll 4 2 roll curveto
    } repeat
    6 2 roll 4 2 roll ArrowB curveto
  } if
} def
/OpenSymbolSpline {
  Spline
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/SQ { /r ED r r moveto r r neg L r neg r neg L r neg r L fill } def
/ST { /y ED /x ED x y moveto x neg y L 0 x L fill } def
/SP { /r ED gsave 0 r moveto 4 { 72 rotate 0 r L } repeat fill grestore } def
%
/FontDot { 
  DS 2 mul dup 
  matrix scale matrix concatmatrix exch matrix
  rotate matrix concatmatrix exch 
  findfont exch makefont setfont 
} def
%
/Rect { 
  x1 y1 y2 add 2 div moveto 
  x1 y2 lineto 
  x2 y2 lineto 
  x2 y1 lineto
  x1 y1 lineto 
  closepath 
} def
%
/OvalFrame { 
  x1 x2 eq y1 y2 eq or 
    { pop pop x1 y1 moveto x2 y2 L } 
    { y1 y2 sub abs x1 x2 sub abs 2 copy gt 
      { exch pop } { pop } ifelse 
      2 div exch { dup 3 1 roll mul exch } if 
      2 copy lt { pop } { exch pop } ifelse
      /b ED 
      x1 y1 y2 add 2 div moveto 
      x1 y2 x2 y2 b arcto 
      x2 y2 x2 y1 b arcto
      x2 y1 x1 y1 b arcto 
      x1 y1 x1 y2 b arcto 
      16 { pop } repeat 
      closepath 
    } ifelse 
} def
%
/Frame { 
  CLW mul /a ED 
  3 -1 roll 
  2 copy gt { exch } if 
  a sub /y2 ED 
  a add /y1 ED 
  2 copy gt { exch } if 
  a sub /x2 ED 
  a add /x1 ED 
  1 index 0 eq { pop pop Rect } { OvalFrame } ifelse 
} def
%
/BezierNArray { 
  /f ED 
  counttomark 2 div dup cvi /n ED 
  n eq not { exch pop } if 
  n 1 sub neg 3 mod 3 add 3 mod { 0 0 /n n 1 add def } repeat 
  f { ] aload /Points ED } { n 2 mul 1 add -1 roll pop } ifelse 
} def
%
/OpenBezier { 
  BezierNArray 
  n 1 eq 
    { pop pop } 
    { ArrowA n 4 sub 3 idiv 
      { 6 2 roll 4 2 roll curveto } repeat 
      6 2 roll 4 2 roll ArrowB curveto } ifelse 
} def
%
/OpenSymbolBezier { 
  OpenBezier
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/ClosedBezier { 
  BezierNArray 
  n 1 eq 
    { pop pop } 
    { moveto n 1 sub 3 idiv 
      { 6 2 roll 4 2 roll curveto } repeat 
      closepath } ifelse 
} def
%
/ClosedSymbolBezier { 
  /f ED				 % save showpoints value 
  2 copy /yEnd ED /xEnd ED
  counttomark -2 roll 2 copy /yStart ED /xStart ED
  counttomark 2 roll
  f
  ClosedBezier
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
  [ xEnd yEnd xStart yStart SymbolLine 
} def
%
/BezierShowPoints { 
  gsave 
  Points aload length 2 div cvi /n ED 
  moveto 
  n 1 sub { lineto } repeat 
  CLW 2 div SLW [ 4 4 ] 0 setdash stroke 
  grestore 
} def
%
/Parab { 
  /y0 ED /x0 ED /y1 ED /x1 ED 
  /dx x0 x1 sub 3 div def 
  /dy y0 y1 sub 3 div def 
  x0 dx sub y0 dy add x1 y1 ArrowA
  x0 dx add y0 dy add x0 2 mul x1 sub y1 ArrowB 
  curveto 
  /Points [ x1 y1 x0 y0 x0 2 mul x1 sub y1 ] def 
} def
%
/Parab1 { % 1 end  |  0 SP
  /ySP ED /xSP ED /y1 ED /x1 ED 
  /dx xSP x1 sub 3 div def 
  /dy ySP y1 sub 3 div def 
  newpath x1 y1 moveto xSP y1 lineto xSP ySP lineto 
                       x1 ySP lineto closepath clip 
  currentpoint
  newpath moveto
  xSP dx sub ySP dy add x1 y1 ArrowA
  xSP dx add ySP dy add xSP 2 mul x1 sub y1 ArrowB 
  curveto 
  /Points [ x1 y1 xSP ySP xSP 2 mul x1 sub y1 ] def 
} def
%
/Grid { 
  newpath 
  /a 4 string def 
  /b ED % 				psk@gridlabels in pt
  /c ED % 				{ \pst@usecolor\psgridlabelcolor }
  /n ED % 				psk@griddots
  cvi dup 1 lt { pop 1 } if 
  /s ED % 				\psk@subgriddiv
  s div dup 0 eq { pop 1 } if 
  /dy ED s div dup 0 eq { pop 1 } if %	\pst@number\psyunit abs
  /dx ED dy div round dy mul %		\pst@number\psxunit abs
  /y0 ED dx div round dx mul 
  /x0 ED dy div round cvi 
  /y2 ED dx div round cvi 
  /x2 ED dy div round cvi 
  /y1 ED dx div round cvi 
  /x1 ED 
  /h y2 y1 sub 0 gt { 1 } { -1 } ifelse def 
  /w x2 x1 sub 0 gt { 1 } { -1 } ifelse def 
  b 0 gt { 
    /z1 b 4 div CLW 2 div add def
%    /Helvetica findfont b scalefont setfont 
    /b b .95 mul CLW 2 div add def } if 
  systemdict /setstrokeadjust known 
    { true setstrokeadjust /t { } def }
    { /t { transform 0.25 sub round 0.25 add exch 0.25 sub round 0.25 add
       exch itransform } bind def } ifelse 
  gsave n 0 gt { 1 setlinecap [ 0 dy n div ] dy n div 2 div setdash } { 2 setlinecap } ifelse 
  /i x1 def 
  /f y1 dy mul n 0 gt { dy n div 2 div h mul sub } if def 
  /g y2 dy mul n 0 gt { dy n div 2 div h mul add } if def 
  x2 x1 sub w mul 1 add dup 1000 gt { pop 1000 } if 
  { i dx mul dup y0 moveto 
    b 0 gt 
      { gsave c i a cvs dup stringwidth pop 
        /z2 ED w 0 gt {z1} {z1 z2 add neg} ifelse 
	h 0 gt {b neg}{z1} ifelse 
        rmoveto show grestore } if 
    dup t f moveto 
    g t L stroke 
    /i i w add def 
  } repeat 
  grestore 
  gsave 
  n 0 gt
  % DG/SR modification begin - Nov. 7, 1997 - Patch 1
  %{ 1 setlinecap [ 0 dx n div ] dy n div 2 div setdash }
    { 1 setlinecap [ 0 dx n div ] dx n div 2 div setdash }
  % DG/SR modification end
    { 2 setlinecap } ifelse 
  /i y1 def 
  /f x1 dx mul n 0 gt { dx n div 2 div w mul sub } if def 
  /g x2 dx mul n 0 gt { dx n div 2 div w mul add } if def 
  y2 y1 sub h mul 1 add dup 1000 gt { pop 1000 } if 
  { newpath i dy mul dup x0 exch moveto 
    b 0 gt { gsave c i a cvs dup stringwidth pop 
      /z2 ED 
      w 0 gt {z1 z2 add neg} {z1} ifelse 
      h 0 gt {z1} {b neg} ifelse 
      rmoveto show grestore } if 
    dup f exch t moveto 
    g exch t L stroke 
    /i i h add def 
  } repeat 
  grestore 
} def
%
/ArcArrow { 
  /d ED /b ED /a ED 
  gsave 
  newpath 0 -1000 moveto clip 
  newpath 
  0 1 0 0 b 
  grestore 
  c mul 
  /e ED 
  pop pop pop r a e d PtoC y add exch x add
  exch r a PtoC y add exch x add exch b pop pop pop pop a e d CLW 8 div c
  mul neg d 
} def
%
%
/isbool { type (booleantype) cvn eq } def
%
/Ellipse { 
  dup isbool { /MoveToStart ED }{ /MoveToStart false def }ifelse  % false or true
  /rotAngle ED
  /mtrx CM def 
  T 
  rotAngle rotate
  scale 
  MoveToStart { 0 0 moveto 1 0 rmoveto } if  % move to the start position
  0 0 1 5 3 roll arc 
  mtrx setmatrix 
} def
%
/ArcAdjust { %%%% Vincent Guirardel
% given a target length (targetLength) and an initial angle (angle0) [in the stack],
% let  M(angle0)=(rx*cos(angle0),ry*sin(angle0))=(x0,y0).
% This computes an angle t such that (x0,y0) is at distance 
% targetLength from the point M(t)=(rx*cos(t),ry*sin(t)).
% NOTE: this an absolute angle, it does not have to be added or substracted to angle0
% contrary to TvZ's code.
% To achieve, this, one iterates the following process: start with some angle t,
% compute the point M' at distance targetLength of (x0,y0) on the semi-line [(x0,y0) M(t)].
% Now take t' (= new angle) so that (0,0) M(t') and M' are aligned.
%
% Another difference with TvZ's code is that we need d (=add/sub) to be defined.
% the value of d = add/sub is used to know on which side we have to move.
% It is only used in the initialisation of the angle before the iteration.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Input stack:  1: target length 2: initial angle
% variables used : rx, ry, d (=add/sub)
%
  /targetLength ED /angle0 ED
  /x0 rx angle0 cos mul def
  /y0 ry angle0 sin mul def
% we are looking for an angle t such that (x0,y0) is at distance targetLength 
% from the point M(t)=(rx*cos(t),ry*sin(t)))
%initialisation of angle (using 1st order approx = TvZ's code)
  targetLength 57.2958 mul
  angle0 sin rx mul dup mul
  angle0 cos ry mul dup mul
  add sqrt div 
% if initialisation angle is two large (more than 90 degrees) set it to 90 degrees
% (if the ellipse is very curved at the point where we draw the arrow, %
% the value can be much more than 360 degrees !)
% this should avoid going on the wrong side (more than 180 degrees) or go near
% a bad attractive point (at 180 degrees)
  dup 90 ge { pop 90 } if 
  angle0 exch d % add or sub
% maximum number of times to iterate the iterative procedure:
% iterative procedure: takes an angle t on top of stack, computes a 
% better angle (and put it on top of stack)
  30 { dup
% compute distance D between (x0,y0) and M(t)
    dup cos rx mul x0 sub dup mul exch sin ry mul y0 sub dup mul add sqrt
% if D almost equals targetLength, we stop
    dup targetLength sub abs 1e-5 le { pop exit } if
% stack now contains D t
% compute the point M(t') at distance targetLength of (x0,y0) on the semi-line [(x0,y0) M(t)]:
% M(t')= ( (x(t)-x0)*targetLength/d+x0 , (y(t)-y0)*targetLength/d+y0 )
    exch dup cos rx mul x0 sub  exch sin ry mul y0 sub
% stack contains:  y(t)-y0, x(t)-x0, d
    2 index Div targetLength mul y0 add ry Div exch
    2 index Div targetLength mul x0 add rx Div
% stack contains x(t')/rx , y(t')/ry , d
% now compute t', and remove D from stack
    atan exch pop
  } repeat
% we don't look at what happened... in particular, if targetLength is greater 
% than the diameter of the ellipse...
% the final angle will be around /angle0 + 180. maybe we should treat this pathological case...
% after iteration, stack contains an angle t such that M(t) is the tail of the arrow
% to give back the result as a an angle relative to angle0 we could add the following line:
% angle0 sub 0 exch d
%
% begin bug fix 2006-01-11
% we want to adjust the new angle t' by a multiple of 360 so that  | t'-angle0 | <= 180
%(we don't want to make the ellipse turn more or less than it should)...
dup angle0 sub dup abs 180 gt { 180 add 360 div floor 360 mul sub } { pop } ifelse
% end bug fix
} def
%
/EllipticArcArrow {
  /d ED      % is add or sub
  /b ED      % arrow procedure
  /a1 ED     % angle
  gsave
  newpath
  0 -1000 moveto
  clip                  % Set clippath far from arrow.
  newpath
  0 1 0 0 b             % Draw arrow to determine length.
  grestore
% Length of arrow is on top of stack. Next 3 numbers are junk.
%
  a1 exch ArcAdjust   % Angular position of base of arrow.
  /a2 ED
  pop pop pop
  a2 cos rx mul xOrig add % hv 2007-08-29   x->xOrig
  a2 sin ry mul yOrig add % hv 2007-08-29   y->yOrig
  a1 cos rx mul xOrig add % 
  a1 sin ry mul yOrig add % 
% Now arrow tip coor and base coor are on stack.
  b pop pop pop pop       % Draw arrow, and discard coordinates.
  a2 CLW 8 div
% change value of d (test it by looking if  `` 1 1 d '' gives 2 or not )
  1 1 d 2 eq { /d { sub } def } { /d { add } def } ifelse
  ArcAdjust
% resets original value of d
  1 1 d 2 eq { /d { sub } def } { /d { add } def } ifelse  % Adjust angle to give overlap.
} def
%%------------------ tvz/DG/hv (2004-05-10) end -------------------%%
%
/Rot { CP CP translate 3 -1 roll neg rotate NET  } def
%
/RotBegin { 
  tx@Dict /TMatrix known not { /TMatrix { } def /RAngle { 0 } def } if 
  /TMatrix [ TMatrix CM ] cvx def 
  /a ED 
  a Rot /RAngle [ RAngle dup a add ] cvx def 
} def
%
/RotEnd { 
  /TMatrix [ TMatrix setmatrix ] cvx def 
  /RAngle [ RAngle pop ] cvx def 
} def
%
/PutCoor { gsave CP T CM STV exch exec moveto setmatrix CP grestore } def
/PutBegin { /TMatrix [ TMatrix CM ] cvx def CP 4 2 roll T moveto } def
/PutEnd { CP /TMatrix [ TMatrix setmatrix ] cvx def moveto } def
%
/Uput {
  /a ED 
  add 2 div /h ED 2 
  div /w ED 
  /s a sin def 
  /c a cos def 
  /b s abs c abs 2 copy gt dup 
    /q ED 
    { pop } { exch pop } ifelse def 
  /w1 c b div w mul def 
  /h1 s b div h mul def 
  q { w1 abs w sub dup c mul abs }{ h1 abs h sub dup s mul abs } ifelse 
} def
%
/UUput { 
  5 dict begin
  /z ED 
  abs /y ED 
  /x ED 
  q { x s div c mul abs y gt }{ x c div s mul abs y gt } ifelse 
    { x x mul y y mul sub z z mul add sqrt z add } 
    { q { x s div } { x c div } ifelse abs 
    } ifelse 
  a PtoC 
  h1 add exch 
  w1 add exch 
  end
} def
%
end
%-----------------------------------------------------------------------------%
%
% END pstricks.pro

%%EndProcSet
%%BeginProcSet: pst-algparser.pro 0 0
% $Id: pst-algparser.pro 446 2017-04-19 11:40:55Z herbert $
%%
%% PostScript prologue for PSTricks algorithm parser
%% Version 0.07, 2014/08/01
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%%
%%-----------------------------------------------------------------------------%
%
%currentdict /Pi known not { /Pi 3.14159265359 def } if
%
/AlgParser { tx@AlgToPs begin AlgToPs end } def  % Dominique Rodriguez
/I2P { AlgParser cvx exec } def  % Infix to Postfix
%
/tx@CoreAnalyzerDict 100 dict def tx@CoreAnalyzerDict begin
%
% PS ANALYZER FOR ALGEBRAIC EXPRESSION V1.13
%
% 09/2011 DR factorial with ! added
%
% E->T|E+T
% T->FS|T*FS
% FS -> F | +FS | -FS
% F->P|F^SF|P!
% P->(E)|literal
% literal->number|var|var[E]|func(params)
% params->E|E,param
% number->TOBEFINISHED
%
%% E expression, T term, SF signed factor, F factor, P power
%
%% parser
%
%% str
%
%% C->E<condition_operators>E
%% STR index -> STR index+lenExpr
/AnalyzeCond { AnalyzeExpr ReadCondOp AnalyzeExpr EvalCondOp  } def
%
%% analyze Expression List (separator , or | )
%% STR index -> STR index+lenExpr
%% /AnalyzeListOfE {
%%   { NextNonBlankChar pop AnalyzeExpr%%dup Strlen eq { exit } if NextNonBlankChar
%%     NextNonBlankChar dup 0 eq { pop exit } if
%%     dup 44 ne 1 index 124 ne and { dup 41 ne { PROBLEMCONTACTBILLOU } { pop exit } ifelse } if
%%     pop NextNonBlankChar dup 0 eq { exit } if 124 ne { PROBLEMCONTACTBILLOU } if 1 add NextNonBlankChar 0 eq {toto} if } loop
%%   AnalyzeListOfEPostHook
%% } def
/AnalyzeListOfE {
  /NotFirst false def
  { NextNonBlankChar pop AnalyzeExpr
    NotFirst { EvalListOfExpr } { /NotFirst true def } ifelse
    dup Strlen eq { exit } if NextNonBlankChar
    dup 44 ne 1 index 124 ne and
    { dup 41 ne { PROBLEMCONTACTBILLOU } { pop exit } ifelse }
    if  pop 1 add } loop
  AnalyzeListOfEPostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% E->T|E+T
%% STR index -> STR index+lenExpr
/AnalyzeExpr {
  AnalyzePreHook AnalyzeTerm IsEndingExpr
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { RollOp 1 add NextNonBlankChar pop AnalyzeTerm PreEvalHook EvalAddSub IsEndingExpr { pop exit } if } loop }
  ifelse
  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% T->FS|T*FS
%% STR index
/AnalyzeTerm {
  AnalyzePreHook AnalyzeSignedFactor IsEndingTerm
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { RollOp 1 add NextNonBlankChar pop AnalyzeSignedFactor PreEvalHook EvalMulDiv IsEndingTerm { pop exit } if} loop }
  ifelse
  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% FS -> F | +FS | -FS
%% STR index
/AnalyzeSignedFactor {
  AnalyzePreHook 2 copy get dup IsUnaryOp
  { RollOp 1 add NextNonBlankChar pop AnalyzeSignedFactor EvalUnaryOp }
  { pop AnalyzeFactor }
  ifelse AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% F->P|F^P|P!
%% STR index
/AnalyzeFactor {
  AnalyzePreHook AnalyzePower IsEndingFactor
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { dup 33 eq%% is there a ! DR 09/2011
      { pop 1 add NextNonBlankChar pop EvalFactorial }
      { RollOp 1 add NextNonBlankChar pop AnalyzePower PreEvalHook EvalPower }
      ifelse
      IsEndingFactor { pop exit } if } loop }
  ifelse  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% P->(E)|literal
%% STR index
/AnalyzePower {
  %% depending of first char either a number, or a literal
  2 copy get dup 40 eq%%an open par
  { pop 1 add NextNonBlankChar pop AnalyzeExpr 1 add NextNonBlankChar pop }
  { AnalyzeLiteral }
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index STR[index] -> STR index
%/AnalyzeLiteral { IsNumber { EvalNumber } { EvalLiteral } ifelse } def
/AnalyzeLiteral { dup IsUnaryOp exch IsNumber or { EvalNumber } { EvalLiteral } ifelse } def%%dr 09102006
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% recognize + or -
%% chr -> T/F
/IsUnaryOp { dup 43 eq exch 45 eq or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a number can contain only : 0123456789.
%% chr -> T/F
/IsNumber { dup 48 ge exch dup 57 le 3 -1 roll and exch 46 eq or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index number
%% a number can be of the form [0-9]*.[0-9]*\([eE][+-]?[0-9]+\)?
%% STR index -> STR index' number
/ReadNumber {
  exch dup 3 -1 roll dup 3 1 roll
  %%read mantissa
  { 1 add  2 copy dup Strlen eq { pop pop 0 exit } if get dup IsNumber not { exit } if pop } loop
  dup 101 eq exch 69 eq or
  %%% there is a "e" or "E" -> read exponant
  { 1 add 2 copy get dup IsUnaryOp
    { pop 1 add 2 copy get } if
    { IsNumber not { exit } if 1 add 2 copy get } loop }
  if
  dup 4 1 roll
  3 -1 roll exch 1 index sub getinterval
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a number can contain only : 0123456789.
%% chr -> T/F
/IsCondOp { dup 30 eq exch dup 60 ge exch 62 le and or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index number
%% a number can be of the form [0-9]*.[0-9]*\([eE][+-]?[0-9]+\)?
%% STR index -> STR index' number
/ReadCondOp {
  NextNonBlankChar 1 index 4 1 roll
  { IsCondOp not { exit } if 1 add  2 copy get } loop
  2 copy 5 -1 roll
  exch 1 index sub getinterval 3 1 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a literal can contain only : 0123456789.
%% chr -> T/F
/IsLiteral {%
  dup 48 ge exch dup  57 le 3 -1 roll and exch
  dup 65 ge exch dup  90 le 3 -1 roll and 3 -1 roll or exch
  dup 97 ge exch     122 le and or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a literal can be of the form [a-zA-Z][a-zA-Z0-9]*\(\((Expression)\)|\(\[Expression\]\)\)?
%% STR index -> literal STR index' nextchr
/ReadLiteral {
  exch dup 3 -1 roll dup 3 1 roll
  %%read literal core
  { 2 copy dup Strlen eq { pop pop 0 exit } if get dup IsLiteral not { exit } if pop 1 add } loop
  4 1 roll dup 5 1 roll 3 -1 roll exch 1 index sub getinterval 4 1 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or a clpar
%% STR index -> STR index STR[index] T/F
/IsEndingExpr {%
  2 copy dup Strlen eq
  %% if end of str is reached -> end !
  { pop pop 0 true }
  %% ending chr -> clpar, comma, |, <, >, =, !,
  {get dup  dup  41 eq
       exch dup 124 eq
       exch dup  93 eq
       exch dup  44 eq
       exch dup  30 eq
       exch dup  60 ge exch 62 le and or or or or or}
  ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or a +-
%% STR index -> STR index STR[index] T/F
/IsEndingTerm { IsEndingExpr { true } { dup dup 43 eq exch 45 eq or } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or */
%% STR index -> STR index STR[index] T/F
/IsEndingFactor { IsEndingTerm { true } { dup dup 42 eq exch 47 eq or } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or ^
%% STR index -> STR index STR[index] T/F
/IsEndingPower { IsEndingFactor { true } { dup 94 eq } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index STR[index]
/NextNonBlankChar { { dup Strlen eq { 0 exit } if 2 copy get dup neBlkChar { exit } if pop 1 add } loop } bind def
/neBlkChar { dup 32 ne exch dup 10 ne exch 9 ne and and } bind def
%%%%%%%%%%%%%%%%%%%%%%%%
%% DEBUG
/BRK {false} def
/BRKtrue {/BRK true def} def
/BRKStop {BRK {BRKtoto} if } def
/BRKEvalStop {BRK exch if } def
/BRKBRK2true {BRK {BRK2true} if } def
/BRK2 {false} def
/BRK2true {/BRK2 true def} def
/BRK2Stop {BRK2 {BRK2toto} if } def/BRK {false} def
end
%
%-------------------------------------------------------------------------------%
%
/tx@AlgToPs 12 dict def tx@AlgToPs begin
%
%% algExpr -> PSVector
/AlgToPs { tx@CoreAnalyzerDict begin InitParser AnalyzeListOfE pop pop EndingSequence end } def
/EndingSequence { ExpressionVector aload length /end cvx exch 1 add array astore } def
/InitParser { /ExpressionVector [ /tx@AddMathFunc cvx /begin cvx ] def dup length /Strlen exch def 0 } def
/Strlen 0 def
/EvalListOfExpr {} def%
/EvalNumber {%
    ReadNumber  cvr /ExpressionVector ExpressionVector aload length dup 3 add -1 roll cvx
    exch 1 add array astore def NextNonBlankChar pop } def
/EvalAddSub {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  43 eq { /add } { /sub } ifelse cvx exch 1 add array astore def
} def
/EvalMulDiv {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  42 eq { /mul } { /div } ifelse cvx exch 1 add array astore def
} def
/EvalPower {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  pop /exp cvx exch 1 add array astore def
} def
/EvalFactorial {% DR 09/2011
  /ExpressionVector ExpressionVector aload length
  /fact cvx exch 1 add array astore def
} def
/EvalLiteral {%
  ReadLiteral
  dup 40 eq%%% there is an open par -> function call
  { pop 2 index
    dup (Sum) eq { EvalSum }
    { dup (IfTE) eq { EvalCond }
      { dup (Derive) eq { pop EvalDerive }
	{ pop 1 add NextNonBlankChar pop AnalyzeListOfE 2 index TrigoFunc
          /ExpressionVector ExpressionVector aload length dup 5 add -1 roll cvn cvx
	  exch 1 add array astore def 1 add NextNonBlankChar pop } ifelse } ifelse} ifelse }
  { /ExpressionVector ExpressionVector aload length dup 6 add -1 roll cvn cvx exch 1 add array astore def
    dup 91 eq%%% there is an open bracket -> vector element
    { pop 1 add NextNonBlankChar pop AnalyzeExpr
      /ExpressionVector ExpressionVector aload length /cvi cvx exch /get cvx exch 2 add array astore def 1 add }
    { pop NextNonBlankChar pop }
    ifelse}
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% the derive function : Derive(n,f(x))
%% firstparindex lastparindex ->
/EvalDerive {
  %% manage the function descripiton
  1 add ReadNumber 3 1 roll NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  1 add NextNonBlankChar pop
  3 -1 roll cvi
  dup 0 eq
  { pop AnalyzeExpr 3 -1 roll pop 1 add }
  { 1 sub 3 1 roll (x)  exch tx@Derive begin DeriveIndexed end 4 -1 roll
    { (x) tx@Derive begin Derive end } repeat
    ExpressionVector exch /ExpressionVector [] def
    AlgToPs aload length
    /ExpressionVector 1 index 3 add -1 roll aload length dup 3 add -1 roll  /l2 exch def /l1 exch def
    l1 l2 add 1 add l2 neg roll l1 l2 add array astore def 3 -1 roll pop 1 add
    1 index length /Strlen exch def } ifelse
} def
/EvalSum {%
  pop 1 add NextNonBlankChar pop
  %% read the variable name
  ReadLiteral pop NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_Sum } if
  %% read the initial value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the increment value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the limit value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  /ExpressionVector ExpressionVector aload length dup 7 add -3 roll 0 4 1 roll
  5 -1 roll 4 add array astore def
  %% keep ExpressionVector for later and create a new one for internal Sum computation
  ExpressionVector 3 1 roll /ExpressionVector [ 6 -1 roll cvn /exch cvx /def cvx ] def
  1 add NextNonBlankChar pop AnalyzeExpr
  %% add each term
  /ExpressionVector ExpressionVector aload length 1 add /add cvx exch array astore def
  /ExpressionVector 4 -1 roll aload length ExpressionVector cvx /for cvx 3 -1 roll 2 add
  array astore def 3 -1 roll pop 1 add
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Convert to radians if trigo function call
%% (name) ->
/TrigoFunc {
  dup (cos) eq 1 index (sin) eq or exch (tan) eq or
  { /ExpressionVector ExpressionVector aload length 3.1415926 /div cvx 180 /mul cvx 5 -1 roll 4 add
    array astore def
  } if
} def
/EvalCond {%
  pop 1 add AnalyzeCond NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_IfTE } if
  ExpressionVector 3 1 roll /ExpressionVector [] def
  1 add AnalyzeExpr ExpressionVector 3 1 roll /ExpressionVector [] def
  NextNonBlankChar 44 ne { ANALYZER_ERROR_missing_second_comma_in_IfTE } if
  1 add AnalyzeExpr
  NextNonBlankChar 41 ne { ANALYZER_ERROR_missing_ending parenthesis_in_IfTE } if
  ExpressionVector
  /ExpressionVector 6 -1 roll aload length dup
  6 add -1 roll cvx exch dup 4 add -1 roll cvx /ifelse cvx 3 -1 roll 3 add array astore def
  1 add 3 -1 roll pop
} def
%% CondOp STR index
/EvalCondOp {%
  3 -1 roll
  dup (=) eq  { /eq } {%
  dup (<) eq  { /lt } {%
  dup (>) eq  { /gt } {%
  dup (>=) eq { /ge } {%
  dup (<=) eq { /ge } {%
  dup (!=) eq { /ne } { ERROR_non_valid_conditional_operator }
  ifelse } ifelse } ifelse } ifelse } ifelse } ifelse
  cvx exch pop
  /ExpressionVector ExpressionVector aload length dup 3 add -1 roll exch 1 add array astore def } def
/EvalUnaryOp {
  3 -1 roll 45 eq { /ExpressionVector ExpressionVector aload length /neg cvx exch 1 add array astore def } if
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% H O O K S
/AnalyzePreHook {} bind def
/PreEvalHook {} bind def
/AnalyzeListOfEPostHook {} bind def
/AnalyzePostHook {} def
/RollOp { 3 1 roll } bind def
end   %tx@CoreAnalyzerDict
%
%--------------------------------------------------------------------%
%
/tx@Derive 41 dict def tx@Derive begin
%%increase ^^ for each function added
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% algExpr variable -> PSVector
/Derive {
  10240 string 3 1 roll 0 3 1 roll
  /Variable exch def
  tx@CoreAnalyzerDict begin InitParser AnalyzeListOfE end
} def
/Strlen 0 def
/InitParser { dup length /Strlen exch def 0 } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% algExpr variable index -> PSVector
/DeriveIndexed {%
  3 1 roll 10240 string 3 1 roll 0 3 1 roll
  /Variable exch def
  tx@CoreAnalyzerDict begin InitParser pop 4 -1 roll AnalyzeExpr 4 -2 roll pop pop 4 -2 roll exch pop end
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u,v)'=-(u',v')
/EvalListOfExpr {%
  4 2 roll 2 copy 9 -1 roll dup length 4 1 roll putinterval add AddPipe
           2 copy 7 -1 roll dup length 4 1 roll putinterval add
  6 -2 roll pop pop
  2 copy pop 0 6 2 roll GetIntervalNewStr 5 1 roll 2 copy 0 exch getinterval 6 1 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (-u)'=-(u')
/EvalUnaryOp {
  4 -2 roll 4 index (0) eq
  { (0) StrConcat 7 -1 roll pop }
  { 7 -1 roll 45 eq
    { AddSub AddOpPar true } { false } ifelse
    3 1 roll 5 index StrConcat 3 -1 roll { AddClPar } if } ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  7 -2 roll pop pop 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (number)'=0
/EvalNumber { ReadNumber (0) 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u+v)'=u'+v'
/EvalAddSub {%
  7 index dup (0) eq
  { pop true }%% du=0 nothing added
  { dup length exch 5 index 5 index 3 -1 roll putinterval 4 -1 roll add 3 1 roll false }
  ifelse
  5 index dup (0) eq
  { pop { (0) } { 4 -2 roll 2 copy pop 0  6 2 roll GetIntervalNewStr } ifelse }%%dv=0
  { exch
    { 5 -2 roll 7 index 45 eq { AddSub } if false } %%nothing yet added
    { 5 -2 roll 7 index 43 eq%%something yet added
      { AddAdd false } { AddSub AddOpPar true } ifelse }
    ifelse 11 1 roll
    3 -1 roll StrConcat 10 -1 roll { AddClPar } if
    2 copy pop 0 6 2 roll GetIntervalNewStr }
  ifelse
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u*v)' or (u/v)'
/EvalMulDiv { 6 index 42 eq {EvalMul} {EvalDiv} ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u*v)'=u'*v+u*v'
/EvalMul {%
  4 -2 roll 7 index dup (0) eq
  { pop false }%%du=0
  { (1) eq%%du=1
    { false }
    { AddOpPar 7 index StrConcat AddClPar AddMul AddOpPar true } ifelse
    3 1 roll 6 index StrConcat 3 -1 roll { AddClPar } if
    true }%%du!=0
  ifelse
  5 1 roll 5 index (0) eq
  { 5 -1 roll not { (0) StrConcat } if }%%dv=0
  { 5 -1 roll { AddAdd } if
    4 index (1) eq
    { 8 index StrConcat }
    { AddOpPar 8 index StrConcat AddClPar AddMul AddOpPar 4 index StrConcat AddClPar }
    ifelse
  }%%dv!=0
  ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u/v)'=(u'*v-u*v')/v^2
/EvalDiv {%
  4 -2 roll
  4 index (0) eq%%dv=0 -> u'/v
  { 7 index (0) eq { (0) StrConcat } { AddOpPar 7 index StrConcat AddClPar AddDiv 5 index StrConcat } ifelse }
  { 7 index dup (0) eq
    { pop }%%du=0
    { (1) eq%%du=1
      { false }
      { AddOpPar 7 index StrConcat AddClPar AddMul AddOpPar true } ifelse
      3 1 roll 6 index StrConcat 3 -1 roll { AddClPar } if}%%du!=0
    ifelse
      AddSub
      4 index (1) eq
      { 8 index StrConcat }
      { AddOpPar 8 index StrConcat AddClPar AddMul AddOpPar 4 index StrConcat AddClPar }
      ifelse
    %}%%dv!=0
    2 copy GetIntervalNewStr 3 1 roll pop 0 AddOpPar 3 -1 roll StrConcat AddClPar
    AddDiv AddOpPar 5 index StrConcat AddClPar 2 copy (^2) putinterval 2 add }
  ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% str1 index str2 -> str1 index
/StrConcat { dup length 4 2 roll 2 copy 6 -1 roll putinterval 3 -1 roll add } bind def
/GetIntervalNewStr { 0 exch getinterval dup length string copy } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u^v)'=(u^v)'=u'vu^(v-1)+v'u^(v)ln(u)
/EvalPower {%
  4 -2 roll 7 index (0) eq
  {%%if du=0 then (u^v)'=v'ln(u)u^v
    4 index (0) eq
    { (0) StrConcat }%%if dv=0 then (u^v)'=0
    { 4 index (1) ne { AddOpPar 4 index StrConcat (\)*) StrConcat } if
      8 index (e) ne { (ln\() StrConcat 8 index StrConcat (\)*) StrConcat } if
      AddOpPar 8 index StrConcat (\)^\() StrConcat 5 index StrConcat AddClPar } ifelse
  }
  {%%du!=0
    4 index (0) eq
    {%%if dv=0 then (u^v)'=vu'u^(v-1)
      5 index dup IsStrNumber
      { dup (0) eq
        { StrConcat }
        { dup dup (1) eq exch (1.0) eq or
          { StrConcat  }
	  { StrConcat
	    7 index dup (1) ne exch (1.0) ne and%%%dr 09102006 insert du if <> 1
	    { (*\() StrConcat 7 index StrConcat (\)) StrConcat } if%%%dr 09102006
            (*\() StrConcat 8 index StrConcat (\)) StrConcat
            5 index  dup dup (2) eq exch (2.0) eq or
	    { pop } { cvr 1 sub 20 string cvs 3 1 roll (^) StrConcat 3 -1 roll StrConcat } ifelse } ifelse } ifelse }
      { pop AddOpPar 5 index StrConcat (\)*\() StrConcat 8 index StrConcat (\)^\() StrConcat
        5 index StrConcat (-1\)) StrConcat } ifelse
    }
    {%%if dv!=0 and du!=0 then (u^v)'=u'vu^(v-1)+v'u^(v)ln(u)
      7 index (1) ne { AddOpPar 7 index StrConcat (\)*) StrConcat } if
      AddOpPar 5 index StrConcat (\)*\() StrConcat
      8 index StrConcat (\)^\() StrConcat
      5 index StrConcat (-1\)+\() StrConcat
      4 index (1) ne { 4 index StrConcat (\)*\() StrConcat } if
      8 index StrConcat (\)^\() StrConcat
      5 index StrConcat (\)*ln\() StrConcat
      8 index StrConcat AddClPar
    } ifelse
  } ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% No derivative for factorial ! only cst => null derivative
/EvalFactorial {% DR 09/2011
  4 index (0) eq
  { (0) mark 8 -2 roll  cleartomark 2 index 7 index dup 4 index exch sub getinterval exch 6 2 roll }
  { DERIVATIVE_ENGINE_ERROR_no_variable_in_factorial } ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% str -> true/false
/IsStrNumber {%
  true exch
  { dup 48 lt exch dup 57 gt 3 -1 roll or
    exch dup 46 ne%%.
    exch dup 43 ne%%+
    exch 45 ne%%-
    and and and { pop false } if } forall
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalLiteral {%
  ReadLiteral dup 40 eq%%% there is an open par -> function call
  { pop (EvalFunc_             ) 9 4 index StrConcat 0 exch getinterval cvn cvx exec }
  { dup 91 eq%%% there is an open bracket -> vector element
    { DERIVATIVE_ENGINE_ERROR_vector_not_yet_implemented }
    { pop EvalVariable }
    ifelse }
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% first last parpos Expr[first:parpos-1] ->
/EvalVariable { 2 index Variable eq { (1) } { (0) } ifelse 4 -1 roll exch 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (f(u))'=u'f'(u)
/EvalFunc {
  4 2 roll 4 index (1) ne
  { AddOpPar 4 index StrConcat (\)*) StrConcat } if
  (Eval             ) 4 8 index StrConcat 0 exch getinterval cvn cvx exec
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Func derivative -> Eval<func>
/EvalFunc_sin {%
  PreCommonFunc
  { (cos\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_cos {%
  PreCommonFunc
  { (\(-sin\() StrConcat 5 index StrConcat (\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_tan {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse  (/cos\() StrConcat 5 index StrConcat (\)^2) StrConcat } if
  PostCommonFunc } def
/EvalFunc_asin {%
  PreCommonFunc
  { (1/sqrt\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_acos {%
  PreCommonFunc
  { (-1/sqrt\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_atg {%
  PreCommonFunc
  { (1/\(1+\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_floor {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse (/\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_ln {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse (/\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_exp {%
  PreCommonFunc
  {  (exp\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_EXP {%
  PreCommonFunc
  {  (EXP\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_sqrt {%
  PreCommonFunc
  { dup 0 eq { (1) StrConcat } { 1 sub } ifelse (/\(2*sqrt\() StrConcat 5 index StrConcat (\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Fact {%
  PreCommonFunc { DERIVATIVE_ENGINE_ERROR_no_variable_expression_in_Fact } if
  PostCommonFunc } def
/EvalFunc_sh {%
  PreCommonFunc
  { (ch\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_ch {%
  PreCommonFunc
  { (sh\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_th {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse  (/ch\() StrConcat 5 index StrConcat (\)^2) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argsh {%
  PreCommonFunc
  { (1/sqrt\(1+\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argch {%
  PreCommonFunc
  { (1/sqrt\(\() StrConcat 5 index StrConcat (\)^2-1\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argth {%
  PreCommonFunc
  { (1/\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/PreCommonFunc {
  1 add NextNonBlankChar pop 3 -1 roll 5 1 roll AnalyzeExpr 1 add NextNonBlankChar pop
  4 2 roll 4 index (0) eq
  { (0) StrConcat false }
  { 4 index (1)  ne { AddOpPar 4 index StrConcat (\)*) StrConcat } if true } ifelse
} def
/PostCommonFunc {
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
/EvalFunc_Derive {%
  1 add ReadNumber cvi 1 add dup cvr log 1 add cvi string cvs
  4 -1 roll pop 5 1 roll 1 add NextNonBlankChar pop AnalyzeExpr 1 add
  4 -2 roll (Derive\() StrConcat 7 -1 roll StrConcat (,) StrConcat 6 -1 roll StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr 6 -1 roll pop 2 index 6 index dup 4 index exch sub getinterval
  exch 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalFunc_Sum {%
  1 add NextNonBlankChar pop
  %% read the variable name
  ReadLiteral pop 3 -1 roll pop NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_Sum } if
  %% read the initial value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the increment value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_third_comma_in_Sum } if
  %% read the limit value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_fourth_comma_in_Sum } if
  1 add NextNonBlankChar pop dup 6 1 roll 3 -1 roll pop AnalyzeExpr 1 add NextNonBlankChar pop
  4 -2 roll 3 index 8 index dup 9 index exch sub getinterval StrConcat
  4 index StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalFunc_IfTE {%
  3 -1 roll pop 1 add NextNonBlankChar pop SkipCond
  NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_IfTE } if
  1 add NextNonBlankChar pop dup 5 1 roll
  AnalyzeExpr NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_second_comma_in_IfTE } if
  1 add NextNonBlankChar pop
  AnalyzeExpr 1 add NextNonBlankChar pop
  4 -2 roll 3 index 10 index dup 11 index exch sub getinterval StrConcat
  6 index StrConcat (,) StrConcat 4 index StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% advance in str until a comma is found (no error detection!)
%% str index -> str index'
/SkipCond { { 1 add 2 copy get 44 eq {exit } if } loop } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Convert to radians if trigo function call
%% (name) ->
/TrigoFunc {
  dup (cos) eq 1 index (sin) eq or exch (tan) eq or
  { /ExpressionVector ExpressionVector aload length Pi /div cvx 180 /mul cvx 5 -1 roll 4 add
    array astore def
  } if
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% No derivative for condition....
/EvalCondOp { 3 -1 roll pop } bind def
/PutIntervalOneAdd {putinterval 1 add} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddOpPar {2 copy (\() PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add close parenthesis in string at the given index
%% str index -> str index+1
/AddClPar {2 copy (\)) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add 0 in string at the given index
%% str index -> str index+1
/AddZero {2 copy (0) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddMul {2 copy (*) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddDiv {2 copy (/) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a plus sign in string at the given index
%% str index -> str index+1
/AddAdd {2 copy (+) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a minus sign in string at the given index
%% str index -> str index+1
/AddSub {2 copy (-) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a pipe sign in string at the given index
%% str index -> str index+1
/AddPipe {2 copy (|) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% H O O K S
/AnalyzePreHook { dup 5 1 roll } bind def
/PreEvalHook {} def
/AnalyzePostHook { 7 -1 roll pop } bind def
/AnalyzeListOfEPostHook { 6 -1 roll mark 6 1 roll cleartomark } bind def
/RollOp { 5 1 roll } bind def
end%%%tx@CoreAnalyzerDict
/tx@AddMathFunc 12 dict def tx@AddMathFunc begin
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% NEW FUNC
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% function arcsine in radians asin(x)=atan(x/sqrt(1-x^2))
%% x -> theta
/asin {%
  dup abs 1 gt { EQDFasinrangeerror  } if
  dup dup dup mul 1 exch sub sqrt atan exch 0 lt { 360 sub } if DegtoRad
} def
%% function arccosine in radians acos(x)=atan(sqrt(1-x^2)/x)
%% x -> theta
/acos {%
  dup abs 1 gt { EQDFacosrangeerror  } if
  dup dup mul 1 exch sub sqrt exch atan DegtoRad
} def
%% function arctangent in radians
%% x -> theta
/atg { 1 atan dup 90 gt { 360 sub } if DegtoRad } bind def
%% HYPERBOLIC FUNCTIONS
/sh { dup Ex exch neg Ex sub 2 div } def
/ch { dup Ex exch neg Ex add 2 div } def
/th { dup sh exch ch div } def
/Argsh { dup dup mul 1 add sqrt add ln } def
/Argch { dup dup mul 1 sub sqrt add ln } def
/Argth { dup 1 add exch 1 exch sub div ln 2 div } def
%% modified exponential funtion for 0
%% x n -> x^n
/Exp { dup 0 eq { pop pop 1 } { exp } ifelse } bind def
%% modified exponential funtion for 0
%% x -> e^x
/Ex { Euler exch exp } bind def
%%
%% factorial function
%% n -> n!
/Fact { 1 exch 2 exch 1 exch { mul } for } bind def
/fact { Fact } bind def
/! { Fact } bind def
end
%
% END pst-algparser.pro

%%EndProcSet
%%BeginProcSet: pst-tools.pro 0 0
% $Id: pst-tools.pro 842 2013-10-26 10:25:41Z herbert $
%
%% PostScript tools prologue for pstricks.tex.
%% Version 0.04, 2013/10/26
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%
%
/Pi2 1.57079632679489661925640 def
/factorial { % n on stack, returns n! 
  dup 0 eq { 1 }{ 
    dup 1 gt { dup 1 sub factorial mul } if }
  ifelse } def 
%
/MoverN { % m n on stack, returns the binomial coefficient m over n
  2 dict begin
  /n exch def /m exch def
  n 0 eq { 1 }{
    m n eq { 1 }{
      m factorial n factorial m n sub factorial mul div } ifelse } ifelse 
  end
} def
%
/ps@ReverseOrderOfPoints { % on stack [P1 P2 P3 ...Pn]=>[Pn,Pn-1,...,P2,P1]
  5 dict begin       % all local
  aload length /n ED % number of coors
  n 2 div cvi /m ED  % number of Points
  /n1 n def
  m { n1 2 roll /n1 n1 2 sub def } repeat
  n array astore
  end
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% subroutines for complex numbers, given as an array [a b] 
% which is a+bi = Real+i Imag
%
/cxadd {		% [a1 b1] [a2 b2] = [a1+a2 b1+b2]
  dup 0 get		% [a1 b1] [a2 b2] a2
  3 -1 roll		% [a2 b2] a2 [a1 b1]
  dup 0 get		% [a2 b2] a2 [a1 b1] a1
  3 -1 roll		% [a2 b2] [a1 b1] a1 a2
  add			% [a2 b2] [a1 b1] a1+a2
  3 1 roll		% a1+a2 [a2 b2] [a1 b1]
  1 get			% a1+a2 [a2 b2] b1
  exch 1 get		% a1+a2 b1 b2
  add 2 array astore
} def
%
/cxneg {		% [a b]
  dup 1 get		% [a b] b
  exch 0 get		% b a
  neg exch neg		% -a -b
  2 array astore
} def
%
/cxsub { cxneg cxadd } def  % same as negative addition
%
% [a1 b1][a2 b2] = [a1a2-b1b2 a1b2+b1a2] = [a3 b3]
/cxmul {		% [a1 b1] [a2 b2]
  dup 0 get		% [a1 b1] [a2 b2] a2
  exch 1 get		% [a1 b1] a2 b2
  3 -1 roll		% a2 b2 [a1 b1]
  dup 0 get		% a2 b2 [a1 b1] a1
  exch 1 get		% a2 b2 a1 b1
  dup			% a2 b2 a1 b1 b1
  5 -1 roll dup		% b2 a1 b1 b1 a2 a2
  3 1 roll mul		% b2 a1 b1 a2 b1a2
  5 -2 roll dup		% b1 a2 b1a2 b2 a1 a1
  3 -1 roll dup		% b1 a2 b1a2 a1 a1 b2 b2
  3 1 roll mul		% b1 a2 b1a2 a1 b2 a1b2
  4 -1 roll add		% b1 a2 a1 b2 b3
  4 2 roll mul		% b1 b2 b3 a1a2
  4 2 roll mul sub	% b3 a3
  exch 2 array astore
} def
%
% [a b]^2 = [a^2-b^2 2ab] = [a2 b2]
/cxsqr {		% [a b]   square root
  dup 0 get exch 1 get	% a b
  dup dup mul		% a b b^2
  3 -1 roll		% b b^2 a
  dup dup mul 		% b b^2 a a^2
  3 -1 roll sub		% b a a2
  3 1 roll mul 2 mul	% a2 b2	
  2 array astore
} def
%
/cxsqrt {		% [a b]
%  dup cxnorm sqrt /r exch def
%  cxarg 2 div RadtoDeg dup cos r mul exch sin r mul cxmake2 
  cxlog 		% log[a b]
  2 cxrdiv 		% log[a b]/2
  aload pop exch	% b a
  2.781 exch exp	% b exp(a)
  exch cxconv exch	% [Re +iIm] exp(a)
  cxrmul		%
} def
%
/cxarg { 		% [a b] 
  aload pop 		% a b
  exch atan 		% arctan b/a
  DegtoRad 		% arg(z)=atan(b/a)
} def
%
% log[a b] = [a^2-b^2 2ab] = [a2 b2]
/cxlog {		% [a b]
  dup 			% [a b][a b]
  cxnorm 		% [a b] |z|
  log 			% [a b] log|z|
  exch 			% log|z|[a b]
  cxarg 		% log|z| Theta
  cxmake2 		% [log|z| Theta]
} def
%
% square of magnitude of complex number
/cxnorm2 {		% [a b]
  dup 0 get exch 1 get	% a b
  dup mul			% a b^2
  exch dup mul add	% a^2+b^2
} def
%
/cxnorm {		% [a b]
  cxnorm2 sqrt
} def
%
/cxconj {		% conjugent complex
  dup 0 get exch 1 get	% a b
  neg 2 array astore	% [a -b]
} def
%
/cxre { 0 get } def	% real value
/cxim { 1 get } def	% imag value
%
% 1/[a b] = ([a -b]/(a^2+b^2)
/cxrecip {		% [a b]
  dup cxnorm2 exch	% n2 [a b]
  dup 0 get exch 1 get	% n2 a b
  3 -1 roll		% a b n2
  dup			% a b n2 n2
  4 -1 roll exch div	% b n2 a/n2
  3 1 roll div		% a/n2 b/n2
  neg 2 array astore
} def
%
/cxmake1 { 0 2 array astore } def % make a complex number, real given
/cxmake2 { 2 array astore } def	  % dito, both given
%
/cxdiv { cxrecip cxmul } def
%
% multiplikation by a real number
/cxrmul {		% [a b] r
  exch aload pop	% r a b
  3 -1 roll dup		% a b r r
  3 1 roll mul		% a r b*r
  3 1 roll mul		% b*r a*r
  exch 2 array astore   % [a*r b*r]
} def
%
% division by a real number
/cxrdiv {		% [a b] r
  1 exch div		% [a b] 1/r
  cxrmul
} def
%
% exp(i theta) = cos(theta)+i sin(theta) polar<->cartesian
/cxconv {		% theta
  RadtoDeg dup sin exch cos cxmake2
} def

%%%%% ### bubblesort ###
%% syntax : array bubblesort --> array2 trie par ordre croissant
%% code de Bill Casselman
%% http://www.math.ubc.ca/people/faculty/cass/graphics/text/www/
/bubblesort { % on stack must be an array [ ... ]
4 dict begin
   /a exch def
   /n a length 1 sub def
   n 0 gt {
      % at this point only the n+1 items in the bottom of a remain to
      % the sorted largest item in that blocks is to be moved up into
      % position n
      n {
         0 1 n 1 sub {
            /i exch def
            a i get a i 1 add get gt {
               % if a[i] > a[i+1] swap a[i] and a[i+1]
               a i 1 add
               a i get
               a i a i 1 add get
               % set new a[i] = old a[i+1]
               put
               % set new a[i+1] = old a[i]
               put
            } if
         } for
         /n n 1 sub def
      } repeat
   } if
   a % return the sorted array
end
} def
%
/concatstringarray{  %  [(a) (b) ... (z)] --> (ab...z)  20100422
  0 1 index { length add } forall 
  string     
  0 3 2 roll      
  { 3 copy putinterval length add }forall 
  pop  
} bind def
%
/dot2comma {% on stack a string (...) 
  2 dict begin
  /Output exch def
  0 1 Output length 1 sub { 
    /Index exch def 
    Output Index get 46 eq { Output Index 44 put } if 
  } for
  Output
  end
} def
%
/rightTrim { % on stack the string and the character number to be stripped  
  /charNo exch def
  dup
  length 1 sub -1 0 { 
    /i exch def dup i get charNo ne { exit } if 
  } for
  0 i 1 add getinterval
  dup length string copy
} bind def  % leaves the stripped string on the stack

/psStringwidth /stringwidth load def
/psShow /show load def

%/stringwidth{ 32 rightTrim psStringwidth } bind def

%/show { 32 rightTrim psShow } bind def
%-----------------------------------------------------------------------------%

/pgffunctions {
    /pgfsc{}bind def% stroke color is empty by default
    /pgffc{}bind def% fill color is empty by default
    /pgfstr{stroke}bind def%
    /pgffill{fill}bind def%
    /pgfeofill{eofill}bind def%
    /pgfe{a dup 0 rlineto exch 0 exch rlineto neg 0 rlineto closepath}bind def% rectangle
    /pgfw{setlinewidth}bind def% setlinewidth
    /pgfs{save pgfpd 72 Resolution div 72 VResolution div neg scale 
      magscale{1 DVImag div dup scale}if 
      pgfx neg pgfy neg translate pgffoa .setopacityalpha}bind def% save
    /pgfr{pgfsd restore}bind def %restore
    userdict begin%
    /pgfo{pgfsd /pgfx currentpoint /pgfy exch def def @beginspecial}bind def %open
    /pgfc{newpath @endspecial pgfpd}bind def %close
    /pgfsd{globaldict /pgfdelta /delta where {pop delta} {0} ifelse put}bind def% save delta
    /pgfpd{/delta globaldict /pgfdelta get def}bind def % put delta
    /.setopacityalpha where {pop} {/.setopacityalpha{pop}def} ifelse % install .setopacityalpha 
    /.pgfsetfillopacityalpha{/pgffoa exch def
      /pgffill{gsave pgffoa .setopacityalpha fill 1 .setopacityalpha newpath fill grestore newpath}bind def
      /pgfeofill{gsave pgffoa .setopacityalpha eofill 1 .setopacityalpha newpath eofill grestore newpath}bind def}bind def
    /.pgfsetstrokeopacityalpha{/pgfsoa exch def /pgfstr{gsave pgfsoa .setopacityalpha stroke grestore newpath}bind def}bind def
    /pgffoa 1 def
    /pgfsoa 1 def
    end
} def
%-----------------------------------------------------------------------------%
% END pst-tools.pro

%%EndProcSet
%%BeginProcSet: pst-dots.pro 0 0
% $Id: pst-dots.pro 446 2017-04-19 11:40:55Z herbert $
%
%% PostScript prologue for pstricks.tex.
%% Version 2.02,  2009/06/16
%%
%% For distribution, see pstricks.tex.
%%
%% Timothy Van Zandt <tvz@Princeton.EDU>
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%%
%% Modified by Etienne Riga  - Dec. 16, 1999
%% Modified by Etienne Riga  - 2005/01/01 (er)
%% to add /Diamond, /SolidDiamond and /BoldDiamond
%% Modified by Herbert Voss (hv) - 2008/04/17 
%
10 dict dup begin			% hold local
  /FontType 3 def
  /FontMatrix [.001 0 0 .001 0 0] def
%  /FontBBox [-571.5 -742.5 571.5 742.5] def % changed to next line 20060616 hv
  /FontBBox [-1000 -1000 1000 1000] def  % See end of file in /BuildGlyph
  /Encoding 256 array def
  0 1 255 {Encoding exch /.notdef put} for % fill the array with /.notdef
  Encoding				   % replace with given dot names
    dup (b) 0 get /Bullet put		   % get the numerical position of b in ASCII
%					   % and save /Bullet at this place in Encoding 
    dup (c) 0 get /Circle put
    dup (C) 0 get /BoldCircle put	% 67
    dup (u) 0 get /SolidTriangle put
    dup (t) 0 get /Triangle put
    dup (T) 0 get /BoldTriangle put
    dup (r) 0 get /SolidSquare put
    dup (s) 0 get /Square put
    dup (S) 0 get /BoldSquare put
    dup (q) 0 get /SolidPentagon put
    dup (p) 0 get /Pentagon put
    dup (P) 0 get /BoldPentagon put
%%%		  
    dup (k) 0 get /Asterisk put
    dup (K) 0 get /BoldAsterisk put
    dup (J) 0 get /SolidAsterisk put
    dup (h) 0 get /Hexagon put
    dup (H) 0 get /BoldHexagon put
    dup (G) 0 get /SolidHexagon put
    dup (f) 0 get /Octogon put		% 2008-04-18 hv
    dup (F) 0 get /BoldOctogon put	% 2008-04-18 hv
    dup (g) 0 get /SolidOctogon put	% 2008-04-18 hv
    dup (a) 0 get /Add put
    dup (A) 0 get /BoldAdd put 		% 65
    dup (x) 0 get /Mul put
    dup (X) 0 get /BoldMul put
    dup (m) 0 get /Oplus put
    dup (M) 0 get /BOplus put
    dup (e) 0 get /SolidOplus put
    dup (n) 0 get /Otimes put
    dup (N) 0 get /BOtimes put
    dup (E) 0 get /SolidOtimes put
    dup (i) 0 get /Bar put
    dup (I) 0 get /BoldBar put
    dup (l) 0 get /SolidDiamond put
    dup (d) 0 get /Diamond put
        (D) 0 get /BoldDiamond put
%%%  
/CharProcs 47 dict def
CharProcs begin
  /CirclePath {0 0 500 0 360 arc closepath} def
  /Bullet {CirclePath fill} def
  /Circle {CirclePath .9 .9 scale CirclePath eofill} def
  /BoldCircle {CirclePath .8 .8 scale CirclePath eofill} def
  /TrianglePath {0 660 moveto -571.5 -330 lineto 571.5 -330 lineto closepath} def
  /SolidTriangle {TrianglePath fill} def
  /Triangle {TrianglePath .85 .85 scale TrianglePath eofill} def
  /BoldTriangle {TrianglePath .7 .7 scale TrianglePath eofill} def
  /SquarePath {-450 450 moveto 450 450 lineto 450 -450 lineto -450 -450 lineto closepath} def
  /SolidSquare {SquarePath fill} def
  /Square {SquarePath .89 .89 scale SquarePath eofill} def
  /BoldSquare {SquarePath .78 .78 scale SquarePath eofill} def
  /PentagonPath {
    -337.8 -465 moveto 337.8 -465 lineto 546.6 177.6 lineto
    0 574.7 lineto -546.6 177.6 lineto closepath
  } def
  /SolidPentagon {PentagonPath fill} def
  /Pentagon {PentagonPath .89 .89 scale PentagonPath eofill} def
  /BoldPentagon {PentagonPath .78 .78 scale PentagonPath eofill} def
%-------------- hv begin 2004/07/25   from: er 2003/03/24
  /HexagonPath {
    0 550 moveto -476 275 lineto -476 -275 lineto
    0 -550 lineto 476 -275 lineto 476 275 lineto closepath
  } def
  /SolidHexagon {HexagonPath fill} def
  /Hexagon {HexagonPath .89 .89 scale HexagonPath eofill} def
  /BoldHexagon {HexagonPath .79 .79 scale HexagonPath eofill} def
%					2008-04-18 hv
  /OctogonPath { 
     550 dup 22.5 tan mul dup neg dup add /xMove exch def 
     exch moveto 7 { xMove 0 rlineto 45 rotate } repeat closepath } def 
  /SolidOctogon { OctogonPath fill                             } def
  /Octogon {      OctogonPath .89 .89 scale OctogonPath eofill } def
  /BoldOctogon {  OctogonPath .79 .79 scale OctogonPath eofill } def
%
  /AsteriskPath {
    20 0 moveto 10 250 180 500 0 500 curveto
    -180 500 -10 250 -20 0 curveto closepath
  } def
  /Asterisk {
    AsteriskPath 60 rotate AsteriskPath 60 rotate AsteriskPath
    60 rotate AsteriskPath 60 rotate AsteriskPath 60 rotate AsteriskPath fill
  } def
%
  /Basterp {50 250 220 500 0 500 curveto -220 500 -50 250 -50 30 cos 100 mul curveto} def
  /BoldAsteriskPath {
    50 30 cos 100 mul moveto  Basterp
    60 rotate Basterp 60 rotate Basterp
    60 rotate Basterp 60 rotate Basterp
    60 rotate Basterp closepath
  } def
  /BoldAsterisk {BoldAsteriskPath fill} def
  /SolidAsterisk {CirclePath .9 .9 scale BoldAsteriskPath eofill} def
  /CrossPath {
    40 550 moveto -40 550 lineto -40 40 lineto -550 40 lineto
    -550 -40 lineto -40 -40 lineto -40 -550 lineto 40 -550 lineto 
    40 -40 lineto 550 -40 lineto 550 40 lineto 40 40 lineto closepath
  } def
  /BoldCrossPath {80 550 moveto -80 550 lineto -80 80 lineto -550 80 lineto
    -550 -80 lineto -80 -80 lineto -80 -550 lineto 80 -550 lineto 
    80 -80 lineto 550 -80 lineto 550 80 lineto 80 80 lineto closepath
  } def
  /Add {CrossPath fill} def
  /Mul {45 rotate CrossPath fill} def
  /BoldAdd {BoldCrossPath fill} def
  /BoldMul {45 rotate BoldCrossPath fill} def
  /Oplus {CirclePath .9 .9 scale CirclePath eofill .775 .775 scale CrossPath fill } def 
  /SolidOplus {CirclePath .775 .775 scale BoldCrossPath eofill} def 
  /BOplus {CirclePath .8 .8 scale CirclePath eofill .775 .775 scale BoldCrossPath fill} def 
  /Otimes {CirclePath .9 .9 scale CirclePath eofill 45 rotate .775 .775 scale CrossPath fill} def 
  /BOtimes {CirclePath .8 .8 scale CirclePath eofill 45 rotate .775 .775 scale BoldCrossPath fill } def 
  /SolidOtimes {CirclePath 45 rotate .775 .775 scale BoldCrossPath eofill} def 
  /BarPath {40 660 moveto -40 660 lineto -40 -660 lineto 40 -660 lineto closepath} def
  /Bar {BarPath fill} def
  /BoldBarPath {80 660 moveto -80 660 lineto -80 -660 lineto 80 -660 lineto closepath} def
  /BoldBar {BoldBarPath fill} def
  /DiamondPath {0 742.5 moveto -428.5 0 lineto 0 -742.5 lineto 428.5 0 lineto closepath} def
  /SolidDiamond {DiamondPath fill} def
  /Diamond {DiamondPath .865 .865 scale DiamondPath eofill} def
  /BoldDiamond {DiamondPath .73 .73 scale DiamondPath eofill} def
%%%
  /.notdef { } def
end
%
/BuildGlyph {
  exch
  begin 		
%  Metrics 1 index get exec 0
    0 0
%      BBoxes 3 index get exec
    -1000 -1000 1000 1000
%     -571.5 -742.5 571.5 742.5
    setcachedevice
    CharProcs begin load exec end
  end
} def
%
/BuildChar {
  1 index /Encoding get exch get
  1 index /BuildGlyph get exec
} bind def
%
end
/PSTricksDotFont exch definefont pop
%
%% end

%%EndProcSet
%%BeginProcSet: pst-node.pro 0 0
% $Id: pst-node.pro 40 2014-07-25 06:46:27Z herbert $
%%
%% PostScript prologue for pst-node.tex.
%% Version 1.15, 2014/01/27.
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%
%%%%  EMPTY lines are not alowed!!! Problem with pst-eps -> \par
%
%
tx@Dict begin 			% from main pstricks dict
 /T /translate load def 
 /CP /currentpoint load def 
% /startGlobal { true setglobal globaldict begin } bind def
% /endGlobal { end false setglobal } bind def
end
/tx@NodeDict 400 dict def tx@NodeDict begin
/NewNode { % on stack: { x y } boolean N@name type InitXnode 
  gsave 
  NodeScale                     % a bugfix for xelatex, it's empty for dvips
  /next exch def 		% { x y } boolean N@name type  
  dict dup 			% { x y } boolean N@name dict dict
  3 1 roll def 			% { x y } boolean dict N@name dict def
  exch { dup 3 1 roll def } if  % { x y } dict boolean
  begin 			% { x y } dict begin
  tx@Dict begin 
    STV CP T exec 		% set scaling
  end 
  /NodeMtrx CM def 		% save CM
  next 				% InitXNode
  end
  grestore 
} def
%
/InitPnode { 
  /Y ED /X ED 
  /NodePos { NodeSep Cos mul NodeSep Sin mul } def
} def
%
/InitCnode { 
  /r ED /Y ED /X ED 
  /NodePos { NodeSep r add dup Cos mul exch Sin mul } def 
} def
%
/GetRnodePos { 
  Cos 0 gt { /dx r NodeSep add def } { /dx l NodeSep sub def } ifelse 
  Sin 0 gt { /dy u NodeSep add def } { /dy d NodeSep sub def } ifelse 
  dx Sin mul abs dy 
  Cos mul abs gt { dy Cos mul Sin div dy } { dx dup Sin mul Cos Div } ifelse 
} def
%
/InitRnode { 
  /Y ED /X ED X sub /r ED /l X neg def Y add neg /d ED Y sub /u ED 
  /NodePos { GetRnodePos } def 
} def
%
/DiaNodePos { 
  w h mul w Sin mul abs h Cos mul abs add Div NodeSep add dup
  Cos mul exch Sin mul 
} def
%
/TriNodePos { 
  Sin s lt 
    { d NodeSep sub dup Cos mul Sin Div exch } 
    { w h mul w Sin mul h Cos abs mul add Div 
      NodeSep add dup Cos mul exch Sin mul 
    } ifelse 
} def
%
/InitTriNode { 
  sub 2 div exch 
  2 div exch 
  2 copy T 
  2 copy 4 index index /d ED 
  pop pop pop pop 
  -90 mul rotate 
  /NodeMtrx CM def 
  /X 0 def /Y 0 def 
  d sub abs neg /d ED 
  d add /h ED 
  2 div h mul h d sub Div /w ED 
  /s d w Atan sin def 
  /NodePos { TriNodePos } def 
} def
%
/OvalNodePos { 
  /ww w NodeSep add def 
  /hh h NodeSep add def 
  Sin ww mul Cos hh mul Atan dup cos ww mul exch sin hh mul 
} def
%
/GetCenter { begin X Y NodeMtrx transform CM itransform end } def
%
/XYPos { 
  dup sin exch cos Do 
  /Cos ED /Sin ED /Dist ED 
  Cos 0 gt 
    { Dist Dist Sin mul Cos div }
    { Cos 0 lt 
      { Dist neg Dist Sin mul Cos div neg }
      { 0 Dist Sin mul } ifelse 
    } ifelse 
  Do 
} def
%
/GetEdge {
  dup 0 eq 
    { pop begin 1 0 NodeMtrx dtransform 
      CM idtransform 
      exch atan sub 
      dup 
      sin /Sin ED 
      cos /Cos ED 
      /NodeSep ED 
      NodePos NodeMtrx dtransform CM idtransform end }
    { 1 eq {{exch}} {{}} ifelse /Do ED pop XYPos } ifelse 
} def
%
/AddOffset { 
  1 index 0 eq 
    { pop pop } 
    { 2 copy 5 2 roll cos mul add 4 1 roll sin mul sub exch } ifelse 
} def
%
/GetEdgeA { 
  NodeSepA AngleA NodeA NodeSepTypeA GetEdge 
  OffsetA AngleA AddOffset 
  yA add /yA1 ED 
  xA add /xA1 ED 
} def
%
/GetEdgeB { 
  NodeSepB AngleB NodeB NodeSepTypeB GetEdge 
  OffsetB AngleB AddOffset 
  yB add /yB1 ED 
  xB add /xB1 ED 
} def
%
/GetArmA { 
  ArmTypeA 0 eq 
    { /xA2 ArmA AngleA cos mul xA1 add def 
      /yA2 ArmA AngleA sin mul yA1 add def } 
    { ArmTypeA 1 eq {{exch}} {{}} ifelse 
      /Do ED 
      ArmA AngleA XYPos OffsetA AngleA AddOffset 
      yA add /yA2 ED 
      xA add /xA2 ED } ifelse 
} def
%
/GetArmB { 
  ArmTypeB 0 eq 
    { /xB2 ArmB AngleB cos mul xB1 add def 
      /yB2 ArmB AngleB sin mul yB1 add def } 
    { ArmTypeB 1 eq {{exch}} {{}} ifelse 
      /Do ED
      ArmB AngleB XYPos OffsetB AngleB AddOffset 
      yB add /yB2 ED 
      xB add /xB2 ED } ifelse 
} def
%
/InitNC { 
  /b ED /a ED % second and first node
  /NodeSepTypeB ED /NodeSepTypeA ED 
  /NodeSepB ED /NodeSepA ED 
  /OffsetB ED /OffsetA ED 
  tx@NodeDict a known tx@NodeDict b known and dup { 
    /NodeA a load def 
    /NodeB b load def 
    NodeA GetCenter /yA ED /xA ED 
    NodeB GetCenter /yB ED /xB ED } if 
} def
%
/LPutLine { 
  4 copy 
  3 -1 roll sub neg 3 1 roll sub Atan /NAngle ED 
  1 t sub mul 
  3 1 roll 1 t sub mul 
  4 1 roll t mul add /Y ED 
  t mul add /X ED 
} def
%
/LPutLines { 
  mark LPutVar counttomark 2 div 1 sub /n ED 
%  t floor dup n gt 
  t floor dup n ge 		% to allow npos<= hv 2008-08-14
  { pop n 1 sub /t 1 def } { dup t sub neg /t ED } ifelse 
  cvi 2 mul { pop } repeat 
  LPutLine 
  cleartomark 
} def
%
/BezierMidpoint { 
  /y3 ED /x3 ED /y2 ED /x2 ED /y1 ED /x1 ED /y0 ED /x0 ED /t ED 
  /cx x1 x0 sub 3 mul def 
  /cy y1 y0 sub 3 mul def 
  /bx x2 x1 sub 3 mul cx sub def 
  /by y2 y1 sub 3 mul cy sub def 
  /ax x3 x0 sub cx sub bx sub def 
  /ay y3 y0 sub cy sub by sub def 
  ax t 3 exp mul bx t t mul mul add 
  cx t mul add x0 add ay t 3 exp mul 
  by t t mul mul add cy t mul add
  y0 add 3 ay t t mul mul mul 2 
  by t mul mul add cy add 3 ax t t mul mul mul 
  2 bx t mul mul add cx add atan /NAngle ED 
  /Y ED /X ED 
} def
%
/HPosBegin { yB yA ge { /t 1 t sub def } if /Y yB yA sub t mul yA add def
} def
%
/HPosEnd { /X Y yyA sub yyB yyA sub Div xxB xxA sub mul xxA add def
           /NAngle yyB yyA sub xxB xxA sub Atan def 
} def
/HPutLine { HPosBegin /yyA ED /xxA ED /yyB ED /xxB ED HPosEnd  } def
%
/HPutLines { HPosBegin yB yA ge 
  { /check { le } def } { /check { ge } def } ifelse 
  /xxA xA def 
  /yyA yA def 
  mark xB yB LPutVar 
    { dup Y check { exit } { /yyA ED /xxA ED } ifelse } 
  loop 
  /yyB ED /xxB ED cleartomark HPosEnd 
} def
%
/VPosBegin { 
  xB xA lt { /t 1 t sub def } if /X xB xA sub t mul xA add def
} def
%
/VPosEnd { /Y X xxA sub xxB xxA sub Div yyB yyA sub mul yyA add def
/NAngle yyB yyA sub xxB xxA sub Atan def } def
/VPutLine { VPosBegin /yyA ED /xxA ED /yyB ED /xxB ED VPosEnd  } def
/VPutLines { VPosBegin xB xA ge { /check { le } def } { /check { ge } def
} ifelse /xxA xA def /yyA yA def mark xB yB LPutVar { 1 index X check {
exit } { /yyA ED /xxA ED } ifelse } loop /yyB ED /xxB ED cleartomark
VPosEnd  } def
/HPutCurve { gsave newpath /SaveLPutVar /LPutVar load def LPutVar 8 -2
roll moveto curveto flattenpath /LPutVar [ {} {} {} {} pathforall ] cvx
def grestore exec /LPutVar /SaveLPutVar load def 
} def
%
/NCCoor { 
  /AngleA yB yA sub xB xA sub Atan def 
  /AngleB AngleA 180 add def
  GetEdgeA GetEdgeB 
  /LPutVar [ xB1 yB1 xA1 yA1 ] cvx def 
  /LPutPos { LPutVar LPutLine } def 
  /HPutPos { LPutVar HPutLine } def 
  /VPutPos { LPutVar VPutLine } def 
  LPutVar 
} def
%
/NCLine { 
  NCCoor 
  tx@Dict begin 
  ArrowA CP 4 2 roll 
  ArrowB 
  lineto pop pop
  end 
} def
%
/NCLines { 
  false NArray 
  n 0 eq 
    { NCLine } 
    { 2 copy yA sub exch xA sub Atan /AngleA ED 
      n 2 mul dup index exch index yB sub exch xB sub 
      Atan /AngleB ED 
      GetEdgeA GetEdgeB 
      /LPutVar [ xB1 yB1 n 2 mul 4 add 4 roll xA1 yA1 ] cvx def 
      mark LPutVar 
      tx@Dict begin false Line end 
      /LPutPos { LPutLines } def 
      /HPutPos { HPutLines } def 
      /VPutPos { VPutLines } def 
    } ifelse 
} def
%
/NCCurve { 
  GetEdgeA 
  GetEdgeB 
  xA1 xB1 sub yA1 yB1 sub Pyth 2 div dup 3 -1
roll mul /ArmA ED mul /ArmB ED /ArmTypeA 0 def /ArmTypeB 0 def GetArmA
GetArmB xA2 yA2 xA1 yA1 tx@Dict begin ArrowA end xB2 yB2 xB1 yB1 tx@Dict
begin ArrowB end curveto /LPutVar [ xA1 yA1 xA2 yA2 xB2 yB2 xB1 yB1 ]
cvx def /LPutPos { t LPutVar BezierMidpoint } def /HPutPos { { HPutLines
} HPutCurve } def /VPutPos { { VPutLines } HPutCurve } def } def
%
/NCAngles { 
  GetEdgeA GetEdgeB GetArmA GetArmB 
  /mtrx AngleA matrix rotate def 
  xA2 yA2 mtrx transform pop 
  xB2 yB2 mtrx transform exch pop 
  mtrx itransform 
  /y0 ED /x0 ED 
  mark ArmB 0 ne { xB1 yB1 } if 
  xB2 yB2 x0 y0 xA2 yA2 
  ArmA 0 ne { xA1 yA1 } if 
  tx@Dict begin false Line end 
  /LPutVar [ xB1 yB1 xB2 yB2 x0 y0 xA2 yA2 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def } def
%
/NCAngle { 
  GetEdgeA GetEdgeB GetArmB 
  /mtrx AngleA matrix rotate def 
  xB2 yB2 mtrx itransform pop xA1 yA1 mtrx itransform exch pop mtrx transform
  /y0 ED /x0 ED 
  mark 
  ArmB 0 ne { xB1 yB1 } if 
  xB2 yB2 x0 y0 xA1 yA1
  tx@Dict begin false Line end 
  /LPutVar [ xB1 yB1 xB2 yB2 x0 y0 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def 
} def
%
/NCBar { 
  GetEdgeA GetEdgeB GetArmA GetArmB 
  /mtrx AngleA matrix rotate def
  xA2 yA2 mtrx itransform pop 
  xB2 yB2 mtrx itransform pop 
  sub dup 0 mtrx transform 
  3 -1 roll 0 gt 
    { /yB2 exch yB2 add def /xB2 exch xB2 add def }
    { /yA2 exch neg yA2 add def /xA2 exch neg xA2 add def } ifelse 
  mark 
  ArmB 0 ne { xB1 yB1 } if 
  xB2 yB2 xA2 yA2 ArmA 0 ne { xA1 yA1 } if 
  tx@Dict begin false Line end 
  /LPutVar [ xB1 yB1 xB2 yB2 xA2 yA2 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def 
} def
%
/NCDiag { 
  /lineAngle ED
  GetEdgeA GetEdgeB GetArmA GetArmB mark
  lineAngle abs 0 gt {
    /xTemp xA2 10 add def
    /yTemp yA2 lineAngle dup sin exch cos div 10 mul add def
    /dY1 yTemp yA2 sub def
    /dX1 xTemp xA2 sub def
    /dY2 yB2 yB1 sub def
    /dX2 xB2 xB1 sub def
    dX1 abs 0.01 lt {
      /m2 dY2 dX2 div def
      /xB2 xA2 def
      /yB2 xA2 xB1 sub m2 mul yB1 add def
    }{
      dX2 abs 0.01 lt {
        /m1 dY1 dX1 div def
        /xB2 xB1 def
        /yB2 xB1 xA2 sub m1 mul yA2 add def
      }{%
        /m1 dY1 dX1 div def
        /m2 dY2 dX2 div def
        /xB2 m1 xA2 mul m2 xB1 mul sub yA2 sub yB1 add m1 m2 sub div def
        /yB2 xB2 xA2 sub m1 mul yA2 add def
      } ifelse
    } ifelse
  } if
  ArmB 0 ne { xB1 yB1 } if
  xB2 yB2 xA2 yA2 
  ArmA 0 ne { xA1 yA1 } if 
  tx@Dict begin false Line end
  /LPutVar [ xB1 yB1 xB2 yB2 xA2 yA2 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def 
%
%  GetEdgeA GetEdgeB GetArmA GetArmB mark 
%  ArmB 0 ne { xB1 yB1 } if
%  xB2 yB2 xA2 yA2 
%  ArmA 0 ne { xA1 yA1 } if 
%  tx@Dict begin false Line end
%  /LPutVar [ xB1 yB1 xB2 yB2 xA2 yA2 xA1 yA1 ] cvx def 
%  /LPutPos { LPutLines } def 
%  /HPutPos { HPutLines } def 
%  /VPutPos { VPutLines } def 
} def
%
/NCDiagg { 
  /lineAngle ED
  GetEdgeA GetArmA 
  lineAngle abs 0 gt 
    { lineAngle }
    { yB yA2 sub xB xA2 sub Atan 180 add } ifelse 
  /AngleB ED
  GetEdgeB mark
  lineAngle abs 0 gt {
    /dY2 yA2 yA1 sub def
    /dX2 xA2 xA1 sub def
    lineAngle abs 90 eq {
      /m2 dY2 dX2 div def
      /yA2 xB xA2 sub m2 mul yA2 add def
      /xA2 xB def
    }{
      /m1 lineAngle dup sin exch cos div def % tan alpha
      dX2 abs 0.01 lt {
        /yA2 xA1 xB sub m1 mul yB add def
        /xA2 xA1 def
      }{%
        /m2 dY2 dX2 div def
        /xA2 m1 xB mul m2 xA2 mul sub yA2 add yB sub m1 m2 sub div def
        /yA2 xA2 xB sub m1 mul yB add def
      } ifelse
    } ifelse
  } if
  xB1 yB1 xA2 yA2
  ArmA 0 ne { xA1 yA1 } if
  tx@Dict begin false Line end
  /LPutVar [ xB1 yB1 xA2 yA2 xA1 yA1 ] cvx def
  /LPutPos { LPutLines } def
  /HPutPos { HPutLines } def
  /VPutPos { VPutLines } def
%
%  GetEdgeA GetArmA 
%  yB yA2 sub xB xA2 sub Atan 180 add /AngleB ED
%  GetEdgeB 
%  mark 
%  xB1 yB1 xA2 yA2 
%  ArmA 0 ne { xA1 yA1 } if 
%  tx@Dict begin false Line end 
%  /LPutVar [ xB1 yB1 xA2 yA2 xA1 yA1 ] cvx def 
%  /LPutPos { LPutLines } def 
%  /HPutPos { HPutLines } def 
%  /VPutPos { VPutLines } def 
} def
%
/NCLoop { 
  GetEdgeA GetEdgeB GetArmA GetArmB 
  /mtrx AngleA matrix rotate def 
  xA2 yA2 mtrx transform loopsize add /yA3 ED /xA3 ED 
  /xB3 xB2 yB2 mtrx transform pop def 
  xB3 yA3 mtrx itransform /yB3 ED /xB3 ED 
  xA3 yA3 mtrx itransform /yA3 ED /xA3 ED 
  mark ArmB 0 ne { xB1 yB1 } if 
  xB2 yB2 xB3 yB3 xA3 yA3 xA2 yA2 ArmA 0 ne { xA1 yA1 } if 
  tx@Dict begin false Line end 
  /LPutVar [ xB1 yB1 xB2 yB2 xB3 yB3 xA3 yA3 xA2 yA2 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def 
} def
%
% DG/SR modification begin - May 9, 1997 - Patch 1
%/NCCircle { 0 0 NodesepA nodeA \tx@GetEdge pop xA sub 2 div dup 2 exp r
%r mul sub abs sqrt atan 2 mul /a ED r AngleA 90 add PtoC yA add exch xA add
%exch 2 copy /LPutVar [ 4 2 roll r AngleA ] cvx def /LPutPos { LPutVar t 360
%mul add dup 5 1 roll 90 sub \tx@PtoC 3 -1 roll add /Y ED add /X ED /NAngle ED
%
/NCCircle { 
  NodeSepA 0 NodeA 0 GetEdge pop 
  2 div dup 2 exp r r mul sub abs sqrt 
  atan 2 mul /a ED 
  r AngleA 90 add PtoC yA add exch xA add 
  exch 2 copy 
  /LPutVar [ 4 2 roll r AngleA ] cvx def 
  /LPutPos { 
    LPutVar t 360 mul add dup 5 1 roll 90 sub PtoC 
    3 -1 roll add 
    /Y ED add /X ED /NAngle ED
% DG/SR modification end
  } def 
  /HPutPos { LPutPos } def 
  /VPutPos { LPutPos } def 
  r AngleA 90 sub a add AngleA 270 add a sub 
  tx@Dict begin 
  /angleB ED /angleA ED /r ED 
  /c 57.2957 r Div def 
  /y ED /x ED 
} def
%
/NCBox { 
  /d ED /h ED 
  /AngleB yB yA sub xB xA sub Atan def 
  /AngleA AngleB 180 add def 
  GetEdgeA GetEdgeB 
  /dx d AngleB sin mul def 
  /dy d AngleB cos mul neg def 
  /hx h AngleB sin mul neg def 
  /hy h AngleB cos mul def 
  /LPutVar [ 
    xA1 hx add yA1 hy add xB1 hx add yB1 hy add 
    xB1 dx add yB1 dy add xA1 dx add yA1 dy add ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { xB yB xA yA LPutLine } def 
  /VPutPos { HPutPos } def 
  mark 
  LPutVar tx@Dict begin false Polygon end 
} def
%
/NCArcBox { 
  /l ED neg /d ED /h ED /a ED 
  /AngleA yB yA sub xB xA sub Atan def 
  /AngleB AngleA 180 add def 
  /tA AngleA a sub 90 add def 
  /tB tA a 2 mul add def 
  /r xB xA sub tA cos tB cos sub Div dup 0 eq { pop 1 } if def
  /x0 xA r tA cos mul add def 
  /y0 yA r tA sin mul add def 
  /c 57.2958 r div def 
  /AngleA AngleA a sub 180 add def 
  /AngleB AngleB a add 180 add def
  GetEdgeA GetEdgeB 
  /AngleA tA 180 add yA yA1 sub xA xA1 sub Pyth c mul sub def 
  /AngleB tB 180 add yB yB1 sub xB xB1 sub Pyth c mul add def 
  l 0 eq { 
    x0 y0 r h add AngleA AngleB arc x0 y0 r d add AngleB AngleA arcn 
  }{ 
    x0 y0 translate 
    /tA AngleA l c mul add def 
    /tB AngleB l c mul sub def
    0 0 r h add tA tB arc r h add 
    AngleB PtoC r d add 
    AngleB PtoC 2 copy 
    6 2 roll l arcto 4 { pop } repeat 
    r d add tB PtoC l arcto 4 { pop } repeat 
    0 0 r d add tB tA arcn r d add 
    AngleA PtoC r h add 
    AngleA PtoC 2 copy 6 2 roll 
    l arcto 4 { pop } repeat 
    r h add tA PtoC l arcto 4 { pop } repeat 
  } ifelse 
  closepath 
  /LPutVar [ x0 y0 r AngleA AngleB h d ] cvx def 
  /LPutPos { 
    LPutVar /d ED /h ED 
    /AngleB ED /AngleA ED 
    /r ED /y0 ED /x0 ED 
    t 1 le { 
      r h add AngleA 1 t sub mul AngleB t mul add dup 90 add /NAngle ED PtoC 
    }{t 2 lt { 
        /NAngle AngleB 180 add def r 2 t sub 
        h mul t 1 sub d mul add add AngleB PtoC 
      }{ 
        t 3 lt { 
          r d add AngleB 3 t sub mul AngleA 2 t sub
          mul add dup 90 sub /NAngle ED PtoC 
        }{ 
          /NAngle AngleA 180 add def 
          r 4 t sub d mul t 3 sub h mul add add AngleA PtoC 
        } ifelse 
      } ifelse 
    } ifelse
    y0 add /Y ED x0 add /X ED 
  } def 
  /HPutPos { LPutPos } def 
  /VPutPos { LPutPos } def 
} def
%
/Tfan { /AngleA yB yA sub xB xA sub Atan def GetEdgeA w xA1 xB sub yA1 yB
sub Pyth Pyth w Div CLW 2 div mul 2 div dup AngleA sin mul yA1 add /yA1
ED AngleA cos mul xA1 add /xA1 ED /LPutVar [ xA1 yA1 m { xB w add yB xB
w sub yB } { xB yB w sub xB yB w add } ifelse xA1 yA1 ] cvx def /LPutPos
{ LPutLines } def /VPutPos@ { LPutVar flag { 8 4 roll pop pop pop pop }
{ pop pop pop pop 4 2 roll } ifelse } def /VPutPos { VPutPos@ VPutLine }
def /HPutPos { VPutPos@ HPutLine } def mark LPutVar tx@Dict begin
/ArrowA { moveto } def /ArrowB { } def false Line closepath end } def
%
/LPutCoor { 
  NAngle 
  tx@Dict begin /NAngle ED end 
  gsave 
  CM STV 
  CP Y sub neg exch X sub neg exch moveto 
  setmatrix CP 
  grestore 
} def
%
/LPut { 
  tx@NodeDict /LPutPos known 
    { LPutPos } { CP /Y ED /X ED /NAngle 0 def } ifelse 
  LPutCoor  
} def
%
/HPutAdjust { 
  Sin Cos mul 0 eq 
    { 0 } 
    { d Cos mul Sin div flag not { neg } if 
      h Cos mul Sin div flag { neg } if 
      2 copy gt { pop } { exch pop } ifelse 
    } ifelse 
  s add flag { r add neg }{ l add } ifelse 
  X add /X ED 
} def
%
/VPutAdjust { 
  Sin Cos mul 
  0 eq 
    { 0 }
    { l Sin mul Cos div flag { neg } if
      r Sin mul Cos div flag not { neg } if 
      2 copy gt { pop } { exch pop } ifelse 
    } ifelse 
  s add flag { d add } { h add neg } ifelse 
  Y add /Y ED 
} def
%
%
end
%
% END pst-node.pro

%%EndProcSet
%%BeginProcSet: pst-3d.pro 0 0
%% $Id: pst-3d.pro 247 2010-01-04 22:45:42Z herbert $
% PostScript prologue for pst-3d.tex.
% Version 0.01, 2010/01/01 
%
/tx@3Ddict 300 dict def 
tx@3Ddict begin
%
/SetMatrixThreeD {
  dup sin /e ED cos /f ED
  /p3 ED /p2 ED /p1 ED
  p1 0 eq
  { /a 0 def /b p2 0 le { 1 } { -1 } ifelse def
    p3 p2 abs
  }
  { p2 0 eq
    { /a p1 0 lt { -1 } { 1 } ifelse def /b 0 def
      p3 p1 abs
    }
    { p1 dup mul p2 dup mul add sqrt dup
      p1 exch div /a ED
      p2 exch div neg /b ED
      p3 p1 a div
    }
    ifelse
  }
  ifelse
  atan dup sin /c ED cos /d ED
  /Matrix3D
  [
    b f mul c a mul e mul sub
    a f mul c b mul e mul add
    d e mul
    b e mul neg c a mul f mul sub
    a e mul neg c b mul f mul add
    d f mul
  ] def
} def
%
/ProjThreeD {
  /z ED /y ED /x ED
  Matrix3D aload pop
  z mul exch y mul add exch x mul add
  4 1 roll
  z mul exch y mul add exch x mul add
  exch
} def
%
/SetMatrixEmbed {
  SetMatrixThreeD
  Matrix3D aload pop
  /z3 ED /z2 ED /z1 ED /x3 ED /x2 ED /x1 ED
  SetMatrixThreeD
  [
  Matrix3D aload pop
  z3 mul exch z2 mul add exch z1 mul add 4 1 roll
  z3 mul exch z2 mul add exch z1 mul add
  Matrix3D aload pop
  x3 mul exch x2 mul add exch x1 mul add 4 1 roll
  x3 mul exch x2 mul add exch x1 mul add
  3 -1 roll 3 -1 roll 4 -1 roll 8 -3 roll 3 copy
  x3 mul exch x2 mul add exch x1 mul add 4 1 roll
  z3 mul exch z2 mul add exch z1 mul add
  ]
  concat
} def
%
/TMSave {
  tx@Dict /TMatrix known not { /TMatrix { } def /RAngle { 0 } def } if 
  /TMatrix [ TMatrix CM ] cvx def 
} def
%
/TMRestore { CP /TMatrix [ TMatrix setmatrix ] cvx def moveto } def
%
/TMChange {
  TMSave
  /cp [ currentpoint ] cvx def % ??? Check this later.
  CM
  CP T STV
  CM matrix invertmatrix    % Inv(M')
  matrix concatmatrix       % M Inv(M')
  exch exec
  concat cp moveto
} def
%
end % of tx@3Ddict
%%
%% End of file `pst-3d.pro'.

%%EndProcSet
%%BeginProcSet: pst-math.pro 0 0
%                           -*- Mode: Postscript -*-
% pst-math.pro --- PostScript header file pst-math.pro
%
% Author          : Christophe JORSSEN 
% Author          : Herbert Voß <hvoss@tug.org>
% Last Mod        : $Date: 2014/07/30 $
% Version         : 0.63 $
%
/PI 3.14159265359 def
/ENeperian 2.71828182846 def
%
/DegToRad {PI mul 180 div} bind def
/RadToDeg {180 mul PI div} bind def
%
/COS {RadToDeg cos} bind def
/SIN {RadToDeg sin} bind def
/TAN {dup SIN exch COS Div} bind def
/tan {dup sin exch cos Div} bind def
/ATAN {neg -1 atan 180 sub DegToRad} bind def
/ACOS {dup dup mul neg 1 add sqrt exch atan DegToRad} bind def
/acos {dup dup mul neg 1 add sqrt exch atan} bind def
/ASEC {1 exch Div ACOS} bind def
/ASIN {neg dup dup mul neg 1 add sqrt neg atan 180 sub DegToRad} bind def
/asin {neg dup dup mul neg 1 add sqrt neg atan 180 sub} bind def
/ACSC {1 exch Div ASIN} bind def
%
/EXP {ENeperian exch exp} bind def
%
/COSH {dup EXP exch neg EXP add 2 div} bind def
/SINH {dup EXP exch neg EXP sub 2 div} bind def
/TANH {dup SINH exch COSH div} bind def
/ACOSH {dup dup mul 1 sub sqrt add ln} bind def
/ASINH {dup dup mul 1 add sqrt add ln} bind def
/ATANH {dup 1 add exch neg 1 add Div ln 2 div} bind def
%
%/SINC {dup SIN exch Div} bind def
/SINC { dup 0 eq { pop 1 } { dup SIN exch div } ifelse } bind def

/GAUSS {dup mul 2 mul dup 4 -2 roll sub dup mul exch div neg EXP exch PI mul sqrt div} bind def
%
/GAMMA { 2 dict begin				% hv 2007-08-30
  /z exch def
  1.000000000190015				% p(0)
  0 1 5 {					% on stack is 0 1 2 3 4 5 
    dup 					% n-1 n-1
    [ 76.18009172947146 
     -86.50532032941677 
      24.0140982483091 
      -1.231739572450155
       0.1208650973866179E-2 
      -0.5395239384953E-5      ] exch get exch 	% p(n) n-1
      1 add z add div			     	% p(n)/(z+n)
      add					% build the sum
    } for
    Pi 2 mul sqrt z div mul
    z 5.5 add z 0.5 add exp mul ENeperian z 5.5 add neg exp mul 
  end } bind def
%    
/GAMMALN {dup dup dup 5.5 add dup ln 3 -1 roll .5 add mul sub neg 1.000000000190015
    0 1 5 {
    [76.18009172947146 -86.50532032941677 24.0140982483091 -1.231739572450155
    .1208650973866179E-2 -.5395239384953E-5 2.5066282746310005] exch get
    4 -1 roll 1 add dup 5 1 roll div add} for
    4 -1 roll div 2.5066282746310005 mul ln add exch pop} bind def
/BETA {2 copy add GAMMALN neg exch GAMMALN 3 -1 roll GAMMALN EXP} bind def
%
/HORNER {aload length
    dup 2 add -1 roll
    exch 1 sub {
        dup 4 1 roll
        mul add exch
    } repeat
    pop
} bind def
%
/BESSEL_J0 {dup abs 8 lt {
    dup mul dup [57568490574 -13362590354 651619640.7 -11214424.18 77392.33017 -184.9052456] HORNER
    exch [57568490411 1029532985 9494680.718 59272.64853 267.8532712 1] HORNER
    Div}
    {abs dup .636619772 exch div sqrt exch dup .785398164 sub exch 8 exch div dup dup mul dup 
    [1 -1.098628627E-2 .2734510407E-4 -.2073370639E-5 .2093887211E-6] HORNER
    3 index COS mul
    exch [-.1562499995E-1 .1430488765E-3 -.6911147651E-5 .7621095161E-6 -.934945152E-7] HORNER
    4 -1 roll SIN mul 3 -1 roll mul neg add mul} 
    ifelse} bind def
%
/BESSEL_Y0 {dup 8 lt {
    dup dup mul dup [-2957821389 7062834065 -512359803.6 10879881.29 -86327.92757 228.4622733] HORNER
    exch [40076544269 745249964.8 7189466.438 47447.26470 226.1030244 1] HORNER
    Div exch dup ln exch BESSEL_J0 .636619772 mul mul add}
    {dup .636619772 exch div sqrt exch dup .785398164 sub exch 8 exch div dup dup mul dup 
    [1 -.1098628627E-2 .2734510407E-4 -.2073370639E-5 .2093887211E-6] HORNER
    3 index SIN mul
    exch [-.1562499995E-1 .1430488765E-3 -.6911147651E-5 .7621095161E-6 -.934945152E-7] HORNER
    4 -1 roll COS mul 3 -1 roll mul add mul} 
    ifelse} bind def
%
/BESSEL_J1 {dup abs 8 lt {
    dup dup mul dup 3 -2 roll [72362614232 -7895059235 242396853.1 -2972611.439 15704.48260 -30.16036606] HORNER mul
    exch [144725228442 2300535178 18583304.74 99447.43394 376.9991397 1] HORNER
    Div}
    {dup abs dup .636619772 exch div sqrt exch dup 2.356194491 sub exch 8 exch div dup dup mul dup 
    [1 .183105E-2 -.3516396496E-4 .2457520174E-5 -.240337019E-6] HORNER
    3 index COS mul
    exch [.04687499995 6.2002690873E-3 .8449199096E-5 -.88228987E-6 .105787412E-6] HORNER
    4 -1 roll SIN mul 3 -1 roll mul neg add mul exch dup abs Div mul} 
    ifelse} bind def
%
/BESSEL_Y1 {dup 8 lt {
    dup dup dup mul dup [-.4900604943E13 .1275274390E13 -.5153428139E11 .7349264551E9 -.4237922726E7 .8511937935E4] HORNER
    exch [.2499580570E14 .4244419664E12 .3733650367E10 .2245904002E8 .1020426050E6 .3549632885E3 1] HORNER
    Div mul exch dup dup ln exch BESSEL_J1 mul exch 1 exch div sub .636619772 mul add}
    {dup .636619772 exch div sqrt exch dup 2.356194491 sub exch 8 exch div dup dup mul dup 
    [1 .183105E-2 -.3516396496E-4 .2457520174E-5 -.240337019E-6] HORNER
    3 index SIN mul
    exch [.04687499995 -.2002690873E-3 .8449199096E-5 6.88228987E-6 .105787412E-6] HORNER
    4 -1 roll COS mul 3 -1 roll mul add mul} 
    ifelse} bind def
%
% En cours...
/BESSEL_Yn {dup 0 eq {pop BESSEL_Y0}{dup 1 eq {pop BESSEL_Y1}{
    exch dup BESSEL_Y0 exch dup BESSEL_Y1 exch 2 exch Div {
        mul 3 -1 roll mul 2 index sub pstack} for
    } ifelse } ifelse } bind def
%
/SIMPSON { 1 dict begin  %% on stack a b var f ierr  Dominik Rodriguez
  3 index 5 index sub                                % compute h
  1                                                  % a b var f ierr h n
  4 index 7 index def 3 index exec                   % a b var f ierr h n f(a)
  5 index 7 index def 4 index exec add               % a b var f ierr h n f(a)+f(b)
  5 index 8 index 4 index 2 div add def 4 index exec % a b var f ierr h n f(a)+f(b) f(a+h/2)
  exch 1 index 4 mul add 0  % a b var f ierr h n old=f(a+h/2) Estim=f(a)+f(b)+4f(a+h/2) NbLoop
    {                                                % a b var f ierr h n old Estim NbLoop
      5 -1 roll 2 div dup 6 1 roll              % h<-h/2
      5 -1 roll 2 mul 5 1 roll                  % n<-2n
                                                % a b var f ierr h n old Estim NbLoop h
      2 div 10 index add 0                      % a b var f ierr h n old Estim NbLoop a+h/2 Cumul
      5 index { 
        1 index 10 index exch def 8 index exec add exch 6 index add exch 
      } repeat                                  % a b var f ierr h n old Estim NbLoop a+nh/2 Cumul
      exch pop                                  % a b var f ierr h n old Estim NbLoop New
      2 index 1 index 4 mul 6 -1 roll 2 mul sub sub % a b var f ierr h n Estim NbLoop New Diff
      4 -1 roll 2 mul 1 index sub 4 1 roll          % a b var f ierr h n Estim NbLoop New Diff
      exch 4 1 roll                             % a b var f ierr h n old Estim NbLoop Diff
      5 index 6 div mul abs 6 index lt { exit } if
      1 add dup 9 eq { exit } if
  } loop                                        % a b var f ierr h n old Estim NbLoop
  exch 5 -1 roll 6 div mul mark 10 2 roll cleartomark
end 
} def
% ------------------------------------ math stuff ----------------------------------
%
% Matrix A in arrays of rows A[[row1][row2]...]
% with [row1]=[a11 a12 ... b1]
% returns on stack solution vector X=[x1 x2 ... xn]
/SolveLinEqSystem { 				% on stack matrix M=[A,b] (A*x=b)
  10 dict begin					% hold all ocal
    /A exch def
    /Rows A length def         			% Rows = number of rows
    /Cols A 0 get length def   			% Cols = number of columns
    /Index [ 0 1 Rows 1 sub { } for ] def	% Index = [0 1 2 ... Rows-1]
    /col 0 def
    /row  0 def
    /PR Rows array def 				% PR[c] = pivot row for row row
  { 						% starts the loop, find pivot entry in row r
    col Cols ge row  Rows ge or { exit } if	% col < Cols and row < Rows else exit
    /pRow row def  				% pRow = pivot row		
    /max A row  get col get abs def		% get A[row[col]], first A[0,0] 
    row 1 add 1 Rows 1 sub { 			% starts for loop 1 1 Rows-1
      /j exch def				% index counter
      /x A j get col get abs def		% get A[j[r]]
      x max gt {				% x>max, then save position
        /pRow j def
        /max x def
      } if
    } for					% now we have the row with biggest A[0,1]
						% with pRow = the pivot row
    max 0 gt {					% swap entries pRow and row  in i 
      /tmp Index row  get def
      Index row  Index pRow get put
      Index pRow tmp put			% and columns pRow and row  in A
      /tmp A row get def
      A row  A pRow get put
      A pRow tmp put   				% pivot
      /row0  A row  get def 			% the pivoting row
      /p0 row0  col get def 			% the pivot value
      row 1 add 1 Rows 1 sub { 			% start for loop
        /j exch def
        /c1 A j get def
        /p c1 col get p0 div def
        c1 col p put				% subtract (p1/p0)*row[i] from row[j]
        col 1 add 1 Cols 1 sub {		% start for loop
          /i exch def
          c1 dup i exch 			% c1 i c1
          i get row0 i get p mul sub put
        } for
      } for
      PR row col put
      /col col 1 add def
      /row row 1 add def
    }{						% all zero entries
      /row row 1 add def			% continue loop with same row
    } ifelse
  } loop
  /X A def					% solution vector
  A Rows 1 sub get dup
  Cols 1 sub get exch
  Cols 2 sub get div
  X Rows 1 sub 3 -1 roll put  			% X[n]
  Rows 2 sub -1 0 {				% for loop to calculate X[i]
    /xi exch def				% current index
    A xi get 					% i-th row
    /Axi exch def
    /sum 0 def
    Cols 2 sub -1 xi 1 add { 
      /n exch def
      /sum sum Axi n get X n get mul add def 
    } for
    Axi Cols 1 sub get 				% b=Axi[Cols-1]
    sum sub 					% b-sum
    Axi xi get div				% b-sum / Axi[xi]
    X xi 3 -1 roll put  			% X[xi]
  } for
  X
  end 
} def
%
/c@_0 2.515517 def 
/c@_1 0.802853 def 
/c@_2 0.010328 def 
/d@_1 1.432788 def 
/d@_2 0.189269 def 
/d@_3 0.001308 def 
/norminv {
  5 dict begin
  neg 1 add 1 exch div ln 2 mul sqrt 
  /t exch def 
  /t2 t dup mul def 
  /t3 t2 t mul def 
  c@_0 c@_1 t mul add c@_2 t2 mul add 1 d@_1 t mul add 
  d@_2 t2 mul add d@_3 t3 mul add div neg t add 
  end
} def 
%end{norminv Michael Sharpe}
%
%
% END pst-math.pro

%%EndProcSet
%%BeginProcSet: pstricks-add.pro 0 0
%% $Id: pstricks-add.pro 37 2014-07-22 13:52:12Z herbert $
%%
% PostScript prologue for pstricks-add.tex.
%
% Version 0.23, 2009/12/17 
%
/tx@addDict 410 dict def tx@addDict begin
%%
realtime srand % set random generator
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/GTriangle {
  gsave
  /mtrx CM def
  /colorA ED /colorB ED /colorC ED 	% save the colors
  /yA ED /xA ED               		% save the origin
  xA yA translate
  rotate       		        	% \psk@gangle
  /yB ED /xB ED /yC ED /xC ED   	% save other coordinates
  /ds [                % save data in a array
     0 0 0 colorA aload pop     	% fd x y xr xg xb
     0 xB xA sub yB yA sub colorB aload pop
     0 xC xA sub yC yA sub colorC aload pop
%     1 xC xB add yB colorA aload pop  	% for use with 4 points ABCD
  ] def
  newpath
  <<
  /ShadingType 4           % single Gouraud
  /ColorSpace [ /DeviceRGB ]
  /DataSource ds
  >> 
  shfill
  closepath
  mtrx
  setmatrix grestore} def
%
/RGBtoCMYK {    % on stack r g b -> C M Y K
  3 dict begin
  /Blue ED /Green ED /Red ED
  1 Red sub     % Cyan
  1 Green sub   % Magenta
  1 Blue sub    % Yellow
  0   		% Black  
  end
} def
%
/CMYKtoGRAY { % on stack c m y k -> gray
  exch 0.11 mul add
  exch 0.59 mul add
  exch 0.3 mul add
  dup 1 gt { pop 1 }  if 
  neg 1 add 
} def
%
/RGBtoGRAY { % on stack r g b -> gray
  0.11 mul
  exch 0.59 mul add
  exch 0.3 mul add 
} def
%
/HSBtoGRAY { 
  6 dict begin
  /b exch def 
  /s exch def 6 mul dup cvi dup 
  /i exch def sub 
  /f exch def
  /F [[0 1 f sub 1][f 0 1][1 0 1 f sub][1 f 0][1 f sub 1 0][0 1 f][0 1 1]] def
  F i get { s mul neg 1 add b mul} forall
  0.11 mul
  exch 0.59 mul add
  exch 0.3 mul add 
  end
} def
%
%% convertisseur longueur d'onde ->R,G,B       Manuel Luque
%% lambda max=780 nanometres
%% lambda min=380 nanometres
%% adaptation de :
%% http://www.physics.sfasu.edu/astro/color.html
%% www.efg2.com/lab
%
/Gamma 0.8 def
/calculateRGB {
  lambda 379 le {/Red 0 def /Green 0 def /Blue 0 def} if
  lambda 781 ge {/Red 0 def /Green 0 def /Blue 0 def} if
  lambda 380 ge {lambda 439 le {
    /R {lambda 440 sub neg 440 380 sub div} def
    /Red R factor mul Gamma exp def
    /G 0 def
    /Green G factor mul Gamma exp def
    /B 1 def
    /Blue B factor mul Gamma exp def} if
  } if
  lambda 440 ge { lambda 489 le {
    /G {lambda 440 sub 490 440 sub div} def
    /Green G factor mul Gamma exp def
    /R 0 def /Red 0 def
    /B 1 def
    /Blue B factor mul Gamma exp def } if
  } if
  lambda 490 ge {lambda 509 le {
    /B {lambda 510 sub neg 510 490 sub div} def
    /Blue B factor mul Gamma exp def
    /R 0 def /Red 0 def
    /G 1 def
    /Green G factor mul Gamma exp def } if
  } if
  lambda 510 ge {lambda 579 le {
    /R {lambda 510 sub 580 510 sub div } def
    /Red R factor mul Gamma exp def
    /Blue 0 def
    /G 1 def
    /Green G factor mul Gamma exp def } if
  } if
  lambda 580 ge {lambda 644 le {
    /G {lambda 645 sub neg 645 580 sub div } def
    /Green G factor mul Gamma exp def
    /Blue 0 def
    /R 1 def
    /Red R factor mul Gamma exp def } if
  } if
  lambda 645 ge { lambda 780 le {
    /Red 1 factor mul Gamma exp def
    /Blue 0 def
    /Green 0 def } if
  } if
} def
%
/factor {
  lambda 380 ge {lambda 419 le { 0.3 0.7 lambda 380 sub mul 420 380 sub div add} if } if
  lambda 420 ge {lambda 700 le { 1 } if } if
  lambda 701 ge {lambda 780 le { 0.3 0.7 780 lambda sub mul 780 700 sub div add} if } if
} def
%
/wavelengthToRGB { % the wavelength in nm must be on top of the stack
  cvi /lambda exch def % no floating point here
  calculateRGB
} def %  now the colors are saved in Red Green Blue
%
/wavelengthToGRAY { % the wavelength in nm must be on top of the stack
  cvi /lambda exch def % no floating point here
  calculateRGB
  Red Green Blue RGBtoGRAY
} def %  now the gray color is on the stack
%
/wavelengthToCMYK { % the wavelength in nm must be on top of the stack
  cvi /lambda exch def % no floating point here
  gsave
  calculateRGB Red Green Blue RGBtoCMYK 
  /Black ED /Yellow ED /Magenta ED /Cyan ED
  grestore
} def %  now the colors are saved in Cyan Magenta Yellow Black
%
/axfill {
    8 dict begin
    /xw exch def /nl exch def
    /C1 exch def /y1 exch def/x1 exch def
    /C0 exch def /y0 exch def/x0 exch def
    <<  /ShadingType 2
        /ColorSpace /DeviceRGB
        /Coords [ x0 y0 x1 y1 ]
        /EmulatorHints [ xw 2 div dup ]
        /Function <<
            /FunctionType 2
            /Domain [0 1]
            /C0 C0
            /C1 C1
            /N      1
        >>
    >> shfill
    end
} bind def
%
%/amplHand {.8} def 
%/dtHand 2 def
/varHand { rand sin amplHand mul add } def
/MovetoByHand { moveto } def 
%/MovetoByHand { /y0 ED /x0 ED x0 y0 moveto } def 
/LinetoByHand { 4 dict begin
  /y1 ED /x1 ED 
  currentpoint /y0 ED /x0 ED
  x0 x1 sub dup mul y0 y1 sub dup mul add sqrt /dEnd ED
  0 dtHand dEnd { dup
    x1 x0 sub mul dEnd div x0 add varHand exch  
    y1 y0 sub mul dEnd div y0 add varHand lineto
  } for
%  /x0 x1 def /y0 y1 def
  end
} def  
%
end
%
% END pstricks-add.pro

%%EndProcSet
%%BeginProcSet: pst-text.pro 0 0
%!
% PostScript header file pst-text.pro
% Version 1.0, 2005-11-29 (hv)
% For distribution, see pstricks.tex.

/tx@TextPathDict 40 dict def
tx@TextPathDict begin

% Syntax:  <dist> PathPosition -
% Function: Searches for position of currentpath distance <dist> from
%           beginning. Sets (X,Y)=position, and Angle=tangent.
/PathPosition
{ /targetdist exch def
  /pathdist 0 def
  /continue true def
  /X { newx } def /Y { newy } def /Angle 0 def
  gsave
    flattenpath
    { movetoproc }  { linetoproc } { } { firstx firsty linetoproc }
    /pathforall load stopped { pop pop pop pop /X 0 def /Y 0 def } if
  grestore
} def

/movetoproc { continue { @movetoproc } { pop pop } ifelse } def

/@movetoproc
{ /newy exch def /newx exch def
  /firstx newx def /firsty newy def
} def

/linetoproc { continue { @linetoproc } { pop pop } ifelse } def

/@linetoproc {
  /oldx newx def /oldy newy def
  /newy exch def /newx exch def
  /dx newx oldx sub def
  /dy newy oldy sub def
  /dist dx dup mul dy dup mul add sqrt def
  /pathdist pathdist dist add def
  pathdist targetdist ge
  { pathdist targetdist sub dist div dup
    dy mul neg newy add /Y exch def
    dx mul neg newx add /X exch def
    /Angle dy dx atan def
    /continue false def
  } if
} def

/TextPathShow { 
  /String exch def
  /CharCount 0 def
% hv begin 2005-11-29   1.00
%   String length
%   { String CharCount 1 getinterval ShowChar
%     /CharCount CharCount 1 add def
   /CharSize 1 def
   currentfont /FontType get 0 eq
   { currentfont /FMapType get dup 2 eq exch dup 5 eq exch 9 eq or or
     { /CharSize 2 def} if
   } if
   String length CharSize idiv
   { String CharCount CharSize getinterval ShowChar
     /CharCount CharCount CharSize add def
% hv end 2005-11-29   1.00
  } repeat
} def

% Syntax: <pathlength> <position> InitTextPath -
/InitTextPath
{ gsave
    currentpoint /Y exch def /X exch def
    exch X Hoffset sub sub mul
    Voffset Hoffset sub add
    neg X add /Hoffset exch def
    /Voffset Y def
  grestore
} def

/Transform
{ PathPosition
  dup
  Angle cos mul Y add exch
  Angle sin mul neg X add exch
  translate
  Angle rotate
} def

/ShowChar { 
  /Char exch def
  gsave
    Char end stringwidth
    tx@TextPathDict begin
    2 div /Sy exch def 2 div /Sx exch def

%%%  MV 10-09-99 00:36
    /sc?currentpoint where {pop sc?currentpoint} {currentpoint} ifelse
%   currentpoint

    Voffset sub Sy add exch
    Hoffset sub Sx add
    Transform
    Sx neg Sy neg moveto
    Char end tx@TextPathSavedShow
    tx@TextPathDict begin
  grestore
  Sx 2 mul Sy 2 mul rmoveto
} def
%
end
% END pst-text.pro

%%EndProcSet
%%BeginProcSet: pst-eucl.pro 0 0
%!
% PostScript prologue for pst-eucl.tex.
% Version 1.01 2012/09/21
% For distribution, see pstricks.tex.
%
/tx@EcldDict 40 dict def tx@EcldDict begin
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Pi
/Pi 3.14159265359 def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% e
/E 2.718281828459045 def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% x -> true (if |x| < 1E-6)
/ZeroEq { abs 1E-6 lt } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% x1 y1 x2 y2 -> a b c (ax-by+c=0 with a^2+b^2=1)
/EqDr {
  4 copy 3 -1 roll sub 7 1 roll exch sub 5 1 roll 4 -1 roll
  mul 3 1 roll mul exch sub
  2 index dup mul 2 index dup mul add sqrt
  4 -1 roll 1 index div exch
  4 -1 roll 1 index div exch
  4 -1 roll 1 index div exch pop
} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% orthogonal projection of M1 onto (OM2)
%% x1 y1 x2 y2 -> x3 y3
/Project {
  2 copy dup mul exch dup mul add 5 1 roll 2 copy 5 -1 roll mul exch
  5 -1 roll mul add 4 -1 roll div dup 4 -1 roll mul exch 3 -1 roll mul
} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a b c (ax2+bx+c=0) -> x1 y1
/SolvTrin {
  /c exch def /b exch def /a exch def
  b dup mul a c mul 4 mul sub dup 0 lt
  { pop 0 0 } %% no solutions
  {sqrt dup b neg add a 2 mul div exch b add neg 2 a mul div }
  ifelse } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% x1 y1 x2 y2 -> Dist
/ABDist { 3 -1 roll sub dup mul 3 1 roll sub dup mul add sqrt } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% x1 y1 x2 y2 -> x2-x1  y2-y1
/ABVect { 3 -1 roll exch sub 3 1 roll sub exch } bind def
%/ABVect { 3 -1 roll sub 3 1 roll exch sub exch } bind def  %% wrong version
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% x1 y1 x2 y2 x3 y3 x4 y4 -> x y
/InterLines {
  EqDr /D1c exch def /D1b exch def /D1a exch def
  EqDr /D2c exch def /D2b exch def /D2a exch def
  D1a D2b mul D1b D2a mul sub dup ZeroEq
%   { pop pop pop 0 0 } %% parallel lines  % --- hv 20110714
   { pop 0 0 } %% parallel lines             --- hv 20110714
   {
    /Det exch def
    D1b D2c mul D1c D2b mul sub Det div
    D1a D2c mul D2a D1c mul sub Det div
   } ifelse  } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a b c R -> x1 y1 x2 y2
/InterLineCircle {
  /CR exch def /Dc exch def neg /Db exch def /Da exch def
  ABVect /Vy exch def /Vx exch def
  %% Dc==0 then O belong to the line
  %% First project O on the line -> M (-ca;-cb)
  %% l'abscisse de M sur (OM) divisee par R donne le cosinus
  %Dc neg dup Db mul exch Da mul 2 copy 0 0
  %ABDist dup CR gt { pop pop pop 0 0 0 0 }
  %{ ZeroEq { pop pop Db Da } if Atan /alpha exch def
  Dc abs CR gt { 0 0 0 0 } 
  { Db neg Da neg Atan /alpha exch def
  Dc CR div dup dup mul 1 exch sub sqrt exch Atan /beta exch def
  alpha beta add dup cos CR mul exch sin CR mul
  alpha beta sub dup cos CR mul exch sin CR mul
  4 copy ABVect Vy mul 0 le exch Vx mul 0 le and
  { 4 2 roll } if } ifelse
 } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% R R' OO' -> x1 y1 x2 y2
/InterCircles {
  /OOP exch def /CRP exch def /CR exch def
  OOP dup mul CRP dup mul sub CR dup mul add OOP div 2 div
  dup dup mul CR dup mul exch sub dup
  0 lt { pop pop 0 0 0 0 } { sqrt 2 copy neg } ifelse
} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% x y theta -> x' y' (rotation of theta)
/Rotate {
  dup sin /sintheta exch def cos /costheta exch def /y exch def /x exch def
  x costheta mul y sintheta mul sub
  y costheta mul x sintheta mul add
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% N -> x y
/GetNode {
  tx@NodeDict begin
    tx@NodeDict 1 index known { load GetCenter } { pop 0 0 } ifelse
  end
} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% x -> ch(x)
/ch { dup Ex exch neg Ex add 2 div } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% x -> sh(x)
/sh { dup Ex exch neg Ex sub 2 div } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% x -> e^(x)
/Ex { E exch exp } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% x f g -> x y n
/NewtonSolving {
  /g exch def /f exch def 0
  { %%% STACK: x0 n
    1 add exch %% one more loop
    dup ZeroEq
    { dup 0.0005 add fgeval
      1 index 0.0005 sub fgeval sub .001 div }
    { dup 1.0005 mul fgeval
      1 index 0.9995 mul fgeval sub .001 2 index mul div } ifelse  %%% STACK: n x0 fg'(x0)
    %%% compute x1=x0-fg(x0)/fg'(x0)
    1 index fgeval exch div dup 4 1 roll sub exch %% stack: dx x0 n
    3 -1 roll ZeroEq              %% exit if root found
    1 index 100 eq or { exit } if %% or looping for more than 100 times
  } loop
  dup 100 lt { exch dup /x exch def f } { pop 0 0 } ifelse
  3 -1 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/fgeval { /x exch def f g sub } bind def
end
% END ps-euclide.pro

%%EndProcSet
%%BeginProcSet: pst-grad.pro 0 0
%!
% PostScript prologue for pst-grad.tex.
% Version 1.05, 2006/11/04 
% prepared by Herbert Voss
% For copying restrictions, see pstricks.tex.
%
% For the PSTricks gradient fillstyle.%
% Based on some EPS files by leeweyr!bill@nuchat.sccsi.com (W. R. Lee).%
% Syntax:% D.G. modification begin - Apr.  9, %1998
%%%%%% R0 G0 B0 R1 G1 B1 NumLines MidPoint Angle GradientFill
%   ifGradientCircle GradientScale %GradientPosX GradientPosY
%     R0 G0 B0 R1 G1 B1 NumLines MidPoint %Angle GradientFill
% D.G. modification end
%
/tx@GradientDict 40 dict def
tx@GradientDict begin
/GradientFill {
 /ifCMYK exch def   % do we have rgb or cmyk? hv 1.06
 rotate
 /MidPoint ED
 /NumLines ED
 ifCMYK {
    /LastBlack ED	% 1.06
    /LastYellow ED	% 1.06
    /LastMagenta ED	% 1.06
    /LastCyan ED	% 1.06
    /FirstBlack ED	% 1.06
    /FirstYellow ED	% 1.06
    /FirstMagenta ED	% 1.06
    /FirstCyan ED	% 1.06
 }{ /LastBlue ED
    /LastGreen ED
    /LastRed ED
    /FirstBlue ED
    /FirstGreen ED
    /FirstRed ED
 } ifelse
 /GradientPosY ED
 /GradientPosX ED
 /GradientScale ED
 /ifGradientCircle ED
 % This avoids gaps due to rounding errors:
 clip
 pathbbox           %leave llx,lly,urx,ury on stack
 4 copy /ury ED /urx ED /lly ED /llx ED
 /y ED /x ED
 ifGradientCircle
   { 0 GradientPosX eq { 0 GradientPosX eq {2 copy translate} if } if }
   {2 copy translate} ifelse
 y sub neg /y ED
 x sub neg /x ED  % This avoids gaps due to rounding errors:
 ifCMYK {				% 1.06
    LastCyan FirstCyan add 2 div	% 1.06
    LastMagenta FirstMagenta add 2 div	% 1.06
    LastYellow FirstYellow add 2 div	% 1.06
    LastBlack FirstBlack add 2 div	% 1.06
    setcmykcolor			% 1.06
  }{
    LastRed FirstRed add 2 div
    LastGreen FirstGreen add 2 div
    LastBlue FirstBlue add 2 div
    setrgbcolor
  } ifelse
 ifGradientCircle
   { /YSizePerLine y NumLines div def
     /CurrentY y 2 div def
     /MidLine NumLines 2 div 1 MidPoint sub mul abs cvi def
   }{
     fill
     /YSizePerLine y NumLines div def
     /CurrentY 0 def
     /MidLine NumLines 1 MidPoint sub mul abs cvi def
   } ifelse
 MidLine NumLines 2 sub gt 
   { /MidLine NumLines def }
   { MidLine 2 lt { /MidLine 0 def } if } ifelse
 MidLine 0 gt {
  ifCMYK {
    /Cyan FirstCyan def
    /Magenta FirstMagenta def
    /Yellow FirstYellow def
    /Black FirstBlack def
    /CyanIncrement LastCyan FirstCyan sub MidLine 1 sub div def
    /MagentaIncrement LastMagenta FirstMagenta sub MidLine 1 sub div def
    /YellowIncrement LastYellow FirstYellow sub MidLine 1 sub div def
    /BlackIncrement LastBlack FirstBlack sub MidLine 1 sub div def
  }{
    /Red FirstRed def
    /Green FirstGreen def
    /Blue FirstBlue def
    /RedIncrement LastRed FirstRed sub MidLine 1 sub div def
    /GreenIncrement LastGreen FirstGreen sub MidLine 1 sub div def
    /BlueIncrement LastBlue FirstBlue sub MidLine 1 sub div def
  } ifelse
  MidLine { GradientLoop } repeat
 } if
 MidLine NumLines lt {
  ifCMYK {
    /Cyan LastCyan def
    /Magenta LastMagenta def
    /Yellow LastYellow def
    /Black LastBlack def
    /CyanIncrement FirstCyan LastCyan sub NumLines MidLine sub 1 sub div def
    /MagentaIncrement FirstMagenta LastMagenta sub NumLines MidLine sub 1 sub div def
    /YellowIncrement FirstYellow LastYellow sub NumLines MidLine sub 1 sub div def
    /BlackIncrement FirstBlack LastBlack sub NumLines MidLine sub 1 sub div def
  }{
    /Red LastRed def
    /Green LastGreen def
    /Blue LastBlue def
    /RedIncrement FirstRed LastRed sub NumLines MidLine sub 1 sub div def
    /GreenIncrement FirstGreen LastGreen sub NumLines MidLine sub 1 sub div def
    /BlueIncrement FirstBlue LastBlue sub NumLines MidLine sub 1 sub div def
  } ifelse
  NumLines MidLine sub { GradientLoop } repeat  
 } if
} def/GradientLoop {
% D.G. modification begin - Jul. 23, 1997 / Apr.  9, 1998
  ifGradientCircle
   {CurrentY 0 gt {
% The default center used is the center of the bounding box of the object
      0 GradientPosX eq        {0 GradientPosX eq
           {/GradientPosX urx llx sub 2 div def
            /GradientPosY ury lly sub 2 div def} if} if
      GradientPosX GradientPosY CurrentY GradientScale mul 0 360 arc
      ifCMYK { Cyan Magenta Yellow Black setcmykcolor }
           { Red Green Blue setrgbcolor } ifelse 
      fill
      /CurrentY CurrentY YSizePerLine sub def
      ifCMYK {
        /Cyan Cyan CyanIncrement add def
        /Magenta Magenta MagentaIncrement add def
        /Yellow Yellow YellowIncrement add def
        /Black Black BlackIncrement add def
      }{	
        /Blue Blue BlueIncrement add def
        /Green Green GreenIncrement add def
        /Red Red RedIncrement add def
      } ifelse
  } if }   { 0 CurrentY moveto    x 0 rlineto
    0 YSizePerLine rlineto    x neg 0 rlineto    closepath
      ifCMYK { Cyan Magenta Yellow Black setcmykcolor }
           { Red Green Blue setrgbcolor } ifelse 
      fill    
      /CurrentY CurrentY YSizePerLine add def
      ifCMYK {
        /Cyan Cyan CyanIncrement add def
        /Magenta Magenta MagentaIncrement add def
        /Yellow Yellow YellowIncrement add def
        /Black Black BlackIncrement add def
      }{	
        /Blue Blue BlueIncrement add def
        /Green Green GreenIncrement add def
        /Red Red RedIncrement add def
      } ifelse
      } ifelse% D.G. modification end
    }def
%
/GradientFillHSB { %	hv 2006-11-04
  rotate
  /MidPoint ED
  /NumLines ED
  /LastBrightness ED
  /LastSaturation ED
  /LastHue ED
  /FirstBrightness ED
  /FirstSaturation ED
  /FirstHue ED
  % This avoids gaps due to rounding errors:
  clip
  pathbbox           %leave llx,lly,urx,ury on stack
  /y ED /x ED
  2 copy translate
  y sub neg /y ED
  x sub neg /x ED
  % This avoids gaps due to rounding errors:
  LastHue FirstHue add 2 div
  LastSaturation FirstSaturation add 2 div
  LastBrightness FirstBrightness add 2 div
  sethsbcolor
  fill
  /YSizePerLine y NumLines div def
  /CurrentY 0 def
  /MidLine NumLines 1 MidPoint sub mul abs cvi def
  MidLine NumLines 2 sub gt
  { /MidLine NumLines def }
  { MidLine 2 lt { /MidLine 0 def } if }
  ifelse
  MidLine 0 gt
  {
    /Hue FirstHue def
    /Saturation FirstSaturation def
    /Brightness FirstBrightness def
    /HueIncrement LastHue FirstHue sub MidLine 1 sub div def
    /SaturationIncrement LastSaturation FirstSaturation sub MidLine 1 sub
                         div def
    /BrightnessIncrement LastBrightness FirstBrightness sub MidLine 1 sub
                         div def
    MidLine { GradientLoopHSB } repeat
  } if
  MidLine NumLines lt
  {
    /Hue LastHue def
    /Saturation LastSaturation def
    /Brightness LastBrightness def
    /HueIncrement FirstHue LastHue sub NumLines MidLine sub 1 sub div def
    /SaturationIncrement FirstSaturation LastSaturation sub
                         NumLines MidLine sub 1 sub div def
    /BrightnessIncrement FirstBrightness LastBrightness sub
                         NumLines MidLine sub 1 sub div def
    NumLines MidLine sub { GradientLoopHSB } repeat
  } if
} def
/GradientLoopHSB {
  0 CurrentY moveto
  x 0 rlineto
  0 YSizePerLine rlineto
  x neg 0 rlineto
  closepath
  Hue Saturation Brightness sethsbcolor fill
  /CurrentY CurrentY YSizePerLine add def
  /Brightness Brightness BrightnessIncrement add def
  /Saturation Saturation SaturationIncrement add def
  /Hue Hue HueIncrement add def
} def
%
end
%
% END pst-grad.pro

%%EndProcSet
%%BeginProcSet: pst-coil.pro 0 0
%!ps
% PostScript prologue for pst-coil.tex.
% Version 1.07, 2015/05/13
% For distribution, see pstricks.tex.
%
/tx@CoilDict 40 dict def tx@CoilDict begin
/CoilLoop { 
  /t ED 
  t sin AspectSin mul t 180 div AspectCos mul add t cos lineto } def
/Coil { 
  /Inc ED 
  dup sin /AspectSin ED 
  cos /AspectCos ED 
  /ArmB ED 
  /ArmA ED
  /h ED /w ED /y1 ED /x1 ED /y0 ED /x0 ED 
  x0 y0 translate y1 y0 sub x1 x0 sub 2 copy Pyth 
  /TotalLength ED 
  Atan rotate 
  /BeginAngle ArmA AspectCos Div w h mul Div 360 mul def 
  /EndAngle TotalLength ArmB sub AspectCos Div
    w h mul Div 360 mul def 
  1 0 0 0 ArrowA ArmA 0 lineto 
  /mtrx CM def 
  w h mul 2 Div w 2 Div scale BeginAngle Inc 
  EndAngle { CoilLoop } for
  EndAngle CoilLoop mtrx setmatrix TotalLength ArmB sub 0 lineto CP
% DG/SR modification begin - Jun.  2, 1998 - Patch 1 (from Michael Vulis)
% TotalLength 0 ArrowB lineto } def
  TotalLength 0 ArrowB lineto
  pop pop pop pop } def
% DG/SR modification end
%
/Sin { 
  25 dict begin
  /Func ED
  /PointsPerPeriod ED
  /ArmB ED 
  /ArmA ED
  /Amplitude ED 
  /roundValue ED
  /relativePeriod ED 
  /Periods ED 
  /y1 ED /x1 ED /y0 ED /x0 ED 
  y1 y0 sub x1 x0 sub 2 copy Pyth 
  dup /TotalLength ED
  ArmA sub ArmB sub /SinLength ED 
  Atan /RotAngle ED
  relativePeriod 
    {} 
    { SinLength Periods div 
      roundValue dup 0 eq { pop cvi } { 1 eq { round } if } ifelse
      /Periods ED } ifelse
  /dxStep SinLength 360 div def         % the default step for x pos
  /xStep 360 PointsPerPeriod div def    % the step for the for loop
  /mtrx CM def 
  x0 y0 translate 
  RotAngle rotate 
  1 0 0 0 ArrowA ArmA 0 lineto 
  1 xStep 360 {                         % PointsPerPeriod times
    dup dxStep mul ArmA add exch        % x pos and value for the func
    Periods mul Func Amplitude mul lineto
  } for
  TotalLength ArmB sub 0 lineto CP
  TotalLength 0 ArrowB lineto
  mtrx setmatrix 
  pop pop pop pop 
  end
} def
%
/AltCoil { 
  /Inc ED 
  dup sin /AspectSin ED 
  cos /AspectCos ED /h ED /w ED /EndAngle ED /BeginAngle ED 
  /mtrx CM def 
  w h mul 2 Div w 2 Div scale BeginAngle sin AspectSin mul 
  BeginAngle 180 div AspectCos mul add BeginAngle cos 
  /lineto load stopped { moveto } if 
  BeginAngle Inc EndAngle { CoilLoop } for 
  EndAngle CoilLoop mtrx setmatrix } def
/ZigZag { 15 dict begin 
  /ArmB ED /ArmA ED 
  2 div /w ED 
  w mul /h ED /y1 ED /x1 ED /y0 ED /x0 ED 
  x1 y1 translate y0 y1 sub x0 x1 sub 2 copy Pyth 
  /TotalLength ED
  Atan rotate TotalLength ArmA sub ArmB sub dup h div cvi /n ED n h mul
  sub 2 div dup ArmA add 
  /ArmA ED ArmB add 
  /ArmB ED 
  /x ArmB h 2 div add def 
  mark 0 0 ArmB 0 
  n { x w /w w neg def /x x h add def } repeat
  TotalLength ArmA sub 0 TotalLength 0 
  end } def
%
 /ZigZagCirc { % x0 y0 x1 y1 bow h w ArmA ArmB on stack
  /bow ED 
  /ArmB ED /ArmA ED 
  2 div /w ED 
  w mul /h ED /y1 ED /x1 ED /y0 ED /x0 ED 
  x1 y1 translate %
  y0 y1 sub x0 x1 sub 2 copy Pyth 2 div 
  /HalfLength ED
  Atan /ang ED %angle of A relative to B
  %rotate % so end B is origin and BA is horizontal, A to right
  /theta bow abs HalfLength Atan 2 mul def %halfangular sector for arc
  /theta2 theta 2 mul def % full arc
  %/psi ang 90 sub theta sub def % angle of B from center if bow>0
  /rho HalfLength theta sin div def % radius of circle
  bow 0 gt { /direc 1 def /thetaB ang 90 sub theta sub def } % travel B to A in pos drn
  { /direc -1 def /thetaB ang 90 add theta add def } ifelse % travel B to A in neg drn
  %thetaB=angle from center to B
  rho thetaB 180 add PtoC translate % origin now at center
  /h h rho div RadtoDeg def
  /ArmA ArmA rho div RadtoDeg def /ArmB ArmB rho div RadtoDeg def
  theta2 ArmA sub ArmB sub dup h div cvi /n ED n h mul
  %HalfLength 2 mul ArmA sub ArmB sub dup h div cvi /n ED n h mul
  sub 2 div dup ArmA add 
  /ArmA ED ArmB add /ArmB ED 
  /h h direc mul def % h is now angle increment for half-period
  /rhoo rho w add def /rhoi rho w sub def % outer and inner radii
  /arg thetaB ArmB direc mul add def % argument for 2nd point
%  thetaB = direc = bow = HalfLength = theta = rho = arg = h = n =
  mark rho thetaB  PtoC  rho arg PtoC /arg arg h 2 div add def
  n { w 0 gt { rhoo }{ rhoi } ifelse arg PtoC /w w neg def /arg arg h add def } repeat
  rho thetaB theta2 ArmA sub direc mul add  PtoC rho thetaB theta2 direc mul add PtoC  
  } def 
%
end
% END pst-coil.pro

%%EndProcSet
%%BeginProcSet: 8r.enc 0 0
% File 8r.enc  TeX Base 1 Encoding  Revision 2.0  2002-10-30
%
% @@psencodingfile@{
%   author    = "S. Rahtz, P. MacKay, Alan Jeffrey, B. Horn, K. Berry,
%                W. Schmidt, P. Lehman",
%   version   = "2.0",
%   date      = "27nov06",
%   filename  = "8r.enc",
%   email     = "tex-fonts@@tug.org",
%   docstring = "This is the encoding vector for Type1 and TrueType
%                fonts to be used with TeX.  This file is part of the
%                PSNFSS bundle, version 9"
% @}
% 
% The idea is to have all the characters normally included in Type 1 fonts
% available for typesetting. This is effectively the characters in Adobe
% Standard encoding, ISO Latin 1, Windows ANSI including the euro symbol,
% MacRoman, and some extra characters from Lucida.
% 
% Character code assignments were made as follows:
% 
% (1) the Windows ANSI characters are almost all in their Windows ANSI
% positions, because some Windows users cannot easily reencode the
% fonts, and it makes no difference on other systems. The only Windows
% ANSI characters not available are those that make no sense for
% typesetting -- rubout (127 decimal), nobreakspace (160), softhyphen
% (173). quotesingle and grave are moved just because it's such an
% irritation not having them in TeX positions.
% 
% (2) Remaining characters are assigned arbitrarily to the lower part
% of the range, avoiding 0, 10 and 13 in case we meet dumb software.
% 
% (3) Y&Y Lucida Bright includes some extra text characters; in the
% hopes that other PostScript fonts, perhaps created for public
% consumption, will include them, they are included starting at 0x12.
% These are /dotlessj /ff /ffi /ffl.
% 
% (4) hyphen appears twice for compatibility with both ASCII and Windows.
%
% (5) /Euro was assigned to 128, as in Windows ANSI
%
% (6) Missing characters from MacRoman encoding incorporated as follows:
%
%     PostScript      MacRoman        TeXBase1
%     --------------  --------------  --------------
%     /notequal       173             0x16
%     /infinity       176             0x17
%     /lessequal      178             0x18
%     /greaterequal   179             0x19
%     /partialdiff    182             0x1A
%     /summation      183             0x1B
%     /product        184             0x1C
%     /pi             185             0x1D
%     /integral       186             0x81
%     /Omega          189             0x8D
%     /radical        195             0x8E
%     /approxequal    197             0x8F
%     /Delta          198             0x9D
%     /lozenge        215             0x9E
%
/TeXBase1Encoding [
% 0x00
 /.notdef /dotaccent /fi /fl
 /fraction /hungarumlaut /Lslash /lslash
 /ogonek /ring /.notdef /breve
 /minus /.notdef /Zcaron /zcaron
% 0x10
 /caron /dotlessi /dotlessj /ff
 /ffi /ffl /notequal /infinity
 /lessequal /greaterequal /partialdiff /summation
 /product /pi /grave /quotesingle
% 0x20
 /space /exclam /quotedbl /numbersign
 /dollar /percent /ampersand /quoteright
 /parenleft /parenright /asterisk /plus
 /comma /hyphen /period /slash
% 0x30
 /zero /one /two /three
 /four /five /six /seven
 /eight /nine /colon /semicolon
 /less /equal /greater /question
% 0x40
 /at /A /B /C
 /D /E /F /G
 /H /I /J /K
 /L /M /N /O
% 0x50
 /P /Q /R /S
 /T /U /V /W
 /X /Y /Z /bracketleft
 /backslash /bracketright /asciicircum /underscore
% 0x60
 /quoteleft /a /b /c
 /d /e /f /g
 /h /i /j /k
 /l /m /n /o
% 0x70
 /p /q /r /s
 /t /u /v /w
 /x /y /z /braceleft
 /bar /braceright /asciitilde /.notdef
% 0x80
 /Euro /integral /quotesinglbase /florin
 /quotedblbase /ellipsis /dagger /daggerdbl
 /circumflex /perthousand /Scaron /guilsinglleft
 /OE /Omega /radical /approxequal
% 0x90
 /.notdef /.notdef /.notdef /quotedblleft
 /quotedblright /bullet /endash /emdash
 /tilde /trademark /scaron /guilsinglright
 /oe /Delta /lozenge /Ydieresis
% 0xA0
 /.notdef /exclamdown /cent /sterling
 /currency /yen /brokenbar /section
 /dieresis /copyright /ordfeminine /guillemotleft
 /logicalnot /hyphen /registered /macron
% 0xB0
 /degree /plusminus /twosuperior /threesuperior
 /acute /mu /paragraph /periodcentered
 /cedilla /onesuperior /ordmasculine /guillemotright
 /onequarter /onehalf /threequarters /questiondown
% 0xC0
 /Agrave /Aacute /Acircumflex /Atilde
 /Adieresis /Aring /AE /Ccedilla
 /Egrave /Eacute /Ecircumflex /Edieresis
 /Igrave /Iacute /Icircumflex /Idieresis
% 0xD0
 /Eth /Ntilde /Ograve /Oacute
 /Ocircumflex /Otilde /Odieresis /multiply
 /Oslash /Ugrave /Uacute /Ucircumflex
 /Udieresis /Yacute /Thorn /germandbls
% 0xE0
 /agrave /aacute /acircumflex /atilde
 /adieresis /aring /ae /ccedilla
 /egrave /eacute /ecircumflex /edieresis
 /igrave /iacute /icircumflex /idieresis
% 0xF0
 /eth /ntilde /ograve /oacute
 /ocircumflex /otilde /odieresis /divide
 /oslash /ugrave /uacute /ucircumflex
 /udieresis /yacute /thorn /ydieresis
] def


%%EndProcSet
%%BeginProcSet: texps.pro 0 0
%!
TeXDict begin/rf{findfont dup length 1 add dict begin{1 index/FID ne 2
index/UniqueID ne and{def}{pop pop}ifelse}forall[1 index 0 6 -1 roll
exec 0 exch 5 -1 roll VResolution Resolution div mul neg 0 0]FontType 0
ne{/Metrics exch def dict begin Encoding{exch dup type/integertype ne{
pop pop 1 sub dup 0 le{pop}{[}ifelse}{FontMatrix 0 get div Metrics 0 get
div def}ifelse}forall Metrics/Metrics currentdict end def}{{1 index type
/nametype eq{exit}if exch pop}loop}ifelse[2 index currentdict end
definefont 3 -1 roll makefont/setfont cvx]cvx def}def/ObliqueSlant{dup
sin S cos div neg}B/SlantFont{4 index mul add}def/ExtendFont{3 -1 roll
mul exch}def/ReEncodeFont{CharStrings rcheck{/Encoding false def dup[
exch{dup CharStrings exch known not{pop/.notdef/Encoding true def}if}
forall Encoding{]exch pop}{cleartomark}ifelse}if/Encoding exch def}def
end

%%EndProcSet
%%BeginProcSet: special.pro 0 0
%!
TeXDict begin/SDict 200 dict N SDict begin/@SpecialDefaults{/hs 612 N
/vs 792 N/ho 0 N/vo 0 N/hsc 1 N/vsc 1 N/ang 0 N/CLIP 0 N/rwiSeen false N
/rhiSeen false N/letter{}N/note{}N/a4{}N/legal{}N}B/@scaleunit 100 N
/@hscale{@scaleunit div/hsc X}B/@vscale{@scaleunit div/vsc X}B/@hsize{
/hs X/CLIP 1 N}B/@vsize{/vs X/CLIP 1 N}B/@clip{/CLIP 2 N}B/@hoffset{/ho
X}B/@voffset{/vo X}B/@angle{/ang X}B/@rwi{10 div/rwi X/rwiSeen true N}B
/@rhi{10 div/rhi X/rhiSeen true N}B/@llx{/llx X}B/@lly{/lly X}B/@urx{
/urx X}B/@ury{/ury X}B/magscale true def end/@MacSetUp{userdict/md known
{userdict/md get type/dicttype eq{userdict begin md length 10 add md
maxlength ge{/md md dup length 20 add dict copy def}if end md begin
/letter{}N/note{}N/legal{}N/od{txpose 1 0 mtx defaultmatrix dtransform S
atan/pa X newpath clippath mark{transform{itransform moveto}}{transform{
itransform lineto}}{6 -2 roll transform 6 -2 roll transform 6 -2 roll
transform{itransform 6 2 roll itransform 6 2 roll itransform 6 2 roll
curveto}}{{closepath}}pathforall newpath counttomark array astore/gc xdf
pop ct 39 0 put 10 fz 0 fs 2 F/|______Courier fnt invertflag{PaintBlack}
if}N/txpose{pxs pys scale ppr aload pop por{noflips{pop S neg S TR pop 1
-1 scale}if xflip yflip and{pop S neg S TR 180 rotate 1 -1 scale ppr 3
get ppr 1 get neg sub neg ppr 2 get ppr 0 get neg sub neg TR}if xflip
yflip not and{pop S neg S TR pop 180 rotate ppr 3 get ppr 1 get neg sub
neg 0 TR}if yflip xflip not and{ppr 1 get neg ppr 0 get neg TR}if}{
noflips{TR pop pop 270 rotate 1 -1 scale}if xflip yflip and{TR pop pop
90 rotate 1 -1 scale ppr 3 get ppr 1 get neg sub neg ppr 2 get ppr 0 get
neg sub neg TR}if xflip yflip not and{TR pop pop 90 rotate ppr 3 get ppr
1 get neg sub neg 0 TR}if yflip xflip not and{TR pop pop 270 rotate ppr
2 get ppr 0 get neg sub neg 0 S TR}if}ifelse scaleby96{ppr aload pop 4
-1 roll add 2 div 3 1 roll add 2 div 2 copy TR .96 dup scale neg S neg S
TR}if}N/cp{pop pop showpage pm restore}N end}if}if}N/normalscale{
Resolution 72 div VResolution 72 div neg scale magscale{DVImag dup scale
}if 0 setgray}N/@beginspecial{SDict begin/SpecialSave save N gsave
normalscale currentpoint TR @SpecialDefaults count/ocount X/dcount
countdictstack N}N/@setspecial{CLIP 1 eq{newpath 0 0 moveto hs 0 rlineto
0 vs rlineto hs neg 0 rlineto closepath clip}if ho vo TR hsc vsc scale
ang rotate rwiSeen{rwi urx llx sub div rhiSeen{rhi ury lly sub div}{dup}
ifelse scale llx neg lly neg TR}{rhiSeen{rhi ury lly sub div dup scale
llx neg lly neg TR}if}ifelse CLIP 2 eq{newpath llx lly moveto urx lly
lineto urx ury lineto llx ury lineto closepath clip}if/showpage{}N
/erasepage{}N/setpagedevice{pop}N/copypage{}N newpath}N/@endspecial{
count ocount sub{pop}repeat countdictstack dcount sub{end}repeat
grestore SpecialSave restore end}N/@defspecial{SDict begin}N
/@fedspecial{end}B/li{lineto}B/rl{rlineto}B/rc{rcurveto}B/np{/SaveX
currentpoint/SaveY X N 1 setlinecap newpath}N/st{stroke SaveX SaveY
moveto}N/fil{fill SaveX SaveY moveto}N/ellipse{/endangle X/startangle X
/yrad X/xrad X/savematrix matrix currentmatrix N TR xrad yrad scale 0 0
1 startangle endangle arc savematrix setmatrix}N end

%%EndProcSet
%%BeginProcSet: color.pro 0 0
%!
TeXDict begin/setcmykcolor where{pop}{/setcmykcolor{dup 10 eq{pop
setrgbcolor}{1 sub 4 1 roll 3{3 index add neg dup 0 lt{pop 0}if 3 1 roll
}repeat setrgbcolor pop}ifelse}B}ifelse/TeXcolorcmyk{setcmykcolor}def
/TeXcolorrgb{setrgbcolor}def/TeXcolorgrey{setgray}def/TeXcolorgray{
setgray}def/TeXcolorhsb{sethsbcolor}def/currentcmykcolor where{pop}{
/currentcmykcolor{currentrgbcolor 10}B}ifelse/DC{exch dup userdict exch
known{pop pop}{X}ifelse}B/GreenYellow{0.15 0 0.69 0 setcmykcolor}DC
/Yellow{0 0 1 0 setcmykcolor}DC/Goldenrod{0 0.10 0.84 0 setcmykcolor}DC
/Dandelion{0 0.29 0.84 0 setcmykcolor}DC/Apricot{0 0.32 0.52 0
setcmykcolor}DC/Peach{0 0.50 0.70 0 setcmykcolor}DC/Melon{0 0.46 0.50 0
setcmykcolor}DC/YellowOrange{0 0.42 1 0 setcmykcolor}DC/Orange{0 0.61
0.87 0 setcmykcolor}DC/BurntOrange{0 0.51 1 0 setcmykcolor}DC
/Bittersweet{0 0.75 1 0.24 setcmykcolor}DC/RedOrange{0 0.77 0.87 0
setcmykcolor}DC/Mahogany{0 0.85 0.87 0.35 setcmykcolor}DC/Maroon{0 0.87
0.68 0.32 setcmykcolor}DC/BrickRed{0 0.89 0.94 0.28 setcmykcolor}DC/Red{
0 1 1 0 setcmykcolor}DC/OrangeRed{0 1 0.50 0 setcmykcolor}DC/RubineRed{
0 1 0.13 0 setcmykcolor}DC/WildStrawberry{0 0.96 0.39 0 setcmykcolor}DC
/Salmon{0 0.53 0.38 0 setcmykcolor}DC/CarnationPink{0 0.63 0 0
setcmykcolor}DC/Magenta{0 1 0 0 setcmykcolor}DC/VioletRed{0 0.81 0 0
setcmykcolor}DC/Rhodamine{0 0.82 0 0 setcmykcolor}DC/Mulberry{0.34 0.90
0 0.02 setcmykcolor}DC/RedViolet{0.07 0.90 0 0.34 setcmykcolor}DC
/Fuchsia{0.47 0.91 0 0.08 setcmykcolor}DC/Lavender{0 0.48 0 0
setcmykcolor}DC/Thistle{0.12 0.59 0 0 setcmykcolor}DC/Orchid{0.32 0.64 0
0 setcmykcolor}DC/DarkOrchid{0.40 0.80 0.20 0 setcmykcolor}DC/Purple{
0.45 0.86 0 0 setcmykcolor}DC/Plum{0.50 1 0 0 setcmykcolor}DC/Violet{
0.79 0.88 0 0 setcmykcolor}DC/RoyalPurple{0.75 0.90 0 0 setcmykcolor}DC
/BlueViolet{0.86 0.91 0 0.04 setcmykcolor}DC/Periwinkle{0.57 0.55 0 0
setcmykcolor}DC/CadetBlue{0.62 0.57 0.23 0 setcmykcolor}DC
/CornflowerBlue{0.65 0.13 0 0 setcmykcolor}DC/MidnightBlue{0.98 0.13 0
0.43 setcmykcolor}DC/NavyBlue{0.94 0.54 0 0 setcmykcolor}DC/RoyalBlue{1
0.50 0 0 setcmykcolor}DC/Blue{1 1 0 0 setcmykcolor}DC/Cerulean{0.94 0.11
0 0 setcmykcolor}DC/Cyan{1 0 0 0 setcmykcolor}DC/ProcessBlue{0.96 0 0 0
setcmykcolor}DC/SkyBlue{0.62 0 0.12 0 setcmykcolor}DC/Turquoise{0.85 0
0.20 0 setcmykcolor}DC/TealBlue{0.86 0 0.34 0.02 setcmykcolor}DC
/Aquamarine{0.82 0 0.30 0 setcmykcolor}DC/BlueGreen{0.85 0 0.33 0
setcmykcolor}DC/Emerald{1 0 0.50 0 setcmykcolor}DC/JungleGreen{0.99 0
0.52 0 setcmykcolor}DC/SeaGreen{0.69 0 0.50 0 setcmykcolor}DC/Green{1 0
1 0 setcmykcolor}DC/ForestGreen{0.91 0 0.88 0.12 setcmykcolor}DC
/PineGreen{0.92 0 0.59 0.25 setcmykcolor}DC/LimeGreen{0.50 0 1 0
setcmykcolor}DC/YellowGreen{0.44 0 0.74 0 setcmykcolor}DC/SpringGreen{
0.26 0 0.76 0 setcmykcolor}DC/OliveGreen{0.64 0 0.95 0.40 setcmykcolor}
DC/RawSienna{0 0.72 1 0.45 setcmykcolor}DC/Sepia{0 0.83 1 0.70
setcmykcolor}DC/Brown{0 0.81 1 0.60 setcmykcolor}DC/Tan{0.14 0.42 0.56 0
setcmykcolor}DC/Gray{0 0 0 0.50 setcmykcolor}DC/Black{0 0 0 1
setcmykcolor}DC/White{0 0 0 0 setcmykcolor}DC end

%%EndProcSet
TeXDict begin @defspecial

 /pgfH{/pgfheight exch def 0.75 setlinewidth [] 0 setdash /pgfshade
{pgfA} def /pgfdir { dup 0 moveto dup 5 index lineto } bind def} bind
def

 /pgfV{/pgfheight exch def 0.75 setlinewidth [] 0 setdash /pgfshade
{pgfA} def /pgfdir { dup 0 exch moveto dup 5 index exch lineto } bind
def} bind def

 /pgfA{ /pgfdiff 8 index round cvi 8 index round cvi sub 2 mul 1 add
def 2 index 6 index sub pgfdiff div 2 index 6 index sub pgfdiff div
2 index 6 index sub pgfdiff div pgfheight 9 index 9 index 9 index 14
index pgfdiff { 3 index 3 index 3 index setrgbcolor pgfdir stroke 4
-1 roll 7 index add 4 -1 roll 6 index add 4 -1 roll 5 index add 4 -1
roll .5 sub } repeat mark 15 1 roll cleartomark exch pop }bind def

 /pgfR1{ newpath dup dup dup 0 360 arc clip newpath dup /pgfendx exch
def /pgfendy exch def 0.875 setlinewidth [] 0 setdash /pgfshade {pgfR}
def /pgfstartx exch def /pgfstarty exch def /pgfdiffx pgfendx pgfstartx
sub def /pgfdiffy pgfendy pgfstarty sub def dup /pgfdomb exch def }bind
def

 /pgfR2{ newpath 0.5 add pgfcircx pgfcircy 3 2 roll 0 360 arc setrgbcolor
fill pop}bind def

 /pgfR{ /pgfdiff 8 index round cvi 8 index round cvi sub 4 mul 1 add
def /pgfcircx pgfstartx 9 index pgfdiffx pgfdomb div mul add def /pgfcircy
pgfstarty 9 index pgfdiffy pgfdomb div mul add def /pgfcircxe pgfstartx
8 index pgfdiffx pgfdomb div mul add def /pgfcircye pgfstarty 8 index
pgfdiffy pgfdomb div mul add def /pgfxstep pgfcircxe pgfcircx sub pgfdiff
div def /pgfystep pgfcircye pgfcircy sub pgfdiff div def 2 index 6
index sub pgfdiff div 2 index 6 index sub pgfdiff div 2 index 6 index
sub pgfdiff div 8 index 8 index 8 index 13 index pgfdiff { 3 index
3 index 3 index setrgbcolor pgfcircx pgfcircy 2 index 0 360 arc closepath
stroke 4 -1 roll 6 index add 4 -1 roll 5 index add 4 -1 roll 4 index
add 4 -1 roll .25 sub /pgfcircx pgfcircx pgfxstep add def /pgfcircy
pgfcircy pgfystep add def } repeat mark 14 1 roll cleartomark exch
pop }bind def

  /pgfsc{}bind def/pgffc{}bind def/pgfstr{stroke}bind def/pgffill{fill}bind
def/pgfeofill{eofill}bind def/pgfe{a dup 0 rlineto exch 0 exch rlineto
neg 0 rlineto closepath}bind def/pgfw{setlinewidth}bind def/pgfs{save
pgfpd 72 Resolution div 72 VResolution div neg scale magscale{1 DVImag
div dup scale}if pgfx neg pgfy neg translate pgffoa .setopacityalpha}bind
def/pgfr{pgfsd restore}bind def userdict begin/pgfo{pgfsd /pgfx currentpoint
/pgfy exch def def @beginspecial}bind def /pgfc{newpath @endspecial
pgfpd}bind def /pgfsd{globaldict /pgfdelta /delta where {pop delta}
{0} ifelse put}bind def/pgfpd{/delta globaldict /pgfdelta get def}bind
def /.setopacityalpha where {pop} {/.setopacityalpha{pop}def} ifelse
/.pgfsetfillopacityalpha{/pgffoa exch def /pgffill{gsave pgffoa .setopacityalpha
fill 1 .setopacityalpha newpath fill grestore newpath}bind def /pgfeofill{gsave
pgffoa .setopacityalpha eofill 1 .setopacityalpha newpath eofill grestore
newpath}bind def}bind def /.pgfsetstrokeopacityalpha{/pgfsoa exch def
/pgfstr{gsave pgfsoa .setopacityalpha stroke grestore newpath}bind
def}bind def /pgffoa 1 def /pgfsoa 1 def end

 systemdict /pdfmark known{userdict /?pdfmark systemdict /exec get
put}{userdict /?pdfmark systemdict /pop get put userdict /pdfmark systemdict
/cleartomark get put}ifelse

 /DvipsToPDF{72.27 mul Resolution div} def/PDFToDvips{72.27 div Resolution
mul} def/BPToDvips{72 div Resolution mul}def/BorderArrayPatch{[exch{dup
dup type/integertype eq exch type/realtype eq or{BPToDvips}if}forall]}def/HyperBorder
{1 PDFToDvips} def/H.V {pdf@hoff pdf@voff null} def/H.B {/Rect[pdf@llx
pdf@lly pdf@urx pdf@ury]} def/H.S {currentpoint HyperBorder add /pdf@lly
exch def dup DvipsToPDF 72 add /pdf@hoff exch def HyperBorder sub /pdf@llx
exch def} def/H.L {2 sub dup/HyperBasePt exch def PDFToDvips /HyperBaseDvips
exch def currentpoint HyperBaseDvips sub /pdf@ury exch def/pdf@urx
exch def} def/H.A {H.L currentpoint exch pop vsize 72 sub exch DvipsToPDF
HyperBasePt sub sub /pdf@voff exch def} def/H.R {currentpoint HyperBorder
sub /pdf@ury exch def HyperBorder add /pdf@urx exch def currentpoint
exch pop vsize 72 sub exch DvipsToPDF sub /pdf@voff exch def} def

 /pgf1{gsave exec 1.0 pgfw 2.00002 0.0 moveto -6.00006 4.00005 lineto
-3.00003 0.0 lineto -6.00006 -4.00005 lineto pgffill  grestore} bind
def

 /pgf2{gsave exec 1.0 pgfw 0.8 pgfw [ ] 0.0 setdash 1 setlinecap 1
setlinejoin -3.00003 4.00005 moveto -2.75002 2.50002 0.0 0.24998 0.75
0.0 curveto 0.0 -0.24998 -2.75002 -2.50002 -3.00003 -4.00005 curveto
pgfstr  grestore} bind def

 /pgf3{gsave exec 1.0 pgfw [ ] 0.0 setdash 0.0 -5.00005 moveto 0.0
5.00005 lineto pgfstr  grestore} bind def

 /pgf4{gsave exec 1.0 pgfw [ ] 0.0 setdash -3.00003 -5.00005 moveto
0.0 -5.00005 lineto 0.0 5.00005 lineto -3.00003 5.00005 lineto pgfstr
 grestore} bind def

 /pgf5{gsave exec 1.0 pgfw [ ] 0.0 setdash -2.00002 -5.00005 moveto
1.0 -3.00003 1.0 3.00003 -2.00002 5.00005 curveto pgfstr  grestore}
bind def

 /pgf6{gsave exec 1.0 pgfw [ ] 0.0 setdash -4.50003 -5.00005 moveto
0.49998 0.0 lineto -4.50003 5.00005 lineto pgfstr  grestore} bind def

 /pgf7{gsave exec 1.0 pgfw -2.50002 0.0 translate [ ] 0.0 setdash 3.00003
0.0 moveto 3.00003 1.65689 1.65689 3.00003 0.0 3.00003 curveto -1.65689
3.00003 -3.00003 1.65689 -3.00003 0.0 curveto -3.00003 -1.65689 -1.65689
-3.00003 0.0 -3.00003 curveto 1.65689 -3.00003 3.00003 -1.65689 3.00003
0.0 curveto closepath gsave pgffc pgffill grestore gsave pgfsc pgfstr
grestore newpath  grestore} bind def

 /pgf8{gsave exec 1.0 pgfw [ ] 0.0 setdash 1.0 0.0 moveto -5.00005
3.00003 lineto -11.00012 0.0 lineto -5.00005 -3.00003 lineto closepath
gsave pgffc pgffill grestore gsave pgfsc pgfstr grestore newpath  grestore}
bind def
 
@fedspecial end
%%BeginFont: Fourier-Math-Symbols
%!PS-AdobeFont-1.0: Fourier-Math-Symbols 001.004
%%CreationDate: Fri Jan 7 18:46:05 2005
%%VMusage: 120000 150000
11 dict begin
/FontInfo 14 dict dup begin
/version (001.004) readonly def
/Notice (Copyright 2003-2004, GUTenberg) readonly def
/FullName (Fourier-Math-Symbols) readonly def
/FamilyName (Fourier-Math-Symbols) readonly def
/ItalicAngle -15 def
/isFixedPitch false def
/UnderlinePosition -17 def
/UnderlineThickness 3 def
/Weight (Regular) readonly def
end readonly def
/FontName /Fourier-Math-Symbols def
/Encoding 256 array
0 1 255 {1 index exch /.notdef put} for
dup 161 /minus put
dup 165 /divide put
dup 197 /plus put
dup 198 /equal put
readonly def
/PaintType 0 def
/FontType 1 def
/FontMatrix [ 0.0010000 0 0 0.0010000 0 0 ] readonly def
/FontBBox {-34 -960 1001 847} readonly def
currentdict end
currentfile eexec
D9D66F633B846A989B9974B0179FC6CC445BCF7C3C3333173232E3FDBFF43949
1DB866C39088C203DC22FDC758584860EC7BB67FDA28CC6208249060E18FAB32
204779B5C03C0493BBBBC95CF02692CC4DEAA8D2EA90B5C2E64374E92BCB8501
429B8FAE4A76C0C6B76D6FF7CF9A7D5EDFBCA0E959541C59BD05B7DE43D25D53
FC3DDA6EF0C2743978A6D03E19CCED4A11F2EA4BCC3110BE8B8D9E2772361969
C19258EFAFDC276CB1ADE9208A941A36D18F9FB1C33DEF76AA315DDB07D441AB
0467A1BF50AD0DE4F98225ADD1F93634005664EC4D3A79AAE931F7496D4AD122
EAEBCBFB4D4AC1B8D85E9CBE4ABB2225405A9DA5AB44E12A710451885D4FADD8
C3F48A838573A733544D6AD3B5C7B3E16F8F777F1DD842F33638F7D57C0C9212
0C6560A06445FFE43730EC1895E85874440C56BF079DCF6C249978AEC565369E
E2DE0A62595334A70543753553A4D58895F84C9627524042C4B480C4654D6578
67B2C0CC4A43523BABBF2E8BB693003339A7DD77148E4C146BF5A7AA602A3908
5300B7C1798206E16AAEC1262E3B1DD7325659679A19229F75B0A7BF816E1594
68BE15C3F762C51595E7902AAB117057F4EB1316DC1C507B857AC1B1BE38123E
4AB0CC69F0C42D92081FEAC1259E24E696131A9170053DED6CE28A4D407AE241
675620191E5953CB96967BF04CE1DCB7B9089849FE477F73ADDA94B72632B5C3
E4B12701C044D3B666DB24E45DF8FB89C5DA53188D7C588C1F9DCE353F3D357C
212D5E0CE43B242313912CB809EA23E8158049754D5A9129419949A7C79BB1C5
17FD49A1E5FC3A4095D91E472B31D7A788DB3D0D0778C6D96F68C849FD58496A
9F820DA8C2E98BA0DB5D0EDD60D0A5EF062D122D5B440DEEF97172CA0DA38AC6
D8AE16E16E62C3A99D3B1DF9F1BEA90163879CEA5BA341CB947DFB0C41B08B06
946F9C8A754B9FD193F9EB60CF81B8343A759E5D9641BCE58C2D8C0BF5CBB461
88E32829BBBEEF6E1C8A713A3A614565A4A9AFDD566D081CE2954D486E275D41
3BB9DCEF1E66E7EC178E370757EC626E6E82D294BF3E83ECC0782DC63E319DD4
CF867F340449A0A245430C101F3E5DB92CD828ECD21A2B602F26E72FEB38368F
DC03123FA421EEA747607B26A3030C048BD160A39735FB6B8836B8B5A4D2AA84
96C5E265C58458246B1452B308A022655587FDF933817766BE8A1E6C29DC4365
DC1ED202CBD81E0339EC4C3C57B054EADA2C699385B3CD763CA06787E96684BF
86F7BBA7009447D8D50167498735295CFFA5358D068EA503BEBC2D3A7EEDE760
BBC03394A6B01B1AEC021C9F06834D1CDE5DED19A5A1F909707C0AA8E88898CF
1946FEBADD822804C3319B8F8FC6EB7CE96C596A8883E67BE54CB8FBE9AE9AD8
6165178CC031B3CD198B9B11374C5531F826B63ADFBA5F1DA265882DA8655742
39CDCD375CE0C2F563D93BD2372F50281760F7E8DDC8742D5334F126E211BB5D
C1F1AA393A388AC0F79D24A7E1E53241456F4A948A034ED993B65DB850BAB001
E4BABEE5099BC3C64026214CE661FF066A3CA50F270A1AB396965CB403B33B37
7695091DE9708A796FF60A4497A2E86D3891F76E452E0F062AD9499739981091
F730560C0B2473C388E12A45F0E7644C1C5A51C189C883C8AB8133723C302B4D
BB9112D42FF7B8C7482761AE06DE0DC9479A28C0B88E3E6881286F234E665326
0724A67F3D24042109F92ADAF59E7D95DAAC2905C830B8A9645A7078EE68A6DC
EA6072E431C0B796F0650CAF08917E1F62C7C5B85255C373B0C284A6A7FC4C23
59020D78684E225B940E64E5E4EA3C7E2CD361376BFA87408AC7971810EC4699
DA70E358523264C81F1CBA692A91ED08602636ACD895231CAAF4BDC582CF6E3E
B442FFF5D4D9B6EC3671EF9AA56E1AD593796E3842D87EFF1A7C
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
%%EndFont 
%%BeginFont: Utopia-Italic
%!PS-AdobeFont-1.0: Utopia-Italic 001.001
%%CreationDate: Wed Oct 2 18:58:18 1991
%%VMusage: 34122 41014
% License clarified 17 November 2006; pfb update 19 November 2006.
11 dict begin
/FontInfo 10 dict dup begin
/version (001.001) readonly def
/Notice (Copyright (c) 1989, 1991 Adobe Systems Incorporated. All Rights Reserved. Utopia is either a registered trademark or trademark of Adobe Systems Incorporated in the United States and/or other countries. Used under license. The Utopia fonts are freely available; see http://tug.org/fonts/utopia.) readonly def
/FullName (Utopia Italic) readonly def
/FamilyName (Utopia) readonly def
/Weight (Regular) readonly def
/ItalicAngle -13 def
/isFixedPitch false def
/UnderlinePosition -100 def
/UnderlineThickness 50 def
end readonly def
/FontName /Utopia-Italic def
/Encoding StandardEncoding def
/PaintType 0 def
/FontType 1 def
/FontMatrix [0.001 0 0 0.001 0 0] readonly def
/FontBBox{-166 -250 1205 890}readonly def
currentdict end
currentfile eexec
D9D66F633B846A989B9974B0179FC6CC445BC06347FF71900AC8FEAE3B716D52
C1AC4E5DCF4EFC3B9121F09CAB0C4BE35FD0740E08C853EF201BBFF011DE2163
790FADCD67A15500D3F87E2616B7DEEBFB3934B09CF7B8BE9B945D2638887F73
1C3214D790EBA3065BF944D77DD51978CB663398285895D774586FDDD6A7467E
B1BAC83EC766EDE0FF34D07C6E315D7B79B205EDE798A08FD0D9CD4A1307FDE8
7F57AE7A32759AAE66C77C6127F65D92BCCE74ED784372E34CC835BC789BDEA2
9E27574D388B2CEB1DB127C190624246F4991BA418137BEC72C8CF7830DCEA26
E13BC7F0CDDAE283F10C1FDCD1B46ED2C4BF3526E9DA8165ADF55799A329EB45
40E811F9140E5296B391A61903BC09B76E7BCF96FA1EA22ACBA9ED962E9BC596
BB22E4A514A5C551107BC74BACBFE55ABADEB1741C20BD80A186E49DD89CE033
CA0ACA0D0D4188B8A6FB40C265A88804443A7E912005A6BFD10EBB43315F7A9E
E8C24321131DDDAE6572BE67DE42C5969688AC1D7EB97887D783F63658AABEB1
FA4C2F625E6B6205D3EEC1C5E2FE8C29BD88FDF52802F3F5BACE6AA2007FC0FA
B6CE66673C1D698F51457AB1343CCCEC0D2FD0383BE98493902021E1A27B71A9
0BD0DC94B4C46825738C15B5E101C68813E1F8C8B19311648DF09363FCEF679C
E691E13CE96DDD1455A75181706F41EA2E0A6A4C870F7D3726547BAD35E0EE54
7F91EFEB803E93D1A9BA74A332EE4E56CDB48AC36A47B9B555997C7A58C3A16C
8D71BE01432D88B842B5D9ACAD19FFF7EC88B4E66036D2735311AA323BDD69D6
8CF32F9AA7781A2146E04D71C54044218DE26A4EFEAF67EFD04E4ADE1D7FE2DB
61A465957450E623CA58FC49FA2236C0BA3E81E9A9FA8909261A4A092AC9640C
08CB2AF3BC1E92E578086556ABF6A1F739582230AF46D4C184714197545BE932
1FE1F05FA46478BEB38010C2FAE84145D367FA53B10F42B7B7BA76B427210475
71E67A52D8EADC847639F0BE7F280F35EDBE34C7FFD9907E796F373015965E1C
FF36F43C653EA3F23B76FC2ECEF9EC19D5BC245369A690C280DAF9F3D8401A08
95D0FC1C3F0C033AE23062A80A3B8A944F642986A878A0284CEFB15CEDEA1345
F74EF90BD0BFB32FB40AE9F9B3565F88BDBC6AAAE1D3C724FD76D73C06742C04
6D0DFBBC837DEDD0ED2C921C753357E2EDD9ADD9195881A43511C4724975021F
E4ED7284859759C250BDA740DF665688B1F31E1DFFADE7B18706D086DF4D925B
C4CCA1F498FDEF871F3BD4C83285561432B757D7778D77CBBB1E317F1D475FD1
E53639673371E803F44D6B5ED7505F246F21D3AD2C8ACD573F96BA95EBDC0FC5
661720BD67BC1717040E698C7B0EED2ECFBD1D9BADF061BF5F70D6AAC9543651
A00868C3EAB2770D7E3CCB5524C42FFBAE30E8C82B4981F5EB051BE747C13439
4852D063A460FFA9094D30049606FDD46DCB8CFB3DD4C3E93796EFD6E11518F9
4E0AD363F6F09B66EE4B6A33DC92C54CBD82A18D496878066CEE28B579D9636B
6281387A05C060A9B328382FDCEEAA899126B167FF2072DC25BA206ED379FA98
C230E7ED6FA8ACC48FFFB2663B75064E2B26689E007EF544F07060235145CED4
9D2F35A27DAE186A2F9E899161FBC7D89A16EDBDCBAA390DFB4C3D373AB6530B
24E56DBB752A5C018CB3674CFBF8EA9DB943789A2BC3165FCA696BF68C837E5D
7DF71A9A9CDE4364FF8106B8B1444161F0438383863D409D7DBD88E7E58511EC
1E2A0F6614105C83352E83371B4C09CA2AB5EEC3343EB7830ADF2216CF619180
B8C7E0F247DDB57070601DBD13FC9453A945F8BE5CFC2D58567E7474557DE109
E0491BCA45D837A6BDFFD368750E08F405AFAD27C67AFA5E9C57A9C9964544EF
54B86BAA23A7418E467E4B784CEC146BDEFC01AF0B5792F7C38F62F741E11B71
9F2E63479DBFE0FBB26859B0E65792A9E52DAB926EFD47AE6B7F72EE81B9AD52
BCD0D011986B3D0E47CCE2BC52AB9C9D8DC76ABE9A1B80706DDE16A39742427B
A60815F2A7A0FE38D3A01F53E01B5D5B4432E41FCF507E741E62D1AFBA823956
31D92CB687C016A8E893C28EC70B6743902EF00BC5D397A46CB803C19DD4F5B5
BE64BB59E8ED0E2D726BDEAD673C8D5E18DB68272D1E12FEA1EDCFAC87E4FA66
F09F9CC06418549D705432DBA9D9E1F9B01B4C467F7FB3B36FBECCDC99A4654D
A95F053C6F57419D5D192CC13EA5A623F81EE19692ED64F32E5F4D6E00A30A70
03719618956C64C0764BD85DDE49D620493586695C0797C7A2E84D1258EFC3FE
91BB4E4D11A3AF781F1551F20C26C8FF6173F8572BCDC8E177328339EED21D83
52DB09F9C68ED1F2A9F1EAD2922C8A8C89D44EAE93A0C123C0DBC7D40FB44C1C
12AD7D1332C408C1BE8F2E260434DC920B6F718348A9E340A6985189CD803DA3
064F47B3A932A2A946D3120BF4959153F9A4F5C2CEA869E27965950FE2940CA8
D2B4F7F076FE8DA3DA8F96460C816EAF14A6A04E928004BDA21C9212688E333C
A5462ED8EC6314BE428EAF2964454AEDA4379E83C1375D4CE9550C15C0E4AD22
77D88CC2F21D2CB30D1F959041FEC5A3BE33A9A01ACEB9CCF1F476F10DAD1AAE
A7C1A863599BCF9A431DE6749FF3C1C851B4AA0BF9B762DD12E13CF20AA18709
24A2AE8783293F1182C9867D327BA0A2E400A501580CAE0921AC7771953A45F6
089A425F027D8B58020A051F93B3D5B311D0AF2B26F944B4ED36340CD545E359
8666A2B111D2E6D1E3EA690EDF7CE218FC01960B916E85F36884B8F3F8F26148
B0A57157A0C21D5D286D4592D16B9154CF9B9E708CEE2596B666507D14FE1876
91437C91EF10F19C1F598D8C145EA94E55267006F260A2E57AA31C13439A59A2
4C0965E9F3DFAC57A0FD878DB9AB32D743D9A1DBD506B515A12BCE5C7DF6FE01
CB6C10016A9EF18DA223789B530BA7457AAEA8A8F2F1342771EB3D39C8E6D351
D0F1BC9AA0B97C84074D4E508774E95C783EFECF94BA18B22BE218294D106318
3712F8AB7B86045A939194E180C655A7235462671018DBB01E4B3F1A5B0A9481
AC425AD8B4DCE63A6A93E254921B8E9F0F208B9B7A84EE6F9A1528F7D79A6F97
4915BF89442CC8AF34B1D3458F56F4199E3471D1CE0E34195C9F886A4898AC8A
89D3B77210B7F3E7C1A59A05A335F5AB4BE5B4F9B71156B365FAB3AFF04E8166
0A4D30F123E2785C542D4719B1B3997620BB28EB411FE4F3B713943C8B81DBFA
6EE9C4C5BEDB9C574ECBA91ED6C8A587B776F59740CCA12416589CB9A8AFC4B2
EDC8BD31464EC731FBC95992607C9AE7D478DFA3565EF145F2B9D66121A1EAD3
5032AAD395660BB91A3C138CE7E8AF17049A98F10329E6A14757972D5FA656AE
31A1B152CEEF8AE58083EEC839D265D39AE86CD1994F41606AF4470F8DC9AF2F
5FAADE14027B0134FE419D23FDEDBE356E1CA99425104AAA491F973F0DE96B45
015E9DEEB9EB2FB88052CF8A7C5B3C774A1A6EAE453C2D57AF959CA23DB56503
D08FB207ACB01394488ECF22AE7B0C559E3A28B9835AD34E9EA65F91563855D3
8CC06A190C79D371B5F75B1026FF045A6ECB1C1AC5FAAAA84E5BF8DEC2B72003
5945B624EE291F442805691AB6A1FAF1E10F780EFC2FEA24AA5DB7C42DF62CAE
386DE0AF983BD1F7B9955547C085B8FA4718E55ABD85A3041A6EA9AC483B47FE
874035870609FD65722EE5C6281A0AD64320E0214D65A282C7C6E2A7945A9FF8
F9EF79E4802C435D3B33FC3E904696ECEEF702E034899E14087CCC98C7A7D918
3C5C6696B1002F7B0AA37C5BD00DD016359FA58D444895ED3D79C4F8441599E6
2D4FCAB033DCA43DFE85D70EC72E63FB1D03D6725E71D264318DA97BF05D0540
264DE8A5ED22CD608ABAD484AD905F88B1E2BA174EA8A8AF8DB0F60BB4CF20F7
741148E592AC4E6BF30D2C82510F35F81C8173D5B75E3BC87ABEAF2BFDC198BC
6397C2470E28D95F655B3610724DD0EB95D6F6FA3A3458A3B94BB4737612E010
F75FD788795C8B7795C2AEA1711499EADA89B1170B09ECDDD6D35A60BF7DC74E
247BD424679EC164954C99AD4B4CB4F8243DF0B31527B46F25FB07DE6B5138EB
78FE8A3ACED59EEB25D2AC4098906FAF4AEF665249891205786B94496E975ACE
8A6055D07BDE85C32892A6971D1B61634E18D2A8790A4DCC299C8F3258D0300B
7A586F641C7D8DC24C1834C894B5FE074B892943D4878C109DF8D497B6D81FF8
8893E1EE6E24C576487521B0B21D08472EFE320411869CC154FA6DB740D399FA
F539E332EC5A41BEB510B63E6909F5519C0DEAFCCD149FED63F8A96B069D7C6C
103D5BD4E4C062F77D569465F65D34E203B775E2615C39BEDE1B66F5CFB7A867
D6BE9FB4F0C99B098B1693FF41A9F54C672ADF31B34326EBD726BC8588977B92
316B08A714E4172C7B07B4742632315EEFA7AD25847BDC5FEE3340F9241FF271
3E89967A2EA7D3745DDAB434D323328030AFEBA01962AAB38AB8F39AA668BE23
0675294BDFD7C25E6B0B717DC116123298A80F59DB58FA03AF2027B2EFBB59E1
15C325
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
%%EndFont 
%%BeginFont: Utopia-Regular
%!PS-AdobeFont-1.0: Utopia-Regular 001.001
%%CreationDate: Wed Oct 2 19:10:38 1991
%%VMusage: 32987 39879
% License clarified 17 November 2006; pfb update 19 November 2006.
11 dict begin
/FontInfo 10 dict dup begin
/version (001.001) readonly def
/Notice (Copyright (c) 1989, 1991 Adobe Systems Incorporated. All Rights Reserved. Utopia is either a registered trademark or trademark of Adobe Systems Incorporated in the United States and/or other countries. Used under license. The Utopia fonts are freely available; see http://tug.org/fonts/utopia.) readonly def
/FullName (Utopia Regular) readonly def
/FamilyName (Utopia) readonly def
/Weight (Regular) readonly def
/ItalicAngle 0 def
/isFixedPitch false def
/UnderlinePosition -100 def
/UnderlineThickness 50 def
end readonly def
/FontName /Utopia-Regular def
/Encoding StandardEncoding def
/PaintType 0 def
/FontType 1 def
/FontMatrix [0.001 0 0 0.001 0 0] readonly def
/FontBBox{-158 -250 1158 890}readonly def
currentdict end
currentfile eexec
D9D66F633B846A989B9974B0179FC6CC445BC06347FF71900AC8FEAE3B716D52
C1AC4E5DCF4EFC3B9121F09CAB0C4BE35FD0740E08C853EF201BBFF011DE2163
790FADCD67A15500D3F87E2616B7DEEBFB3934B09CF7B8BE9B945D2638887F73
1C3214D790EBA3065BF944D77DD51978CB663398285895D774586FDDD6A7467E
B1BAC83EC766EDE0FF34D07C6E315D7B79B205EDE798A08FD0D9CD4A1307FDE8
7F57AE7A32759AAE66C77C6127F65D92BCCE74ED784372E34CC835BC789BDEA2
9E27574D388B2CEB1DB127C190624246F4991BA418137BEC72C8CF7830DCEA26
E13BC7F0CDDAE283F10C1FDCD1B46ED2C4BF3526E9DD2FD5DD021D1116D3D9B4
44188211B1332E1BE656BCD0DC7C6D7F23ED03F9A42FD10B79980768710365EB
A8E211AC8936893AA9318E20D297C730A6A626FECA9E5F91E1E0B5992698A7F3
F8BEB86C9BD1B318CB141ACCA92730554DB8F57A8A21370C885A2F6612188DF1
0200D203FB6B33556F21DADE387C352EB80799C9BFA76FC4192381FF39AD0FDD
883D39690055E6A12477D408452D16B726E759BFE286CF62450D5683C4EB0845
EE3B21D7D64E100CCE7A2B86926828DDDDCFAFBF3861F98324538A0799F67E49
72B96013BF16E190839B9D1DF92A8B6A610468110B7CBF1C24CD2CB1E994CCC2
4BA3DF5753B81CBCB3B71C63FFB17B3B47E949C570D03A4B162E12ACB36EA11A
22733406532DB9FF39B2B2DE58B270277E7B1C3E1A460CF4B6FF063F5CF37F5E
AC709027E0FCEC1B27227D8A49D0664C6FB0178976D6EB5B09B4F47B5E94D782
25FC9D56FD8EFD97D514EB2ECC5630ADD87D6ABA98B19DC1AB262AB9A8C979C0
59A76953EC55333F7800EE9330B7FCCD8C3BC325658816EA542654337DA7D3C0
407058CC4601BA7B6C6B2DA0E376F7D94DED19271029E32844351B475FA30E37
2D98E7D5E6340A878CEA0811FFF598E5E1617F2D13066E7640416BBA886DDF0A
E9B8A56119CE61E57FA8A6309245DF8BC6CCA7CEA55FDE2D7B6CD06E8C118928
1EE6CB47A4B7D7E38CEBED3A0D1F2639BFF76FAFACC17476D13F4CB31FBEBF15
89252E409F16ED56EC1DEAB4F330B7659E93AD217785061D581BC8FAA0851486
654C51CA8472E0FF71158D1D3285ED72ED927B7F750F99BEE45F5C77300D0411
A3D81B0A9C8F5865B057F75E8D97E77958D3502994B90340EF5362A99D9750D7
14286B362186F0715DA5C6039DE18044B8E67EB1152D6C0DC98D0E36E6D3C331
C817257F4D3CAF8AE438EB03B04E8597046197D67105121CD8F5DCBBABCA9FC6
55EC17EBF96D17329B7C8BE8F7D3062E20E83FA6AF45A0C932B5E6EFB4DBB928
E4511768F708A03FA8BEA26BEBE94936A426DB77A8E800BF093CF53914B71382
019AC58ACA79B9DF64946EA241C84569F2A13CE8AEC335F6B5DE8C00317AC6EE
983987246EB7659537AD0F945CEB9EAC541E02AE257377258E81CFE33CB66A9B
EB514F04CA9AB516CCAFE56EB0324AB192EBDDA61E0792EC1857BCC062666338
0089C3A9FDEB405DCF235A497AC316B132B3476551DCEBA0560C18F1BF84F1E0
1467DE59252B169861541BD6774161EA8F9035787CA842050E2089AAEED6F37B
2D12BCF5E67293A1F71DF87589FD22D5F72B9C91CCF4019F97356DEBC9B82C93
BD0040BBCEB10CF8F6000BF098AE401F14F4BB6F5D1DAF0A3F095107D502476C
356175D567B8BE8693B835B72F954CD3441A2F20E833C42E2895D18B389A733F
D795C23DC15DE48B0A6D53DBB26C9D816102A7E1E738CBA1275687FAB6790164
07230D41DC67E4CDE439D1E74B4C2EEBB48201897A62210A0CC71BD028D471DF
DC29877CDCF0AE20EC2A0A4650F1153CEF42513361C9C263685D6EF4F05C5E2A
075C82B0463E915D294464F94F1D6A17686EA19A1E5F45549C89D8733DCF9ADA
EB7BB44EA98CCC2E6FE82182E620098FEB77B77AB9D89D4F2136778DFE06A06F
1707EBA923604214B49F1B1D03B51D3B5ED9BE84D91DA3BD49B1C7D348CFAF54
ACA70F3D7C5D45D698EEB767B20AE93A46EC5A657CC9ECB2223036932C5284AF
F4F488C9309FA2005E086914165C91132223FD13FBDF7EB073FC61ACD153885B
90306801A48E699C23E4023D9C17C2A86019287CC9C0D9F2ED84AB6270FF771F
930FE080271ED9AC3CD2FD678734863351A8B217ED745BA8BC4F70AD3AF011C7
D202AABA7149E6B89648071912ECA3C2E597CBE549DE048D1CE8D77D52F2290E
545DAB1BB0423C060780333AB3CAAA091282500AC8B72411E97281482694D17B
C8EB9776956736A7E4068D529E201B77D566104E12AB7AFCCC7401AC1BBBA29A
0CF8449C165FECC03853B76D9040D2631E04CC60718A2DF00E20B2B90D76252E
04CFCA5D663679FF1EE1CD26B2025C272F3889A95CFD37F040E7B69617A15799
D3F20879DF105D2F20D5F9BB1FAA6C3B62B1FEFC1238F36B24B0862092EE2FCC
C39DBEC8BEEDA85DDFA8CEDBE3DCECAC2935A349CE6B07099AF0E0C529BB14FF
E9E1962B50A7E014BFF4EFB16BAC76AA179CB516D72B822CE9CE94C8E4A17761
37664A831D727BEA6D6BAE6D6B6E21A391F98B7D5755F212110E0CDDFD031A61
9C56F34098316D41B02EBDE8E962BE73E64A09CA195445145B82A7A40332D83C
EA800D9F9B3BD3A14A4A8FC5A7D7C64A46E1F11BD1DF3297A958C2E432373060
0B8E4C52DDC3D9B6B493D5A6B8270DFBAF4D01FE7E21855566D70C09BE176C49
4FDDFF066C548330A9C6C702D128EB498CBF9660E05F8C62B05C3A50FE7EFE13
EBAC6BD4F64E7DAF0EE4153E4CD4DC5903FA1BC78F2BC224D1E7C9D0C317785D
3316994DE4231204EA3DECC5CF88B5F923CC6D2E1B945C5AEDEBD3E25E9F6A43
919B829F759259BDBD310C8124BA9C5CC2F25785DB68B56D6276A55D031C7D4F
8838157372BAC8B8450810568FEDDE6F27665665C88AD3BC51FAB8406A0BE19C
307AE7B86063B735900768D5837386F411D0FEA83DDCA89F51676B5DDCEEF684
F758FCABEA3D5FA9361A7E7234D8169D764755FC4393E7A43B53D1ADD19DE618
859C957D0B8DD011BD67682CA8BF45F894BD466FA0E7B290025C06FFD94BFF47
1B4BAC22104BDD47FC8F1476909062F88BB7B30F8721BE7F1C2D5949147F03E4
C4691582311FF2EE1312FFD9406E3875D44AD245F4A10F83A266D0935A3C5F29
45C2283091A62B5B795FE1C987556F5DAFB3770C604950CBD5BEEB8A2D7BF5D7
9B42ACAD360A6984F5A95A1EEFA58FC45548547B5EAF4EBEA0B8C5107C0701C1
1A2635328F0A5E5D7CCAAF6D21D5E033DEF661A3EAD19566C24EDB058D006562
E702D397584C8686902DA2DFBB497D23E9C78A2758A2DC856E1B02B7691CA8A5
2ABC8A46535DC8961CD5E3373FDBBE249F9BD34878A78A4ADC04F7B13C901BF4
E6117118A6E7E102D5B039BE2C981AAE83F0D086E0630E360136BA4C9CE17319
CC2ECC6DCB8F5EE82B81E01F4C2302DA5F326A7DFDD8349E5C907E30FA77D390
13E61A11246FCC4643A000E7496F9664023A54A3CD885FDA93636AA95C08136A
02C225D9AD4028D465A04AF0CB612549C9A020F6254C627A1F1B6ECFF7760187
0841FDD91E74AE298C0A256E68192BDEEB522214C31669CA51B6C103F633F3FC
8EB4ABBFC61498A905D123F438BA92D3E4E92A2EA6E1A4ED09870FCBCE70D7D6
7E877B3A477B4BDFECCE3AA279B9BA977B4FB8E52D65ECA562C10CCA4622DCB5
028A6D3A83F79AC36EDACE15E0DD3CDAC1FA8B1C4BD086E4726C73C38EEA3027
8281AC54B0CC5E38C5A8626BEAF7923C1480BF31CEAC9C0229BEF25E055B2636
20A6D2192C861552D9F2F7A3807671C22255B0C94D7640D513E00E064D372DAB
56438F11715DFCA476DC1E663A20A44629F22D3F1929A7ABD7959F0E4DC1B9D3
455CBDD1711900B18D391DEB1190643BBA0B998DC7E7DD987F3D24B0E934456F
8E9293593273FC5060A51770A748D61C4B7C043467B6EA2F200A8293896D39F7
2936E74C53FB87929C4B694FC6883145CD7C89B67A1D220FA70EA9F9B21E328A
19B248C1700EF5B2440E3983072E51B056FAB9C164EEA068BCBE53025788C3B5
485151C67DCFD8E8868EB7125505D34C751744962994578C43A710A148B39D6F
C5FB46FD98C2DBA138DEF8F63B1559BBA472F2B0E4F0B1FF2088EED64E45DDAA
A2FB8ABA276546D8D1AB820C581ABDDF50D5942EBD989C3FD8082CD5B5C16940
6A8B0306926BEC0FDA0ADC91D3B4D3AF29E62B3728418B2C29117FE0E1D2B9CA
F79BA51D435187DEA3DC8F7A013FF5B43EE440207E685C4C1DCB53E90D943833
A0D213DBB1F129E5AC8CAA04AAAB6B810C293E955B2445E978091C4C8B236492
183BF6B996A877CFF424F9A7525B256291C1FED9F034830429DD9D16904A62E1
45D2980B7078930475301CA51BFA6CC431D0EF8D900426DA3CC71918F739B07D
DB23E9D46BB3065343337FBB5D720CD9A1592832890F3CFDA7AFCFEE54EA8A84
1B3D5204455BACB028B250673E321815C3C7AC430E1E2A35E4D405E8F0CF90AB
AEC6F28C2EE0009E431F53CE092880A6E45FBDFF24EA3CD69F1FAAC221E5913F
1D146B2AEE0FE0FE9C8A8D56BB65F17F5364090783923C878B942CCFA5277FFC
B4329E5CFF8AB0C0F8069E82BBCAD614837D04F7DAFD992965837E6078F8AEC5
42E9819A587601F37335669A3DDBFC05DE237D5C198848DE8EC9C425EB1E6A81
177A7AD24B75A31D3BACECE30E396A0FC84339E97EAA35BD7DEF5A660EA3317D
DCB013FBACF1E8EABBC26BB2F762273692696B62640A8F09AAE77F2EBFE0DB8B
19E152524A20F85B08E39D35F605821C57FEDB6A796C72F84C715E3BC597196C
0299E57A8EB35BF35326F6045E06AF0F1E4F893C9187A47F92E62A71AEF1A7DA
6410CC5D0D89A19315AD3C9DEECB5275EA37BA44B97EBA36860A41F3636C82E0
C0C045A961064ECE6D4FF9E1672427219B706394A9B6CC2EF8B7A1A92F22D2F2
351D1175A40DE56AB52E800BE048276BA5CF33411B194DEE1C07B8C2A6733FC6
8ED569742D7E55FA5FF17B14F02996F048A31C4902E76E0D7598F65DF8E873AF
92E7960ED1CC6D6B31BD5C89C672D5B872F733DA1AECC715C87987C4699AEF08
232BE7FE13167500C2538273E7922488522C98D8B0DDFCD48D1863E0FCB7C1D1
5977460EA23FCBD3D60ABC0586CBF5520E8F235DD7C2E59C0E85370EE65A8A70
81940A1A70E1039CAEE78B1FF3F937E9606FEF1DA115EC84215B410F7428C9B5
0AFA99B797CE55BBEC379CEF318F559E22271A8EB931F454BD99012773E93432
27E1BF694480448013E5A63B5D19876C87468BB4D5038DB8FD9ED2073D21FF62
6663380089C3A9EFB4A10880B70385DA62ACDF1DDB10682B89541080B5C0BFA6
3A7CDAB026162A4997B592374A9BF3C78BE63E3DFF1D1740516AEC9620AD47B6
79838CD6D7788ECA7D1FBE0619A1FBA979FF7B99D851BEEC4675F34A29FEF6CD
671F232517AA77DD0A04ACF56C510778B42CFEF484C13628E491CC03F80BC986
1CC7439AD6F2085824670D545E909493D4E4A0FCB1710F359EB9A7D1DEE214BE
DB5D57149B3280F9055B426B1CEEBDAC322153206C9C01123E97FC1B10BE8F26
2043BC13726DDCDE7FAE056BC687F886C05522B117EB0E7F84AC8C90A4CA2FB4
1F60997B611C74341F4CF24489367F4648B32403385F9AF86EF6E3C753C053EB
516C02DEC09EDAF67396C1F5D03FB3F14CFEF80336C980D43818F2266FA28273
B7989D201B249D03A9B6B8CB5E734ECCA84ABCF740B8E0B36080BE1355EB2292
B088597132E323A2B45604C2037E4729C67763358A9D8CB001C1E32F79737EE8
29F5F830D39DB92D17AF7229704DEEEB09C564C0DBA064ADFCDBFD4B4BC91833
8F6118D1D9538D40D963F2B4A1C977C0EE614B5D11D7EEE8B46D7ACC7A15CCC4
FFB1994CE65A13C4E5FD0D1DB375718A5ED56E0684FA4F2863327CCEB361EC81
0BAA3854562E8B620439F55FCA41FBC3D285A49FE26076E2B24CDCC5A61DBF3C
CB014CB7BEABB6B6F31FD3F45696BA921B738870536B18E1A8FFCE3D41699573
0EBFBC6B7601DC7DF5B3174EFFE77BFE2AF0126804BF16A66B7C79A2AA279225
ECF09D4D3A2D9480E4BEF9224B6B3B0C42BCB6B3794F6303D038DAFC2F7B2248
91BC2D1537CC885DBD8FCDB0326172364A0C3924C1425CEC4CB9224DCB5B5822
A937EDB6EC99C49DB2B2A97497F7B5F9C44E2C537CF25A80C4C8B98874E2F0A8
AEC5384817B886A79776A2A462E9C8ADE3A8E9A6191A2E82FD5C78839321E380
331BA4ABC516125B2CF4F89556C07545AB05B31766EDD87AD40DD1FD91291BB7
82B26FB58A9FB1545FA8436EDE35AD66CD0369E4956AA272B1959517A06338D1
36FB96E445CDDA3D906FA2C256F817D5C1B557FBE8D6A219CE0CD3D8750A6E78
56E0323CA9B40F918E814A200FFD14091BF1F8FAB6E088FA4FA477284597F46A
AE7CE33A02E7C543DB1B8DD9CBDC8F8522002D16634DF877308F895A9C8393E0
2F64ADEEA9F33F9E3DC40386FD60E7B30BC1504400C8B360EBFFB8D4651822DD
C1FD05D62F43F9AF4FDBED89E370A620C426010BBAD2A98E10DCDF5B791C1E93
55B641D8A0417FB91C66ECA1A873D0036588FEC43414502FD8BC994E2E05E600
E476D08DDB67E8D30D7CC0D290E551C39CFF94968EF45D9B9937701C6FE3A67E
D98B4763F4E417EEAFC6E54F9E0660AB33CC2A32BB05764C514F4A59ECC4344E
76144DFFC8BB74F62A53F750B082C4948FCBEB0923BC8F92B8A6B403BE707330
ECBB978C3A3A8807B6E8F7CDA61AE479B270875D9CFCABCD08416ADBAE868F8A
E82D80AD95A46D936EF155DC90A0125E8E61DB1894A86AEED980A54683E22207
DCAEE1E36A85AA31C1BB73744863FDEC2E3307DC4AE783220C34FD16DA13B0DA
8CC22B31AE04870CD2885E71EF1BFF1C0B7B167597C15B4B8376C0C328F44E8D
61C0988726A31D7C11E6F47F0397B2020D3E880220549405DEBCC5AB0E397683
290DCBF452FE696782CCAA8EB830C6DE57F022B1C776266C42E9F158122A3C4C
B44D5E4AE05405BEC9B165186DCD3B7A259AF32F4C81EB6C5D597CF8B567E5E3
7EFD3B8AD3F55CBFC8CBCFE5F973B650EA434B4343766317DDBC5F443EC06A1B
8C86B62029875499EF632E97B54E9B4DEF9D348B8C38A1B75DD571F6C2E0BAEF
8C4CDBEEA58F730A0094ECDD2326B351F087C182580E11718265119F9D2F3FA8
D3EDD40001AFAC37EBE22D81EF5C6A6CAF0F0FB5C4AC746436363D8DC08AA092
C687D5DB2D469ECBDD7F98A82465238867DA25D4002D8F9D37E3F452F9515320
E678DF666AA4E390286872ED0EB25F6836C91BB2D923234FD2A4638C68084D1D
924AD7BBB0F287463C4214B86E9F3C39D4BF396D04DA8603642142C01F4B57ED
0C66F034DCF935F3A6FE7F0F98FE893D492C518F7D9B253A16CEEF48DC98DCF8
4D5B5E53D8568E4B232A5C3E69EB6E0965F63B26AB4E3CD426A85761F994C6B9
11EBC83E56E17C8724AB4F8590F1A4821D62D4246CA01559A57AFE057F9B932E
C17F47F22BB495D3F08D50F8EE04F1CE9B4D8049856A89FA8D5652ADB5D7FEFB
9C0883C20E8A5A7ABF3C3772A3EC51B19AF6A20E796E75AF7ED5D669900CF426
D447CDF8EFEE1F9903195EAE6054FC37A0B045FF502C408B4E250362DF356AA0
94C6E70901535BA5204C21B59E76F49184B672F4AA1142813B858BBBB811420D
BE034D5A84DD01647B95376007DA9A69D16EB93D56DF6964009E3CE1ED3A79F9
A76D150A6B98A2F172F4D03ED7B86BD623761A3ED83159F40D0A5F5658FE258D
0E268FCD322FD08D6A1FDE37ACE4F3C2854EF12017FACD4133CEB0ADE8277EA4
4D59E7A013246928D445F6762398FEE159A7BD1E7D42A0FCEB3A1425A6E64C52
1F215F8F09005FA73E7CCC71BAEA130CDB2A33801EEA4002CA4E6E8D58BC4DAA
0F89C4691C674C00BE39026318554FFFDBB018F81C0780D1734C25FA5B99C0B0
6C27B1214347478315DA17B524BB1DB1FAA9A141098E391E3DCBDA5D49EFE81D
2B4F07891A12E9A031DE4ACD3DCE45001E1E014B9B527B5EB7D27011B2FB0CFE
7474DA83291D1B712664A20C807DD48011C25708CE8AAF3A48C72F9E61612661
883E19E10D2EC89FE134F450B11BECF04D9A9635B7B1B80D86604C883BCD9F4B
B11F6298661BA0D26803A9C29C80750DA73281B98068BBA5A21D86F7D05417BC
F56F0529AAC1C22B083B94B8F39DC98E1D2EDB561C7BD24DE5DF820F1FDB1989
BD6132081EC9F7A07DEA1D31D3D04EB580E525ED71E4045D5EC7B1974D62C0A8
FCA09AB80DD7C74FFA4FA8830799C73FC85E7C843643888C8BFCB4BA4D76A00D
02ED83AFA30BB07086DD0A79BA7AF664CF7F96455AA1104D76D10197E98EC0EB
98343850686EBE6B36D7E20C22B47727364D9B99FFC4C87D544888114C39C59E
BC603E89BC41374881C1459F39A009874958841F91F7EAB823B429D03BBFC425
440BEF24539B286EF92EA79B4F0C8A9BCFB6B625A6B7D531F2012899D78FF37C
2B3BF7CF68DA315AF14FEDA1D8DA8015D9540810B2D7D1E294048D35BE9F8F9C
31AD6BD9E1AFF5117988FC94009BFC69A4F3DA17340E96AF4A5DF3291081863F
977509340FF806A967B12AAFAB3F19AFBC99B106C67DD1CF609CEC6E8D6BBE99
009F2E137C8E65B349B69EED368CFA2F39E2BF7BADF84057830853650B14414F
AC37B3A34E2C1CA5A4367C5C7FB62D001806AEE0BCB164EDF10B07D80245F249
EFE2C8D21F6547AE0E1E1AFC71B6D6D10151FF96E6CA527EA721CEE889E3A4D6
9168407ACED726EBDC077F5423A8129C0ED56C44ABEF54DCDA7DA59D3FA13F79
9A5F58B1037CFE6AFEDF2D0EF38D2C4BE95451CD1B9D2AAFD887B22532E89090
0555926963A9746888A9DCD2A0CF54F0BA788AC2D0FB94B7DA5A50186ECD90E2
F15FE9274A91C1BA1415C33397A2BE0463CFA83046EAF95C6F3F0C16892BB267
C863BF187F5A76A7B6CB6E9BB6DED6D6F3A77553DE7432E5B5613DCF35CE7CAB
C8D78DEEA5EFEA9316BBDF6F242714A07ACD1FFC9CD544479FBD2A6BAB0BFD7D
0A1190E460A4BAA2D2590DDB065C407944AEBC54904D450A4667588B3A47FFFB
9D64170FE565312BA4F4C5F75CA88E1CFD383431F0D60FAE992BFEBB308580E7
F2E6FE36D4E749563B3AD1A5C09010BF60478E29A02192BBE3D61849898025FF
4554899EC403F106BE1F5AEFDE3E2428B9CE6DA5E780DCCA30C3B2E11A6248C4
4AC609AD1C25F6634513CBB2183C51EA2546A25393C8AA802189AD2AD0784932
BE8D968D159872E9A32DE2E2C90487508517F987D5FE2DF396DD4BA955FCBDB8
06B48BB1A88C859761C6C9FD252E7C2A0CC0595877F2724E8229B07C5622FF86
79D40361D43C2B668FA4414EF338939DD0ECDBC6C4F90893C52237A1A348BC3B
46AC25FD4F9597DA95F26D0EB2999A13CEADDACB5FC01A27199E7B6A8E0282FE
E206948B81B0D04E284E2E82CFE36CAEF0430E9D0B26577B7C6DB4A1D5E9C4B1
8334BD99CFBE66F6F4FA2F4117204438274C07A7E84F3A8C0B3BA88CF2126219
9758B181F46A5AD05D483B99ED3B49603BD57C512C2C65489C9B3880549AB96F
55898CADE88736716631BA515DF54269D8699A6A588647510A48CC5CD0E715ED
9333A0F27B4EF634A45224AD15BE8F1AB2DEF8B54FE048E425D3A862BE560DA5
1E215709FF5B128C54749538D977103AA5FF4BFDADBBE53F14CD845E46A319CE
B80A1B1D6C85001F3F47C2A67F00C63B037CDFA5ADB90099BD230FCC203E9E65
8A4368AEF6126D47E4E00D0DD40DA9004EB39A781870D904D309DE41766EBB7C
544F9DEA43CD89B61D054BC5F9569C883103BD39341ECA57AE07B610F51F646E
6A2817F68EEA18E6E3F482B939FE798C7F0022F1431678ABCD77283F85570B5E
2E37512DF4917A6CFF717651A35C064845FE7E3BA76AB635C15F357619CF742C
2DB209479E5FC4C7552C356610BD1697B62E19A940FA065E4DE6D9DA1E33CBE4
43E06A82A194C7BD36C5AAE4C8C22DCC6B256C022585E10075810675F271D291
E0D9D6E243D74D9C588EC824900CECACAE695718E8E83C3E6673E3AC373C8B5E
A64263D8DEF9F05F41A79E0989664B0992ECDD03482EB74FED57E91C3514353B
439CCE6BD4A64198FE3E78A4D5246D21E1C2DBC14712EFA0C697F3D3AC23F121
BA199A34A30DCB98E84F966E4BC3B06679D082BCDEBDD3CB31CF4FEE4B47C17B
5AAAF6C4A60136D39C77A57CEDCEF5C75CEDAD2E4E67EF4412A0807DAB3EBF01
5FA81AB1E03F144527B58634F830E7D4E00B608C75E3E216E8306AA6E46A02BE
E7505BE7E298ED7B33BD257FDA60ACA859D2DAC3A15CFE434FA982AEC2F391AD
D683C19516EA71B31EE879F0F8BD6849BD36D39C9C21572EF1FF3361F64ABAF6
B54A9E43E065B7CB21EA1E554444D7299E50BFF5971730486C1179748391AA34
4E9DD19EC876C57739E410DD8BA255941E830ECADE6229643EC14B466399EF17
39D57AE2E3021A0CD14BDDA7D264A22CA66A74B6786C6F5595F3D270F374F532
050892D700ED36CE7E8D4E3B5F9590C3EB0DD8D8B9B1FED23A9541207AEEA15C
9CFBF063C30C63C7FA7FA0DAA1DD581B4E38AA035D748FE934288972EA88D56A
0894939CCF4ED575970BCCA467C6325B8C95984CAB25F6039826CA2FECD4899F
0433A41ACB30C8FC300C919C9284F51AA4F99320A13FF4989022884FEBEEADEE
EE6E1DE6FF195DFC849C8DD92419D4535D0FEEB7D2A560B752BFD65122549AEA
D85A2715B88654742B61DC6841C11D890D6F4A2AAC9F0E78B6D4DEEC3223C145
9E3780784299A74EEBD2463C369CF59D0ABF36A7C6F8384EEB6A506FE31DF1EF
BDF951ACFC069A28876BBB81176EC2DFA0C80A73C85755F156873A3ACA424D47
7181A5688D20129A61EAB2FEDA92721CAE69AEF32464B010723571D8AAE5343C
A2E68B6780E13BAA70CB43CE78D530256D5C32566966025BC640A895DCCBD827
66129D166FE9AF614905425E91404CF5881E3AF035A95E34E6136DF3353FE81B
6D554CE7D5B99028D0E71D853D934D5C58DF39ECB59E842E4E32795F2726F642
B6E6A3DC6528C07711DB22578A7F9D695B9ABC5B55ABF4C2B0C4870C8E6F6100
8EA274290FCD3F1FBE38ED9482E4DAA7AADBF42F8D9E86229BFCB8DA81C61E38
A796B63990C31F1EB7E810D7C7DD6EE60E68ACC33669815B3D8EDC0ACD26BF02
BDFBCBA4C247A018783CD7471B6B3DEDD132190484C04147E5962FB314D3A0BA
9C0B070524C767499819371CF255F11C9296CBD0DF347C7CC0DC333B263AAEF2
1B9D499FD98781A4B9105A913C1D063F3E7BAA7C39F4B6BD1E357FB864015D22
55966F9E924497B54138E0F4E0A56EE29EB9C290E2B4CA64606F06141EB8E428
CCFDA0E9E9B0EBFFE38C633A8182DB2326EAF931CABED6FC01603D852D721F4D
2CC0C25D34BBF10CB73BAB8C886D9A9C3DD8F6F3796DA873898332B98FC1CE3B
BAB5061600B69EAF12178B7D0353AF45A790993F8B72C6F78648D24473A7B68D
6253F41785B9C2F1EFE7E5AF428334FB69D26FCEA46C42B46783C47878DB8931
F2130B4F7568615A372A10B47BCBAE9648725F78F0792BAD6EA59178A1B5A7F4
D96F87910BD20054D930900AFD7B9F79EC93E78B6C7E919BC90F61C9BC429B5E
DCE10321CFA3B6323B4D47A75A1E3C15078FCB6FF6632DDECD3D907FDCB16755
CB0A9E18BC038564950D616DDB5EB8A67A86074E90EE54BAC37AF9DD116E86CD
E9886B1980F54777E37305BB91A865A73613DFAAC0F03847C3FF81C0765595AC
6C30FD3966F7E9540D668371FCB69CE957D03AF99109B8F075026E71B7F2D799
153B8890E6945DA1B312D270EA09718566B9DEB49D8141816C34812C92259B85
F87358392559DD3DCE2B8387D7E8F1AC5E4DA50EDD037D57A87459CC9ED262A9
2291FFF8ADAFCF82675F53FCE45F11C6189F2E1FF5FC2287857A70B815F5106B
491FC19E2A7D7CA77790C6E7A6F25758BF03511038FFFC8BCC3D355A7D8E2BCD
F099DCD86A068CB0951FF1F221AD2D4B08DF3E6C2B420AACE9D96DD5E71B9B5A
63F09BD178D45BCD5A6D416357C301D0C25DB3C51A24FBBDA1A58F4F89ED1837
EEDD2F88F2350965DCFD4DD1BBFF6E1D23B4919725071EFCC69903AC847DEE0F
651DC288720FA9C29C80CD99FA259F81B3CA5B558C2CC46B88509E5CAE8580F5
D49FF26884FFF134B5597F3BCE0F32C783FA7F0D136433372FB302886322215C
3D886202CB9F27E5DB8D941425DE146F79D67EC0B658DBDEC0CC728A5DFA0356
054FC5F98270AB9DCC4110705211D2D4CE4B680CD4A539CD8C1A877BFE3765AA
73CC1073B72CB3BBAF57E3440A7FFEAE231FDD2AC1DA356869FF6D2AC506293B
FBCDBD511E413783526BA2D7BEC9CB8D7490840734CAF5FECDDBBCE73C5D02BF
2689258D338A1A961EC09D161EE8C21786331231B2D4042F81CDC0EFF8720FDE
FCD3A9CB830A87973887D58C7AF3094DF38DE47C1368619306C9D0708FB4A2CC
D51C522441AA6D6A39B77D59EF97501986FB5FB2B944CCAC62892B194531AB5D
30E388276291BC6899D23052D9DCD913B1CD4A8CDEE9C8EB83AAD9C042CD53F3
841A5CB6302325F17817A5C161B0EA34EA8AE53DB629AD25FEB1D17089311FCD
0BA89EAC6DB8DDA112B42DA479D69835EFB70E70853D17814CAED52014123879
331B700AEC2E4D01A7CC383E74CF69E103D98C2AE3B0DF0C1186CF54160459F0
F51ACB4086198D504CE91F8896FB43E0C46C10372F8406C35173ADA1039BA22A
2D2F34C00B0BB94203CD404C7F799FC22BEAC7FF68FBD045C20FB8463A043518
948D1EC237F1C69091A16E9A05F3E48C51B790456992B79CD83E401B20261CAB
35E773E4F3DAE6C0DD154F5EAD399FAE6F36007794913987A7F412C5D01D219F
C9727D5F28A595BB4CF6F0D3D84C9892F62621E7DFBD1F17FD7B956BE214D343
A16514D45E10E9351F8081CA1B6728BEAC6D1C6304C67E36721E6AF09D0F40A4
179A630E8B9FAC3D25BEC767B50B1C8B747E9EC5BA87417CF217AD915C93E0EA
AE856734A4BFA44D54979C5CDC199D06B1DB9FD1F0893C9339FDD7AD22B05EB5
C16639D1787957BC8DC4C50F3D93D2A80F6CFA414594C7F48EF43B7CC441188A
E4F970797ED72FE8F466C4270BBC4E8DC15A93D785F46EAFB39BD5BFE18B13B2
374D2CAD6AE8905C3A53DB214B499966E7750AD1D087D90AC84D9209A828AA08
B7B25FD05CAA4B9DC8840BEAC0ACBD34F1CC554195FA21FBE04B89583763256F
C751236EA5B938E84C7FE201496791B61752317B4E50E209FFF58568936A9C36
E699A60BDCDA55B7972EEBCD07D99352E15C86D65B49CD84DDCABC86083942FD
6F232FD6EAA48779BB10EB7AB5959E51BA70AEF09084C0A71FED32E11D690E7F
BA1EA33FF01D0090ABEE88F352B02AE14862B6710C85280C452488DE986FF799
4E1DF0FC3153FCC2D24D4AFBC8543F7258593FF15D913EFABF13C5F22C21AC8F
6BDADD395FBADA732BFBD25AF1D323BE337EAC9DE58C5519DEBDE40551B37BD3
D9BCB0CAF0A5BE2BC5729FB9CB18192668E4A618E398360B862823FB8561FE45
D591C7AE1FF04C52A9A6F90DF81288F7A63B7607C61529DDDFEA142873AD4A5B
966EA1773D744CA6E7AC92DC0FBA649C135CEC445BDFA0F597586FFA31CCA9DF
71CD39F600D74CF7C73075692DBA984442B64FFFFCB8A2046A3494C62FE92EC3
3A01257507D6912177B49480F4647EEB32A582E81DE59EE53CA92B32EEFFB5A9
C12DD6CF5D842D3E715DE552F38C68EC6965D12DA679351EBD7D6CBA28289AEB
53CF730134E5268465B5003AA9A82CE27BFF9E15F96D8B4615E961F8ABDF9749
A0EAD1D8A9C0DF7FD1D5BC8D616C43426ED4818E6B636E9685F6A4BD8D2A5B49
A83F9CD57A798C6ECFC97B56AD8F981A7DEB38D014ED7A8BCC2B627675FC601A
4BEBBA917071737F6A8A528E5BE25FD3D20B40FA37655F10D11491FD3323FE87
75BB2652FEA42649762BE852179E3AA7F79292637E5BCD3CFD0A8A2DBAA5B355
BF4EF02A9302528125C38530ADB923FC7130D2F74986277219567841861C80AE
970D740946E627F08AEBA817B0D4E580ECBA16C9B8E9B42A12BCEF4974D0DC5E
49F0F411A7E32EA9C799500AE379DEFEEAD82107C674586C58ED51AA1DEE088D
B4265ECAD50E6EA6B47FD045F9549CC955F28C7B07059034DC0C4ECAD2F37B5C
7E396EB7E6B7C19307F26F283F8F3DD7EDFD455E6DAB04B9190CA06764D06556
08F26E42DC0BAE861E30922DEF02D25A46CD35D2AB92C4F0B01316DCE81EF3B9
46BD918796B8B3D013D032F7985DC668BBF8B81F2F094F96BAAAB10030ABBBA4
79C429C46122E78A91C9C6D1ACA5ACE9D1B772B91C8E322D8AC678DFB5802C70
096D30847ED70F0C1F48467A7CE6640773031CC28B46BFAE70D826A2E978BEFE
17D2C16E95C66B38B2731B4C9F7AB139AAA35CB0FA250CB560B52E7E406A38EB
15B2F44CA8FC260DFB963FDDDF2CBA8432DF162407CF111E19204FBC4008353D
E883AC55130F488DAD0D9EBED4AB18DCD8DB0B22E3F3F28E0FF437C285B5692B
F0CBD8927092AAC822C35C3E52832DABE3123DDFE86404A490FFA93115756559
25B10513AF0BE13335D4B7C050632BA81907309DF8A1C1D4CE3535E6115BCB80
8983AA65D4C1028826406C0C48C93E4A6F59354D51A10846252DB967C072FA42
DDA18FCC3DC212B93E8619484DCA9A57F44390E7CB41A15F246312DA76605D10
255EA8AE573B3746AB5403576F249D56C275EC6BD45DF7B2AEAD2A36029A5E62
E5732930FFBA1BBC39E0224E7BC020901C4BB8F23C25F697511B17E543355B50
CFFDC49CCD228994BD7971ABC27359F425D8363153D7858938EA88B884F1F308
92DA26167213D6E68E130DBB6B168270DC425857BD17F3F5742863D08F4EA1CF
2AC9F062111CF4CF3E37C0A5CB76DE092AA56532247B9C7DE89DC4F350685E5B
5AD4F5DA73AF0BE7CF1E2A0B082FEFF8E7A317DBA0EBA498BDD7446E62032DD4
CD1A013A32552E779DB914BFAAFD428F4F6F41BFB2003CDFFF3ECEA5FAAA891A
362181BC99FC4884648C09DFB3A33BACC39A0A733C79DE7186F6DDF28F91B11D
FF5039960D95D4CC054CE1C9E4CC644285E4068E836EA7E2D2C16267C76EE53F
DFCB26A5B72591625B9A30A5DD5158C3B6E92BC8913774822D5B337E1B685CE6
475AE9D2661AC80787590690880078816011301ECB3CC9B0F81C88A18CBA5300
538165888E6EC4A1E452ABF37FEBC47CB99738A5FEBF2880E1FD2E6A0F4C888B
7218AC9DF07980D22FF242C818385745D1D23970838CCA22E4554BA62EE47216
7D737B0BB10D8005C10C03E32FABA701CE19D25C1F81BAA3515DBA6B779D3B0E
78BF9C25BE836438DF56A1C294B02998CEC3EEF89673AACC10D57441AD1C2BBA
14A80490F87695C80A4A5F490680CF89E3E6567C51DB9B60C505F5D8D0E07D50
9831859B5F0661FD61D049704944B3A0F5A49038B276BFD311B485DB048C56CA
F482FBDC6A6E463E6682A6F755AF7A5ACE49530D31ACB4129E452A7B4819C74D
0E934B82623A5A8C2525BE47C6D73CD722591AFFAABB8BFB5B90F72838831E22
40DD621CED480A22CB35FB7DD6E8D6ABC873983AD636E124B0059E62947F5514
9A0E525E893B22AFF674FA31A8F256D759A696611C01CDDD7AE93AF05923A517
0843BAF1A8B25845F3F68383DFF2D7A00D45291EC878F265104CE4622D643692
F58860F1F93F4CB7E301F974A88D03C4BD1AC400FF7C4D1B7258E254E6054EE9
DC28D7F205D552F066D7CA0156C6288A09CE4D0477FE38FA7C47B46026BD0B17
DFD16221D57E9F1837C984BBC2D87D5CA3EC737F0A32AF7A8A1DF32E5F6D8AA7
C2F3433224C442DF5A2223F7386394784B69836FC06150D711DCD80FBE471394
55CF2D2F9632F8ABE339F272B8EE522901420A065219BEB79D511C1C0D931B4C
433656DCE09EB50EF61C016AA3A2F840442586F4C82B54F34B2C311E89B2C618
53CA8F2A7E865029A7D40C544C8DC22A0E8F08F0B8E9353BCBAE8C53D46B7357
28593C8B964887DD4D02DAB82508429233A6DDE4A088F6C52A77DA4B60659C99
9F121B726FF1158AFAAC4DCDBC0383A56E3AF219860B048FD32210C735A33722
30E5E0ADDC90D3256410CDAAC147863BDF6C09D3721CBABD26370EE057967301
149C0C5E88C18920E487431BAF94C608C73C17ED7DF997549E98FE8636F409F1
1B728F6C2B39C92D4D46A51AC26F66CC3C860A6667AB0DBF0217EF6AE4BBC361
D5CDBCDA2322382C5B1DCD051B9D89054E235A254D0B1E04BCAE7677E13468DA
3F8BE19BC32CA37BBA9DCA1E03C4DA176337BC5B2CD0E18AD6C22155AAACD587
7E72AEC403402891AC5EB3224BE8AF6B0B15F2BB905F842A893FE475828953B4
5477A1B75AB5B81013FDE00444567AB8FE96A7A5E40AF84AFA4CF96C1AA9299E
CFC54640281759A1FF6B456F2A1AF1A5561EE22FDF1BCA8D27AE121F61383A42
00C5CF5D9512CFCD58E64E719C6805CBAB0E3404FB8F0487486F160989FA73BF
02E0C3CE80D611962E1B3F9AB8638AC93BA161F11D1D814232FDF3A885738B6E
0B901D223B174A7F471C058E960213940A80CEFAA64869C4D2EA58A743E50AF2
13309129B51B118AC04210374D1D6BE5DC59A64B704CF295DBAC5E4E39DB672A
A80D1D913F74C1D0BA6308A39A4D01202CE97796A0F1835DB79045692A116C00
A89416987EB3C3BD453F6DE58744C4D965391000360B90FB0B1B4A665AC8C390
9CB46689ADCEBFD81E44BA1657329A8B528037B5E3E20C2AEAAC871B05379C51
8E6E1B428F21738FB44101AFEF2568FFC2BA3AB6F81108D1336B7B2207292A1E
3755D00BBEF3C65F3E13CD
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
%%EndFont 
%%BeginFont: Utopia-Bold
%!PS-AdobeFont-1.0: Utopia-Bold 001.001
%%CreationDate: Wed Oct 2 18:24:56 1991
%%VMusage: 33079 39971
% License clarified 17 November 2006; pfb update 19 November 2006.
11 dict begin
/FontInfo 10 dict dup begin
/version (001.001) readonly def
/Notice (Copyright (c) 1989, 1991 Adobe Systems Incorporated. All Rights Reserved. Utopia is either a registered trademark or trademark of Adobe Systems Incorporated in the United States and/or other countries. Used under license. The Utopia fonts are freely available; see http://tug.org/fonts/utopia.) readonly def
/FullName (Utopia Bold) readonly def
/FamilyName (Utopia) readonly def
/Weight (Bold) readonly def
/ItalicAngle 0 def
/isFixedPitch false def
/UnderlinePosition -100 def
/UnderlineThickness 50 def
end readonly def
/FontName /Utopia-Bold def
/Encoding StandardEncoding def
/PaintType 0 def
/FontType 1 def
/FontMatrix [0.001 0 0 0.001 0 0] readonly def
/FontBBox{-155 -250 1249 916}readonly def
currentdict end
currentfile eexec
D9D66F633B846A989B9974B0179FC6CC445BC06347FF71900AC8FEAE3B716D52
C1AC4E5DCF4EFC3B9121F09CAB0C4BE35FD0740E08C853EF201BBFF011DE2163
790FADCD67A15500D3F87E2616B7DEEBFB3934B09CF7B8BE9B945D2638887F73
1C3214D790EBA3065BF944D77DD51978CB663398285895D774586FDDD6A7467E
B1BAC83EC766EDE0FF34D07C6E315D7B79B205EDE798A08FD0D9CD4A1307FDE8
7F57AE7A32759AAE66C77C6127F65D92BCCE74ED784372E34CC835BC789BDEA2
9E27574D388B2CEB1DB127C190624246F4991BA418137BEC72C8CF7830DCEA26
E13BC7F0CDDAE283F10C1FDCD1B46ED2C4BF3526E9DD2FD5DD021D1116D3D9B4
44188211B1332E1BE656BCD0DC7C6D7F23ED03F9A42FD10B79980768710365EB
A8E211AC8936893AA9318E20D297C730A6A626FECD20651E6159D498F85DEA98
038CD78953484C2AB6579DE0F8455DBC490B5E1656B45A31736E5E2BF50B8F31
267E916812FA4661B391CCF31C1CEF974E371009854CCC04B88163FDD69DFF46
307B783974C408286274E78CEFDD99FB253F6040F96E4DFB000EF00A93CC110A
AFEDBCB7E9DAFDB19E29736CA84017FBA4C48D67F617A0937229695652772391
0B47379ADCE97C1A2272E8ECE87A1E0B35CFC9400B90A330FDDC52494432E48A
07A5427237AE7DCEBA59F06395833B628C8BF425A38348523AB24EE529E70F6D
E36B4FCA848B48F5D18F20D88818239EA04A1D52164110F10A861C7B7AA87786
3787FA2BB85BEF178696D7433F83886F07FE61A11DF621C607226F24F7EDBCE7
EF8B9A9C547562D02F4CD5A7C1C4E9CF749B6E8484911EB05DC8C54A020A5376
9746976D0F3E7C6D7D6D03D38DAE94B64AE7BCB30EA45A64C8A37114EA85F851
5E5F96B454764A111B571111C7198992EA306160E302F1BC74EBD30F86678687
F7FC00E9E3CDE46A18A27D24305A3C595197D22DF748F133F070C630ABB6DC81
263ECD7E72539CE014BDF4B6F329B383570C09CE92278ECC0B38FA0BF876EBEF
458119485A6A70B3C82D9CF63A2EA37E776AF51DD37736854F8CFF11413C0061
18E2A555443444908D6E49D23F564B971C26A335C7A93634622FDC1D98982CE1
CF21854B959F0E1C248D4355FD3C3479B6FD320669A68F8B4E14BE7C83F37CD3
2978597FA3D1316AFBBC16678C2C59B38A74E29B9E7D4BEF828A51B13E71DF2C
C78DC0518AD29137C8DC053AD6D86747DC82DFD3366CBFCD581044AE5B23B88A
25842ED0050BE19E7F538EDAF1128614873F52B8FE20E16DEF21E3D2FB51713F
DB39D6C3E8B60AC7B4A83F38D6C3283AA890E5C5D4462D0CDA1D49DEB5221D7D
759291FD43C594074033868359A9CB523210CF1A2479FCCC7401AC1BBBA29A0C
F8449C165FECC03856CB08DA710B6DE98A17CA615483CEDBDBD9C2F47D84B562
1745DBAEB9560610DAA89F9D6EE68F8DFD8D0E136CF2B9B44D86E9064DDBA73D
4AD2AECB1F576EE1254970C70643BAACDEE7682FACB396AF64E102AD05E9141A
2A2B04760E9C6C61639B9E43B6D719F2431580556CCDFEF253C0B613B9BCFAD5
ACE01883440C3C61D2BF098A3823E734AAC86926CEEBD235D1F3E05CA0A67A4F
22C2D72A793CE08FC5937B4D7FC5E77105598B3AB259EEE0DA4D7517CF10172A
9CF549FC86FE3C79A1FE96E5ECBD1897E78765DAB8AF93587203554CB8008AB9
1561F7B489D2FA6D444F54CAFFB3F32607B0397165B14A92BE18683BC31EF660
5F4FF9BA5338BFD5864400194937B828D9D86E7EE72A083EDF44B4052C7AEAE1
7734CD28601788EEBDAD2B623303ADD6029EB1D4D1250D769FBD461CE70F3DAE
FDF7FE421EEED9E501237FCD5F7DD882644EC037E53EA6A5216617F31BD2C5B1
5075E1A6F451A55A9862CA1C8FC3550BA661252DC26313FA7D4D37D0FC52CB93
8B81F1CA562A7F1F3A6AE580F7C4662A8D9F8B0FE80FE32B7AA829A4C185B878
B8000CFC63A7179906CB112441C4D31272D19165E0D774DE3F53F1CEA0DEF092
4FA99DCD8A91C01AE80B55FE8A4C3B71618CFE7B401161E375FDB205B8CEA526
18A1D6D534DDC6DCFF55167F6497C9C4BC36702B3F48124430CFD49B3B2CBE1C
7A2D6404EBFD2B3A23BD8323840C531605BD13EBB44A71F76248B694684125A3
85AB03B3E1D3BE1EB284C7F9FE20C0B73A3C9B5FBCF36B0E7AA6A9E3EE39CAAC
9A1926DAD7EDDAD3FE53F1DCF5517AC6E153CB0CEFD9F225AE1908F8610B178B
7B536FFAA648A9822FEE696F566A83597958730BA4E58C2F29771497E9F59DBE
0128C6BD4509E8A3017D2C31F192BC69828681967A2EA7DC476E4771A5F2A0DC
60F58E1CC111B1018F6210E7B8421656F86AEF7C9459D61FC2129BAC144B55EB
BE9D21542662EDDBD16E5BD358B6F36F9504A25C1D71E4F05B5E06C7B81BBF4F
AD370B0FF2409AD16282F172C43104F4BBDBCE706F141A75E7B554898FE557F6
A7A22B1E79D2E13D32D7A2336832501CA2C904FD3162CF242FCA166454A20957
C760D639DE068E646B6E717CE9A1DC4466AEF129B80145D3FC30583423EFA120
2DFB1CA24866C0D80E1C4D03BAA1CD98DAEA1DA807B25961851DC746F0052FE9
0297395079FEA2E1D6599F98D55F11AE5AEEEEA7745BA5975C89DE4633FFB2E5
9669E5D028E4410FD43C24C27B10EBF332F2D4BD16E2B646D930CC18A0E1D160
4DDBDC54DE542299E8F0087C439B8FBB6DA7585F870E2E2FBBBB8BA15E6A07CD
C7D8B70E2F3EF13A15CE6B09B55AEE658C50AB2A2BDD7A1F83B8214FCE10AE55
732814A18E0EFD1E2A6C3CE354E8BD6B807B5914422C329AE0BA4551FAF98C53
6741348D88BC9EAE1F959FB8895F710F29B907D815236B7D589ABB896C024C82
F11EC7D1484CCFF48FD1898015DD89A0C4DE78877F7EDAEB65D26DDCAC87FC48
1D1389AE6E5484F628D631C559BBC8A6D5E664802F87FC6E2A968DD2504CB17D
F50584A1C001110DEC85496D798E68619D9D9AFAEE525672810BFAD7E790F164
1B8E7398476D6AD1B55D6FCC54ED101BCA58DA8315DA5B6D8554C69C4966D8B8
86F94D5A7A87D004F5A922749CD7481236BE656AD5A28166D7BE247EA7C2A641
F59DE30D32158765325CFD454E54D849C83E36B305836CBE4227D95D73CC8479
F4FCE63F04013E72BC6F543D2DD7CF381C72291EBB12D84260766E2BAF099358
77F4C305C3677E60FD2D66CC5990B1973A20136965426E5CF6B6A655DCBC122D
F4C0EEE1780AC687FE143B12A3C5AAA0927881E681DF7DF49367DA43A975EA2C
36FC3CD9E2F8FF14AE5AEDF18F287EE5554A7AB4B050D01D8CF293EBBAE7F37B
E9CC5DE889C159657948519D8ED4C10D68CC9CB0348FAE8497CBA193748C0BFC
C3A3D588D038811FA81A8CB71FAA49067500073BF77B72EE115A2D12F90A1DE8
5431932209B3F4CAC4C1F4E3DF94C2214FCC5FA24D4932479E48E7EC95975819
2BB46558622D678050F02E45DD3BF0F122661F2A0DA2CEA7D4AA01770DAAB0E8
BFE3F4AAE25D9A4E38C348201578146A03AA51CC215ADA35D87FAE6D73BE41C3
0244BC43DBDC198C07B86D88A55797130C729630ED0ABE793BDDEFF023267466
134AE2CB44D964677EB1969E80CEF22DC62C985AE61B6E0B6F39D8955E11C53C
A6A8FDF41236AD3EF3567D31CB24F3D43E18F802B514EAD5C8185DB6E454887E
33D19CFFA051E178FE43C103EB63B589190FA9A1B48D39F7A42DA293BEBB75FD
BA7529663E2A5F9CA80B90EDAED775EAB0E5C5875A3B85B4B8EF8CA9E4624271
DB221ECCFA17E33F0B756348FF6F708E45173F4219582D4594A92C5DB56F5E0E
7D53FE85871F67BD0D84ACBEDFEE2D8EC10EC4DEA74063C334FF08439E4EEAE1
6EDF26D85EEE2E3140555CA64C3EEFEE8EEBD3FA6C1D5BC4454F1FDE39EEE3AC
43FEF1FF955C9F58B2DC490CD3CC898580933E34E7D58E98A4C8A68806BEA865
F81614B83D2089445B018E37BF984F934C544FCABCE014DB8857315264449269
7AF95FB4F19D0E6C7E03FEAD0B74A25256DD28053EC041E3960111A1630CEF84
7215A3D0F8EA2C3552E70D8797C57DC820D7C9186DCC989682AEB72B6B9E6EF1
2456F3F5F79161AD20DB220020E4FC01DC4E23EE35ED1F2F85E0B96CA7FF8684
14C293A71128B87293D4363E5D0A84F1341F1DF8A702F5BE217A815AE86E8383
7A76FF08FA474677DBD3AF4D51258AD07F7B40CAB36919B73DD8FCD76D82B932
6EEF9FE6A551BAA6B894DAA381ED7177BAB6DD22AD422869E2BAC35AC4097C44
9B7505ABE52CAA725C87D52DA04128FF971D283FEFB349087A36932C179BF218
8FCC17214D33FA2CD847FFE9BF4FFAAA0D6E5613A6F4EC09911CBD92D81247EA
158DD7B4E8E9A11D95DD198C51BE09B61935109739FC823A705E8B1275BABCEC
48E4ACC15BE22D4A122DEF616B104C5804E7FDC99E42FFFA745190AC246E4B9D
B1C5DA71AFBF455E6888534EED218D60FD780D21C4F14BD04AC854BFBB0FB5F4
DD67DD781A87ABAA8929733AAB834C1A6C772217A856F22CFD63FC4B05B6BF0D
AE97F67BDD87E823BCEF512B3BDF1915AB28B530C920E67407CF321E331ADFBE
5413C8EFA8F2F6BF7A0AA240FD49AEE908F5D46A50C126DAD1C261A9FAA753C5
FC5C0A20F53DD57E53AB4918EDB95DFD2B3409AF0E1D356361BFAE0DD740199C
6F9B3C8142A1EC084B83E3B9EE0B0A881DCE4A66F3EC26769C43CA8A6E9769A8
45515B38D7EF9EDAF5CD7F0B9C8B26AC7491331707A805221A03E2BEC959F88C
7FBB2A90BED3E491105C3164B472239A73F35C1710F5BEF91D079A6FBB2C2695
E79BFA461FD71E8F20CE050DFA0E68B1368F56BACEB5FCD36A3D575219377880
9D509097D29ADC8913BB0C4CB09F132058E88858EF4BC281646E4F93697807EE
1526874650CAA1C636BB3C963C28E974E01DC3E988A7D9BB7118FE1EA4974CA5
35487D47B6127BA66FA0E5B4D0C766579DAD52D5C2911B79BCA63C8D8DAB7180
25099FF54B995885FE0AF3996FF4F35ADDB5D13A00C702D52F92007263B00FE2
00C7204814EF743BE11D5752AED1EC42F237D54F20FA821DF65154219C257701
4CD7C8EC5AA896238478D7225030337A86FFA7A4E0AB0DEA3A8BE3B68263ECFB
214693519CD9F0CABEEAEF907FDABC9B780F885F7AA841419555F2D683CE217D
C03A7D5F3595F52A1637F71C470EB34D53F81048C48A9F9FFED6FB35FE4C6DCF
F85A557905F7302C36F94DB4D82AC0887217F34330B898DBB37B9CE3F1D0C624
D9A9538E1F4B5619BD0A487ACA07E96FCA85B085F8A8F736C9155313490AEB57
973C9FD3B35074D85BE81E848CC7B7B3899337AEC6F84BADBDA46E862AAE8909
DA38268757958DE42535CEF08123B62748256444086AF935F716F47D04EC5A73
A98F1555679F6116B45D136415D0F5E6CB87C4EF1A271A052E23200E94EE04AA
8AAD5CA267A77E88279F4D79D351D72148A9607B703E7A2A5B06B69782A8D1B0
C11F16242C23E026AFD9B5D8016DC3A382CD38571CB6B3A684DDB55AA6135D16
4A571F638FC6E9A84FD09E38C8C3F9AFFB407059F595DE64767C9544C93EA4E4
0724AE4F47148AA1D82680155EE634BE928C7F70B0FBBC592094E91158482A0C
C98E7EA1555E295D408B783320EB9EA89B60B29C99F730A5C8CA3404923DF882
1359AA00F72187D83B605BB6DB3EA3A8E48AE21DC3B6C24BED7660A5B914E044
534BDCE12AF96BBA81E22133A947415FA2D308CFC6B8766D2A04D217F0459067
2247F6EB4F935BC91CA74ACA52E6119CDF9C014BC00A96F50880099DFA9DF5E3
5B551CEED3B63F25F101272C631BEFA230C261DA2F87A30A31E9D23BFD193F0F
5AACBF5E1F6A2B94E8820E58B8A1B9AABCBE0EDB42A4AA93DC6DF356C1DD847F
173D7DF58570C54EA96C9C06201880277CB69B8FF49D4FA6EAAF63F54715CD6B
B44C15CC510ADEC7AF9C3AA9EDC1A1C00558EABF5B9CDBB5E0039FE7704BBF2D
2CDF44BE37A19245E34FBB7B295F769C4B5252A895B0064C2A1CFF39423D6AA1
706D39DD38FEC1C6C82FC542FAAF9B4F5B165382C75D64B1710A88AEF979E526
8D7DC50670C4B58FA4DCBEC17218A1C3F5D116DD87E53498554EE9A0B90656F5
84C513E2A42DFF5C7774DB00EB9208D9C76FC69A886B8C68AA4FF46189E6E543
778DA1999BEB2767C8D190AD1C8A0331510C003930CD829CE05AD2C294BC0C53
23164D1C34DD4C5C487A00CD2CC6AB5B38398CEA6B3AC0B08922F035C9E64989
9F6B7FC76BA919480FDFE3C79EDBE0084A3246BAFCD57CDD53034091340EEC60
5313952366C1486113854688B6C6CF1EE56BC6350E0168E12BD0EDA53C557495
692EBB6086347811F7C8B1580AA7E3AD8CEC06549E906A6AAE4EC6327CD4BD54
6E95B0DC426DF7A1DFA830FF6526134F7355718D50CE18101A371D49C8AE59C3
0D2E1A9E9BF8A9FB74909EE16F5399D185231DA4EB5E716F5ABFCD726A98F74C
B852D663D45B50B2632589662C8D59A0E13A2E414FC4E3FA180B24BBB424F144
D0203CD421C4F2099128D1C3566EC9A7373C3A46422059350856FBC0992B66DA
71D88C2BC6D6DF576A99648B4654617C282972DDAB121A36A4463C5F063817DA
4BD7D765F334B1025509BC8777A60DAB3979FD2AA8D317EDEE007C3E29D017EC
168CD79AA7CAF3D4E9473D485AC640F552D411F7CA7D4C7399E3BB738107A40B
9BFC367708C980CFC1AD9B6E2732EBC81F6E6A06E2CAEC6C66B3F7FA15E13D73
7E303923E6D956D36EB7383EE87B3B664AD0FBCD336EA87295109A935C260A89
E79CC20C6E78F34B4FD357B30BCE49F1B8D2CAE75B6C1D44D7AFFD757B3CDC1B
5F3368518794364ACB70FBCF33BC99957FC27C6FA59171BC12C8AD6AF60B5556
5A2907C704167F82DAB6DB280E5CC3879D99EFF809AA0080AD2AD5D4E1DAD4AE
D3B848E232337C2E7063C1BEC413CBF283AA4E2971044E7021EC70517E9D4BEA
29CF5D824D9BB848749587A48B07527A08BDDBE7EC346B71E487A1D6CEB03DF3
C8DE35F0742502772B69E3A5161B6520ECC07125C06408446BEC354AE5CC0E55
B44F9D99050D44FF846625D4B99C104772E43558D34A1D46683E515B154BCF99
217F8B05003681D7C51D5EB133FE40B035DD3D50A5332AEB06AE11D861DF6C95
A5978375ABDCE208BBD9573C792C99C7ADF0F3542ECD1A8D5A33AE34368E7971
2A5E8440B1114F728A9FBA354F49ECF6856F1D10C8EE6D10578FBC9C11EC7E1B
A93B0C8B4BC671E4E811982D89D3E1179C46B6BCA323CC1B73E399FAAC0FFADA
147DFFFFF6DB607AA7B90F8B2165402EAE9010928582C3C43BFF440DDC599421
048329FB1BAAF4879364011CD06B761A21AF056AE238AE6836588F082C19E6E2
974666A9AA01A26B8297CC9EFE00CED8428D248B1119002AB51A571FC88B25C6
5C46861430544D48FD3B40E95428ACA71A5023470E66EB4BEA3778C1315F665A
F9F823CD76A9912C485C5DAC43F6BC883206CDFE2D3C8C41985B898D9412BACB
2DAA9050F3077109A4500AE59464563D4E5916B4684BA271B7429BC242A14E2F
E023C4E56F85D4D1F07DDD370EC750752A6B8E0789CB31CD63D325C1ACB39418
3F0365B9817B90D3EA865B47C416D38C10AAD1B220F9A1632C60EB44F2804C6A
600056A639805EFA48E9BCB2FFF243628AAE82CED85C7C0F55B4BC12DEAB1022
40D5771AE5B8DBCACFD9B37E73602F5EAFD33A8B88F4912AD08CC15C138E4E47
192E820BDFB13866FDEF3E965E239269390D58E227BABB15DB9C5117227E44CA
8EE79FAB1ADC44E92B1038F6BBCD836D1668B85BE456F4FDA49C661747F284E2
51D1C14862F5B9D7E22A51AB446DE4B3B09C19F419E6F2EF0662683891B46601
66B3AE0673B3CF44B40C220690BD705474E6FDC8720F72167FF64106EF343E37
85A3537F71088F57E11AB564A93AC81677F99FEC51253FE8B9ED08ACE96BE736
EE4ED2A49279CC65C70B8A6E2BD241B993D1A05CD06352E7E3F3A8DD1453474E
7BE960612179D317AE98A934A369B8397BA0C9EB824ECE8E15F552ABD89A39B8
B4243FA388E903A6B211D062680850BCC45B1F4A5D68600ABF056A0BF754402B
8695C894A282F786D66629A99496695477BC00F78AC94C8CBE561500BE94D5BE
11D73A0D395528C24D7556DED336C5BD458C2961DFE5DB99809122572E30C55A
161494DECD05E5CA53C762F0EB521374B2B5FB0FE451A130C3E73DBF548B508A
F129D67E8BFC9BF4DEBD5710D87346A5CED174B0CFEFD6CF2B68FE21329F8023
163F4E21363A1756EC2A5F3DFC49711B8CB6006AF354480753962BFBD71950CA
A5BD78AD689C54F600AD7250E5739D693C39D622AD28767FD778625515CD16BB
481198E9DAC53D80BF9FEF50C0117CDA3F99048676615D1465AE9AE2228E3945
80C82BFA06F4BEAE533886E62C8C767B1BCA72E841B7C9E5475EB2D2FA3A5DA7
F3CC441E1673A2EF6C8F4D8EF680EFDDC722FECF62C991F7666A3EA61974BDE3
AB3916E379EFD0EDD9F850A3D67EB44948E85C561840B35A59317A96DEEA6FAC
166A7B989962F1B7F7798592BBC8360DB10CB21DF07C74E0EDF6B04E6848ECE5
BA865B1CF5D1139379B126444D305523D3386E85B8D831EDEA947F2AFF2E0FFF
AAA911840172E6D44A1987BA0B9C419A69F3E76C4A2F6672A632BF4DC73FBB36
B3F3C6D6D84E6F655464590BB6A4D0230CB915E5AF8059C9E47302C69058C90E
667E746FCA5A25395A5F8910A5C0642414EC4F8012CA555F2F2C7362EC1E331A
DFBE5413CB797E5EACA0AD8FB6C6A1BD4E6F8E53921741047CFCD44BAA43A86E
490375D9F063B335DC111D389D94D7763BF73C624CA4AC7E77D79BA760DD928B
97F03B930942E1672945A22893BAD39B99FEF5CEF5B4636A0AD892865704CCCC
0D2D8392CB24B9102FE3B76F5D283003E2606CF72B5F4E101511B944313480D1
DDD17518CD75C377AC736200D8F97BB70311CD967D167E9A345F8A6B53F4CADF
4E6AD3AADA6F16F6FA29859AB7EAFA4FDB7E63C505C2179E0D9F1AF9D7259642
BA2E3FBE9BF910E36225AFB40387A4065E32E828FFBDD1A2F5C816D74DC29EBE
AC3111CBB4943A23EC7439FFC507C68BBAD0FE4EB738DE4897887608F321C8F8
ABDE1FA0D8846434D4261EB4B41B13E43FFDA2931DEE03B0E76B60EAB233B80B
94704D10B4A5A251E8B781F24F01DFF117A5465400DCB8986292BD055F90D469
360D3D583EEC828969DEE5DF27C5FB76BB81C7A1ED5960655644AB7A4A0C06C5
9A88C96A2AA3C09BF35A1113A8647376E2BCF23F629B06EE09153958B75D9B46
B798FC3D68A453F48F50F6787ABC2DEB203720820E6DC2842F5C7F6E3BD7A706
F7F2104F4C3EF5050070CCB94528CC1C9A135CF13C8358614EA5C5FD0A5DD59C
F4A57E894BFAE5DDBEE7C232FE95627F75ADF49EB243A98053C19D4317458F7D
5F461C42FA21DAE9B782EBA7766BB35F992809430D02325B43438BE587AE0068
FD7D712D907749CF24C17CB43F188FD3402DF4BD31EC25883724A23AFA2EAEE5
5E5CAC6C6580C7A7E68688357B6129593E63BB1437A129A280F194CA51AA6668
C2A05801A766219CD91E8A4A2AD40C95345FAE185BF87666C0F892542E394AF3
C5B120D7802594D9A987567ED3DD476023B64B49434DA48595E399ED18C97185
576319D178A8D61FAFCCB13A05F905F7F25D08739A644046CDE1FF7180E277C7
71894D8D3A8018F078DB6C3D1F0BC631A07B390F3CE63EE5D56C3DF27820845B
235B1B6443DE0D5A4F0514CD05C467F05ADB762EA2EC8E3C5722A4696AD34812
0566B4930C7AC6C3755BFFD040AE3F01C677647F4069EC95D6B59D2682CCA9B7
6A29E28F55E68313BEF4F9DAA3401B6A9C5422072F121C81022D2E4700F5F4BB
8759AFEF42B52D27B79411B00E7563DFE6085FAD056585FC6AC72AE3686DC56C
8802E58DB4EAE8A942B268807B9377E87FF1EC792C2392B23A294DFF58501D42
DCC4F62DD4CEB1AA06ADBE7FA6153E0D8525FD5B9C0A32F749D69F1448EAA347
734DEAB5D5ABD94F0A0DDD37D9C6D844EA8513A5DFAAB457E04C7115CAF789BC
0778B174A9C9C4E50BC74E4466BC6BF8734C4FE9A0E37AF5E9934C372E4C019A
9D7EAB5242DEA5D0038116DCD604A420F38A9C82BD00B3E763443F2CBC985090
CA164DF0983B824457852F773678C72CBACE6B217FD6CC9B23FF154B85F9782E
396779164AF871F01B5F46C739DDFA96C0E5A79C61B48A01318ED14EAE09AD2F
2C71C272431F91B8EA9D94135E01173C16AEC84A3320B7ADCAED8D5EC2F0D77C
C7B7C5D540E617F24470C4A6DF9486B3CFFA939A405C8055D11DB95B7E04662C
BF7A95168C6AA9E424877F73BF22E6B2271D67A94B587D813CE8818625DE5EA9
D1D975B0A4694FB5C708A42C1B6EBA112970A146E64993006F9B213250E4B49D
16C55B067A402341D53F2D8F0632D5767850B226DEA67C66F7FB5135895AA362
EFA768E5D8E181D387D569742D7E55FA5FF17B14F02996F048A31C4AC82EEBD7
F925A4A579E86C88015D38944F18880B15551AC6F13F3C9B5C3DA72BA319C03D
F35EEDE62CD25DAEF69F3E2762F2E7BAE35D6601C8BE6CCC4FCD2C8C2580D636
30CB1C443632C88DFA94C3F3055264E310DEEFBD46BB8DA583B8358FCDA3FDE4
A4BEE6A19FB81A4C966F68A52AE85DFF6F484F11557B9B6FC8CA6460CD9FA071
D9B490FB2039F35A34B7841067DFC393A62D5DFEA07A3E2B0D7959568AE5BA12
827B5EC8101D679F7C319A7FE7CF37FC469E424D4BC119FEA2880FF93AF0A45B
6152366A6E5505CB5038C26CE74124515503A3B05D871D43A1466247C5AFDD0D
FD80C94CA118C220206C5FF791AFECA43815B7630FAC34BD23ADAACA3C14B5AF
665F595EEAB91FD04EADED15087DA8D1A8CCC3E6FB3DB6AED4A82578DF654186
51E3B1EDFE0DF90293851FFF75DA8B93ABD94651FE20B5D014949A69061CAE94
BBA531796A58826B135F60246D47ECFBAD7FAE19BEFAA0DBC21B1210F5167B40
21E8EDE70F2A3A1E688B8609D8E08397557B2468CF994F92CBE7C21733BDE362
20D0F9BC3EC339A0AA80766111649FB2888C65AE2169B55214CF1358C9596D3F
BEE63CE67AB71E903C1FB61E756C8D886CBE43246A11B4C149BEB92B97EE5D0B
31296704AB31D22FBC1FA4B0816A67A6C5F4E7C0DFF7FE9E68CF6121F3B67F8C
92EDA1B576258F9DE07D3615FB04F269EF8C5CB91A1088CE1C25E89B8A526A2E
A6FCF8E658E88C81FCB41E4CE1917DD7DB8FB5E7950A373258DF1865E6B04275
1ADA602B7D3A9DFD240DD11799C05FAA12C4E482F941A99AEC0678BB188D37B7
EF315FEAF1B7B910D52FA446A36D82C9A1B135B5E5097E52BF2EC7FFFD4CD022
8FF74CB09E3104AD5F9CF990FE37A7CF0FDCCC17744C42FF7CD9543818F06520
434E176F1BB05AE1A8CB5ED2E852BC1B9D191A8009532C5155214A256768FA6D
9E2897EFB8E3D8EF0F44C10BEEE15CDA5D85977BB510FA6AB55FEB9BE60C6C0C
6A678658F1CA8091B6B280F49EFE8C3192C6B79D8710A07C8C94E3D88F602965
133552868F32572C4F483A34E3E9657BC12FE27EC1704E20AC727F7D5698A5DB
7310B61F15D3F92E04B9F6FDE38DDCBFE0D7A1352D7D7031418FFC78FEB68568
BA3DACE2F7F8756B84668451BF2FB8C7A3E4A1F5927F24BB45C46DFC69EB7B63
D4B451062FBFB68A5C9DAB1A5256F5F95734D8735E786B7812BA06DA81520EA0
35BB2B9652D2F2991B86ABB8CC58D14D7216D93F833F07277994DE7E0300196B
4B2B0AA48833928CF16E660BE8BEC3C4A44B5DB47854302CCC9AB2A1A1D9AAD9
47AC9F7EE6EA74F7F270671486A5FA1A10495E7F598004D2AE19FBB769A595B5
3381864BAA2CAF1A5D1BA053C20A3928103ADC845CAE402F080142812F7300F1
E113F5191DBA97C825B8DC0A45B3ACC18F5AE1585AB04A87A3ADF709033E986F
ED505EC60F74520290F38D6641CD4169BFE52A21BEC82D0049DB8716EF5E4C23
158304CFE1A4269E5E418CD69ED4B401D9178390151CB4C146DD7D2B59AB1FF7
DB422443EB3A0D8295047E20F78ECE001EB5EE7A9F51B10F0445DCD6ECE89EB6
6E88AD2B2CF8DDBC3C483D2AB008F76365233840410B46699FD6B53A9DD8EF9D
B27FF9992916C3E12419F466756FFCC1D45A057F9A34A4A0A7EE8D58B32C0B7F
F4B23ABE3A1C88551EDFF4ED6D4B180A2FB9E54065B2DACC9BA576F43657BE02
1A1F6CB7701696D402F881C289B8919A64A7D97E7AD291BB0ED43A035D81A05B
DD021509A8EEF53AC93A98E89333C94E7465C365A2C92AAD8041372EC25804D6
7B1C6FE3A9FF7B3D1A0643EF1645AF320262DFC6DD4D4F0C01CA495CE8287867
199083B5419E736D93A647BF00BD69FD89C7679E6B18F9FF226F39CD61A6A094
6805D745A94757972D5FA656AE31A1B152CEEF8AE58083EA84EB5813BE70AC6C
141100367968FD0EFCFF7628062173093637901C9356CDD3C93C1655AAB1FBCD
29DACBA53D1A4EC2A667C94A7F81AD088F2B37B3D6B8701E473A1C83B5A6F175
214EB32A5FFB9A33AFD79FA72717A394C54D38BC30D0C97A17FEB93EB0164E17
78533968EEEDA6111A1C0B9D7BB2137244D7BCEA74FD44358595A47913D246BB
CA2774F277362287BBBA100AA11381BBF102A5FFDBFF5542CE8F9D7C8048B7C2
738EE52A7491F8DE642C6D89EE6E8F2C2EA704AB2CFEF7BD716B2401FF59DF84
DC27B11B312844D02CE69F8B5F320F88273A286B74E9E8081139E7FD5BD1587C
4261D836E4C20FD1DF68AEFD6F65DED12F4BC6817E040E1E3ADF5B73C48A1CE6
7B50E6234663F374BC512CD0EBDD3D3F654AFAF4CCC70AAA293FB94F7E606751
6003BC1C239580F381B4B8F665A23FB21107595DEE5A8AFF67D47BB6301AD4F8
60D1FE4D5BA985E148BF2DBB9A8BB4800C8A74DB43DACF1B88468B64630284F8
70F114F43D6F39796552554390F2712173706E36EA41C57E7E0A23C759278698
7A899E28ED6BF9E73FCDD01770FE56B13AA90E4AEDA7834BE592C02C24B1A645
7B8932C670FFEA359C59A019B99966F6116F2011E4D58F30B9517087989A59A6
33BFBB69DD309854D64168E6CE21C03B4D7FCB6B79C57C3CEE9710990A30B3F5
683C781BEACA5798470B9FD03ADA152A9B3D12AA27C820EE43E426AFE898EAF7
1F507560FEC3EB90D4ECD9633A09FE997E44AB95B4E84932A4A861CE35C53B65
2407D65B41B5137076DC7E2274CAFDFCFA1D14B742B142E017B54FABB72DC31C
1077ED4D968F820C1EA70C974724A6508B40890B1E1934F8663E374572C145AF
82C8DF50197789934689A75C4F7B3EDF4F96C82774AF2520D8CB1D59CA27D3FF
75032BB753ADEF5DF8C41F14DBB01D5F186B2BF17A1D39E9038C3F782716985C
38EF4F13071FF8BE66A85E5CA2278D459102D73192BEF8EC3711E36CCB2C2F1A
1013B2E1342B2920E9889F9EAF2090A5D19BA298BE88A15784601E8179342B3F
00F01352CDB63550D1034F2724950D36773F67EE3327BCB2651A79BECD436280
B09EED605D6191BE93DC8273AB5998B05858B10C67772F9F5A48601F9C3B812F
59A054B16E55E468D926F3A2F6AFFCA93DCF1F18743B065A3528C72584477EB4
496736A25ECF8B2A7CB5B95ABE7C0B07942C19B0FF29C8D674A40671CB28D3CA
BFD3B31EFC46812C77B3E19EF3EA865733782D6B82E6832DA2E4E126E9D92879
2F7B233818741EF7322BC951B0F71586C278D55A8CE9B8C53B276738EE742F66
18A21411D7F8A0E47F4C50C3F54C3377C3835F8A5D188D9CB6432FD9F0C4C433
4DBBC111884395F19DC8B8C93E92493E0CD01D87699A884FFFCABA110369D1CD
7F93C15B0FEE17D0657B326DCAD1BAC48396F9F26A51F259BA15A6C7AAF16A70
C79E83E7A3A1C69698ABA746D179E6E254246A530290DD67B4EEBAA887FEECD1
355E70394198DD79E3B92701EB30DE7CEC2182EF88AD3876EF2C616178FE5106
6CC891698CDD763B923BD37DE76858E73535836FD6255DDCD2C1F07F14E8C5C5
08EF64FF17C61244EC514BCEA15AF56729765F9108594F2C4C28B919AD8CF8CF
851725C1751284A22644AF3F96E0782D29C615B9CA39C1D9D6B384E0E48A40F1
6E82832861EE0BC9F35F5F7149B43BFAC222B4B68F5103D16DF6603BB8D4835F
9E1E41BD624EDA71138E8BC0A629AABA2D5A0C378F2FD7CC8CA1C7A987986D92
54AD5CF6B6E653AB93FF26DBE0EE5F68A5AD47527C4A5BEF13CF1690D5B63427
8AD9C7BCE263D125438F49FD43B42E44DBCDB3A69475E4BCDC9861B5C26D51A5
ADB79A3D8183D968C765C50484D5DB2FB18D5AA60BCF00A2630A2DC6A85959E4
54B24863B704FDAADC7110A1F6AEE421E9B0A1172B33C72254B7C21C1EFCA360
9DBA18F3A81009CB267EEC0E6711016CFE60CDCE3FF9FE4645A0C59AEBCD331F
AA6F37D473839A3AA86E6F60CB652CAF8A57A810B9836250900AB9D5321A775B
AC217C866E06A225AD4078BEE94F88D3634B26F0BB826BF4E4921EFC56E20A52
B7C63864057D0141EA5B1EDAFD996CD28FE93B5B466C2017D5CA9A54BEF82C58
449B31F2D98D4D9FB35CBE13BABF834D4A36E346227656484D4AD89EE5E24AB1
02CE8D543EF6209384C547078DDC591B2BFFFC6242981AA1B990EAF7EFD7B801
030045366D40CA90EBC37E8F700E4ECEB2D3E1674E1A8C926D32F0041CB4C68F
0E9570EC5616FBB3A5FDE9C81B445FBEF645662317B77FCC8BDFDFB773DF01F7
41AB833D40624A25AE4B5B91EA29FA74043199ED47DC78B36323259C0396B9CC
80958573E32614EBA1922C0082E5B02051A5546A98549A25E035C8C36BC58C59
DE3D8472B1ED723A5E3B440C8E60399C74DEF09DB0B407C78EE86633A14B3AAA
9DE3187F7FCC9EBFE9461A3921081A27252537AB3E6CE04B7B6DC2FE5557B87D
4F00CC331C8AD4824115EC9262CBF581728D2BA62DB25FE53250FBAD3A96B998
CC9E63ADAE2121B3E2C5205CDEA2424695E0924912CB3721B0CADDC4F07942FE
6EF6BE075CB50963655E9F1774FA87B1ABD995EF0764AFE2A8DA739214B180AC
D9D271E896093F89443EE041761ACFCF019B148663F02B35149759292B252259
D14214D9907CF4D17FDA4AD5D02D108F1F767CB5747F2A1470137698EFD99870
079F75FAB57E02B3660295BD7E09ED2F5A1C1F4DCC080405905ABF09534302DC
4B76FD263627E5DFFE587F371054A8FAACCE74175C75B8D3A97BFB1A9372BDEE
3694783226C887FA0765531342EAF438FEAA5696EAF490376CBBC158E5CA939B
DB8AAF017106C9D9E42F4A921F74
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
%%EndFont 
TeXDict begin 39158274 55380987 1000 600 600
(fleches_equations_pstricks.dvi)
@start /Fa 57[66 66 31[66 3[66 161[{}4 91.6562 /Fourier-Math-Symbols
rf /Fb 135[47 120[{ TeXBase1Encoding ReEncodeFont }1
91.6562 /Utopia-Italic rf /Fd 22[47 115[56 32 40 36 2[53
57 85 26 48 1[27 3[47 55 45 1[48 12[57 3[55 3[52 10[58
8[49 49 49 49 49 1[49 49 49 42 24 36 45[{
 TeXBase1Encoding ReEncodeFont }30 91.6562 /Utopia-Regular
rf /Fe 173[90 82[{ TeXBase1Encoding ReEncodeFont }1 131.985
/Utopia-Bold rf /Ff 54[66 66 113[68 83 66 59 1[81 1[81
78 1[62 2[41 85 1[63 66 82 73 1[68 65[{ TeXBase1Encoding ReEncodeFont }
17 105.588 /Utopia-Bold rf end
%%EndProlog
%%BeginSetup
%%Feature: *Resolution 600dpi
TeXDict begin
%%BeginPaperSize: a4
/setpagedevice where
{ pop << /PageSize [595 842] >> setpagedevice }
{ /a4 where { pop a4 } if }
ifelse
%%EndPaperSize
 end
%%EndSetup
%%Page: 1 1
TeXDict begin 1 0 bop gsave 1 TeXcolorgray clippath fill grestore
0 0 a
SDict begin [/Producer (dvips + Distiller)/Title ()/Subject ()/Creator
(LaTeX with hyperref package)/Author ()/Keywords () /DOCINFO pdfmark
end
 0 0 a 0 0 a
SDict begin /product where{pop product(Distiller)search{pop pop pop
version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
grestore}if}{pop}ifelse}{pop}ifelse}if end
 0 0 a 0 TeXcolorgray -126 -481 a
SDict begin H.S end
 -126
-481 a -126 -481 a
SDict begin H.R end
 -126 -481 a -126 -481 a
SDict begin [/View [/XYZ H.V]/Dest (page.1) cvn /DEST pdfmark end
 -126 -481
a Black 0 TeXcolorgray Black 0 TeXcolorgray -118 -189
a
 /pssetRGBcolor /setrgbcolor load def /pssetCMYKcolor /setcmykcolor
load def /pssetGraycolor /setgray load def
 -118 -189 a -118 -189 a
tx@Dict begin  gsave STV CP T /ps@rot 0 def grestore  end
 -118 -189 a -118 -189 a
tx@Dict begin  gsave STV CP T /ps@refangle 0.  def grestore  end
 -118
-189 a -118 -189 a
tx@Dict begin  gsave STV CP T /ps@rot 0 def grestore  end
 -118 -189 a -118 -189 a
SDict begin [/PageMode /UseOutlines/Page 1/View [/Fit] /DOCVIEW pdfmark
end
 -118 -189
a -118 -189 a
SDict begin [ {Catalog}<<>> /PUT pdfmark end
 -118 -189 a -118 -189 a
SDict begin H.S end
 -118 -189 a -118
-189 a
SDict begin 14.5 H.A end
 -118 -189 a -118 -189 a
SDict begin [/View [/XYZ H.V]/Dest (Doc-Start) cvn /DEST pdfmark end
 -118 -189 a 1919 -27 a


1919 -27 a 1919 -27 a


 pgfo

 save

 0 setgray

 0.3985 pgfw

 save

 save

 /pgffc{0.75687 0.04706 0.7804 setrgbcolor}def

 save

 /pgffc{0.75687 0.04706 0.7804 setrgbcolor}def

 239.47311 19.38937 moveto

 -239.47311 19.38937 lineto

 -242.22429 19.38937 -244.4545 17.15916 -244.4545 14.40799 curveto

 -244.4545 -14.40799 lineto

 -244.4545 -17.15916 -242.22429 -19.38937 -239.47311 -19.38937 curveto

 239.47311 -19.38937 lineto

 242.22429 -19.38937 244.4545 -17.15916 244.4545 -14.40799 curveto

 244.4545 14.40799 lineto

 244.4545 17.15916 242.22429 19.38937 239.47311 19.38937 curveto

 closepath

 -244.4545 -19.38937 moveto

 gsave pgffc pgffill grestore newpath

 restore

 save

 [1.0 0.0 0.0 1.0 -240.94797 -3.0964 ] concat

 pgfs



 0 setgray
 0 TeXcolorgray 0 TeXcolorgray 1 1 1
TeXcolorrgb 2490 -15 a Fe(R)8 b Ff(\311)g(S)g(O)g(L)d(U)j(T)g(I)f(O)h
(N)29 b(D)8 b(E)g(S)34 b(\311)8 b(Q)d(U)s(A)r(T)j(I)g(O)f(N)h(S)29
b(A)q(V)8 b(E)g(C)32 b(D)8 b(E)g(S)34 b(FL)8 b(\310)g(C)g(H)g(E)g(S)p
0 TeXcolorgray 1919 -27 a


 pgfr

 restore

 restore

 restore

 newpath

 restore

 pgfc


 -118 411 a Fd(Les)21 b(commandes)e
(utilis\351es)g(n\351cessitent)g(P)n(sT)-7 b(r)q(icks)n(.)1628
665 y(7)r Fb(x)19 b Fa(\241)12 b Fd(4)k Fa(\306)h Fd(5)r
Fb(x)i Fa(\305)12 b Fd(12)2346 665 y
tx@Dict begin  { 0.0 3.95998 } PutCoor PutBegin  end
 2346 665 a 2346
691 a
tx@Dict begin  tx@NodeDict begin {7.812 1.398 0.0 0.0 3.69597 } false
/N@ru@A 16 {InitRnode } /NodeScale {} def NewNode end  end
 2346 691 a 2346 665 a
tx@Dict begin  PutEnd  end
 2346 665 a 2346 665 a
tx@Dict begin  { 0.0 1.84802 } PutCoor PutBegin  end
 2346
665 a 2346 691 a
tx@Dict begin  tx@NodeDict begin {7.812 1.398 0.0 0.0 3.69597 } false
/N@rd@A 16 {InitRnode } /NodeScale {} def NewNode end  end
 2346 691 a 2346 665 a
tx@Dict begin  PutEnd  end
 2346 665 a 1433
834 a Fd(7)r Fb(x)19 b Fa(\241)12 b Fd(4)g Fa(\241)g
Fd(5)r Fb(x)23 b Fa(\306)17 b Fd(12)2346 834 y
tx@Dict begin  { 0.0 3.95998 } PutCoor PutBegin  end
 2346 834
a 2346 861 a
tx@Dict begin  tx@NodeDict begin {7.812 1.398 0.0 0.0 3.69597 } false
/N@ru@B 16 {InitRnode } /NodeScale {} def NewNode end  end
 2346 861 a 2346 834 a
tx@Dict begin  PutEnd  end
 2346 834 a 2346 834
a
tx@Dict begin  { 0.0 1.84802 } PutCoor PutBegin  end
 2346 834 a 2346 861 a
tx@Dict begin  tx@NodeDict begin {7.812 1.398 0.0 0.0 3.69597 } false
/N@rd@B 16 {InitRnode } /NodeScale {} def NewNode end  end
 2346 861 a 2346 834 a
tx@Dict begin  PutEnd  end
 2346 834
a 2346 834 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 1 0 0  setrgbcolor  /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@rd@A /N@ru@B InitNC
{  tx@Dict begin /Lineto /lineto load def 0  setlinejoin false pop
end /AngleA 0. def /AngleB 0. def /ArmA 26.39992 def /ArmB 26.39992
def /ArmTypeA 0 def /ArmTypeB 0 def /AngleB 0. def NCBar  } if end
 gsave 0.8 SLW 1 0 0  setrgbcolor  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore  grestore end
 2346 834 a 2346 834 a
tx@Dict begin  gsave STV CP T /ps@refangle {NAngle 90 add } def /ps@rot
{ } def grestore  end
 2346 834 a 2346 834
a
tx@Dict begin  tx@NodeDict begin /t 1.5 def LPut end PutBegin  end
 2346 834 a 2346 834 a
tx@Dict begin  { 5.0 tx@Dict /NCLW known { NCLW add } if 20.50797 7.392
0.16199 NAngle 90 add  Uput exch pop add a  tx@Dict begin PtoC end
h1 add exch w1 add exch } PutCoor PutBegin  end
 2346 834 a 1 0 0 TeXcolorrgb
2261 864 a Fa(\241)p Fd(5)r Fb(x)p 0 TeXcolorgray 2346
834 a
tx@Dict begin  PutEnd  end
 2346 834 a 2346 834 a
tx@Dict begin PutEnd  end
 2346 834 a 1767 1004 a Fd(2)r
Fb(x)23 b Fa(\306)17 b Fd(12)12 b Fa(\305)g Fd(4)2346
1004 y
tx@Dict begin  { 0.0 3.95998 } PutCoor PutBegin  end
 2346 1004 a 2346 1030 a
tx@Dict begin  tx@NodeDict begin {7.812 1.398 0.0 0.0 3.69597 } false
/N@ru@C 16 {InitRnode } /NodeScale {} def NewNode end  end
 2346 1030 a 2346 1004
a
tx@Dict begin  PutEnd  end
 2346 1004 a 2346 1004 a
tx@Dict begin  { 0.0 1.84802 } PutCoor PutBegin  end
 2346 1004 a 2346 1030 a
tx@Dict begin  tx@NodeDict begin {7.812 1.398 0.0 0.0 3.69597 } false
/N@rd@C 16 {InitRnode } /NodeScale {} def NewNode end  end
 2346
1030 a 2346 1004 a
tx@Dict begin  PutEnd  end
 2346 1004 a 2346 1004 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 1 0 0  setrgbcolor  /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@rd@B /N@ru@C InitNC
{  tx@Dict begin /Lineto /lineto load def 0  setlinejoin false pop
end /AngleA 0. def /AngleB 0. def /ArmA 26.39992 def /ArmB 26.39992
def /ArmTypeA 0 def /ArmTypeB 0 def /AngleB 0. def NCBar  } if end
 gsave 0.8 SLW 1 0 0  setrgbcolor  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore  grestore end
 2346 1004
a 2346 1004 a
tx@Dict begin  gsave STV CP T /ps@refangle {NAngle 90 add } def /ps@rot
{ } def grestore  end
 2346 1004 a 2346 1004 a
tx@Dict begin  tx@NodeDict begin /t 1.5 def LPut end PutBegin  end
 2346 1004 a 2346
1004 a
tx@Dict begin  { 5.0 tx@Dict /NCLW known { NCLW add } if 13.79997 7.392
0.084 NAngle 90 add  Uput exch pop add a  tx@Dict begin PtoC end h1
add exch w1 add exch } PutCoor PutBegin  end
 2346 1004 a 1 0 0 TeXcolorrgb 2289 1034 a Fa(\305)p
Fd(4)p 0 TeXcolorgray 2346 1004 a
tx@Dict begin  PutEnd  end
 2346 1004 a 2346 1004
a
tx@Dict begin PutEnd  end
 2346 1004 a 1818 1173 a Fb(x)23 b Fa(\306)17 b Fd(16)12
b Fa(\245)g Fd(4)2346 1173 y
tx@Dict begin  { 0.0 3.95998 } PutCoor PutBegin  end
 2346 1173 a 2346 1200 a
tx@Dict begin  tx@NodeDict begin {7.812 1.398 0.0 0.0 3.69597 } false
/N@ru@D 16 {InitRnode } /NodeScale {} def NewNode end  end

2346 1200 a 2346 1173 a
tx@Dict begin  PutEnd  end
 2346 1173 a 2346 1173 a
tx@Dict begin  { 0.0 1.84802 } PutCoor PutBegin  end
 2346
1173 a 2346 1200 a
tx@Dict begin  tx@NodeDict begin {7.812 1.398 0.0 0.0 3.69597 } false
/N@rd@D 16 {InitRnode } /NodeScale {} def NewNode end  end
 2346 1200 a 2346 1173 a
tx@Dict begin  PutEnd  end
 2346 1173
a 2346 1173 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 1 0 0  setrgbcolor  /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@rd@C /N@ru@D InitNC
{  tx@Dict begin /Lineto /lineto load def 0  setlinejoin false pop
end /AngleA 0. def /AngleB 0. def /ArmA 26.39992 def /ArmB 26.39992
def /ArmTypeA 0 def /ArmTypeB 0 def /AngleB 0. def NCBar  } if end
 gsave 0.8 SLW 1 0 0  setrgbcolor  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore  grestore end
 2346 1173 a 2346 1173 a
tx@Dict begin  gsave STV CP T /ps@refangle {NAngle 90 add } def /ps@rot
{ } def grestore  end
 2346 1173 a 2346
1173 a
tx@Dict begin  tx@NodeDict begin /t 1.5 def LPut end PutBegin  end
 2346 1173 a 2346 1173 a
tx@Dict begin  { 5.0 tx@Dict /NCLW known { NCLW add } if 13.79997 7.392
0.0 NAngle 90 add  Uput exch pop add a  tx@Dict begin PtoC end h1 add
exch w1 add exch } PutCoor PutBegin  end
 2346 1173 a 1 0 0 TeXcolorrgb
2289 1204 a Fa(\245)p Fd(4)p 0 TeXcolorgray 2346 1173
a
tx@Dict begin  PutEnd  end
 2346 1173 a 2346 1173 a
tx@Dict begin PutEnd  end
 2346 1173 a 1392 1399 a
tx@Dict begin  { 0.0 3.95998 } PutCoor PutBegin  end
 1392
1399 a 1392 1425 a
tx@Dict begin  tx@NodeDict begin {7.812 1.398 0.0 0.0 3.69597 } false
/N@lu@A 16 {InitRnode } /NodeScale {} def NewNode end  end
 1392 1425 a 1392 1399 a
tx@Dict begin  PutEnd  end
 1392 1399
a 1392 1399 a
tx@Dict begin  { 0.0 1.84802 } PutCoor PutBegin  end
 1392 1399 a 1392 1425 a
tx@Dict begin  tx@NodeDict begin {7.812 1.398 0.0 0.0 3.69597 } false
/N@ld@A 16 {InitRnode } /NodeScale {} def NewNode end  end
 1392 1425 a 1392
1399 a
tx@Dict begin  PutEnd  end
 1392 1399 a 278 w Fd(7)r Fb(x)19 b Fa(\241)12
b Fd(4)k Fa(\306)h Fd(5)r Fb(x)i Fa(\305)12 b Fd(12)2388
1399 y
tx@Dict begin  { 0.0 3.95998 } PutCoor PutBegin  end
 2388 1399 a 2388 1425 a
tx@Dict begin  tx@NodeDict begin {7.812 1.398 0.0 0.0 3.69597 } false
/N@ru@A 16 {InitRnode } /NodeScale {} def NewNode end  end
 2388 1425 a 2388 1399
a
tx@Dict begin  PutEnd  end
 2388 1399 a 2388 1399 a
tx@Dict begin  { 0.0 1.84802 } PutCoor PutBegin  end
 2388 1399 a 2388 1425 a
tx@Dict begin  tx@NodeDict begin {7.812 1.398 0.0 0.0 3.69597 } false
/N@rd@A 16 {InitRnode } /NodeScale {} def NewNode end  end
 2388
1425 a 2388 1399 a
tx@Dict begin  PutEnd  end
 2388 1399 a 1392 1568 a
tx@Dict begin  { 0.0 3.95998 } PutCoor PutBegin  end
 1392 1568
a 1392 1595 a
tx@Dict begin  tx@NodeDict begin {7.812 1.398 0.0 0.0 3.69597 } false
/N@lu@B 16 {InitRnode } /NodeScale {} def NewNode end  end
 1392 1595 a 1392 1568 a
tx@Dict begin  PutEnd  end
 1392 1568 a 1392
1568 a
tx@Dict begin  { 0.0 1.84802 } PutCoor PutBegin  end
 1392 1568 a 1392 1595 a
tx@Dict begin  tx@NodeDict begin {7.812 1.398 0.0 0.0 3.69597 } false
/N@ld@B 16 {InitRnode } /NodeScale {} def NewNode end  end
 1392 1595 a 1392 1568
a
tx@Dict begin  PutEnd  end
 1392 1568 a 83 w Fd(7)r Fb(x)19 b Fa(\241)12 b Fd(4)g
Fa(\241)g Fd(5)r Fb(x)23 b Fa(\306)17 b Fd(12)2388 1568
y
tx@Dict begin  { 0.0 3.95998 } PutCoor PutBegin  end
 2388 1568 a 2388 1595 a
tx@Dict begin  tx@NodeDict begin {7.812 1.398 0.0 0.0 3.69597 } false
/N@ru@B 16 {InitRnode } /NodeScale {} def NewNode end  end
 2388 1595 a 2388 1568 a
tx@Dict begin  PutEnd  end
 2388
1568 a 2388 1568 a
tx@Dict begin  { 0.0 1.84802 } PutCoor PutBegin  end
 2388 1568 a 2388 1595 a
tx@Dict begin  tx@NodeDict begin {7.812 1.398 0.0 0.0 3.69597 } false
/N@rd@B 16 {InitRnode } /NodeScale {} def NewNode end  end
 2388 1595
a 2388 1568 a
tx@Dict begin  PutEnd  end
 2388 1568 a 2388 1568 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 1 0 0  setrgbcolor  /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@rd@A /N@ru@B InitNC
{  tx@Dict begin /Lineto /lineto load def 0  setlinejoin false pop
end /AngleA 0. def /AngleB 0. def /ArmA 26.39992 def /ArmB 26.39992
def /ArmTypeA 0 def /ArmTypeB 0 def /AngleB 0. def NCBar  } if end
 gsave 0.8 SLW 1 0 0  setrgbcolor  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore  grestore end
 2388 1568 a 2388
1568 a
tx@Dict begin  gsave STV CP T /ps@refangle {NAngle 90 add } def /ps@rot
{ } def grestore  end
 2388 1568 a 2388 1568 a
tx@Dict begin  tx@NodeDict begin /t 1.5 def LPut end PutBegin  end
 2388 1568 a 2388 1568
a
tx@Dict begin  { 5.0 tx@Dict /NCLW known { NCLW add } if 20.50797 7.392
0.16199 NAngle 90 add  Uput exch pop add a  tx@Dict begin PtoC end
h1 add exch w1 add exch } PutCoor PutBegin  end
 2388 1568 a 1 0 0 TeXcolorrgb 2303 1598 a Fa(\241)p
Fd(5)r Fb(x)p 0 TeXcolorgray 2388 1568 a
tx@Dict begin  PutEnd  end
 2388 1568 a
2388 1568 a
tx@Dict begin PutEnd  end
 2388 1568 a 2388 1568 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 1 0 0  setrgbcolor  /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@ld@A /N@lu@B InitNC
{  tx@Dict begin /Lineto /lineto load def 0  setlinejoin false pop
end /AngleA 180. def /AngleB 180. def /ArmA 26.39992 def /ArmB 26.39992
def /ArmTypeA 0 def /ArmTypeB 0 def /AngleB 180. def NCBar  } if end
 gsave 0.8 SLW 1 0 0  setrgbcolor  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore  grestore end
 2388 1568 a 2388
1568 a
tx@Dict begin  gsave STV CP T /ps@refangle {NAngle 90 sub } def /ps@rot
{ } def grestore  end
 2388 1568 a 2388 1568 a
tx@Dict begin  tx@NodeDict begin /t 1.5 def LPut end PutBegin  end
 2388 1568 a 2388 1568
a
tx@Dict begin  { 5.0 tx@Dict /NCLW known { NCLW add } if 20.50797 7.392
0.16199 NAngle 90 sub  Uput exch pop add a  tx@Dict begin PtoC end
h1 add exch w1 add exch } PutCoor PutBegin  end
 2388 1568 a 1 0 0 TeXcolorrgb 2303 1598 a Fa(\241)p
Fd(5)r Fb(x)p 0 TeXcolorgray 2388 1568 a
tx@Dict begin  PutEnd  end
 2388 1568 a
2388 1568 a
tx@Dict begin PutEnd  end
 2388 1568 a 1392 1737 a
tx@Dict begin  { 0.0 3.95998 } PutCoor PutBegin  end
 1392 1737 a 1392
1764 a
tx@Dict begin  tx@NodeDict begin {7.812 1.398 0.0 0.0 3.69597 } false
/N@lu@C 16 {InitRnode } /NodeScale {} def NewNode end  end
 1392 1764 a 1392 1737 a
tx@Dict begin  PutEnd  end
 1392 1737 a 1392 1737
a
tx@Dict begin  { 0.0 1.84802 } PutCoor PutBegin  end
 1392 1737 a 1392 1764 a
tx@Dict begin  tx@NodeDict begin {7.812 1.398 0.0 0.0 3.69597 } false
/N@ld@C 16 {InitRnode } /NodeScale {} def NewNode end  end
 1392 1764 a 1392 1737 a
tx@Dict begin  PutEnd  end
 1392
1737 a 416 w Fd(2)r Fb(x)24 b Fa(\306)17 b Fd(12)12 b
Fa(\305)g Fd(4)2388 1737 y
tx@Dict begin  { 0.0 3.95998 } PutCoor PutBegin  end
 2388 1737 a 2388 1764 a
tx@Dict begin  tx@NodeDict begin {7.812 1.398 0.0 0.0 3.69597 } false
/N@ru@C 16 {InitRnode } /NodeScale {} def NewNode end  end
 2388
1764 a 2388 1737 a
tx@Dict begin  PutEnd  end
 2388 1737 a 2388 1737 a
tx@Dict begin  { 0.0 1.84802 } PutCoor PutBegin  end
 2388 1737
a 2388 1764 a
tx@Dict begin  tx@NodeDict begin {7.812 1.398 0.0 0.0 3.69597 } false
/N@rd@C 16 {InitRnode } /NodeScale {} def NewNode end  end
 2388 1764 a 2388 1737 a
tx@Dict begin  PutEnd  end
 2388 1737 a 2388
1737 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 1 0 0  setrgbcolor  /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@rd@B /N@ru@C InitNC
{  tx@Dict begin /Lineto /lineto load def 0  setlinejoin false pop
end /AngleA 0. def /AngleB 0. def /ArmA 26.39992 def /ArmB 26.39992
def /ArmTypeA 0 def /ArmTypeB 0 def /AngleB 0. def NCBar  } if end
 gsave 0.8 SLW 1 0 0  setrgbcolor  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore  grestore end
 2388 1737 a 2388 1737 a
tx@Dict begin  gsave STV CP T /ps@refangle {NAngle 90 add } def /ps@rot
{ } def grestore  end
 2388 1737 a 2388 1737
a
tx@Dict begin  tx@NodeDict begin /t 1.5 def LPut end PutBegin  end
 2388 1737 a 2388 1737 a
tx@Dict begin  { 5.0 tx@Dict /NCLW known { NCLW add } if 13.79997 7.392
0.084 NAngle 90 add  Uput exch pop add a  tx@Dict begin PtoC end h1
add exch w1 add exch } PutCoor PutBegin  end
 2388 1737 a 1 0 0 TeXcolorrgb
2331 1768 a Fa(\305)p Fd(4)p 0 TeXcolorgray 2388 1737
a
tx@Dict begin  PutEnd  end
 2388 1737 a 2388 1737 a
tx@Dict begin PutEnd  end
 2388 1737 a 2388 1737 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 1 0 0  setrgbcolor  /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@ld@B /N@lu@C InitNC
{  tx@Dict begin /Lineto /lineto load def 0  setlinejoin false pop
end /AngleA 180. def /AngleB 180. def /ArmA 26.39992 def /ArmB 26.39992
def /ArmTypeA 0 def /ArmTypeB 0 def /AngleB 180. def NCBar  } if end
 gsave 0.8 SLW 1 0 0  setrgbcolor  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore  grestore end
 2388
1737 a 2388 1737 a
tx@Dict begin  gsave STV CP T /ps@refangle {NAngle 90 sub } def /ps@rot
{ } def grestore  end
 2388 1737 a 2388 1737 a
tx@Dict begin  tx@NodeDict begin /t 1.5 def LPut end PutBegin  end
 2388 1737
a 2388 1737 a
tx@Dict begin  { 5.0 tx@Dict /NCLW known { NCLW add } if 13.79997 7.392
0.084 NAngle 90 sub  Uput exch pop add a  tx@Dict begin PtoC end h1
add exch w1 add exch } PutCoor PutBegin  end
 2388 1737 a 1 0 0 TeXcolorrgb 2331 1768
a Fa(\305)p Fd(4)p 0 TeXcolorgray 2388 1737 a
tx@Dict begin  PutEnd  end
 2388 1737
a 2388 1737 a
tx@Dict begin PutEnd  end
 2388 1737 a 1392 1907 a
tx@Dict begin  { 0.0 3.95998 } PutCoor PutBegin  end
 1392 1907 a 1392
1933 a
tx@Dict begin  tx@NodeDict begin {7.812 1.398 0.0 0.0 3.69597 } false
/N@lu@D 16 {InitRnode } /NodeScale {} def NewNode end  end
 1392 1933 a 1392 1907 a
tx@Dict begin  PutEnd  end
 1392 1907 a 1392 1907
a
tx@Dict begin  { 0.0 1.84802 } PutCoor PutBegin  end
 1392 1907 a 1392 1933 a
tx@Dict begin  tx@NodeDict begin {7.812 1.398 0.0 0.0 3.69597 } false
/N@ld@D 16 {InitRnode } /NodeScale {} def NewNode end  end
 1392 1933 a 1392 1907 a
tx@Dict begin  PutEnd  end
 1392
1907 a 467 w Fb(x)24 b Fa(\306)17 b Fd(16)12 b Fa(\245)g
Fd(4)2388 1907 y
tx@Dict begin  { 0.0 3.95998 } PutCoor PutBegin  end
 2388 1907 a 2388 1933 a
tx@Dict begin  tx@NodeDict begin {7.812 1.398 0.0 0.0 3.69597 } false
/N@ru@D 16 {InitRnode } /NodeScale {} def NewNode end  end
 2388 1933 a
2388 1907 a
tx@Dict begin  PutEnd  end
 2388 1907 a 2388 1907 a
tx@Dict begin  { 0.0 1.84802 } PutCoor PutBegin  end
 2388 1907 a 2388
1933 a
tx@Dict begin  tx@NodeDict begin {7.812 1.398 0.0 0.0 3.69597 } false
/N@rd@D 16 {InitRnode } /NodeScale {} def NewNode end  end
 2388 1933 a 2388 1907 a
tx@Dict begin  PutEnd  end
 2388 1907 a 2388 1907
a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 1 0 0  setrgbcolor  /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@rd@C /N@ru@D InitNC
{  tx@Dict begin /Lineto /lineto load def 0  setlinejoin false pop
end /AngleA 0. def /AngleB 0. def /ArmA 26.39992 def /ArmB 26.39992
def /ArmTypeA 0 def /ArmTypeB 0 def /AngleB 0. def NCBar  } if end
 gsave 0.8 SLW 1 0 0  setrgbcolor  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore  grestore end
 2388 1907 a 2388 1907 a
tx@Dict begin  gsave STV CP T /ps@refangle {NAngle 90 add } def /ps@rot
{ } def grestore  end
 2388 1907 a 2388 1907 a
tx@Dict begin  tx@NodeDict begin /t 1.5 def LPut end PutBegin  end
 2388
1907 a 2388 1907 a
tx@Dict begin  { 5.0 tx@Dict /NCLW known { NCLW add } if 13.79997 7.392
0.0 NAngle 90 add  Uput exch pop add a  tx@Dict begin PtoC end h1 add
exch w1 add exch } PutCoor PutBegin  end
 2388 1907 a 1 0 0 TeXcolorrgb 2331
1938 a Fa(\245)p Fd(4)p 0 TeXcolorgray 2388 1907 a
tx@Dict begin  PutEnd  end
 2388
1907 a 2388 1907 a
tx@Dict begin PutEnd  end
 2388 1907 a 2388 1907 a
tx@Dict begin gsave STV newpath /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  0.8
SLW 1 0 0  setrgbcolor  /ArrowA { moveto } def /ArrowB { BeginArrow
1.  1.  scale  false 0.4 1.4 1.5 2. CLW mul add dup 2 div /w ED mul
dup /h ED mul /a ED { 0 h T 1 -1 scale } if gsave w neg h moveto 0
0 L w h L w neg a neg rlineto gsave  1. .setopacityalpha  fill grestore
grestore 0 h a sub moveto   EndArrow  } def /ArrowInside { } def  /NCLW
CLW def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@ld@C /N@lu@D InitNC
{  tx@Dict begin /Lineto /lineto load def 0  setlinejoin false pop
end /AngleA 180. def /AngleB 180. def /ArmA 26.39992 def /ArmB 26.39992
def /ArmTypeA 0 def /ArmTypeB 0 def /AngleB 180. def NCBar  } if end
 gsave 0.8 SLW 1 0 0  setrgbcolor  1. .setopacityalpha   0  setlinejoin
0  setlinecap stroke  grestore  grestore end
 2388 1907
a 2388 1907 a
tx@Dict begin  gsave STV CP T /ps@refangle {NAngle 90 sub } def /ps@rot
{ } def grestore  end
 2388 1907 a 2388 1907 a
tx@Dict begin  tx@NodeDict begin /t 1.5 def LPut end PutBegin  end
 2388 1907 a 2388
1907 a
tx@Dict begin  { 5.0 tx@Dict /NCLW known { NCLW add } if 13.79997 7.392
0.0 NAngle 90 sub  Uput exch pop add a  tx@Dict begin PtoC end h1 add
exch w1 add exch } PutCoor PutBegin  end
 2388 1907 a 1 0 0 TeXcolorrgb 2331 1938 a Fa(\245)p
Fd(4)p 0 TeXcolorgray 2388 1907 a
tx@Dict begin  PutEnd  end
 2388 1907 a 2388 1907
a
tx@Dict begin PutEnd  end
 2388 1907 a 0 TeXcolorgray -118 5892 4016 2 v -118
6013 a Fd(.)g(.)g(.)1832 b(1/)p 0 TeXcolorgray 1921 6013
a
SDict begin H.S end
 1921 6013 a 0 TeXcolorgray Fd(1)p 0 TeXcolorgray 1970
5951 a
SDict begin H.R end
 1970 5951 a 1970 6013 a
SDict begin [/Color [1 0 0]/H /I/Border [0 0 0]BorderArrayPatch/Subtype
/Link/Dest (page.1) cvn H.B /ANN pdfmark end
 1970 6013 a 0 TeXcolorgray
1216 w Fd(Ann\351e)21 b(2017-2018)p 0 TeXcolorgray eop
end
%%Trailer

userdict /end-hook known{end-hook}if
%%EOF
