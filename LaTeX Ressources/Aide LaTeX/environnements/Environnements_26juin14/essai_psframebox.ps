%!PS-Adobe-2.0
%%Creator: dvips(k) 5.993 Copyright 2013 Radical Eye Software
%%Title: essai_psframebox.dvi
%%CreationDate: Thu Jul 10 21:15:17 2014
%%Pages: 2
%%PageOrder: Ascend
%%BoundingBox: 0 0 596 842
%%DocumentFonts: Utopia-Bold Utopia-Italic Utopia-Regular dsrom10
%%+ Fourier-Math-Letters Fourier-Math-Symbols rsfs10
%%DocumentPaperSizes: a4
%%EndComments
%DVIPSWebPage: (www.radicaleye.com)
%DVIPSCommandLine: dvips -Pdownload35 -o essai_psframebox.ps
%+ essai_psframebox.dvi
%DVIPSParameters: dpi=600
%DVIPSSource:  TeX output 2014.07.10:2115
%%BeginProcSet: tex.pro 0 0
%!
/TeXDict 300 dict def TeXDict begin/N{def}def/B{bind def}N/S{exch}N/X{S
N}B/A{dup}B/TR{translate}N/isls false N/vsize 11 72 mul N/hsize 8.5 72
mul N/landplus90{false}def/@rigin{isls{[0 landplus90{1 -1}{-1 1}ifelse 0
0 0]concat}if 72 Resolution div 72 VResolution div neg scale isls{
landplus90{VResolution 72 div vsize mul 0 exch}{Resolution -72 div hsize
mul 0}ifelse TR}if Resolution VResolution vsize -72 div 1 add mul TR[
matrix currentmatrix{A A round sub abs 0.00001 lt{round}if}forall round
exch round exch]setmatrix}N/@landscape{/isls true N}B/@manualfeed{
statusdict/manualfeed true put}B/@copies{/#copies X}B/FMat[1 0 0 -1 0 0]
N/FBB[0 0 0 0]N/nn 0 N/IEn 0 N/ctr 0 N/df-tail{/nn 8 dict N nn begin
/FontType 3 N/FontMatrix fntrx N/FontBBox FBB N string/base X array
/BitMaps X/BuildChar{CharBuilder}N/Encoding IEn N end A{/foo setfont}2
array copy cvx N load 0 nn put/ctr 0 N[}B/sf 0 N/df{/sf 1 N/fntrx FMat N
df-tail}B/dfs{div/sf X/fntrx[sf 0 0 sf neg 0 0]N df-tail}B/E{pop nn A
definefont setfont}B/Cw{Cd A length 5 sub get}B/Ch{Cd A length 4 sub get
}B/Cx{128 Cd A length 3 sub get sub}B/Cy{Cd A length 2 sub get 127 sub}
B/Cdx{Cd A length 1 sub get}B/Ci{Cd A type/stringtype ne{ctr get/ctr ctr
1 add N}if}B/CharBuilder{save 3 1 roll S A/base get 2 index get S
/BitMaps get S get/Cd X pop/ctr 0 N Cdx 0 Cx Cy Ch sub Cx Cw add Cy
setcachedevice Cw Ch true[1 0 0 -1 -.1 Cx sub Cy .1 sub]{Ci}imagemask
restore}B/D{/cc X A type/stringtype ne{]}if nn/base get cc ctr put nn
/BitMaps get S ctr S sf 1 ne{A A length 1 sub A 2 index S get sf div put
}if put/ctr ctr 1 add N}B/I{cc 1 add D}B/bop{userdict/bop-hook known{
bop-hook}if/SI save N @rigin 0 0 moveto/V matrix currentmatrix A 1 get A
mul exch 0 get A mul add .99 lt{/QV}{/RV}ifelse load def pop pop}N/eop{
SI restore userdict/eop-hook known{eop-hook}if showpage}N/@start{
userdict/start-hook known{start-hook}if pop/VResolution X/Resolution X
1000 div/DVImag X/IEn 256 array N 2 string 0 1 255{IEn S A 360 add 36 4
index cvrs cvn put}for pop 65781.76 div/vsize X 65781.76 div/hsize X}N
/dir 0 def/dyy{/dir 0 def}B/dyt{/dir 1 def}B/dty{/dir 2 def}B/dtt{/dir 3
def}B/p{dir 2 eq{-90 rotate show 90 rotate}{dir 3 eq{-90 rotate show 90
rotate}{show}ifelse}ifelse}N/RMat[1 0 0 -1 0 0]N/BDot 260 string N/Rx 0
N/Ry 0 N/V{}B/RV/v{/Ry X/Rx X V}B statusdict begin/product where{pop
false[(Display)(NeXT)(LaserWriter 16/600)]{A length product length le{A
length product exch 0 exch getinterval eq{pop true exit}if}{pop}ifelse}
forall}{false}ifelse end{{gsave TR -.1 .1 TR 1 1 scale Rx Ry false RMat{
BDot}imagemask grestore}}{{gsave TR -.1 .1 TR Rx Ry scale 1 1 false RMat
{BDot}imagemask grestore}}ifelse B/QV{gsave newpath transform round exch
round exch itransform moveto Rx 0 rlineto 0 Ry neg rlineto Rx neg 0
rlineto fill grestore}B/a{moveto}B/delta 0 N/tail{A/delta X 0 rmoveto}B
/M{S p delta add tail}B/b{S p tail}B/c{-4 M}B/d{-3 M}B/e{-2 M}B/f{-1 M}
B/g{0 M}B/h{1 M}B/i{2 M}B/j{3 M}B/k{4 M}B/w{0 rmoveto}B/l{p -4 w}B/m{p
-3 w}B/n{p -2 w}B/o{p -1 w}B/q{p 1 w}B/r{p 2 w}B/s{p 3 w}B/t{p 4 w}B/x{
0 S rmoveto}B/y{3 2 roll p a}B/bos{/SS save N}B/eos{SS restore}B end

%%EndProcSet
%%BeginProcSet: pstricks.pro 0 0
% $Id: pstricks.pro 801 2013-07-09 18:10:41Z herbert $
%
%% PostScript prologue for pstricks.tex.
%% Version 1.17, 2013/07/08
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%
%
% Define the follwing gs-functions if not known, eg when using distiller
%
systemdict /.setopacityalpha known not {/.setopacityalpha { pop } def } if
systemdict /.setblendmode known not {/.setblendmode { pop } def } if
systemdict /.setshapealpha known not {/.setshapealpha { pop } def } if
%
/tx@Dict 200 dict def 				% the main PSTricks dictionary
tx@Dict begin
/ADict 25 dict def				% The arrow dictionary
/CM { matrix currentmatrix } bind def
/SLW /setlinewidth load def
/CLW /currentlinewidth load def
/CP /currentpoint load def
/ED { exch def } bind def
/L /lineto load def
/T /translate load def
/TMatrix { } def
/RAngle { 0 } def
/Sqrt { dup 0 lt { pop 0 } { sqrt } ifelse } def  % return 0 for negative arguments 
/Atan { /atan load stopped { pop pop 0 } if } def % return 0 if atan not known
/ATAN1 {neg -1 atan 180 sub } def		% atan(x) (only one parameter)
/Div { dup 0 eq { pop } { div } ifelse } def  	% control the division
/tan { dup cos abs 1.e-10 lt 
  { pop 1.e10 } 				% return 1.e10 as infinit
  { dup sin exch cos div } ifelse 		% default sin/cos
} def
/Tan { dup sin exch cos Div } def 		% sin(x)/cos(x) x in degrees
/Acos {dup dup mul neg 1 add dup 0 lt {		% arc cos, returns 0 when negative root
  pop pop 0 }{ sqrt exch atan} ifelse } def
/Acos2 { 2 dict begin 
  /x ED /y ED
  y abs 1.0e-20 lt { 1.0e30 } if
  x y div 
  dup dup mul neg 1 add dup 0 lt {		% arc cos needs two values x,y
  pop pop 0 }{ sqrt exch atan} ifelse 
  y 0 lt { 180 add } if
} def
/NET { neg exch neg exch T } def	      	% change coordinate system to the negative one		
/Pyth { dup mul exch dup mul add sqrt } def   	% Pythagoras, expects 2 parameter
/Pyth2 {					% Pythagoras, xA yA xB yB
  3 -1 roll 		% xA xB yB yA
  sub			% xA xB yB-yA
  3 1 roll 		% yB-yA xA xB
  sub			% yB-yA xA-xB
  Pyth } def
/PtoC { 2 copy cos mul 3 1 roll sin mul } def 	% Polar to Cartesian
/Rand { rand 4294967295 div } def		% a real random number
%----------------- hv added 20050516 ---------------
/PiDiv2 1.57079632680 def
/Pi 3.14159265359 def 
/TwoPi 6.28318530718 def
/Euler 2.71828182846 def 
%/e Euler bind def
%
/RadtoDeg { 180 mul Pi div } bind def 		% convert from radian to degrees
/DegtoRad { Pi mul 180 div } bind def 		% viceversa
%
/startGlobal { true setglobal globaldict begin } bind def
/endGlobal { end false setglobal } bind def
/pssetRGBcolor /setrgbcolor load def
/pssetCMYKcolor /setcmykcolor load def
/pssetGraycolor /setgray load def
%
%----------------- hv end---------------------------
/PathLength@ { /z z y y1 sub x x1 sub Pyth add def /y1 y def /x1 x def } def
%
/PathLength { 
  flattenpath /z 0 def 
  { /y1 ED /x1 ED /y2 y1 def /x2 x1 def }
  { /y ED /x ED PathLength@ } 
  {} 
  { /y y2 def /x x2 def PathLength@ }
  /pathforall load stopped { pop pop pop pop } if 
  z 
} def
%
/STP { .996264 dup scale } def			% BP/PT scaling
/STV { SDict begin normalscale end STP  } def	% 
%
/DashLine {
    dup 0 gt
    { /a .5 def PathLength exch div }
    { pop /a 1 def PathLength } ifelse
    /b ED % pattern should fit evenly in b
    dup /X ED % pattern array
    0 get /y ED % length of first black segment
    /z 0 X {add} forall def % length of the full pattern
    %% Computation of the scaling factor as described by van Zandt:
    b a .5 sub 2 mul y mul sub z Div round
    z mul a .5 sub 2 mul y mul add b exch Div
    %%%% scaling factor on stack.
    /z ED %% now, z is the scaling factor
    false % for the length test below
    X { z mul } forall X astore %% modification TN 04-08-07
    %%% Checking whether at least one dash in X has positive length:
    {0 gt or} forall
    { X 1 a sub y mul }
    { [ 1 0 ] 0 }
    ifelse
    setdash stroke
} def
%
/DotLine { 
  /b PathLength def 
  /a ED /z ED /y CLW def 
  /z y z add def 
  a 0 gt { 
    /b b a div def 
  }{ 
    a 0 eq { 
      /b b y sub def 
    }{ a -3 eq { 
      /b b y add def } if 
    } ifelse 
  } ifelse 
  [ 0 b b z Div round Div dup 0 le { pop 1 } if ] 
  a 0 gt { 0 }{ y 2 div a -2 gt { neg }if } ifelse 
  setdash 1 setlinecap stroke 
} def
%
/SymbolLine {   % on stack [ x y x y ...
  counttomark 					% number of elements
  2 div cvi /n ED     				% n pairs
  /YA ED /XA ED					% the start point
  n 1 sub { 
    /YB ED /XB ED
    /XLength XB XA sub def
    /YLength YB YA sub def
    /PAngle YLength XLength Atan def
    /XYLength XLength YLength Pyth def

    %% for negative SymStep we calculate the distance 
    SymStep 0 lt 
      { %XYLength SymStep div abs cvi 
        /nSym SymStep abs cvi def } 
      { /nSym XYLength SymStep div cvi def }
    ifelse
    0.5 setflat
    /Shift Symbol stringwidth pop 2 div def 
    /deltaX XLength nSym div def
    /deltaY YLength nSym div def
    curveticks 
      { XA YA moveto }
      { XA Shift sub YA Shift sub moveto }
    ifelse 
    nSym { 
      gsave 
      curveticks 
        { PAngle 180 sub CorrAngle sub tickAngle add /rotAngle ED  
          currentpoint translate rotAngle rotate 
          0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
          SymbolLinewidth setlinewidth stroke
        }
        { 
          rotateSymbol { PAngle 180 sub CorrAngle sub rotate } if
          Symbol show 
        }
      ifelse 
      grestore 
      deltaX deltaY rmoveto
    } repeat
    /YA YB def /XA XB def
  } repeat 
  curveticks 
    { XA YA moveto }
    { XA Shift sub YA Shift sub moveto }
  ifelse 
  gsave 
  curveticks 
    { PAngle 180 sub CorrAngle sub tickAngle add /rotAngle ED  
      XA YA translate rotAngle rotate 
      0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
      SymbolLinewidth setlinewidth stroke
    }
    { 
      rotateSymbol { PAngle 180 sub CorrAngle sub rotate } if
      Symbol show 
    }
  ifelse 
  grestore
  pop 				% delete the mark symbol
} def
%
/LineFill { % hv ------------ patch 7 -------------
  gsave 
  abs /hatchWidthInc ED
  abs /hatchSepInc ED
  abs CLW add /a ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform pathbbox 
  /y2 ED 
  a Div ceiling cvi /x2 ED /y1 ED 
  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clipType   % must be defined in pstricks.tex: clip -- eoclip 
  newpath 
  2 setlinecap 
  systemdict
  /setstrokeadjust known { true setstrokeadjust } if 
  x2 x1 sub 1 add { 
    x1 a mul y1 moveto 0 y2 rlineto stroke 
    /x1 x1 1 add 
      hatchWidthInc 0 gt { CLW add } if 
    def 
    hatchSepInc 0 gt hatchWidthInc 0 gt or { 
      /a a hatchSepInc add def
      CLW hatchWidthInc add SLW 
    } if
  } repeat 
  grestore 
  pop pop } def
%
/DotFill {%	 on stack: dot radius
  /dotRadius ED
  abs CLW add /a ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform 
  pathbbox % llx lly urx ury of smallest bounding box
  /y2 ED /x2 ED /y1 ED /x1 ED 
  y2 y1 sub a div 2 add cvi /Ny ED
  x2 x1 sub a div 2 add cvi /Nx ED
  clipType   % must be defined in pstricks.tex: clip -- eoclip 
  newpath 
  /yA y1 dotRadius add CLW add def
  /xA0 x1 dotRadius add CLW add def
  Ny {
     /xA xA0 def
     Nx { 
       newpath 
       xA yA dotRadius 0 360 arc 
       SolidDot { gsave fill grestore } if 
       stroke
       xA a add /xA ED
     } repeat
     yA a add /yA ED
  } repeat
  grestore
} def
%
/PenroseFill {%	 on stack: scaling factor
  /Scale ED
%  1 exch div round /penroseFactor ED 
%  a 0 dtransform round exch round exch
%  2 copy idtransform 
%  exch Atan rotate 
%  idtransform pop /a ED 
%  .25 .25 itransform pathbbox 
%  /y2 ED 
%  a Div ceiling cvi /x2 ED /y1 ED 
%  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clip 
  newpath 
gsave
  220 150 translate
  Scale dup scale
  systemdict /setstrokeadjust known { true setstrokeadjust } if 
  /I/S/L/W/G/+/Z/F/E/D[/def/exch/for{E D}/add{s E get mul}
 { Z -36.2001 1 33 }{25 E S rlineto}{/q Z dup q G E q 1 + G}{Z 2 2}]{cvx def}forall
  [0 72 1008 {dup sin E cos }F ]1 setlinejoin/s W{/a W{/b I 10{/i I 4{/m I moveto
  i m +/j I 10{/l Z b m l + G a l G sub s m get div .2 + floor .3 + 25
  mul j l + S rmoveto}F i L j L stroke }F}F}F}F 
  grestore 
%  pop pop 
} def
%
/PenroseFillA {%  on stack: scaling factor, border color, kite color, dart color
  /Scale ED
  Scale dup scale
  /border_colour ED 
  /kite_colour ED 
  /dart_colour ED
  clip 

  newpath 
  gsave
  100 100 translate
  6 
  Scale 1 lt { 1 Scale dup add div mul cvi } if %%%%   Number of iterations
  10					%%%%   Long side length in millimeters
  /border_width { L 0.06 mul }def		%%%%   Choose the scalefactor for the borders
  /L exch 25.4 div 72 mul def		%%%%   Conversion: mm -> inches -> points
  /f{-1 5 sqrt add 2 div}bind def		%%%%   The reciprocal of the golden ratio
  /l{L f mul}bind def			%%%%   Short side length l = L*f
  /Ll{L l add}bind def			%%%%   Ll =  L + l
  /c{36 cos L mul}bind def		%%%%   c  =  L*cos(36)
  /s{36 sin L mul}bind def		%%%%   s  =  L*sin(36)
  /draw_tile { 0 0 moveto c s lineto 0 lineto gsave closepath gsave fill grestore
	     0 setlinewidth stroke grestore border_colour stroke } bind def
  /half_kite { dup dup 0 gt{ 1 sub gsave f f neg scale -36 rotate half_dart
			   Ll 0 translate 144 rotate kite grestore }
	      		 { kite_colour L draw_tile }ifelse
	     pop } bind def
  /half_dart { dup dup 0 gt{ 1 sub gsave f f scale half_kite
			   -144 rotate Ll neg 0 translate half_dart grestore }
	      		 { dart_colour l draw_tile }ifelse
  	     pop } bind def
  /kite{ gsave half_kite 1 -1 scale half_kite grestore }bind def
  border_width setlinewidth  1 setlinejoin  1 setlinecap
%  450 0 translate  
  dup f exch neg exp dup scale
  5 {kite 72 rotate } repeat stroke 
  grestore
} def
%
%
/TruchetFill { %	 on stack: scaling factor
  10 dict begin
  dup dup scale
  1 exch div round /penroseFactor ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform pathbbox 
  /y2 ED 
  a Div ceiling cvi /x2 ED /y1 ED 
  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clip 
  newpath 
  systemdict
  /setstrokeadjust known { true setstrokeadjust } if 
  /ma a neg def
  /ha a 2 div def 
  /mha ha neg def
  /tile { 
    rand dup 2 idiv 2 mul eq { 90 rotate } if
    mha mha moveto ha mha lineto
    ha ha lineto mha ha lineto
%    closepath .1 setlinewidth stroke
    contents
  } def
  /contents{ 
    0 ha moveto ha 0 lineto
    0 mha moveto mha 0 lineto
%    1 setlinewidth stroke
  } def
  /dotiling {
    f ma mul a f a mul { 
      /i exch def
      f ma mul a f a mul { 
        /j exch def
        gsave i j translate
        tile stroke grestore
      } for
    } for
  } def
%
  /f 3 def 
  5 srand dotiling 
  end % local user dict
} def
%
/BeginArrow { 
  ADict begin 			% hold it local, for end see EndArrow
  /@mtrx CM def 
  gsave 
  2 copy T 
  2 index sub neg exch 
  3 index sub exch Atan 
  rotate newpath 
} def
%
/EndArrow { @mtrx setmatrix CP grestore end } def % end the ADict
%
/Arrow { 
  CLW mul add dup 
  2 div /w ED 
  mul dup /h ED 
  mul /a ED 
  { 0 h T 1 -1 scale } if 
  w neg h moveto 
  0 0 L w h L w neg a neg rlineto 
  gsave fill grestore 
} def
%
/ArrowD { % the sides are drawn as curves (hv 20071211)
  CLW mul add dup 
  2 div /w ED 
  mul dup /h ED 
  mul /Inset ED 
  { 0 h T 1 -1 scale } if % changes the direction
% we use y=w/h^2 * x^2 as equation for the control points
% for the coordinates the arrow is seen from top to bottom
% the bottom (tip) is (0;0)
  w neg h moveto % lower left of >
  w 9 div 4 mul neg h 3 div 2 mul
  w 9 div neg       h 3 div  
  0 0 curveto    % tip of >
  w 9 div        h 3 div  
  w 9 div 4 mul  h 3 div 2 mul
  w h curveto % upper left of >
  w neg Inset neg rlineto % move to x=0 and inset
  gsave fill grestore 
} def 
%
/Tbar { 
  CLW mul add /z ED 
  z -2 div CLW 2 div moveto 
  z 0 rlineto stroke 
  0 CLW moveto 
} def
%
/Bracket { 
  CLW mul add dup CLW sub 2 div 
  /x ED mul CLW add /y ED /z CLW 2 div def 
  x neg y moveto 
  x neg CLW 2 div L x CLW 2 div L x y L stroke 
  0 CLW moveto 
} def
%
/RoundBracket { 
  CLW mul add dup 2 div 
  /x ED mul /y ED /mtrx CM def 
  0 CLW 2 div T x y mul 0 ne { x y scale } if 
  1 1 moveto 
  .85 .5 .35 0 0 0 curveto 
  -.35 0 -.85 .5 -1 1 curveto 
  mtrx setmatrix stroke 0 CLW moveto 
} def
%
/SD { 0 360 arc fill } def
%
/EndDot { % DS is the dot size 
  { /z DS def } { /z 0 def } ifelse  	% outer or inner dimen 
  /b ED 				% the color definition
  0 z DS SD 
  b { 0 z DS CLW sub SD } if 
  0 DS z add CLW 4 div sub 
  moveto 
} def
%
/Shadow { [ { /moveto load } { /lineto load } { /curveto load } {
  /closepath load } /pathforall load stopped { pop pop pop pop CP /moveto
  load } if ] cvx newpath 3 1 roll T exec } def
%
/NArray { % holds the coordinates and on top of stack the showpoints boolean
  /showpoints ED 
  counttomark 2 div dup cvi /n ED  	% n 2 div on stack 
  n eq not { exch pop } if		% even numbers of points? delete one
  ] aload /Points ED 
  showpoints not { Points aload pop } if
%    { ] aload /Points ED } 
%    { n 2 mul 1 add -1 roll pop } ifelse	% delete the mark symbol 
} def
%
/Line { 
  NArray n 0 eq not 
    { n 1 eq { 0 0 /n 2 def } if ArrowA /n n 2 sub def 
      n { Lineto } repeat 
      CP 4 2 roll ArrowB L pop pop 
    } if 
} def
%
/LineToYAxis {
  /Ox ED		% Save the x origin value 
  NArray            % all x-y pairs on stack
  n { 2 copy moveto % go to current point
    Ox exch Lineto   % line to y-axis
    pop             % delete old x-value
  } repeat
} def
%
/LineToXAxis{
  /Oy ED		% Save the y origin value 
  NArray		% all x-y pairs on stack
  n 0 eq not
    { n 1 eq { 0 0 /n 2 def } if
      ArrowA
      /n n 2 sub def
      CP 2 copy moveto pop Oy Lineto
      n { 2 copy moveto pop Oy Lineto } repeat
      CP
      4 2 roll
      ArrowB
      2 copy moveto pop Oy
      L
      pop pop } if
} def
%
/Arcto { 
  /a [ 6 -2 roll ] cvx def 
  a r 
  /arcto load stopped { 5 } { 4 } ifelse { pop } repeat 
  a 
} def
%
/CheckClosed { 
  dup n 2 mul 1 sub index eq 2 index n 2 mul 1 add index eq
  and { pop pop /n n 1 sub def } if 
} def
%
/Polygon { 
  NArray n 2 eq { 0 0 /n 3 def } if 
  n 3 lt 
    { n { pop pop } repeat } 
    { n 3 gt { CheckClosed } if 
      n 2 mul -2 roll 
      /y0 ED /x0 ED /y1 ED /x1 ED  
      x1 y1 
      /x1 x0 x1 add 2 div def 
      /y1 y0 y1 add 2 div def 
      x1 y1 moveto 
      /n n 2 sub def 
      n { Lineto } repeat 
      x1 y1 x0 y0 6 4 roll Lineto
      Lineto pop pop closepath } ifelse 
} def
%
/SymbolPolygon {   % on stack [ x y x y ...
  counttomark 					% number of elements
  2 add /m ED
  2 copy m 2 roll				% copy last two
  m 2 div cvi /n ED    				% n pairs
  /YA ED /XA ED					% the start point
  n 1 sub { 
    /YB ED /XB ED
    /XLength XB XA sub def
    /YLength YB YA sub def
    /PAngle YLength XLength Atan def
    /XYLength XLength YLength Pyth def
    /nSym XYLength SymStep Div cvi def
    /Shift Symbol stringwidth pop 2 Div def 
    /deltaX XLength nSym Div def
    /deltaY YLength nSym Div def
    XA Shift sub YA Shift sub moveto 
    nSym { 
      gsave rotateSymbol { PAngle 180 sub CorrAngle sub rotate } if
      Symbol show 
      grestore 
      deltaX deltaY rmoveto
    } repeat
%    XB Shift sub YB Shift sub moveto Symbol show
    /YA YB def /XA XB def
  } repeat 
  pop	% delete the mark symbol
} def
%
/Diamond { 
  /mtrx CM def 
  T rotate 
  /h ED 
  /w ED 
  dup 0 eq { pop } { CLW mul neg 
    /d ED 
    /a w h Atan def 
    /h d a sin Div h add def 
    /w d a cos Div w add def } ifelse 
  mark w 2 div h 2 div w 0 0 h neg w neg 0 0 h w 2 div h 2 div 
  /ArrowA { moveto } def 
  /ArrowB { } def 
  false Line 
  closepath mtrx setmatrix } def
%
/Triangle { 
  /mtrx CM def 
  translate 
  rotate /h ED 2 div /w ED 
  dup CLW mul /d ED 
  /h h d w h Atan sin Div sub def 
  /w w d h w Atan 2 div dup cos exch sin Div mul sub def 
  mark 
  0 d w neg d 0 h w d 0 d 
  /ArrowA { moveto } def 
  /ArrowB { } def 
  false 
  Line 
  closepath 
  mtrx
% DG/SR modification begin - Jun.  1, 1998 - Patch 3 (from Michael Vulis)
% setmatrix } def
  setmatrix pop 
} def
% DG/SR modification end
%
/CCA { 
  /y ED /x ED 
  2 copy y sub /dy1 ED 
  x sub /dx1 ED 
  /l1 dx1 dy1 Pyth def 
} def
%
/CC { 
  /l0 l1 def 
  /x1 x dx sub def 
  /y1 y dy sub def 
  /dx0 dx1 def 
  /dy0 dy1 def 
  CCA 
  /dx dx0 l1 c exp mul dx1 l0 c exp mul add def 
  /dy dy0 l1 c exp mul dy1 l0 c exp mul add def 
  /m dx0 dy0 Atan dx1 dy1 Atan sub 2 div cos abs b exp a mul dx dy Pyth Div 2 div def 
  /x2 x l0 dx mul m mul sub def
  /y2 y l0 dy mul m mul sub def 
  /dx l1 dx mul m mul neg def 
  /dy l1 dy mul m mul neg def 
} def
%
/IC { 
  /c c 1 add def 
  c 0 lt { /c 0 def } { c 3 gt { /c 3 def } if } ifelse 
  /a a 2 mul 3 div 45 cos b exp div def 
  CCA 
  /dx 0 def 
  /dy 0 def 
} def
%
/BOC { IC CC x2 y2 x1 y1 ArrowA CP 4 2 roll x y curveto } def
/NC { CC x1 y1 x2 y2 x y curveto } def
/EOC { x dx sub y dy sub 4 2 roll ArrowB 2 copy curveto } def
/BAC { IC CC x y moveto CC x1 y1 CP ArrowA } def
/NAC { x2 y2 x y curveto CC x1 y1 } def
/EAC { x2 y2 x y ArrowB curveto pop pop } def
%
/OpenCurve { 
  NArray n 3 lt 
    { n { pop pop } repeat } 
    { BOC /n n 3 sub def n { NC } repeat EOC } ifelse 
} def
%
/CurvePath { 
  %% for negative SymStep we calculate the distance 
  SymStep 0 lt { gsave PathLength SymStep div abs /SymStep ED grestore } if
  0.5 setflat
  flattenpath /z 0 def /z0 0 def
  { /y1 ED /x1 ED /y2 y1 def /x2 x1 def 
    x1 Shift sub y1 Shift sub moveto 
    gsave 
    curveticks 
      { x1 y1 translate startAngle rotate 
        0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
        SymbolLinewidth setlinewidth stroke      
      }
      { startAngle rotate Symbol show }
    ifelse 
    grestore /z0 z def }
  { /y ED /x ED PathLength@ z z0 sub SymStep ge {
      x Shift sub y Shift sub moveto 
      gsave 
      curveticks 
        { y yOld sub x xOld sub Atan 180 sub CorrAngle sub /rotAngle ED  
          x y translate rotAngle rotate 
          0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
          SymbolLinewidth setlinewidth stroke
        }
        { 
          rotateSymbol { y yOld sub x xOld sub Atan 180 sub CorrAngle sub rotate } if        
          Symbol show 
        }
      ifelse 
      grestore /z0 z def } if 
    /yOld y def /xOld x def } 
  {} %% the lineto part
  { /y y2 def /x x2 def PathLength@ 
    x Shift sub y Shift sub moveto 
    gsave
    curveticks 
      { y yOld sub x xOld sub Atan 180 sub /rotAngle ED  
        x y translate rotAngle rotate 
        0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
        SymbolLinewidth setlinewidth stroke
      }
      { 
        x Shift sub y Shift sub moveto 
        rotateSymbol { y yOld sub x xOld sub Atan 180 sub CorrAngle sub rotate } if        
        Symbol show 
      }
    ifelse 
    grestore
  }
  pathforall 
%  curveticks 
%   { gsave 
%     x y translate rotAngle rotate 
%     0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
%     SymbolLinewidth setlinewidth stroke grestore
%   } if
  z 
} def
%
/OpenSymbolCurve { 
  OpenCurve
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/AltCurve { 
  { false NArray n 2 mul 2 roll 
    [ n 2 mul 3 sub 1 roll ] aload
    /Points ED 
    n 2 mul -2 roll } 
  { false NArray } ifelse 
  n 4 lt { n { pop pop } repeat } { BAC /n n 4 sub def n { NAC } repeat EAC } ifelse 
} def
%
/AltOpenSymbolCurve { 
  AltCurve
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/ClosedCurve { 
  NArray n 3 lt 
    { n { pop pop } repeat } 
    { n 3 gt { CheckClosed } if 
      6 copy n 2 mul 6 add 6 roll 
      IC CC x y moveto n { NC } repeat 
      closepath pop pop 
    } ifelse 
} def
%
/ClosedSymbolCurve { 
  ClosedCurve
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/SQ { /r ED r r moveto r r neg L r neg r neg L r neg r L fill } def
/ST { /y ED /x ED x y moveto x neg y L 0 x L fill } def
/SP { /r ED gsave 0 r moveto 4 { 72 rotate 0 r L } repeat fill grestore } def
%
/FontDot { 
  DS 2 mul dup 
  matrix scale matrix concatmatrix exch matrix
  rotate matrix concatmatrix exch 
  findfont exch makefont setfont 
} def
%
/Rect { 
  x1 y1 y2 add 2 div moveto 
  x1 y2 lineto 
  x2 y2 lineto 
  x2 y1 lineto
  x1 y1 lineto 
  closepath 
} def
%
/OvalFrame { 
  x1 x2 eq y1 y2 eq or 
    { pop pop x1 y1 moveto x2 y2 L } 
    { y1 y2 sub abs x1 x2 sub abs 2 copy gt 
      { exch pop } { pop } ifelse 
      2 div exch { dup 3 1 roll mul exch } if 
      2 copy lt { pop } { exch pop } ifelse
      /b ED 
      x1 y1 y2 add 2 div moveto 
      x1 y2 x2 y2 b arcto 
      x2 y2 x2 y1 b arcto
      x2 y1 x1 y1 b arcto 
      x1 y1 x1 y2 b arcto 
      16 { pop } repeat 
      closepath 
    } ifelse 
} def
%
/Frame { 
  CLW mul /a ED 
  3 -1 roll 
  2 copy gt { exch } if 
  a sub /y2 ED 
  a add /y1 ED 
  2 copy gt { exch } if 
  a sub /x2 ED 
  a add /x1 ED 
  1 index 0 eq { pop pop Rect } { OvalFrame } ifelse 
} def
%
/BezierNArray { 
  /f ED 
  counttomark 2 div dup cvi /n ED 
  n eq not { exch pop } if 
  n 1 sub neg 3 mod 3 add 3 mod { 0 0 /n n 1 add def } repeat 
  f { ] aload /Points ED } { n 2 mul 1 add -1 roll pop } ifelse 
} def
%
/OpenBezier { 
  BezierNArray 
  n 1 eq 
    { pop pop } 
    { ArrowA n 4 sub 3 idiv 
      { 6 2 roll 4 2 roll curveto } repeat 
      6 2 roll 4 2 roll ArrowB curveto } ifelse 
} def
%
/OpenSymbolBezier { 
  OpenBezier
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/ClosedBezier { 
  BezierNArray 
  n 1 eq 
    { pop pop } 
    { moveto n 1 sub 3 idiv 
      { 6 2 roll 4 2 roll curveto } repeat 
      closepath } ifelse 
} def
%
/ClosedSymbolBezier { 
  /f ED				 % save showpoints value 
  2 copy /yEnd ED /xEnd ED
  counttomark -2 roll 2 copy /yStart ED /xStart ED
  counttomark 2 roll
  f
  ClosedBezier
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
  [ xEnd yEnd xStart yStart SymbolLine 
} def
%
/BezierShowPoints { 
  gsave 
  Points aload length 2 div cvi /n ED 
  moveto 
  n 1 sub { lineto } repeat 
  CLW 2 div SLW [ 4 4 ] 0 setdash stroke 
  grestore 
} def
%
/Parab { 
  /y0 ED /x0 ED /y1 ED /x1 ED 
  /dx x0 x1 sub 3 div def 
  /dy y0 y1 sub 3 div def 
  x0 dx sub y0 dy add x1 y1 ArrowA
  x0 dx add y0 dy add x0 2 mul x1 sub y1 ArrowB 
  curveto 
  /Points [ x1 y1 x0 y0 x0 2 mul x1 sub y1 ] def 
} def
%
/Parab1 { % 1 end  |  0 SP
  /ySP ED /xSP ED /y1 ED /x1 ED 
  /dx xSP x1 sub 3 div def 
  /dy ySP y1 sub 3 div def 
  newpath x1 y1 moveto xSP y1 lineto xSP ySP lineto 
                       x1 ySP lineto closepath clip 
  currentpoint
  newpath moveto
  xSP dx sub ySP dy add x1 y1 ArrowA
  xSP dx add ySP dy add xSP 2 mul x1 sub y1 ArrowB 
  curveto 
  /Points [ x1 y1 xSP ySP xSP 2 mul x1 sub y1 ] def 
} def
%
/Grid { 
  newpath 
  /a 4 string def 
  /b ED % 				psk@gridlabels in pt
  /c ED % 				{ \pst@usecolor\psgridlabelcolor }
  /n ED % 				psk@griddots
  cvi dup 1 lt { pop 1 } if 
  /s ED % 				\psk@subgriddiv
  s div dup 0 eq { pop 1 } if 
  /dy ED s div dup 0 eq { pop 1 } if %	\pst@number\psyunit abs
  /dx ED dy div round dy mul %		\pst@number\psxunit abs
  /y0 ED dx div round dx mul 
  /x0 ED dy div round cvi 
  /y2 ED dx div round cvi 
  /x2 ED dy div round cvi 
  /y1 ED dx div round cvi 
  /x1 ED 
  /h y2 y1 sub 0 gt { 1 } { -1 } ifelse def 
  /w x2 x1 sub 0 gt { 1 } { -1 } ifelse def 
  b 0 gt { 
    /z1 b 4 div CLW 2 div add def
%    /Helvetica findfont b scalefont setfont 
    /b b .95 mul CLW 2 div add def } if 
  systemdict /setstrokeadjust known 
    { true setstrokeadjust /t { } def }
    { /t { transform 0.25 sub round 0.25 add exch 0.25 sub round 0.25 add
       exch itransform } bind def } ifelse 
  gsave n 0 gt { 1 setlinecap [ 0 dy n div ] dy n div 2 div setdash } { 2 setlinecap } ifelse 
  /i x1 def 
  /f y1 dy mul n 0 gt { dy n div 2 div h mul sub } if def 
  /g y2 dy mul n 0 gt { dy n div 2 div h mul add } if def 
  x2 x1 sub w mul 1 add dup 1000 gt { pop 1000 } if 
  { i dx mul dup y0 moveto 
    b 0 gt 
      { gsave c i a cvs dup stringwidth pop 
        /z2 ED w 0 gt {z1} {z1 z2 add neg} ifelse 
	h 0 gt {b neg}{z1} ifelse 
        rmoveto show grestore } if 
    dup t f moveto 
    g t L stroke 
    /i i w add def 
  } repeat 
  grestore 
  gsave 
  n 0 gt
  % DG/SR modification begin - Nov. 7, 1997 - Patch 1
  %{ 1 setlinecap [ 0 dx n div ] dy n div 2 div setdash }
    { 1 setlinecap [ 0 dx n div ] dx n div 2 div setdash }
  % DG/SR modification end
    { 2 setlinecap } ifelse 
  /i y1 def 
  /f x1 dx mul n 0 gt { dx n div 2 div w mul sub } if def 
  /g x2 dx mul n 0 gt { dx n div 2 div w mul add } if def 
  y2 y1 sub h mul 1 add dup 1000 gt { pop 1000 } if 
  { newpath i dy mul dup x0 exch moveto 
    b 0 gt { gsave c i a cvs dup stringwidth pop 
      /z2 ED 
      w 0 gt {z1 z2 add neg} {z1} ifelse 
      h 0 gt {z1} {b neg} ifelse 
      rmoveto show grestore } if 
    dup f exch t moveto 
    g exch t L stroke 
    /i i h add def 
  } repeat 
  grestore 
} def
%
/ArcArrow { 
  /d ED /b ED /a ED 
  gsave 
  newpath 0 -1000 moveto clip 
  newpath 
  0 1 0 0 b 
  grestore 
  c mul 
  /e ED 
  pop pop pop r a e d PtoC y add exch x add
  exch r a PtoC y add exch x add exch b pop pop pop pop a e d CLW 8 div c
  mul neg d 
} def
%
/Ellipse { 
  /rotAngle ED
  /mtrx CM def 
  T 
  rotAngle rotate
  scale 0 0 1 5 3 roll arc 
  mtrx setmatrix 
} def
%
/ArcAdjust { %%%% Vincent Guirardel
% given a target length (targetLength) and an initial angle (angle0) [in the stack],
% let  M(angle0)=(rx*cos(angle0),ry*sin(angle0))=(x0,y0).
% This computes an angle t such that (x0,y0) is at distance 
% targetLength from the point M(t)=(rx*cos(t),ry*sin(t)).
% NOTE: this an absolute angle, it does not have to be added or substracted to angle0
% contrary to TvZ's code.
% To achieve, this, one iterates the following process: start with some angle t,
% compute the point M' at distance targetLength of (x0,y0) on the semi-line [(x0,y0) M(t)].
% Now take t' (= new angle) so that (0,0) M(t') and M' are aligned.
%
% Another difference with TvZ's code is that we need d (=add/sub) to be defined.
% the value of d = add/sub is used to know on which side we have to move.
% It is only used in the initialisation of the angle before the iteration.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Input stack:  1: target length 2: initial angle
% variables used : rx, ry, d (=add/sub)
%
  /targetLength ED /angle0 ED
  /x0 rx angle0 cos mul def
  /y0 ry angle0 sin mul def
% we are looking for an angle t such that (x0,y0) is at distance targetLength 
% from the point M(t)=(rx*cos(t),ry*sin(t)))
%initialisation of angle (using 1st order approx = TvZ's code)
  targetLength 57.2958 mul
  angle0 sin rx mul dup mul
  angle0 cos ry mul dup mul
  add sqrt div 
% if initialisation angle is two large (more than 90 degrees) set it to 90 degrees
% (if the ellipse is very curved at the point where we draw the arrow, %
% the value can be much more than 360 degrees !)
% this should avoid going on the wrong side (more than 180 degrees) or go near
% a bad attractive point (at 180 degrees)
  dup 90 ge { pop 90 } if 
  angle0 exch d % add or sub
% maximum number of times to iterate the iterative procedure:
% iterative procedure: takes an angle t on top of stack, computes a 
% better angle (and put it on top of stack)
  30 { dup
% compute distance D between (x0,y0) and M(t)
    dup cos rx mul x0 sub dup mul exch sin ry mul y0 sub dup mul add sqrt
% if D almost equals targetLength, we stop
    dup targetLength sub abs 1e-5 le { pop exit } if
% stack now contains D t
% compute the point M(t') at distance targetLength of (x0,y0) on the semi-line [(x0,y0) M(t)]:
% M(t')= ( (x(t)-x0)*targetLength/d+x0 , (y(t)-y0)*targetLength/d+y0 )
    exch dup cos rx mul x0 sub  exch sin ry mul y0 sub
% stack contains:  y(t)-y0, x(t)-x0, d
    2 index Div targetLength mul y0 add ry Div exch
    2 index Div targetLength mul x0 add rx Div
% stack contains x(t')/rx , y(t')/ry , d
% now compute t', and remove D from stack
    atan exch pop
  } repeat
% we don't look at what happened... in particular, if targetLength is greater 
% than the diameter of the ellipse...
% the final angle will be around /angle0 + 180. maybe we should treat this pathological case...
% after iteration, stack contains an angle t such that M(t) is the tail of the arrow
% to give back the result as a an angle relative to angle0 we could add the following line:
% angle0 sub 0 exch d
%
% begin bug fix 2006-01-11
% we want to adjust the new angle t' by a multiple of 360 so that  | t'-angle0 | <= 180
%(we don't want to make the ellipse turn more or less than it should)...
dup angle0 sub dup abs 180 gt { 180 add 360 div floor 360 mul sub } { pop } ifelse
% end bug fix
} def
%
/EllipticArcArrow {
  /d ED      % is add or sub
  /b ED      % arrow procedure
  /a1 ED     % angle
  gsave
  newpath
  0 -1000 moveto
  clip                  % Set clippath far from arrow.
  newpath
  0 1 0 0 b             % Draw arrow to determine length.
  grestore
% Length of arrow is on top of stack. Next 3 numbers are junk.
%
  a1 exch ArcAdjust   % Angular position of base of arrow.
  /a2 ED
  pop pop pop
  a2 cos rx mul xOrig add % hv 2007-08-29   x->xOrig
  a2 sin ry mul yOrig add % hv 2007-08-29   y->yOrig
  a1 cos rx mul xOrig add % 
  a1 sin ry mul yOrig add % 
% Now arrow tip coor and base coor are on stack.
  b pop pop pop pop       % Draw arrow, and discard coordinates.
  a2 CLW 8 div
% change value of d (test it by looking if  `` 1 1 d '' gives 2 or not )
  1 1 d 2 eq { /d { sub } def } { /d { add } def } ifelse
  ArcAdjust
% resets original value of d
  1 1 d 2 eq { /d { sub } def } { /d { add } def } ifelse  % Adjust angle to give overlap.
} def
%%------------------ tvz/DG/hv (2004-05-10) end -------------------%%
%
/Rot { CP CP translate 3 -1 roll neg rotate NET  } def
%
/RotBegin { 
  tx@Dict /TMatrix known not { /TMatrix { } def /RAngle { 0 } def } if 
  /TMatrix [ TMatrix CM ] cvx def 
  /a ED 
  a Rot /RAngle [ RAngle dup a add ] cvx def 
} def
%
/RotEnd { 
  /TMatrix [ TMatrix setmatrix ] cvx def 
  /RAngle [ RAngle pop ] cvx def 
} def
%
/PutCoor { gsave CP T CM STV exch exec moveto setmatrix CP grestore } def
/PutBegin { /TMatrix [ TMatrix CM ] cvx def CP 4 2 roll T moveto } def
/PutEnd { CP /TMatrix [ TMatrix setmatrix ] cvx def moveto } def
%
/Uput { 
  /a ED 
  add 2 div /h ED 2 
  div /w ED 
  /s a sin def 
  /c a cos def 
  /b s abs c abs 2 copy gt dup 
    /q ED 
    { pop } { exch pop } ifelse def 
  /w1 c b div w mul def 
  /h1 s b div h mul def 
  q { w1 abs w sub dup c mul abs }{ h1 abs h sub dup s mul abs } ifelse 
} def
%
/UUput { 
  /z ED 
  abs /y ED 
  /x ED 
  q { x s div c mul abs y gt }{ x c div s mul abs y gt } ifelse 
    { x x mul y y mul sub z z mul add sqrt z add } 
    { q { x s div } { x c div } ifelse abs 
    } ifelse 
  a PtoC 
  h1 add exch 
  w1 add exch 
} def
%
/BeginOL { 
  dup (all) eq exch TheOL eq or 
    { IfVisible not { Visible /IfVisible true def } if } 
    { IfVisible { Invisible /IfVisible false def } if } ifelse 
} def
%
/InitOL { 
  /OLUnit [ 3000 3000 matrix defaultmatrix dtransform ] cvx def
  /Visible { CP OLUnit idtransform T moveto } def 
  /Invisible { CP OLUnit neg exch neg exch idtransform T moveto } def 
  /BOL { BeginOL } def
  /IfVisible true def 
} def
%
end
%-----------------------------------------------------------------------------%
%
% END pstricks.pro

%%EndProcSet
%%BeginProcSet: pst-algparser.pro 0 0
% $Id: pst-algparser.pro 801 2013-07-09 18:10:41Z herbert $
%%
%% PostScript prologue for PSTricks algorithm parser
%% Version 0.04, 2011/10/21
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%%
%%-----------------------------------------------------------------------------%
%
/AlgParser { tx@AlgToPs begin AlgToPs end } def  % Dominique Rodriguez
%
/tx@CoreAnalyzerDict 100 dict def tx@CoreAnalyzerDict begin
%
% PS ANALYZER FOR ALGEBRAIC EXPRESSION V1.13
%
% 09/2011 DR factorial with ! added
%
% E->T|E+T
% T->FS|T*FS
% FS -> F | +FS | -FS
% F->P|F^SF|P!
% P->(E)|literal
% literal->number|var|var[E]|func(params)
% params->E|E,param
% number->TOBEFINISHED
%
%% E expression, T term, SF signed factor, F factor, P power
%
%% parser
%
%% str
%
%% C->E<condition_operators>E
%% STR index -> STR index+lenExpr
/AnalyzeCond { AnalyzeExpr ReadCondOp AnalyzeExpr EvalCondOp  } def
%
%% analyze Expression List (separator , or | )
%% STR index -> STR index+lenExpr
%% /AnalyzeListOfE {
%%   { NextNonBlankChar pop AnalyzeExpr%%dup Strlen eq { exit } if NextNonBlankChar
%%     NextNonBlankChar dup 0 eq { pop exit } if
%%     dup 44 ne 1 index 124 ne and { dup 41 ne { PROBLEMCONTACTBILLOU } { pop exit } ifelse } if
%%     pop NextNonBlankChar dup 0 eq { exit } if 124 ne { PROBLEMCONTACTBILLOU } if 1 add NextNonBlankChar 0 eq {toto} if } loop
%%   AnalyzeListOfEPostHook
%% } def
/AnalyzeListOfE {
  /NotFirst false def
  { NextNonBlankChar pop AnalyzeExpr
    NotFirst { EvalListOfExpr } { /NotFirst true def } ifelse
    dup Strlen eq { exit } if NextNonBlankChar
    dup 44 ne 1 index 124 ne and
    { dup 41 ne { PROBLEMCONTACTBILLOU } { pop exit } ifelse }
    if  pop 1 add } loop
  AnalyzeListOfEPostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% E->T|E+T
%% STR index -> STR index+lenExpr
/AnalyzeExpr {
  AnalyzePreHook AnalyzeTerm IsEndingExpr
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { RollOp 1 add NextNonBlankChar pop AnalyzeTerm PreEvalHook EvalAddSub IsEndingExpr { pop exit } if } loop }
  ifelse
  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% T->FS|T*FS
%% STR index
/AnalyzeTerm {
  AnalyzePreHook AnalyzeSignedFactor IsEndingTerm
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { RollOp 1 add NextNonBlankChar pop AnalyzeSignedFactor PreEvalHook EvalMulDiv IsEndingTerm { pop exit } if} loop }
  ifelse
  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% FS -> F | +FS | -FS
%% STR index
/AnalyzeSignedFactor {
  AnalyzePreHook 2 copy get dup IsUnaryOp
  { RollOp 1 add NextNonBlankChar pop AnalyzeSignedFactor EvalUnaryOp }
  { pop AnalyzeFactor }
  ifelse AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% F->P|F^P|P!
%% STR index
/AnalyzeFactor {
  AnalyzePreHook AnalyzePower IsEndingFactor
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { dup 33 eq%% is there a ! DR 09/2011
      { pop 1 add NextNonBlankChar pop EvalFactorial }
      { RollOp 1 add NextNonBlankChar pop AnalyzePower PreEvalHook EvalPower }
      ifelse
      IsEndingFactor { pop exit } if } loop }
  ifelse  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% P->(E)|literal
%% STR index
/AnalyzePower {
  %% depending of first char either a number, or a literal
  2 copy get dup 40 eq%%an open par
  { pop 1 add NextNonBlankChar pop AnalyzeExpr 1 add NextNonBlankChar pop }
  { AnalyzeLiteral }
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index STR[index] -> STR index
%/AnalyzeLiteral { IsNumber { EvalNumber } { EvalLiteral } ifelse } def
/AnalyzeLiteral { dup IsUnaryOp exch IsNumber or { EvalNumber } { EvalLiteral } ifelse } def%%dr 09102006
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% recognize + or -
%% chr -> T/F
/IsUnaryOp { dup 43 eq exch 45 eq or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a number can contain only : 0123456789.
%% chr -> T/F
/IsNumber { dup 48 ge exch dup 57 le 3 -1 roll and exch 46 eq or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index number
%% a number can be of the form [0-9]*.[0-9]*\([eE][+-]?[0-9]+\)?
%% STR index -> STR index' number
/ReadNumber {
  exch dup 3 -1 roll dup 3 1 roll
  %%read mantissa
  { 1 add  2 copy dup Strlen eq { pop pop 0 exit } if get dup IsNumber not { exit } if pop } loop
  dup 101 eq exch 69 eq or
  %%% there is a "e" or "E" -> read exponant
  { 1 add 2 copy get dup IsUnaryOp
    { pop 1 add 2 copy get } if
    { IsNumber not { exit } if 1 add 2 copy get } loop }
  if
  dup 4 1 roll
  3 -1 roll exch 1 index sub getinterval
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a number can contain only : 0123456789.
%% chr -> T/F
/IsCondOp { dup 30 eq exch dup 60 ge exch 62 le and or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index number
%% a number can be of the form [0-9]*.[0-9]*\([eE][+-]?[0-9]+\)?
%% STR index -> STR index' number
/ReadCondOp {
  NextNonBlankChar 1 index 4 1 roll
  { IsCondOp not { exit } if 1 add  2 copy get } loop
  2 copy 5 -1 roll
  exch 1 index sub getinterval 3 1 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a literal can contain only : 0123456789.
%% chr -> T/F
/IsLiteral {%
  dup 48 ge exch dup  57 le 3 -1 roll and exch
  dup 65 ge exch dup  90 le 3 -1 roll and 3 -1 roll or exch
  dup 97 ge exch     122 le and or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a literal can be of the form [a-zA-Z][a-zA-Z0-9]*\(\((Expression)\)|\(\[Expression\]\)\)?
%% STR index -> literal STR index' nextchr
/ReadLiteral {
  exch dup 3 -1 roll dup 3 1 roll
  %%read literal core
  { 2 copy dup Strlen eq { pop pop 0 exit } if get dup IsLiteral not { exit } if pop 1 add } loop
  4 1 roll dup 5 1 roll 3 -1 roll exch 1 index sub getinterval 4 1 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or a clpar
%% STR index -> STR index STR[index] T/F
/IsEndingExpr {%
  2 copy dup Strlen eq
  %% if end of str is reached -> end !
  { pop pop 0 true }
  %% ending chr -> clpar, comma, |, <, >, =, !,
  {get dup  dup  41 eq
       exch dup 124 eq
       exch dup  93 eq
       exch dup  44 eq
       exch dup  30 eq
       exch dup  60 ge exch 62 le and or or or or or}
  ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or a +-
%% STR index -> STR index STR[index] T/F
/IsEndingTerm { IsEndingExpr { true } { dup dup 43 eq exch 45 eq or } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or */
%% STR index -> STR index STR[index] T/F
/IsEndingFactor { IsEndingTerm { true } { dup dup 42 eq exch 47 eq or } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or ^
%% STR index -> STR index STR[index] T/F
/IsEndingPower { IsEndingFactor { true } { dup 94 eq } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index STR[index]
/NextNonBlankChar { { dup Strlen eq { 0 exit } if 2 copy get dup neBlkChar { exit } if pop 1 add } loop } bind def
/neBlkChar { dup 32 ne exch dup 10 ne exch 9 ne and and } bind def
%%%%%%%%%%%%%%%%%%%%%%%%
%% DEBUG
/BRK {false} def
/BRKtrue {/BRK true def} def
/BRKStop {BRK {BRKtoto} if } def
/BRKEvalStop {BRK exch if } def
/BRKBRK2true {BRK {BRK2true} if } def
/BRK2 {false} def
/BRK2true {/BRK2 true def} def
/BRK2Stop {BRK2 {BRK2toto} if } def/BRK {false} def
end
%
%-------------------------------------------------------------------------------%
%
/tx@AlgToPs 12 dict def tx@AlgToPs begin
%
%% algExpr -> PSVector
/AlgToPs { tx@CoreAnalyzerDict begin InitParser AnalyzeListOfE pop pop EndingSequence end } def
/EndingSequence { ExpressionVector aload length /end cvx exch 1 add array astore } def
/InitParser { /ExpressionVector [ /tx@AddMathFunc cvx /begin cvx ] def dup length /Strlen exch def 0 } def
/Strlen 0 def
/EvalListOfExpr {} def%
/EvalNumber {%
    ReadNumber  cvr /ExpressionVector ExpressionVector aload length dup 3 add -1 roll cvx
    exch 1 add array astore def NextNonBlankChar pop } def
/EvalAddSub {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  43 eq { /add } { /sub } ifelse cvx exch 1 add array astore def
} def
/EvalMulDiv {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  42 eq { /mul } { /div } ifelse cvx exch 1 add array astore def
} def
/EvalPower {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  pop /exp cvx exch 1 add array astore def
} def
/EvalFactorial {% DR 09/2011
  /ExpressionVector ExpressionVector aload length
  /fact cvx exch 1 add array astore def
} def
/EvalLiteral {%
  ReadLiteral
  dup 40 eq%%% there is an open par -> function call
  { pop 2 index
    dup (Sum) eq { EvalSum }
    { dup (IfTE) eq { EvalCond }
      { dup (Derive) eq { pop EvalDerive }
	{ pop 1 add NextNonBlankChar pop AnalyzeListOfE 2 index TrigoFunc
          /ExpressionVector ExpressionVector aload length dup 5 add -1 roll cvn cvx
	  exch 1 add array astore def 1 add NextNonBlankChar pop } ifelse } ifelse} ifelse }
  { /ExpressionVector ExpressionVector aload length dup 6 add -1 roll cvn cvx exch 1 add array astore def
    dup 91 eq%%% there is an open bracket -> vector element
    { pop 1 add NextNonBlankChar pop AnalyzeExpr
      /ExpressionVector ExpressionVector aload length /cvi cvx exch /get cvx exch 2 add array astore def 1 add }
    { pop NextNonBlankChar pop }
    ifelse}
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% the derive function : Derive(n,f(x))
%% firstparindex lastparindex ->
/EvalDerive {
  %% manage the function descripiton
  1 add ReadNumber 3 1 roll NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  1 add NextNonBlankChar pop
  3 -1 roll cvi
  dup 0 eq
  { pop AnalyzeExpr 3 -1 roll pop 1 add }
  { 1 sub 3 1 roll (x)  exch tx@Derive begin DeriveIndexed end 4 -1 roll
    { (x) tx@Derive begin Derive end } repeat
    ExpressionVector exch /ExpressionVector [] def
    AlgToPs aload length
    /ExpressionVector 1 index 3 add -1 roll aload length dup 3 add -1 roll  /l2 exch def /l1 exch def
    l1 l2 add 1 add l2 neg roll l1 l2 add array astore def 3 -1 roll pop 1 add
    1 index length /Strlen exch def } ifelse
} def
/EvalSum {%
  pop 1 add NextNonBlankChar pop
  %% read the variable name
  ReadLiteral pop NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_Sum } if
  %% read the initial value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the increment value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the limit value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  /ExpressionVector ExpressionVector aload length dup 7 add -3 roll 0 4 1 roll
  5 -1 roll 4 add array astore def
  %% keep ExpressionVector for later and create a new one for internal Sum computation
  ExpressionVector 3 1 roll /ExpressionVector [ 6 -1 roll cvn /exch cvx /def cvx ] def
  1 add NextNonBlankChar pop AnalyzeExpr
  %% add each term
  /ExpressionVector ExpressionVector aload length 1 add /add cvx exch array astore def
  /ExpressionVector 4 -1 roll aload length ExpressionVector cvx /for cvx 3 -1 roll 2 add
  array astore def 3 -1 roll pop 1 add
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Convert to radians if trigo function call
%% (name) ->
/TrigoFunc {
  dup (cos) eq 1 index (sin) eq or exch (tan) eq or
  { /ExpressionVector ExpressionVector aload length Pi /div cvx 180 /mul cvx 5 -1 roll 4 add
    array astore def
  } if
} def
/EvalCond {%
  pop 1 add AnalyzeCond NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_IfTE } if
  ExpressionVector 3 1 roll /ExpressionVector [] def
  1 add AnalyzeExpr ExpressionVector 3 1 roll /ExpressionVector [] def
  NextNonBlankChar 44 ne { ANALYZER_ERROR_missing_second_comma_in_IfTE } if
  1 add AnalyzeExpr
  NextNonBlankChar 41 ne { ANALYZER_ERROR_missing_ending parenthesis_in_IfTE } if
  ExpressionVector
  /ExpressionVector 6 -1 roll aload length dup
  6 add -1 roll cvx exch dup 4 add -1 roll cvx /ifelse cvx 3 -1 roll 3 add array astore def
  1 add 3 -1 roll pop
} def
%% CondOp STR index
/EvalCondOp {%
  3 -1 roll
  dup (=) eq  { /eq } {%
  dup (<) eq  { /lt } {%
  dup (>) eq  { /gt } {%
  dup (>=) eq { /ge } {%
  dup (<=) eq { /ge } {%
  dup (!=) eq { /ne } { ERROR_non_valid_conditional_operator }
  ifelse } ifelse } ifelse } ifelse } ifelse } ifelse
  cvx exch pop
  /ExpressionVector ExpressionVector aload length dup 3 add -1 roll exch 1 add array astore def } def
/EvalUnaryOp {
  3 -1 roll 45 eq { /ExpressionVector ExpressionVector aload length /neg cvx exch 1 add array astore def } if
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% H O O K S
/AnalyzePreHook {} bind def
/PreEvalHook {} bind def
/AnalyzeListOfEPostHook {} bind def
/AnalyzePostHook {} def
/RollOp { 3 1 roll } bind def
end   %tx@CoreAnalyzerDict
%
%--------------------------------------------------------------------%
%
/tx@Derive 41 dict def tx@Derive begin
%%increase ^^ for each function added
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% algExpr variable -> PSVector
/Derive {%
  10240 string 3 1 roll 0 3 1 roll
  /Variable exch def
  tx@CoreAnalyzerDict begin InitParser AnalyzeListOfE end
} def
/Strlen 0 def
/InitParser { dup length /Strlen exch def 0 } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% algExpr variable index -> PSVector
/DeriveIndexed {%
  3 1 roll 10240 string 3 1 roll 0 3 1 roll
  /Variable exch def
  tx@CoreAnalyzerDict begin InitParser pop 4 -1 roll AnalyzeExpr 4 -2 roll pop pop 4 -2 roll exch pop end
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u,v)'=-(u',v')
/EvalListOfExpr {%
  4 2 roll 2 copy 9 -1 roll dup length 4 1 roll putinterval add AddPipe
           2 copy 7 -1 roll dup length 4 1 roll putinterval add
  6 -2 roll pop pop
  2 copy pop 0 6 2 roll GetIntervalNewStr 5 1 roll 2 copy 0 exch getinterval 6 1 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (-u)'=-(u')
/EvalUnaryOp {
  4 -2 roll 4 index (0) eq
  { (0) StrConcat 7 -1 roll pop }
  { 7 -1 roll 45 eq
    { AddSub AddOpPar true } { false } ifelse
    3 1 roll 5 index StrConcat 3 -1 roll { AddClPar } if } ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  7 -2 roll pop pop 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (number)'=0
/EvalNumber { ReadNumber (0) 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u+v)'=u'+v'
/EvalAddSub {%
  7 index dup (0) eq
  { pop true }%% du=0 nothing added
  { dup length exch 5 index 5 index 3 -1 roll putinterval 4 -1 roll add 3 1 roll false }
  ifelse
  5 index dup (0) eq
  { pop { (0) } { 4 -2 roll 2 copy pop 0  6 2 roll GetIntervalNewStr } ifelse }%%dv=0
  { exch
    { 5 -2 roll 7 index 45 eq { AddSub } if false } %%nothing yet added
    { 5 -2 roll 7 index 43 eq%%something yet added
      { AddAdd false } { AddSub AddOpPar true } ifelse }
    ifelse 11 1 roll
    3 -1 roll StrConcat 10 -1 roll { AddClPar } if
    2 copy pop 0 6 2 roll GetIntervalNewStr }
  ifelse
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u*v)' or (u/v)'
/EvalMulDiv { 6 index 42 eq {EvalMul} {EvalDiv} ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u*v)'=u'*v+u*v'
/EvalMul {%
  4 -2 roll 7 index dup (0) eq
  { pop false }%%du=0
  { (1) eq%%du=1
    { false }
    { AddOpPar 7 index StrConcat AddClPar AddMul AddOpPar true } ifelse
    3 1 roll 6 index StrConcat 3 -1 roll { AddClPar } if
    true }%%du!=0
  ifelse
  5 1 roll 5 index (0) eq
  { 5 -1 roll not { (0) StrConcat } if }%%dv=0
  { 5 -1 roll { AddAdd } if
    4 index (1) eq
    { 8 index StrConcat }
    { AddOpPar 8 index StrConcat AddClPar AddMul AddOpPar 4 index StrConcat AddClPar }
    ifelse
  }%%dv!=0
  ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u/v)'=(u'*v-u*v')/v^2
/EvalDiv {%
  4 -2 roll
  4 index (0) eq%%dv=0 -> u'/v
  { 7 index (0) eq { (0) StrConcat } { AddOpPar 7 index StrConcat AddClPar AddDiv 5 index StrConcat } ifelse }
  { 7 index dup (0) eq
    { pop }%%du=0
    { (1) eq%%du=1
      { false }
      { AddOpPar 7 index StrConcat AddClPar AddMul AddOpPar true } ifelse
      3 1 roll 6 index StrConcat 3 -1 roll { AddClPar } if}%%du!=0
    ifelse
      AddSub
      4 index (1) eq
      { 8 index StrConcat }
      { AddOpPar 8 index StrConcat AddClPar AddMul AddOpPar 4 index StrConcat AddClPar }
      ifelse
    %}%%dv!=0
    2 copy GetIntervalNewStr 3 1 roll pop 0 AddOpPar 3 -1 roll StrConcat AddClPar
    AddDiv AddOpPar 5 index StrConcat AddClPar 2 copy (^2) putinterval 2 add }
  ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% str1 index str2 -> str1 index
/StrConcat { dup length 4 2 roll 2 copy 6 -1 roll putinterval 3 -1 roll add } bind def
/GetIntervalNewStr { 0 exch getinterval dup length string copy } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u^v)'=(u^v)'=u'vu^(v-1)+v'u^(v)ln(u)
/EvalPower {%
  4 -2 roll 7 index (0) eq
  {%%if du=0 then (u^v)'=v'ln(u)u^v
    4 index (0) eq
    { (0) StrConcat }%%if dv=0 then (u^v)'=0
    { 4 index (1) ne { AddOpPar 4 index StrConcat (\)*) StrConcat } if
      8 index (e) ne { (ln\() StrConcat 8 index StrConcat (\)*) StrConcat } if
      AddOpPar 8 index StrConcat (\)^\() StrConcat 5 index StrConcat AddClPar } ifelse
  }
  {%%du!=0
    4 index (0) eq
    {%%if dv=0 then (u^v)'=vu'u^(v-1)
      5 index dup IsStrNumber
      { dup (0) eq
        { StrConcat }
        { dup dup (1) eq exch (1.0) eq or
          { StrConcat  }
	  { StrConcat
	    7 index dup (1) ne exch (1.0) ne and%%%dr 09102006 insert du if <> 1
	    { (*\() StrConcat 7 index StrConcat (\)) StrConcat } if%%%dr 09102006
            (*\() StrConcat 8 index StrConcat (\)) StrConcat
            5 index  dup dup (2) eq exch (2.0) eq or
	    { pop } { cvr 1 sub 20 string cvs 3 1 roll (^) StrConcat 3 -1 roll StrConcat } ifelse } ifelse } ifelse }
      { pop AddOpPar 5 index StrConcat (\)*\() StrConcat 8 index StrConcat (\)^\() StrConcat
        5 index StrConcat (-1\)) StrConcat } ifelse
    }
    {%%if dv!=0 and du!=0 then (u^v)'=u'vu^(v-1)+v'u^(v)ln(u)
      7 index (1) ne { AddOpPar 7 index StrConcat (\)*) StrConcat } if
      AddOpPar 5 index StrConcat (\)*\() StrConcat
      8 index StrConcat (\)^\() StrConcat
      5 index StrConcat (-1\)+\() StrConcat
      4 index (1) ne { 4 index StrConcat (\)*\() StrConcat } if
      8 index StrConcat (\)^\() StrConcat
      5 index StrConcat (\)*ln\() StrConcat
      8 index StrConcat AddClPar
    } ifelse
  } ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% No derivative for factorial ! only cst => null derivative
/EvalFactorial {% DR 09/2011
  4 index (0) eq
  { (0) mark 8 -2 roll  cleartomark 2 index 7 index dup 4 index exch sub getinterval exch 6 2 roll }
  { DERIVATIVE_ENGINE_ERROR_no_variable_in_factorial } ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% str -> true/false
/IsStrNumber {%
  true exch
  { dup 48 lt exch dup 57 gt 3 -1 roll or
    exch dup 46 ne%%.
    exch dup 43 ne%%+
    exch 45 ne%%-
    and and and { pop false } if } forall
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalLiteral {%
  ReadLiteral dup 40 eq%%% there is an open par -> function call
  { pop (EvalFunc_             ) 9 4 index StrConcat 0 exch getinterval cvn cvx exec }
  { dup 91 eq%%% there is an open bracket -> vector element
    { DERIVATIVE_ENGINE_ERROR_vector_not_yet_implemented }
    { pop EvalVariable }
    ifelse }
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% first last parpos Expr[first:parpos-1] ->
/EvalVariable { 2 index Variable eq { (1) } { (0) } ifelse 4 -1 roll exch 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (f(u))'=u'f'(u)
/EvalFunc {
  4 2 roll 4 index (1) ne
  { AddOpPar 4 index StrConcat (\)*) StrConcat } if
  (Eval             ) 4 8 index StrConcat 0 exch getinterval cvn cvx exec
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Func derivative -> Eval<func>
/EvalFunc_sin {%
  PreCommonFunc
  { (cos\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_cos {%
  PreCommonFunc
  { (\(-sin\() StrConcat 5 index StrConcat (\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_tan {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse  (/cos\() StrConcat 5 index StrConcat (\)^2) StrConcat } if
  PostCommonFunc } def
/EvalFunc_asin {%
  PreCommonFunc
  { (1/sqrt\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_acos {%
  PreCommonFunc
  { (-1/sqrt\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_atg {%
  PreCommonFunc
  { (1/\(1+\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_ln {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse (/\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_exp {%
  PreCommonFunc
  {  (exp\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_EXP {%
  PreCommonFunc
  {  (EXP\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_sqrt {%
  PreCommonFunc
  { dup 0 eq { (1) StrConcat } { 1 sub } ifelse (/\(2*sqrt\() StrConcat 5 index StrConcat (\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Fact {%
  PreCommonFunc { DERIVATIVE_ENGINE_ERROR_no_variable_expression_in_Fact } if
  PostCommonFunc } def
/EvalFunc_sh {%
  PreCommonFunc
  { (ch\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_ch {%
  PreCommonFunc
  { (sh\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_th {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse  (/ch\() StrConcat 5 index StrConcat (\)^2) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argsh {%
  PreCommonFunc
  { (1/sqrt\(1+\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argch {%
  PreCommonFunc
  { (1/sqrt\(\() StrConcat 5 index StrConcat (\)^2-1\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argth {%
  PreCommonFunc
  { (1/\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/PreCommonFunc {
  1 add NextNonBlankChar pop 3 -1 roll 5 1 roll AnalyzeExpr 1 add NextNonBlankChar pop
  4 2 roll 4 index (0) eq
  { (0) StrConcat false }
  { 4 index (1)  ne { AddOpPar 4 index StrConcat (\)*) StrConcat } if true } ifelse
} def
/PostCommonFunc {
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
/EvalFunc_Derive {%
  1 add ReadNumber cvi 1 add dup cvr log 1 add cvi string cvs
  4 -1 roll pop 5 1 roll 1 add NextNonBlankChar pop AnalyzeExpr 1 add
  4 -2 roll (Derive\() StrConcat 7 -1 roll StrConcat (,) StrConcat 6 -1 roll StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr 6 -1 roll pop 2 index 6 index dup 4 index exch sub getinterval
  exch 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalFunc_Sum {%
  1 add NextNonBlankChar pop
  %% read the variable name
  ReadLiteral pop 3 -1 roll pop NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_Sum } if
  %% read the initial value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the increment value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_third_comma_in_Sum } if
  %% read the limit value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_fourth_comma_in_Sum } if
  1 add NextNonBlankChar pop dup 6 1 roll 3 -1 roll pop AnalyzeExpr 1 add NextNonBlankChar pop
  4 -2 roll 3 index 8 index dup 9 index exch sub getinterval StrConcat
  4 index StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalFunc_IfTE {%
  3 -1 roll pop 1 add NextNonBlankChar pop SkipCond
  NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_IfTE } if
  1 add NextNonBlankChar pop dup 5 1 roll
  AnalyzeExpr NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_second_comma_in_IfTE } if
  1 add NextNonBlankChar pop
  AnalyzeExpr 1 add NextNonBlankChar pop
  4 -2 roll 3 index 10 index dup 11 index exch sub getinterval StrConcat
  6 index StrConcat (,) StrConcat 4 index StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% advance in str until a comma is found (no error detection!)
%% str index -> str index'
/SkipCond { { 1 add 2 copy get 44 eq {exit } if } loop } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Convert to radians if trigo function call
%% (name) ->
/TrigoFunc {
  dup (cos) eq 1 index (sin) eq or exch (tan) eq or
  { /ExpressionVector ExpressionVector aload length Pi /div cvx 180 /mul cvx 5 -1 roll 4 add
    array astore def
  } if
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% No derivative for condition....
/EvalCondOp { 3 -1 roll pop } bind def
/PutIntervalOneAdd {putinterval 1 add} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddOpPar {2 copy (\() PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add close parenthesis in string at the given index
%% str index -> str index+1
/AddClPar {2 copy (\)) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add 0 in string at the given index
%% str index -> str index+1
/AddZero {2 copy (0) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddMul {2 copy (*) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddDiv {2 copy (/) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a plus sign in string at the given index
%% str index -> str index+1
/AddAdd {2 copy (+) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a minus sign in string at the given index
%% str index -> str index+1
/AddSub {2 copy (-) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a pipe sign in string at the given index
%% str index -> str index+1
/AddPipe {2 copy (|) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% H O O K S
/AnalyzePreHook { dup 5 1 roll } bind def
/PreEvalHook {} def
/AnalyzePostHook { 7 -1 roll pop } bind def
/AnalyzeListOfEPostHook { 6 -1 roll mark 6 1 roll cleartomark } bind def
/RollOp { 5 1 roll } bind def
end%%%tx@CoreAnalyzerDict
/tx@AddMathFunc 12 dict def tx@AddMathFunc begin
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% NEW FUNC
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% function arcsine in radians asin(x)=atan(x/sqrt(1-x^2))
%% x -> theta
/asin {%
  dup abs 1 gt { EQDFasinrangeerror  } if
  dup dup dup mul 1 exch sub sqrt atan exch 0 lt { 360 sub } if DegtoRad
} def
%% function arccosine in radians acos(x)=atan(sqrt(1-x^2)/x)
%% x -> theta
/acos {%
  dup abs 1 gt { EQDFacosrangeerror  } if
  dup dup mul 1 exch sub sqrt exch atan DegtoRad
} def
%% function arctangent in radians
%% x -> theta
/atg { 1 atan dup 90 gt { 360 sub } if DegtoRad } bind def
%% HYPERBOLIC FUNCTIONS
/sh { dup Ex exch neg Ex sub 2 div } def
/ch { dup Ex exch neg Ex add 2 div } def
/th { dup sh exch ch div } def
/Argsh { dup dup mul 1 add sqrt add ln } def
/Argch { dup dup mul 1 sub sqrt add ln } def
/Argth { dup 1 add exch 1 exch sub div ln 2 div } def
%% modified exponential funtion for 0
%% x n -> x^n
/Exp { dup 0 eq { pop pop 1 } { exp } ifelse } bind def
%% modified exponential funtion for 0
%% x -> e^x
/Ex { Euler exch exp } bind def
%%
%% factorial function
%% n -> n!
/Fact { 1 exch 2 exch 1 exch { mul } for } bind def
/fact { Fact } bind def
/! { Fact } bind def
end
%
% END pst-algparser.pro

%%EndProcSet
%%BeginProcSet: pst-tools.pro 0 0
% $Id: pst-tools.pro 713 2012-10-16 14:25:00Z herbert $
%
%% PostScript tools prologue for pstricks.tex.
%% Version 0.03, 2012/10/16
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%
%
/Pi2 1.57079632679489661925640 def
/factorial { % n on stack, returns n! 
  dup 0 eq { 1 }{ 
    dup 1 gt { dup 1 sub factorial mul } if }
  ifelse } def 
%
/MoverN { % m n on stack, returns the binomial coefficient m over n
  2 dict begin
  /n exch def /m exch def
  n 0 eq { 1 }{
    m n eq { 1 }{
      m factorial n factorial m n sub factorial mul div } ifelse } ifelse 
  end
} def
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% subroutines for complex numbers, given as an array [a b] 
% which is a+bi = Real+i Imag
%
/cxadd {		% [a1 b1] [a2 b2] = [a1+a2 b1+b2]
  dup 0 get		% [a1 b1] [a2 b2] a2
  3 -1 roll		% [a2 b2] a2 [a1 b1]
  dup 0 get		% [a2 b2] a2 [a1 b1] a1
  3 -1 roll		% [a2 b2] [a1 b1] a1 a2
  add			% [a2 b2] [a1 b1] a1+a2
  3 1 roll		% a1+a2 [a2 b2] [a1 b1]
  1 get			% a1+a2 [a2 b2] b1
  exch 1 get		% a1+a2 b1 b2
  add 2 array astore
} def
%
/cxneg {		% [a b]
  dup 1 get		% [a b] b
  exch 0 get		% b a
  neg exch neg		% -a -b
  2 array astore
} def
%
/cxsub { cxneg cxadd } def  % same as negative addition
%
% [a1 b1][a2 b2] = [a1a2-b1b2 a1b2+b1a2] = [a3 b3]
/cxmul {		% [a1 b1] [a2 b2]
  dup 0 get		% [a1 b1] [a2 b2] a2
  exch 1 get		% [a1 b1] a2 b2
  3 -1 roll		% a2 b2 [a1 b1]
  dup 0 get		% a2 b2 [a1 b1] a1
  exch 1 get		% a2 b2 a1 b1
  dup			% a2 b2 a1 b1 b1
  5 -1 roll dup		% b2 a1 b1 b1 a2 a2
  3 1 roll mul		% b2 a1 b1 a2 b1a2
  5 -2 roll dup		% b1 a2 b1a2 b2 a1 a1
  3 -1 roll dup		% b1 a2 b1a2 a1 a1 b2 b2
  3 1 roll mul		% b1 a2 b1a2 a1 b2 a1b2
  4 -1 roll add		% b1 a2 a1 b2 b3
  4 2 roll mul		% b1 b2 b3 a1a2
  4 2 roll mul sub	% b3 a3
  exch 2 array astore
} def
%
% [a b]^2 = [a^2-b^2 2ab] = [a2 b2]
/cxsqr {		% [a b]   square root
  dup 0 get exch 1 get	% a b
  dup dup mul		% a b b^2
  3 -1 roll		% b b^2 a
  dup dup mul 		% b b^2 a a^2
  3 -1 roll sub		% b a a2
  3 1 roll mul 2 mul	% a2 b2	
  2 array astore
} def
%
/cxsqrt {		% [a b]
%  dup cxnorm sqrt /r exch def
%  cxarg 2 div RadtoDeg dup cos r mul exch sin r mul cxmake2 
  cxlog 		% log[a b]
  2 cxrdiv 		% log[a b]/2
  aload pop exch	% b a
  2.781 exch exp	% b exp(a)
  exch cxconv exch	% [Re +iIm] exp(a)
  cxrmul		%
} def
%
/cxarg { 		% [a b] 
  aload pop 		% a b
  exch atan 		% arctan b/a
  DegtoRad 		% arg(z)=atan(b/a)
} def
%
% log[a b] = [a^2-b^2 2ab] = [a2 b2]
/cxlog {		% [a b]
  dup 			% [a b][a b]
  cxnorm 		% [a b] |z|
  log 			% [a b] log|z|
  exch 			% log|z|[a b]
  cxarg 		% log|z| Theta
  cxmake2 		% [log|z| Theta]
} def
%
% square of magnitude of complex number
/cxnorm2 {		% [a b]
  dup 0 get exch 1 get	% a b
  dup mul			% a b^2
  exch dup mul add	% a^2+b^2
} def
%
/cxnorm {		% [a b]
  cxnorm2 sqrt
} def
%
/cxconj {		% conjugent complex
  dup 0 get exch 1 get	% a b
  neg 2 array astore	% [a -b]
} def
%
/cxre { 0 get } def	% real value
/cxim { 1 get } def	% imag value
%
% 1/[a b] = ([a -b]/(a^2+b^2)
/cxrecip {		% [a b]
  dup cxnorm2 exch	% n2 [a b]
  dup 0 get exch 1 get	% n2 a b
  3 -1 roll		% a b n2
  dup			% a b n2 n2
  4 -1 roll exch div	% b n2 a/n2
  3 1 roll div		% a/n2 b/n2
  neg 2 array astore
} def
%
/cxmake1 { 0 2 array astore } def % make a complex number, real given
/cxmake2 { 2 array astore } def	  % dito, both given
%
/cxdiv { cxrecip cxmul } def
%
% multiplikation by a real number
/cxrmul {		% [a b] r
  exch aload pop	% r a b
  3 -1 roll dup		% a b r r
  3 1 roll mul		% a r b*r
  3 1 roll mul		% b*r a*r
  exch 2 array astore   % [a*r b*r]
} def
%
% division by a real number
/cxrdiv {		% [a b] r
  1 exch div		% [a b] 1/r
  cxrmul
} def
%
% exp(i theta) = cos(theta)+i sin(theta) polar<->cartesian
/cxconv {		% theta
  RadtoDeg dup sin exch cos cxmake2
} def

%%%%% ### bubblesort ###
%% syntax : array bubblesort --> array2 trie par ordre croissant
%% code de Bill Casselman
%% http://www.math.ubc.ca/people/faculty/cass/graphics/text/www/
/bubblesort { % on stack must be an array [ ... ]
4 dict begin
   /a exch def
   /n a length 1 sub def
   n 0 gt {
      % at this point only the n+1 items in the bottom of a remain to
      % the sorted largest item in that blocks is to be moved up into
      % position n
      n {
         0 1 n 1 sub {
            /i exch def
            a i get a i 1 add get gt {
               % if a[i] > a[i+1] swap a[i] and a[i+1]
               a i 1 add
               a i get
               a i a i 1 add get
               % set new a[i] = old a[i+1]
               put
               % set new a[i+1] = old a[i]
               put
            } if
         } for
         /n n 1 sub def
      } repeat
   } if
   a % return the sorted array
end
} def
%
/concatstringarray{  %  [(a) (b) ... (z)] --> (ab...z)  20100422
  0 1 index { length add } forall 
  string     
  0 3 2 roll      
  { 3 copy putinterval length add }forall 
  pop  
} bind def
%
/dot2comma {% on stack a string (...) 
  2 dict begin
  /Output exch def
  0 1 Output length 1 sub { 
    /Index exch def 
    Output Index get 46 eq { Output Index 44 put } if 
  } for
  Output
  end
} def
%
/rightTrim { 
  dup
  length 1 sub -1 0 { 
    /i exch def dup i get 32 ne { exit } if 
  } for
  0 i 1 add getinterval
  dup length string copy
} bind def

/psStringwidth /stringwidth load def
/psShow /show load def

%/stringwidth{ rightTrim psStringwidth } bind def

%/show { rightTrim psShow } bind def
%-----------------------------------------------------------------------------%
% END pst-tools.pro

%%EndProcSet
%%BeginProcSet: pst-dots.pro 0 0
% $Id: pst-dots.pro 801 2013-07-09 18:10:41Z herbert $
%
%% PostScript prologue for pstricks.tex.
%% Version 2.02,  2009/06/16
%%
%% For distribution, see pstricks.tex.
%%
%% Timothy Van Zandt <tvz@Princeton.EDU>
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%%
%% Modified by Etienne Riga  - Dec. 16, 1999
%% Modified by Etienne Riga  - 2005/01/01 (er)
%% to add /Diamond, /SolidDiamond and /BoldDiamond
%% Modified by Herbert Voss (hv) - 2008/04/17 
%
10 dict dup begin			% hold local
  /FontType 3 def
  /FontMatrix [.001 0 0 .001 0 0] def
%  /FontBBox [-571.5 -742.5 571.5 742.5] def % changed to next line 20060616 hv
  /FontBBox [-1000 -1000 1000 1000] def  % See end of file in /BuildGlyph
  /Encoding 256 array def
  0 1 255 {Encoding exch /.notdef put} for % fill the array with /.notdef
  Encoding				   % replace with given dot names
    dup (b) 0 get /Bullet put		   % get the numerical position of b in ASCII
%					   % and save /Bullet at this place in Encoding 
    dup (c) 0 get /Circle put
    dup (C) 0 get /BoldCircle put	% 67
    dup (u) 0 get /SolidTriangle put
    dup (t) 0 get /Triangle put
    dup (T) 0 get /BoldTriangle put
    dup (r) 0 get /SolidSquare put
    dup (s) 0 get /Square put
    dup (S) 0 get /BoldSquare put
    dup (q) 0 get /SolidPentagon put
    dup (p) 0 get /Pentagon put
    dup (P) 0 get /BoldPentagon put
%%%		  
    dup (k) 0 get /Asterisk put
    dup (K) 0 get /BoldAsterisk put
    dup (J) 0 get /SolidAsterisk put
    dup (h) 0 get /Hexagon put
    dup (H) 0 get /BoldHexagon put
    dup (G) 0 get /SolidHexagon put
    dup (f) 0 get /Octogon put		% 2008-04-18 hv
    dup (F) 0 get /BoldOctogon put	% 2008-04-18 hv
    dup (g) 0 get /SolidOctogon put	% 2008-04-18 hv
    dup (a) 0 get /Add put
    dup (A) 0 get /BoldAdd put 		% 65
    dup (x) 0 get /Mul put
    dup (X) 0 get /BoldMul put
    dup (m) 0 get /Oplus put
    dup (M) 0 get /BOplus put
    dup (e) 0 get /SolidOplus put
    dup (n) 0 get /Otimes put
    dup (N) 0 get /BOtimes put
    dup (E) 0 get /SolidOtimes put
    dup (i) 0 get /Bar put
    dup (I) 0 get /BoldBar put
    dup (l) 0 get /SolidDiamond put
    dup (d) 0 get /Diamond put
        (D) 0 get /BoldDiamond put
%%%  
/CharProcs 47 dict def
CharProcs begin
  /CirclePath {0 0 500 0 360 arc closepath} def
  /Bullet {CirclePath fill} def
  /Circle {CirclePath .9 .9 scale CirclePath eofill} def
  /BoldCircle {CirclePath .8 .8 scale CirclePath eofill} def
  /TrianglePath {0 660 moveto -571.5 -330 lineto 571.5 -330 lineto closepath} def
  /SolidTriangle {TrianglePath fill} def
  /Triangle {TrianglePath .85 .85 scale TrianglePath eofill} def
  /BoldTriangle {TrianglePath .7 .7 scale TrianglePath eofill} def
  /SquarePath {-450 450 moveto 450 450 lineto 450 -450 lineto -450 -450 lineto closepath} def
  /SolidSquare {SquarePath fill} def
  /Square {SquarePath .89 .89 scale SquarePath eofill} def
  /BoldSquare {SquarePath .78 .78 scale SquarePath eofill} def
  /PentagonPath {
    -337.8 -465 moveto 337.8 -465 lineto 546.6 177.6 lineto
    0 574.7 lineto -546.6 177.6 lineto closepath
  } def
  /SolidPentagon {PentagonPath fill} def
  /Pentagon {PentagonPath .89 .89 scale PentagonPath eofill} def
  /BoldPentagon {PentagonPath .78 .78 scale PentagonPath eofill} def
%-------------- hv begin 2004/07/25   from: er 2003/03/24
  /HexagonPath {
    0 550 moveto -476 275 lineto -476 -275 lineto
    0 -550 lineto 476 -275 lineto 476 275 lineto closepath
  } def
  /SolidHexagon {HexagonPath fill} def
  /Hexagon {HexagonPath .89 .89 scale HexagonPath eofill} def
  /BoldHexagon {HexagonPath .79 .79 scale HexagonPath eofill} def
%					2008-04-18 hv
  /OctogonPath { 
     550 dup 22.5 tan mul dup neg dup add /xMove exch def 
     exch moveto 7 { xMove 0 rlineto 45 rotate } repeat closepath } def 
  /SolidOctogon { OctogonPath fill                             } def
  /Octogon {      OctogonPath .89 .89 scale OctogonPath eofill } def
  /BoldOctogon {  OctogonPath .79 .79 scale OctogonPath eofill } def
%
  /AsteriskPath {
    20 0 moveto 10 250 180 500 0 500 curveto
    -180 500 -10 250 -20 0 curveto closepath
  } def
  /Asterisk {
    AsteriskPath 60 rotate AsteriskPath 60 rotate AsteriskPath
    60 rotate AsteriskPath 60 rotate AsteriskPath 60 rotate AsteriskPath fill
  } def
%
  /Basterp {50 250 220 500 0 500 curveto -220 500 -50 250 -50 30 cos 100 mul curveto} def
  /BoldAsteriskPath {
    50 30 cos 100 mul moveto  Basterp
    60 rotate Basterp 60 rotate Basterp
    60 rotate Basterp 60 rotate Basterp
    60 rotate Basterp closepath
  } def
  /BoldAsterisk {BoldAsteriskPath fill} def
  /SolidAsterisk {CirclePath .9 .9 scale BoldAsteriskPath eofill} def
  /CrossPath {
    40 550 moveto -40 550 lineto -40 40 lineto -550 40 lineto
    -550 -40 lineto -40 -40 lineto -40 -550 lineto 40 -550 lineto 
    40 -40 lineto 550 -40 lineto 550 40 lineto 40 40 lineto closepath
  } def
  /BoldCrossPath {80 550 moveto -80 550 lineto -80 80 lineto -550 80 lineto
    -550 -80 lineto -80 -80 lineto -80 -550 lineto 80 -550 lineto 
    80 -80 lineto 550 -80 lineto 550 80 lineto 80 80 lineto closepath
  } def
  /Add {CrossPath fill} def
  /Mul {45 rotate CrossPath fill} def
  /BoldAdd {BoldCrossPath fill} def
  /BoldMul {45 rotate BoldCrossPath fill} def
  /Oplus {CirclePath .9 .9 scale CirclePath eofill .775 .775 scale CrossPath fill } def 
  /SolidOplus {CirclePath .775 .775 scale BoldCrossPath eofill} def 
  /BOplus {CirclePath .8 .8 scale CirclePath eofill .775 .775 scale BoldCrossPath fill} def 
  /Otimes {CirclePath .9 .9 scale CirclePath eofill 45 rotate .775 .775 scale CrossPath fill} def 
  /BOtimes {CirclePath .8 .8 scale CirclePath eofill 45 rotate .775 .775 scale BoldCrossPath fill } def 
  /SolidOtimes {CirclePath 45 rotate .775 .775 scale BoldCrossPath eofill} def 
  /BarPath {40 660 moveto -40 660 lineto -40 -660 lineto 40 -660 lineto closepath} def
  /Bar {BarPath fill} def
  /BoldBarPath {80 660 moveto -80 660 lineto -80 -660 lineto 80 -660 lineto closepath} def
  /BoldBar {BoldBarPath fill} def
  /DiamondPath {0 742.5 moveto -428.5 0 lineto 0 -742.5 lineto 428.5 0 lineto closepath} def
  /SolidDiamond {DiamondPath fill} def
  /Diamond {DiamondPath .865 .865 scale DiamondPath eofill} def
  /BoldDiamond {DiamondPath .73 .73 scale DiamondPath eofill} def
%%%
  /.notdef { } def
end
%
/BuildGlyph {
  exch
  begin 		
%  Metrics 1 index get exec 0
    0 0
%      BBoxes 3 index get exec
    -1000 -1000 1000 1000
%     -571.5 -742.5 571.5 742.5
    setcachedevice
    CharProcs begin load exec end
  end
} def
%
/BuildChar {
  1 index /Encoding get exch get
  1 index /BuildGlyph get exec
} bind def
%
end
/PSTricksDotFont exch definefont pop
%
%% end

%%EndProcSet
%%BeginProcSet: pst-grad.pro 0 0
%!
% PostScript prologue for pst-grad.tex.
% Version 1.05, 2006/11/04 
% prepared by Herbert Voss
% For copying restrictions, see pstricks.tex.
%
% For the PSTricks gradient fillstyle.%
% Based on some EPS files by leeweyr!bill@nuchat.sccsi.com (W. R. Lee).%
% Syntax:% D.G. modification begin - Apr.  9, %1998
%%%%%% R0 G0 B0 R1 G1 B1 NumLines MidPoint Angle GradientFill
%   ifGradientCircle GradientScale %GradientPosX GradientPosY
%     R0 G0 B0 R1 G1 B1 NumLines MidPoint %Angle GradientFill
% D.G. modification end
%
/tx@GradientDict 40 dict def
tx@GradientDict begin
/GradientFill {
 /ifCMYK exch def   % do we have rgb or cmyk? hv 1.06
 rotate
 /MidPoint ED
 /NumLines ED
 ifCMYK {
    /LastBlack ED	% 1.06
    /LastYellow ED	% 1.06
    /LastMagenta ED	% 1.06
    /LastCyan ED	% 1.06
    /FirstBlack ED	% 1.06
    /FirstYellow ED	% 1.06
    /FirstMagenta ED	% 1.06
    /FirstCyan ED	% 1.06
 }{ /LastBlue ED
    /LastGreen ED
    /LastRed ED
    /FirstBlue ED
    /FirstGreen ED
    /FirstRed ED
 } ifelse
 /GradientPosY ED
 /GradientPosX ED
 /GradientScale ED
 /ifGradientCircle ED
 % This avoids gaps due to rounding errors:
 clip
 pathbbox           %leave llx,lly,urx,ury on stack
 4 copy /ury ED /urx ED /lly ED /llx ED
 /y ED /x ED
 ifGradientCircle
   { 0 GradientPosX eq { 0 GradientPosX eq {2 copy translate} if } if }
   {2 copy translate} ifelse
 y sub neg /y ED
 x sub neg /x ED  % This avoids gaps due to rounding errors:
 ifCMYK {				% 1.06
    LastCyan FirstCyan add 2 div	% 1.06
    LastMagenta FirstMagenta add 2 div	% 1.06
    LastYellow FirstYellow add 2 div	% 1.06
    LastBlack FirstBlack add 2 div	% 1.06
    setcmykcolor			% 1.06
  }{
    LastRed FirstRed add 2 div
    LastGreen FirstGreen add 2 div
    LastBlue FirstBlue add 2 div
    setrgbcolor
  } ifelse
 ifGradientCircle
   { /YSizePerLine y NumLines div def
     /CurrentY y 2 div def
     /MidLine NumLines 2 div 1 MidPoint sub mul abs cvi def
   }{
     fill
     /YSizePerLine y NumLines div def
     /CurrentY 0 def
     /MidLine NumLines 1 MidPoint sub mul abs cvi def
   } ifelse
 MidLine NumLines 2 sub gt 
   { /MidLine NumLines def }
   { MidLine 2 lt { /MidLine 0 def } if } ifelse
 MidLine 0 gt {
  ifCMYK {
    /Cyan FirstCyan def
    /Magenta FirstMagenta def
    /Yellow FirstYellow def
    /Black FirstBlack def
    /CyanIncrement LastCyan FirstCyan sub MidLine 1 sub div def
    /MagentaIncrement LastMagenta FirstMagenta sub MidLine 1 sub div def
    /YellowIncrement LastYellow FirstYellow sub MidLine 1 sub div def
    /BlackIncrement LastBlack FirstBlack sub MidLine 1 sub div def
  }{
    /Red FirstRed def
    /Green FirstGreen def
    /Blue FirstBlue def
    /RedIncrement LastRed FirstRed sub MidLine 1 sub div def
    /GreenIncrement LastGreen FirstGreen sub MidLine 1 sub div def
    /BlueIncrement LastBlue FirstBlue sub MidLine 1 sub div def
  } ifelse
  MidLine { GradientLoop } repeat
 } if
 MidLine NumLines lt {
  ifCMYK {
    /Cyan LastCyan def
    /Magenta LastMagenta def
    /Yellow LastYellow def
    /Black LastBlack def
    /CyanIncrement FirstCyan LastCyan sub NumLines MidLine sub 1 sub div def
    /MagentaIncrement FirstMagenta LastMagenta sub NumLines MidLine sub 1 sub div def
    /YellowIncrement FirstYellow LastYellow sub NumLines MidLine sub 1 sub div def
    /BlackIncrement FirstBlack LastBlack sub NumLines MidLine sub 1 sub div def
  }{
    /Red LastRed def
    /Green LastGreen def
    /Blue LastBlue def
    /RedIncrement FirstRed LastRed sub NumLines MidLine sub 1 sub div def
    /GreenIncrement FirstGreen LastGreen sub NumLines MidLine sub 1 sub div def
    /BlueIncrement FirstBlue LastBlue sub NumLines MidLine sub 1 sub div def
  } ifelse
  NumLines MidLine sub { GradientLoop } repeat  
 } if
} def/GradientLoop {
% D.G. modification begin - Jul. 23, 1997 / Apr.  9, 1998
  ifGradientCircle
   {CurrentY 0 gt {
% The default center used is the center of the bounding box of the object
      0 GradientPosX eq        {0 GradientPosX eq
           {/GradientPosX urx llx sub 2 div def
            /GradientPosY ury lly sub 2 div def} if} if
      GradientPosX GradientPosY CurrentY GradientScale mul 0 360 arc
      ifCMYK { Cyan Magenta Yellow Black setcmykcolor }
           { Red Green Blue setrgbcolor } ifelse 
      fill
      /CurrentY CurrentY YSizePerLine sub def
      ifCMYK {
        /Cyan Cyan CyanIncrement add def
        /Magenta Magenta MagentaIncrement add def
        /Yellow Yellow YellowIncrement add def
        /Black Black BlackIncrement add def
      }{	
        /Blue Blue BlueIncrement add def
        /Green Green GreenIncrement add def
        /Red Red RedIncrement add def
      } ifelse
  } if }   { 0 CurrentY moveto    x 0 rlineto
    0 YSizePerLine rlineto    x neg 0 rlineto    closepath
      ifCMYK { Cyan Magenta Yellow Black setcmykcolor }
           { Red Green Blue setrgbcolor } ifelse 
      fill    
      /CurrentY CurrentY YSizePerLine add def
      ifCMYK {
        /Cyan Cyan CyanIncrement add def
        /Magenta Magenta MagentaIncrement add def
        /Yellow Yellow YellowIncrement add def
        /Black Black BlackIncrement add def
      }{	
        /Blue Blue BlueIncrement add def
        /Green Green GreenIncrement add def
        /Red Red RedIncrement add def
      } ifelse
      } ifelse% D.G. modification end
    }def
%
/GradientFillHSB { %	hv 2006-11-04
  rotate
  /MidPoint ED
  /NumLines ED
  /LastBrightness ED
  /LastSaturation ED
  /LastHue ED
  /FirstBrightness ED
  /FirstSaturation ED
  /FirstHue ED
  % This avoids gaps due to rounding errors:
  clip
  pathbbox           %leave llx,lly,urx,ury on stack
  /y ED /x ED
  2 copy translate
  y sub neg /y ED
  x sub neg /x ED
  % This avoids gaps due to rounding errors:
  LastHue FirstHue add 2 div
  LastSaturation FirstSaturation add 2 div
  LastBrightness FirstBrightness add 2 div
  sethsbcolor
  fill
  /YSizePerLine y NumLines div def
  /CurrentY 0 def
  /MidLine NumLines 1 MidPoint sub mul abs cvi def
  MidLine NumLines 2 sub gt
  { /MidLine NumLines def }
  { MidLine 2 lt { /MidLine 0 def } if }
  ifelse
  MidLine 0 gt
  {
    /Hue FirstHue def
    /Saturation FirstSaturation def
    /Brightness FirstBrightness def
    /HueIncrement LastHue FirstHue sub MidLine 1 sub div def
    /SaturationIncrement LastSaturation FirstSaturation sub MidLine 1 sub
                         div def
    /BrightnessIncrement LastBrightness FirstBrightness sub MidLine 1 sub
                         div def
    MidLine { GradientLoopHSB } repeat
  } if
  MidLine NumLines lt
  {
    /Hue LastHue def
    /Saturation LastSaturation def
    /Brightness LastBrightness def
    /HueIncrement FirstHue LastHue sub NumLines MidLine sub 1 sub div def
    /SaturationIncrement FirstSaturation LastSaturation sub
                         NumLines MidLine sub 1 sub div def
    /BrightnessIncrement FirstBrightness LastBrightness sub
                         NumLines MidLine sub 1 sub div def
    NumLines MidLine sub { GradientLoopHSB } repeat
  } if
} def
/GradientLoopHSB {
  0 CurrentY moveto
  x 0 rlineto
  0 YSizePerLine rlineto
  x neg 0 rlineto
  closepath
  Hue Saturation Brightness sethsbcolor fill
  /CurrentY CurrentY YSizePerLine add def
  /Brightness Brightness BrightnessIncrement add def
  /Saturation Saturation SaturationIncrement add def
  /Hue Hue HueIncrement add def
} def
%
end
%
% END pst-grad.pro

%%EndProcSet
%%BeginProcSet: pst-node.pro 0 0
% $Id: pst-node.pro 805 2013-07-11 13:18:11Z herbert $
%%
%% PostScript prologue for pst-node.tex.
%% Version 1.14, 2012/09/18.
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%
tx@Dict begin 			% from main pstricks dict
 /T /translate load def 
 /CP /currentpoint load def 
% /startGlobal { true setglobal globaldict begin } bind def
% /endGlobal { end false setglobal } bind def
end
/tx@NodeDict 400 dict def tx@NodeDict begin
/NewNode { % on stack: { x y } boolean N@name type InitXnode 
  gsave 
  NodeScale                     % a bugfix for xelatex, it's empty for dvips
  /next exch def 		% { x y } boolean N@name type  
  dict dup 			% { x y } boolean N@name dict dict
  3 1 roll def 			% { x y } boolean dict N@name dict def
  exch { dup 3 1 roll def } if  % { x y } dict boolean
  begin 			% { x y } dict begin
  tx@Dict begin 
    STV CP T exec 		% set scaling
  end 
  /NodeMtrx CM def 		% save CM
  next 				% InitXNode
  end
  grestore 
} def
%
/InitPnode { 
  /Y ED /X ED 
  /NodePos { NodeSep Cos mul NodeSep Sin mul } def
} def
%
/InitCnode { 
  /r ED /Y ED /X ED 
  /NodePos { NodeSep r add dup Cos mul exch Sin mul } def 
} def
%
/GetRnodePos { 
  Cos 0 gt { /dx r NodeSep add def } { /dx l NodeSep sub def } ifelse 
  Sin 0 gt { /dy u NodeSep add def } { /dy d NodeSep sub def } ifelse 
  dx Sin mul abs dy 
  Cos mul abs gt { dy Cos mul Sin div dy } { dx dup Sin mul Cos Div } ifelse 
} def
%
/InitRnode { 
  /Y ED /X ED X sub /r ED /l X neg def Y add neg /d ED Y sub /u ED 
  /NodePos { GetRnodePos } def 
} def
%
/DiaNodePos { 
  w h mul w Sin mul abs h Cos mul abs add Div NodeSep add dup
  Cos mul exch Sin mul 
} def
%
/TriNodePos { 
  Sin s lt 
    { d NodeSep sub dup Cos mul Sin Div exch } 
    { w h mul w Sin mul h Cos abs mul add Div 
      NodeSep add dup Cos mul exch Sin mul 
    } ifelse 
} def
%
/InitTriNode { 
  sub 2 div exch 
  2 div exch 
  2 copy T 
  2 copy 4 index index /d ED 
  pop pop pop pop 
  -90 mul rotate 
  /NodeMtrx CM def 
  /X 0 def /Y 0 def 
  d sub abs neg /d ED 
  d add /h ED 
  2 div h mul h d sub Div /w ED 
  /s d w Atan sin def 
  /NodePos { TriNodePos } def 
} def
%
/OvalNodePos { 
  /ww w NodeSep add def 
  /hh h NodeSep add def 
  Sin ww mul Cos hh mul Atan dup cos ww mul exch sin hh mul 
} def
%
/GetCenter { begin X Y NodeMtrx transform CM itransform end } def
%
/XYPos { 
  dup sin exch cos Do 
  /Cos ED /Sin ED /Dist ED 
  Cos 0 gt 
    { Dist Dist Sin mul Cos div }
    { Cos 0 lt 
      { Dist neg Dist Sin mul Cos div neg }
      { 0 Dist Sin mul } ifelse 
    } ifelse 
  Do 
} def
%
/GetEdge {
  dup 0 eq 
    { pop begin 1 0 NodeMtrx dtransform 
      CM idtransform 
      exch atan sub 
      dup 
      sin /Sin ED 
      cos /Cos ED 
      /NodeSep ED 
      NodePos NodeMtrx dtransform CM idtransform end }
    { 1 eq {{exch}} {{}} ifelse /Do ED pop XYPos } ifelse 
} def
%
/AddOffset { 
  1 index 0 eq 
    { pop pop } 
    { 2 copy 5 2 roll cos mul add 4 1 roll sin mul sub exch } ifelse 
} def
%
/GetEdgeA { 
  NodeSepA AngleA NodeA NodeSepTypeA GetEdge 
  OffsetA AngleA AddOffset 
  yA add /yA1 ED 
  xA add /xA1 ED 
} def
%
/GetEdgeB { 
  NodeSepB AngleB NodeB NodeSepTypeB GetEdge 
  OffsetB AngleB AddOffset 
  yB add /yB1 ED 
  xB add /xB1 ED 
} def
%
/GetArmA { 
  ArmTypeA 0 eq 
    { /xA2 ArmA AngleA cos mul xA1 add def 
      /yA2 ArmA AngleA sin mul yA1 add def } 
    { ArmTypeA 1 eq {{exch}} {{}} ifelse 
      /Do ED 
      ArmA AngleA XYPos OffsetA AngleA AddOffset 
      yA add /yA2 ED 
      xA add /xA2 ED } ifelse 
} def
%
/GetArmB { 
  ArmTypeB 0 eq 
    { /xB2 ArmB AngleB cos mul xB1 add def 
      /yB2 ArmB AngleB sin mul yB1 add def } 
    { ArmTypeB 1 eq {{exch}} {{}} ifelse 
      /Do ED
      ArmB AngleB XYPos OffsetB AngleB AddOffset 
      yB add /yB2 ED 
      xB add /xB2 ED } ifelse 
} def
%
/InitNC { 
  /b ED /a ED % second and first node
  /NodeSepTypeB ED /NodeSepTypeA ED 
  /NodeSepB ED /NodeSepA ED 
  /OffsetB ED /OffsetA ED 
  tx@NodeDict a known tx@NodeDict b known and dup { 
    /NodeA a load def 
    /NodeB b load def 
    NodeA GetCenter /yA ED /xA ED 
    NodeB GetCenter /yB ED /xB ED } if 
} def
%
/LPutLine { 
  4 copy 
  3 -1 roll sub neg 3 1 roll sub Atan /NAngle ED 
  1 t sub mul 
  3 1 roll 1 t sub mul 
  4 1 roll t mul add /Y ED 
  t mul add /X ED 
} def
%
/LPutLines { 
  mark LPutVar counttomark 2 div 1 sub /n ED 
%  t floor dup n gt 
  t floor dup n ge 		% to allow npos<= hv 2008-08-14
  { pop n 1 sub /t 1 def } { dup t sub neg /t ED } ifelse 
  cvi 2 mul { pop } repeat 
  LPutLine 
  cleartomark 
} def
%
/BezierMidpoint { 
  /y3 ED /x3 ED /y2 ED /x2 ED /y1 ED /x1 ED /y0 ED /x0 ED /t ED 
  /cx x1 x0 sub 3 mul def 
  /cy y1 y0 sub 3 mul def 
  /bx x2 x1 sub 3 mul cx sub def 
  /by y2 y1 sub 3 mul cy sub def 
  /ax x3 x0 sub cx sub bx sub def 
  /ay y3 y0 sub cy sub by sub def 
  ax t 3 exp mul bx t t mul mul add 
  cx t mul add x0 add ay t 3 exp mul 
  by t t mul mul add cy t mul add
  y0 add 3 ay t t mul mul mul 2 
  by t mul mul add cy add 3 ax t t mul mul mul 
  2 bx t mul mul add cx add atan /NAngle ED 
  /Y ED /X ED 
} def
%
/HPosBegin { yB yA ge { /t 1 t sub def } if /Y yB yA sub t mul yA add def
} def
/HPosEnd { /X Y yyA sub yyB yyA sub Div xxB xxA sub mul xxA add def
/NAngle yyB yyA sub xxB xxA sub Atan def } def
/HPutLine { HPosBegin /yyA ED /xxA ED /yyB ED /xxB ED HPosEnd  } def
/HPutLines { HPosBegin yB yA ge { /check { le } def } { /check { ge } def
} ifelse /xxA xA def /yyA yA def mark xB yB LPutVar { dup Y check { exit
} { /yyA ED /xxA ED } ifelse } loop /yyB ED /xxB ED cleartomark HPosEnd 
} def
/VPosBegin { xB xA lt { /t 1 t sub def } if /X xB xA sub t mul xA add def
} def
/VPosEnd { /Y X xxA sub xxB xxA sub Div yyB yyA sub mul yyA add def
/NAngle yyB yyA sub xxB xxA sub Atan def } def
/VPutLine { VPosBegin /yyA ED /xxA ED /yyB ED /xxB ED VPosEnd  } def
/VPutLines { VPosBegin xB xA ge { /check { le } def } { /check { ge } def
} ifelse /xxA xA def /yyA yA def mark xB yB LPutVar { 1 index X check {
exit } { /yyA ED /xxA ED } ifelse } loop /yyB ED /xxB ED cleartomark
VPosEnd  } def
/HPutCurve { gsave newpath /SaveLPutVar /LPutVar load def LPutVar 8 -2
roll moveto curveto flattenpath /LPutVar [ {} {} {} {} pathforall ] cvx
def grestore exec /LPutVar /SaveLPutVar load def } def

/NCCoor { 
  /AngleA yB yA sub xB xA sub Atan def 
  /AngleB AngleA 180 add def
  GetEdgeA GetEdgeB 
  /LPutVar [ xB1 yB1 xA1 yA1 ] cvx def 
  /LPutPos { LPutVar LPutLine } def 
  /HPutPos { LPutVar HPutLine } def 
  /VPutPos { LPutVar VPutLine } def 
  LPutVar 
} def
%
/NCLine { 
  NCCoor 
  tx@Dict begin 
  ArrowA CP 4 2 roll 
  ArrowB 
  lineto pop pop
  end 
} def
%
/NCLines { 
  false NArray 
  n 0 eq 
    { NCLine } 
    { 2 copy yA sub exch xA sub Atan /AngleA ED 
      n 2 mul dup index exch index yB sub exch xB sub 
      Atan /AngleB ED 
      GetEdgeA GetEdgeB 
      /LPutVar [ xB1 yB1 n 2 mul 4 add 4 roll xA1 yA1 ] cvx def 
      mark LPutVar 
      tx@Dict begin false Line end 
      /LPutPos { LPutLines } def 
      /HPutPos { HPutLines } def 
      /VPutPos { VPutLines } def 
    } ifelse 
} def
%
/NCCurve { 
  GetEdgeA 
  GetEdgeB 
  xA1 xB1 sub yA1 yB1 sub Pyth 2 div dup 3 -1
roll mul /ArmA ED mul /ArmB ED /ArmTypeA 0 def /ArmTypeB 0 def GetArmA
GetArmB xA2 yA2 xA1 yA1 tx@Dict begin ArrowA end xB2 yB2 xB1 yB1 tx@Dict
begin ArrowB end curveto /LPutVar [ xA1 yA1 xA2 yA2 xB2 yB2 xB1 yB1 ]
cvx def /LPutPos { t LPutVar BezierMidpoint } def /HPutPos { { HPutLines
} HPutCurve } def /VPutPos { { VPutLines } HPutCurve } def } def
%
/NCAngles { 
  GetEdgeA GetEdgeB GetArmA GetArmB 
  /mtrx AngleA matrix rotate def 
  xA2 yA2 mtrx transform pop 
  xB2 yB2 mtrx transform exch pop 
  mtrx itransform 
  /y0 ED /x0 ED 
  mark ArmB 0 ne { xB1 yB1 } if 
  xB2 yB2 x0 y0 xA2 yA2 
  ArmA 0 ne { xA1 yA1 } if 
  tx@Dict begin false Line end 
  /LPutVar [ xB1 yB1 xB2 yB2 x0 y0 xA2 yA2 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def } def
%
/NCAngle { 
  GetEdgeA GetEdgeB GetArmB 
  /mtrx AngleA matrix rotate def 
  xB2 yB2 mtrx itransform pop xA1 yA1 mtrx itransform exch pop mtrx transform
  /y0 ED /x0 ED 
  mark 
  ArmB 0 ne { xB1 yB1 } if 
  xB2 yB2 x0 y0 xA1 yA1
  tx@Dict begin false Line end 
  /LPutVar [ xB1 yB1 xB2 yB2 x0 y0 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def 
} def
%
/NCBar { 
  GetEdgeA GetEdgeB GetArmA GetArmB 
  /mtrx AngleA matrix rotate def
  xA2 yA2 mtrx itransform pop 
  xB2 yB2 mtrx itransform pop 
  sub dup 0 mtrx transform 
  3 -1 roll 0 gt 
    { /yB2 exch yB2 add def /xB2 exch xB2 add def }
    { /yA2 exch neg yA2 add def /xA2 exch neg xA2 add def } ifelse 
  mark 
  ArmB 0 ne { xB1 yB1 } if 
  xB2 yB2 xA2 yA2 ArmA 0 ne { xA1 yA1 } if 
  tx@Dict begin false Line end 
  /LPutVar [ xB1 yB1 xB2 yB2 xA2 yA2 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def 
} def
%
/NCDiag { 
  /lineAngle ED
  GetEdgeA GetEdgeB GetArmA GetArmB mark
  lineAngle abs 0 gt {
    /xTemp xA2 10 add def
    /yTemp yA2 lineAngle dup sin exch cos div 10 mul add def
    /dY1 yTemp yA2 sub def
    /dX1 xTemp xA2 sub def
    /dY2 yB2 yB1 sub def
    /dX2 xB2 xB1 sub def
    dX1 abs 0.01 lt {
      /m2 dY2 dX2 div def
      /xB2 xA2 def
      /yB2 xA2 xB1 sub m2 mul yB1 add def
    }{
      dX2 abs 0.01 lt {
        /m1 dY1 dX1 div def
        /xB2 xB1 def
        /yB2 xB1 xA2 sub m1 mul yA2 add def
      }{%
        /m1 dY1 dX1 div def
        /m2 dY2 dX2 div def
        /xB2 m1 xA2 mul m2 xB1 mul sub yA2 sub yB1 add m1 m2 sub div def
        /yB2 xB2 xA2 sub m1 mul yA2 add def
      } ifelse
    } ifelse
  } if
  ArmB 0 ne { xB1 yB1 } if
  xB2 yB2 xA2 yA2 
  ArmA 0 ne { xA1 yA1 } if 
  tx@Dict begin false Line end
  /LPutVar [ xB1 yB1 xB2 yB2 xA2 yA2 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def 
%
%  GetEdgeA GetEdgeB GetArmA GetArmB mark 
%  ArmB 0 ne { xB1 yB1 } if
%  xB2 yB2 xA2 yA2 
%  ArmA 0 ne { xA1 yA1 } if 
%  tx@Dict begin false Line end
%  /LPutVar [ xB1 yB1 xB2 yB2 xA2 yA2 xA1 yA1 ] cvx def 
%  /LPutPos { LPutLines } def 
%  /HPutPos { HPutLines } def 
%  /VPutPos { VPutLines } def 
} def
%
/NCDiagg { 
  /lineAngle ED
  GetEdgeA GetArmA 
  lineAngle abs 0 gt 
    { lineAngle }
    { yB yA2 sub xB xA2 sub Atan 180 add } ifelse 
  /AngleB ED
  GetEdgeB mark
  lineAngle abs 0 gt {
    /dY2 yA2 yA1 sub def
    /dX2 xA2 xA1 sub def
    lineAngle abs 90 eq {
      /m2 dY2 dX2 div def
      /yA2 xB xA2 sub m2 mul yA2 add def
      /xA2 xB def
    }{
      /m1 lineAngle dup sin exch cos div def % tan alpha
      dX2 abs 0.01 lt {
        /yA2 xA1 xB sub m1 mul yB add def
        /xA2 xA1 def
      }{%
        /m2 dY2 dX2 div def
        /xA2 m1 xB mul m2 xA2 mul sub yA2 add yB sub m1 m2 sub div def
        /yA2 xA2 xB sub m1 mul yB add def
      } ifelse
    } ifelse
  } if
  xB1 yB1 xA2 yA2
  ArmA 0 ne { xA1 yA1 } if
  tx@Dict begin false Line end
  /LPutVar [ xB1 yB1 xA2 yA2 xA1 yA1 ] cvx def
  /LPutPos { LPutLines } def
  /HPutPos { HPutLines } def
  /VPutPos { VPutLines } def
%
%  GetEdgeA GetArmA 
%  yB yA2 sub xB xA2 sub Atan 180 add /AngleB ED
%  GetEdgeB 
%  mark 
%  xB1 yB1 xA2 yA2 
%  ArmA 0 ne { xA1 yA1 } if 
%  tx@Dict begin false Line end 
%  /LPutVar [ xB1 yB1 xA2 yA2 xA1 yA1 ] cvx def 
%  /LPutPos { LPutLines } def 
%  /HPutPos { HPutLines } def 
%  /VPutPos { VPutLines } def 
} def
%
/NCLoop { 
  GetEdgeA GetEdgeB GetArmA GetArmB 
  /mtrx AngleA matrix rotate def 
  xA2 yA2 mtrx transform loopsize add /yA3 ED /xA3 ED 
  /xB3 xB2 yB2 mtrx transform pop def 
  xB3 yA3 mtrx itransform /yB3 ED /xB3 ED 
  xA3 yA3 mtrx itransform /yA3 ED /xA3 ED 
  mark ArmB 0 ne { xB1 yB1 } if 
  xB2 yB2 xB3 yB3 xA3 yA3 xA2 yA2 ArmA 0 ne { xA1 yA1 } if 
  tx@Dict begin false Line end 
  /LPutVar [ xB1 yB1 xB2 yB2 xB3 yB3 xA3 yA3 xA2 yA2 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def 
} def
%
% DG/SR modification begin - May 9, 1997 - Patch 1
%/NCCircle { 0 0 NodesepA nodeA \tx@GetEdge pop xA sub 2 div dup 2 exp r
%r mul sub abs sqrt atan 2 mul /a ED r AngleA 90 add PtoC yA add exch xA add
%exch 2 copy /LPutVar [ 4 2 roll r AngleA ] cvx def /LPutPos { LPutVar t 360
%mul add dup 5 1 roll 90 sub \tx@PtoC 3 -1 roll add /Y ED add /X ED /NAngle ED
%
/NCCircle { 
  NodeSepA 0 NodeA 0 GetEdge pop 
  2 div dup 2 exp r r mul sub abs sqrt 
  atan 2 mul /a ED 
  r AngleA 90 add PtoC yA add exch xA add 
  exch 2 copy 
  /LPutVar [ 4 2 roll r AngleA ] cvx def 
  /LPutPos { 
    LPutVar t 360 mul add dup 5 1 roll 90 sub PtoC 
    3 -1 roll add 
    /Y ED add /X ED /NAngle ED
% DG/SR modification end
  } def 
  /HPutPos { LPutPos } def 
  /VPutPos { LPutPos } def 
  r AngleA 90 sub a add AngleA 270 add a sub 
  tx@Dict begin 
  /angleB ED /angleA ED /r ED 
  /c 57.2957 r Div def 
  /y ED /x ED 
} def
%
/NCBox { 
  /d ED /h ED 
  /AngleB yB yA sub xB xA sub Atan def 
  /AngleA AngleB 180 add def 
  GetEdgeA GetEdgeB 
  /dx d AngleB sin mul def 
  /dy d AngleB cos mul neg def 
  /hx h AngleB sin mul neg def 
  /hy h AngleB cos mul def 
  /LPutVar [ 
    xA1 hx add yA1 hy add xB1 hx add yB1 hy add 
    xB1 dx add yB1 dy add xA1 dx add yA1 dy add ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { xB yB xA yA LPutLine } def 
  /VPutPos { HPutPos } def 
  mark 
  LPutVar tx@Dict begin false Polygon end 
} def
%
/NCArcBox { 
  /l ED neg /d ED /h ED /a ED 
  /AngleA yB yA sub xB xA sub Atan def 
  /AngleB AngleA 180 add def 
  /tA AngleA a sub 90 add def 
  /tB tA a 2 mul add def 
  /r xB xA sub tA cos tB cos sub Div dup 0 eq { pop 1 } if def
  /x0 xA r tA cos mul add def 
  /y0 yA r tA sin mul add def 
  /c 57.2958 r div def 
  /AngleA AngleA a sub 180 add def 
  /AngleB AngleB a add 180 add def
  GetEdgeA GetEdgeB 
  /AngleA tA 180 add yA yA1 sub xA xA1 sub Pyth c mul sub def 
  /AngleB tB 180 add yB yB1 sub xB xB1 sub Pyth c mul add def 
  l 0 eq { 
    x0 y0 r h add AngleA AngleB arc x0 y0 r d add AngleB AngleA arcn 
  }{ 
    x0 y0 translate 
    /tA AngleA l c mul add def 
    /tB AngleB l c mul sub def
    0 0 r h add tA tB arc r h add 
    AngleB PtoC r d add 
    AngleB PtoC 2 copy 
    6 2 roll l arcto 4 { pop } repeat 
    r d add tB PtoC l arcto 4 { pop } repeat 
    0 0 r d add tB tA arcn r d add 
    AngleA PtoC r h add 
    AngleA PtoC 2 copy 6 2 roll 
    l arcto 4 { pop } repeat 
    r h add tA PtoC l arcto 4 { pop } repeat 
  } ifelse 
  closepath 
  /LPutVar [ x0 y0 r AngleA AngleB h d ] cvx def 
  /LPutPos { 
    LPutVar /d ED /h ED 
    /AngleB ED /AngleA ED 
    /r ED /y0 ED /x0 ED 
    t 1 le { 
      r h add AngleA 1 t sub mul AngleB t mul add dup 90 add /NAngle ED PtoC 
    }{t 2 lt { 
        /NAngle AngleB 180 add def r 2 t sub 
        h mul t 1 sub d mul add add AngleB PtoC 
      }{ 
        t 3 lt { 
          r d add AngleB 3 t sub mul AngleA 2 t sub
          mul add dup 90 sub /NAngle ED PtoC 
        }{ 
          /NAngle AngleA 180 add def 
          r 4 t sub d mul t 3 sub h mul add add AngleA PtoC 
        } ifelse 
      } ifelse 
    } ifelse
    y0 add /Y ED x0 add /X ED 
  } def 
  /HPutPos { LPutPos } def 
  /VPutPos { LPutPos } def 
} def
%
/Tfan { /AngleA yB yA sub xB xA sub Atan def GetEdgeA w xA1 xB sub yA1 yB
sub Pyth Pyth w Div CLW 2 div mul 2 div dup AngleA sin mul yA1 add /yA1
ED AngleA cos mul xA1 add /xA1 ED /LPutVar [ xA1 yA1 m { xB w add yB xB
w sub yB } { xB yB w sub xB yB w add } ifelse xA1 yA1 ] cvx def /LPutPos
{ LPutLines } def /VPutPos@ { LPutVar flag { 8 4 roll pop pop pop pop }
{ pop pop pop pop 4 2 roll } ifelse } def /VPutPos { VPutPos@ VPutLine }
def /HPutPos { VPutPos@ HPutLine } def mark LPutVar tx@Dict begin
/ArrowA { moveto } def /ArrowB { } def false Line closepath end } def
%
/LPutCoor { 
  NAngle 
  tx@Dict begin /NAngle ED end 
  gsave 
  CM STV 
  CP Y sub neg exch X sub neg exch moveto 
  setmatrix CP 
  grestore 
} def
%
/LPut { 
  tx@NodeDict /LPutPos known 
    { LPutPos } { CP /Y ED /X ED /NAngle 0 def } ifelse 
  LPutCoor  
} def
%
/HPutAdjust { 
  Sin Cos mul 0 eq 
    { 0 } 
    { d Cos mul Sin div flag not { neg } if 
      h Cos mul Sin div flag { neg } if 
      2 copy gt { pop } { exch pop } ifelse 
    } ifelse 
  s add flag { r add neg }{ l add } ifelse 
  X add /X ED 
} def
%
/VPutAdjust { 
  Sin Cos mul 
  0 eq 
    { 0 }
    { l Sin mul Cos div flag { neg } if
      r Sin mul Cos div flag not { neg } if 
      2 copy gt { pop } { exch pop } ifelse 
    } ifelse 
  s add flag { d add } { h add neg } ifelse 
  Y add /Y ED 
} def
%
%
end
%
% END pst-node.pro

%%EndProcSet
%%BeginProcSet: pst-coil.pro 0 0
%!ps
% PostScript prologue for pst-coil.tex.
% Version 1.06, 2011/09/18
% For distribution, see pstricks.tex.
%
/tx@CoilDict 40 dict def tx@CoilDict begin
/CoilLoop { 
  /t ED 
  t sin AspectSin mul t 180 div AspectCos mul add t cos lineto } def
/Coil { 
  /Inc ED 
  dup sin /AspectSin ED 
  cos /AspectCos ED 
  /ArmB ED 
  /ArmA ED
  /h ED /w ED /y1 ED /x1 ED /y0 ED /x0 ED 
  x0 y0 translate y1 y0 sub x1 x0 sub 2 copy Pyth 
  /TotalLength ED 
  Atan rotate 
  /BeginAngle ArmA AspectCos Div w h mul Div 360 mul def 
  /EndAngle TotalLength ArmB sub AspectCos Div
    w h mul Div 360 mul def 
  1 0 0 0 ArrowA ArmA 0 lineto 
  /mtrx CM def 
  w h mul 2 Div w 2 Div scale BeginAngle Inc 
  EndAngle { CoilLoop } for
  EndAngle CoilLoop mtrx setmatrix TotalLength ArmB sub 0 lineto CP
% DG/SR modification begin - Jun.  2, 1998 - Patch 1 (from Michael Vulis)
% TotalLength 0 ArrowB lineto } def
  TotalLength 0 ArrowB lineto
  pop pop pop pop } def
% DG/SR modification end
%
/Sin { 
  /Func ED
  /PointsPerPeriod ED
  /ArmB ED 
  /ArmA ED
  /Amplitude ED 
  /roundValue ED
  /relativePeriod ED 
  /Periods ED 
  /y1 ED /x1 ED /y0 ED /x0 ED 
  x0 y0 translate y1 y0 sub x1 x0 sub 2 copy Pyth 
  dup /TotalLength ED
  ArmA sub ArmB sub /SinLength ED 
  Atan rotate 
  1 0 0 0 ArrowA ArmA 0 lineto 
  /mtrx CM def 
  relativePeriod 
    {} 
    { SinLength Periods div 
      roundValue dup 0 eq { pop cvi } { 1 eq { round } if } ifelse
      /Periods ED } ifelse
  /dxStep SinLength 360 div def         % the default step for x pos
  /xStep 360 PointsPerPeriod div def    % the step for the for loop
  1 xStep 360 {                         % PointsPerPeriod times
    dup dxStep mul ArmA add exch        % x pos and value for the func
    Periods mul Func Amplitude mul lineto
  } for
  mtrx setmatrix TotalLength ArmB sub 0 lineto CP
  TotalLength 0 ArrowB lineto
  pop pop pop pop 
} def
%
/AltCoil { 
  /Inc ED 
  dup sin /AspectSin ED 
  cos /AspectCos ED /h ED /w ED /EndAngle ED /BeginAngle ED 
  /mtrx CM def 
  w h mul 2 Div w 2 Div scale BeginAngle sin AspectSin mul 
  BeginAngle 180 div AspectCos mul add BeginAngle cos 
  /lineto load stopped { moveto } if 
  BeginAngle Inc EndAngle { CoilLoop } for 
  EndAngle CoilLoop mtrx setmatrix } def
/ZigZag { 15 dict begin 
  /ArmB ED /ArmA ED 
  2 div /w ED 
  w mul /h ED /y1 ED /x1 ED /y0 ED /x0 ED 
  x1 y1 translate y0 y1 sub x0 x1 sub 2 copy Pyth 
  /TotalLength ED
  Atan rotate TotalLength ArmA sub ArmB sub dup h div cvi /n ED n h mul
  sub 2 div dup ArmA add 
  /ArmA ED ArmB add 
  /ArmB ED 
  /x ArmB h 2 div add def 
  mark 0 0 ArmB 0 
  n { x w /w w neg def /x x h add def } repeat
  TotalLength ArmA sub 0 TotalLength 0 
  end } def
%
 /ZigZagCirc { % x0 y0 x1 y1 bow h w ArmA ArmB on stack
  /bow ED 
  /ArmB ED /ArmA ED 
  2 div /w ED 
  w mul /h ED /y1 ED /x1 ED /y0 ED /x0 ED 
  x1 y1 translate %
  y0 y1 sub x0 x1 sub 2 copy Pyth 2 div 
  /HalfLength ED
  Atan /ang ED %angle of A relative to B
  %rotate % so end B is origin and BA is horizontal, A to right
  /theta bow abs HalfLength Atan 2 mul def %halfangular sector for arc
  /theta2 theta 2 mul def % full arc
  %/psi ang 90 sub theta sub def % angle of B from center if bow>0
  /rho HalfLength theta sin div def % radius of circle
  bow 0 gt { /direc 1 def /thetaB ang 90 sub theta sub def } % travel B to A in pos drn
  { /direc -1 def /thetaB ang 90 add theta add def } ifelse % travel B to A in neg drn
  %thetaB=angle from center to B
  rho thetaB 180 add PtoC translate % origin now at center
  /h h rho div RadtoDeg def
  /ArmA ArmA rho div RadtoDeg def /ArmB ArmB rho div RadtoDeg def
  theta2 ArmA sub ArmB sub dup h div cvi /n ED n h mul
  %HalfLength 2 mul ArmA sub ArmB sub dup h div cvi /n ED n h mul
  sub 2 div dup ArmA add 
  /ArmA ED ArmB add /ArmB ED 
  /h h direc mul def % h is now angle increment for half-period
  /rhoo rho w add def /rhoi rho w sub def % outer and inner radii
  /arg thetaB ArmB direc mul add def % argument for 2nd point
%  thetaB = direc = bow = HalfLength = theta = rho = arg = h = n =
  mark rho thetaB  PtoC  rho arg PtoC /arg arg h 2 div add def
  n { w 0 gt { rhoo }{ rhoi } ifelse arg PtoC /w w neg def /arg arg h add def } repeat
  rho thetaB theta2 ArmA sub direc mul add  PtoC rho thetaB theta2 direc mul add PtoC  
  } def 
%
end
% END pst-coil.pro

%%EndProcSet
%%BeginProcSet: pst-text.pro 0 0
%!
% PostScript header file pst-text.pro
% Version 1.0, 2005-11-29 (hv)
% For distribution, see pstricks.tex.

/tx@TextPathDict 40 dict def
tx@TextPathDict begin

% Syntax:  <dist> PathPosition -
% Function: Searches for position of currentpath distance <dist> from
%           beginning. Sets (X,Y)=position, and Angle=tangent.
/PathPosition
{ /targetdist exch def
  /pathdist 0 def
  /continue true def
  /X { newx } def /Y { newy } def /Angle 0 def
  gsave
    flattenpath
    { movetoproc }  { linetoproc } { } { firstx firsty linetoproc }
    /pathforall load stopped { pop pop pop pop /X 0 def /Y 0 def } if
  grestore
} def

/movetoproc { continue { @movetoproc } { pop pop } ifelse } def

/@movetoproc
{ /newy exch def /newx exch def
  /firstx newx def /firsty newy def
} def

/linetoproc { continue { @linetoproc } { pop pop } ifelse } def

/@linetoproc {
  /oldx newx def /oldy newy def
  /newy exch def /newx exch def
  /dx newx oldx sub def
  /dy newy oldy sub def
  /dist dx dup mul dy dup mul add sqrt def
  /pathdist pathdist dist add def
  pathdist targetdist ge
  { pathdist targetdist sub dist div dup
    dy mul neg newy add /Y exch def
    dx mul neg newx add /X exch def
    /Angle dy dx atan def
    /continue false def
  } if
} def

/TextPathShow { 
  /String exch def
  /CharCount 0 def
% hv begin 2005-11-29   1.00
%   String length
%   { String CharCount 1 getinterval ShowChar
%     /CharCount CharCount 1 add def
   /CharSize 1 def
   currentfont /FontType get 0 eq
   { currentfont /FMapType get dup 2 eq exch dup 5 eq exch 9 eq or or
     { /CharSize 2 def} if
   } if
   String length CharSize idiv
   { String CharCount CharSize getinterval ShowChar
     /CharCount CharCount CharSize add def
% hv end 2005-11-29   1.00
  } repeat
} def

% Syntax: <pathlength> <position> InitTextPath -
/InitTextPath
{ gsave
    currentpoint /Y exch def /X exch def
    exch X Hoffset sub sub mul
    Voffset Hoffset sub add
    neg X add /Hoffset exch def
    /Voffset Y def
  grestore
} def

/Transform
{ PathPosition
  dup
  Angle cos mul Y add exch
  Angle sin mul neg X add exch
  translate
  Angle rotate
} def

/ShowChar { 
  /Char exch def
  gsave
    Char end stringwidth
    tx@TextPathDict begin
    2 div /Sy exch def 2 div /Sx exch def

%%%  MV 10-09-99 00:36
    /sc?currentpoint where {pop sc?currentpoint} {currentpoint} ifelse
%   currentpoint

    Voffset sub Sy add exch
    Hoffset sub Sx add
    Transform
    Sx neg Sy neg moveto
    Char end tx@TextPathSavedShow
    tx@TextPathDict begin
  grestore
  Sx 2 mul Sy 2 mul rmoveto
} def
%
end
% END pst-text.pro

%%EndProcSet
%%BeginProcSet: pst-3d.pro 0 0
%% $Id: pst-3d.pro 247 2010-01-04 22:45:42Z herbert $
% PostScript prologue for pst-3d.tex.
% Version 0.01, 2010/01/01 
%
/tx@3Ddict 300 dict def 
tx@3Ddict begin
%
/SetMatrixThreeD {
  dup sin /e ED cos /f ED
  /p3 ED /p2 ED /p1 ED
  p1 0 eq
  { /a 0 def /b p2 0 le { 1 } { -1 } ifelse def
    p3 p2 abs
  }
  { p2 0 eq
    { /a p1 0 lt { -1 } { 1 } ifelse def /b 0 def
      p3 p1 abs
    }
    { p1 dup mul p2 dup mul add sqrt dup
      p1 exch div /a ED
      p2 exch div neg /b ED
      p3 p1 a div
    }
    ifelse
  }
  ifelse
  atan dup sin /c ED cos /d ED
  /Matrix3D
  [
    b f mul c a mul e mul sub
    a f mul c b mul e mul add
    d e mul
    b e mul neg c a mul f mul sub
    a e mul neg c b mul f mul add
    d f mul
  ] def
} def
%
/ProjThreeD {
  /z ED /y ED /x ED
  Matrix3D aload pop
  z mul exch y mul add exch x mul add
  4 1 roll
  z mul exch y mul add exch x mul add
  exch
} def
%
/SetMatrixEmbed {
  SetMatrixThreeD
  Matrix3D aload pop
  /z3 ED /z2 ED /z1 ED /x3 ED /x2 ED /x1 ED
  SetMatrixThreeD
  [
  Matrix3D aload pop
  z3 mul exch z2 mul add exch z1 mul add 4 1 roll
  z3 mul exch z2 mul add exch z1 mul add
  Matrix3D aload pop
  x3 mul exch x2 mul add exch x1 mul add 4 1 roll
  x3 mul exch x2 mul add exch x1 mul add
  3 -1 roll 3 -1 roll 4 -1 roll 8 -3 roll 3 copy
  x3 mul exch x2 mul add exch x1 mul add 4 1 roll
  z3 mul exch z2 mul add exch z1 mul add
  ]
  concat
} def
%
/TMSave {
  tx@Dict /TMatrix known not { /TMatrix { } def /RAngle { 0 } def } if 
  /TMatrix [ TMatrix CM ] cvx def 
} def
%
/TMRestore { CP /TMatrix [ TMatrix setmatrix ] cvx def moveto } def
%
/TMChange {
  TMSave
  /cp [ currentpoint ] cvx def % ??? Check this later.
  CM
  CP T STV
  CM matrix invertmatrix    % Inv(M')
  matrix concatmatrix       % M Inv(M')
  exch exec
  concat cp moveto
} def
%
end % of tx@3Ddict
%%
%% End of file `pst-3d.pro'.

%%EndProcSet
%%BeginProcSet: pst-math.pro 0 0
%                           -*- Mode: Postscript -*-
% pst-math.pro --- PostScript header file pst-math.pro
%
% Author          : Christophe JORSSEN 
% Author          : Herbert Vo <hvoss@tug.org>
% Created the     : Sat 20 March 2004
% Last Mod        : $Date: 2010/10/02 $
% Version         : 0.62 $
%
/PI 3.14159265359 def
/ENeperian 2.71828182846 def
%
/DegToRad {PI mul 180 div} bind def
/RadToDeg {180 mul PI div} bind def
%
/COS {RadToDeg cos} bind def
/SIN {RadToDeg sin} bind def
/TAN {dup SIN exch COS Div} bind def
/tan {dup sin exch cos Div} bind def
/ATAN {neg -1 atan 180 sub DegToRad} bind def
/ACOS {dup dup mul neg 1 add sqrt exch atan DegToRad} bind def
/acos {dup dup mul neg 1 add sqrt exch atan} bind def
/ASIN {neg dup dup mul neg 1 add sqrt neg atan 180 sub DegToRad} bind def
/asin {neg dup dup mul neg 1 add sqrt neg atan 180 sub} bind def
%
/EXP {ENeperian exch exp} bind def
%
/COSH {dup EXP exch neg EXP add 2 div} bind def
/SINH {dup EXP exch neg EXP sub 2 div} bind def
/TANH {dup SINH exch COSH div} bind def
/ACOSH {dup dup mul 1 sub sqrt add ln} bind def
/ASINH {dup dup mul 1 add sqrt add ln} bind def
/ATANH {dup 1 add exch neg 1 add Div ln 2 div} bind def
%
%/SINC {dup SIN exch Div} bind def
/SINC { dup 0 eq { pop 1 } { dup SIN exch div } ifelse } bind def

/GAUSS {dup mul 2 mul dup 4 -2 roll sub dup mul exch div neg EXP exch PI mul sqrt div} bind def
%
/GAMMA { 2 dict begin				% hv 2007-08-30
  /z exch def
  1.000000000190015				% p(0)
  0 1 5 {					% on stack is 0 1 2 3 4 5 
    dup 					% n-1 n-1
    [ 76.18009172947146 
     -86.50532032941677 
      24.0140982483091 
      -1.231739572450155
       0.1208650973866179E-2 
      -0.5395239384953E-5      ] exch get exch 	% p(n) n-1
      1 add z add div			     	% p(n)/(z+n)
      add					% build the sum
    } for
    Pi 2 mul sqrt z div mul
    z 5.5 add z 0.5 add exp mul ENeperian z 5.5 add neg exp mul 
  end } bind def
%    
/GAMMALN {dup dup dup 5.5 add dup ln 3 -1 roll .5 add mul sub neg 1.000000000190015
    0 1 5 {
    [76.18009172947146 -86.50532032941677 24.0140982483091 -1.231739572450155
    .1208650973866179E-2 -.5395239384953E-5 2.5066282746310005] exch get
    4 -1 roll 1 add dup 5 1 roll div add} for
    4 -1 roll div 2.5066282746310005 mul ln add exch pop} bind def
/BETA {2 copy add GAMMALN neg exch GAMMALN 3 -1 roll GAMMALN EXP} bind def
%
/HORNER {aload length
    dup 2 add -1 roll
    exch 1 sub {
        dup 4 1 roll
        mul add exch
    } repeat
    pop
} bind def
%
/BESSEL_J0 {dup abs 8 lt {
    dup mul dup [57568490574 -13362590354 651619640.7 -11214424.18 77392.33017 -184.9052456] HORNER
    exch [57568490411 1029532985 9494680.718 59272.64853 267.8532712 1] HORNER
    Div}
    {abs dup .636619772 exch div sqrt exch dup .785398164 sub exch 8 exch div dup dup mul dup 
    [1 -1.098628627E-2 .2734510407E-4 -.2073370639E-5 .2093887211E-6] HORNER
    3 index COS mul
    exch [-.1562499995E-1 .1430488765E-3 -.6911147651E-5 .7621095161E-6 -.934945152E-7] HORNER
    4 -1 roll SIN mul 3 -1 roll mul neg add mul} 
    ifelse} bind def
%
/BESSEL_Y0 {dup 8 lt {
    dup dup mul dup [-2957821389 7062834065 -512359803.6 10879881.29 -86327.92757 228.4622733] HORNER
    exch [40076544269 745249964.8 7189466.438 47447.26470 226.1030244 1] HORNER
    Div exch dup ln exch BESSEL_J0 .636619772 mul mul add}
    {dup .636619772 exch div sqrt exch dup .785398164 sub exch 8 exch div dup dup mul dup 
    [1 -.1098628627E-2 .2734510407E-4 -.2073370639E-5 .2093887211E-6] HORNER
    3 index SIN mul
    exch [-.1562499995E-1 .1430488765E-3 -.6911147651E-5 .7621095161E-6 -.934945152E-7] HORNER
    4 -1 roll COS mul 3 -1 roll mul add mul} 
    ifelse} bind def
%
/BESSEL_J1 {dup abs 8 lt {
    dup dup mul dup 3 -2 roll [72362614232 -7895059235 242396853.1 -2972611.439 15704.48260 -30.16036606] HORNER mul
    exch [144725228442 2300535178 18583304.74 99447.43394 376.9991397 1] HORNER
    Div}
    {dup abs dup .636619772 exch div sqrt exch dup 2.356194491 sub exch 8 exch div dup dup mul dup 
    [1 .183105E-2 -.3516396496E-4 .2457520174E-5 -.240337019E-6] HORNER
    3 index COS mul
    exch [.04687499995 6.2002690873E-3 .8449199096E-5 -.88228987E-6 .105787412E-6] HORNER
    4 -1 roll SIN mul 3 -1 roll mul neg add mul exch dup abs Div mul} 
    ifelse} bind def
%
/BESSEL_Y1 {dup 8 lt {
    dup dup dup mul dup [-.4900604943E13 .1275274390E13 -.5153428139E11 .7349264551E9 -.4237922726E7 .8511937935E4] HORNER
    exch [.2499580570E14 .4244419664E12 .3733650367E10 .2245904002E8 .1020426050E6 .3549632885E3 1] HORNER
    Div mul exch dup dup ln exch BESSEL_J1 mul exch 1 exch div sub .636619772 mul add}
    {dup .636619772 exch div sqrt exch dup 2.356194491 sub exch 8 exch div dup dup mul dup 
    [1 .183105E-2 -.3516396496E-4 .2457520174E-5 -.240337019E-6] HORNER
    3 index SIN mul
    exch [.04687499995 -.2002690873E-3 .8449199096E-5 6.88228987E-6 .105787412E-6] HORNER
    4 -1 roll COS mul 3 -1 roll mul add mul} 
    ifelse} bind def
%
% En cours...
/BESSEL_Yn {dup 0 eq {pop BESSEL_Y0}{dup 1 eq {pop BESSEL_Y1}{
    exch dup BESSEL_Y0 exch dup BESSEL_Y1 exch 2 exch Div {
        mul 3 -1 roll mul 2 index sub pstack} for
    } ifelse } ifelse } bind def
%
/SIMPSON { 1 dict begin  %% on stack a b var f ierr  Dominik Rodriguez
  3 index 5 index sub                                % compute h
  1                                                  % a b var f ierr h n
  4 index 7 index def 3 index exec                   % a b var f ierr h n f(a)
  5 index 7 index def 4 index exec add               % a b var f ierr h n f(a)+f(b)
  5 index 8 index 4 index 2 div add def 4 index exec % a b var f ierr h n f(a)+f(b) f(a+h/2)
  exch 1 index 4 mul add 0  % a b var f ierr h n old=f(a+h/2) Estim=f(a)+f(b)+4f(a+h/2) NbLoop
    {                                                % a b var f ierr h n old Estim NbLoop
      5 -1 roll 2 div dup 6 1 roll              % h<-h/2
      5 -1 roll 2 mul 5 1 roll                  % n<-2n
                                                % a b var f ierr h n old Estim NbLoop h
      2 div 10 index add 0                      % a b var f ierr h n old Estim NbLoop a+h/2 Cumul
      5 index { 
        1 index 10 index exch def 8 index exec add exch 6 index add exch 
      } repeat                                  % a b var f ierr h n old Estim NbLoop a+nh/2 Cumul
      exch pop                                  % a b var f ierr h n old Estim NbLoop New
      2 index 1 index 4 mul 6 -1 roll 2 mul sub sub % a b var f ierr h n Estim NbLoop New Diff
      4 -1 roll 2 mul 1 index sub 4 1 roll          % a b var f ierr h n Estim NbLoop New Diff
      exch 4 1 roll                             % a b var f ierr h n old Estim NbLoop Diff
      5 index 6 div mul abs 6 index lt { exit } if
      1 add dup 9 eq { exit } if
  } loop                                        % a b var f ierr h n old Estim NbLoop
  exch 5 -1 roll 6 div mul mark 10 2 roll cleartomark
end 
} def
% ------------------------------------ math stuff ----------------------------------
%
% Matrix A in arrays of rows A[[row1][row2]...]
% with [row1]=[a11 a12 ... b1]
% returns on stack solution vector X=[x1 x2 ... xn]
/SolveLinEqSystem { 				% on stack matrix M=[A,b] (A*x=b)
  10 dict begin					% hold all ocal
    /A exch def
    /Rows A length def         			% Rows = number of rows
    /Cols A 0 get length def   			% Cols = number of columns
    /Index [ 0 1 Rows 1 sub { } for ] def	% Index = [0 1 2 ... Rows-1]
    /col 0 def
    /row  0 def
    /PR Rows array def 				% PR[c] = pivot row for row row
  { 						% starts the loop, find pivot entry in row r
    col Cols ge row  Rows ge or { exit } if	% col < Cols and row < Rows else exit
    /pRow row def  				% pRow = pivot row		
    /max A row  get col get abs def		% get A[row[col]], first A[0,0] 
    row 1 add 1 Rows 1 sub { 			% starts for loop 1 1 Rows-1
      /j exch def				% index counter
      /x A j get col get abs def		% get A[j[r]]
      x max gt {				% x>max, then save position
        /pRow j def
        /max x def
      } if
    } for					% now we have the row with biggest A[0,1]
						% with pRow = the pivot row
    max 0 gt {					% swap entries pRow and row  in i 
      /tmp Index row  get def
      Index row  Index pRow get put
      Index pRow tmp put			% and columns pRow and row  in A
      /tmp A row get def
      A row  A pRow get put
      A pRow tmp put   				% pivot
      /row0  A row  get def 			% the pivoting row
      /p0 row0  col get def 			% the pivot value
      row 1 add 1 Rows 1 sub { 			% start for loop
        /j exch def
        /c1 A j get def
        /p c1 col get p0 div def
        c1 col p put				% subtract (p1/p0)*row[i] from row[j]
        col 1 add 1 Cols 1 sub {		% start for loop
          /i exch def
          c1 dup i exch 			% c1 i c1
          i get row0 i get p mul sub put
        } for
      } for
      PR row col put
      /col col 1 add def
      /row row 1 add def
    }{						% all zero entries
      /row row 1 add def			% continue loop with same row
    } ifelse
  } loop
  /X A def					% solution vector
  A Rows 1 sub get dup
  Cols 1 sub get exch
  Cols 2 sub get div
  X Rows 1 sub 3 -1 roll put  			% X[n]
  Rows 2 sub -1 0 {				% for loop to calculate X[i]
    /xi exch def				% current index
    A xi get 					% i-th row
    /Axi exch def
    /sum 0 def
    Cols 2 sub -1 xi 1 add { 
      /n exch def
      /sum sum Axi n get X n get mul add def 
    } for
    Axi Cols 1 sub get 				% b=Axi[Cols-1]
    sum sub 					% b-sum
    Axi xi get div				% b-sum / Axi[xi]
    X xi 3 -1 roll put  			% X[xi]
  } for
  X
  end 
} def
%
/c@_0 2.515517 def 
/c@_1 0.802853 def 
/c@_2 0.010328 def 
/d@_1 1.432788 def 
/d@_2 0.189269 def 
/d@_3 0.001308 def 
/norminv {
  5 dict begin
  neg 1 add 1 exch div ln 2 mul sqrt 
  /t exch def 
  /t2 t dup mul def 
  /t3 t2 t mul def 
  c@_0 c@_1 t mul add c@_2 t2 mul add 1 d@_1 t mul add 
  d@_2 t2 mul add d@_3 t3 mul add div neg t add 
  end
} def 
%end{norminv Michael Sharpe}
%
%
% END pst-math.pro

%%EndProcSet
%%BeginProcSet: pstricks-add.pro 0 0
%% $Id: pstricks-add.pro 692 2012-06-04 06:47:40Z herbert $
%%
% PostScript prologue for pstricks-add.tex.
%
% Version 0.23, 2009/12/17 
%
/tx@addDict 410 dict def tx@addDict begin
%%
realtime srand % set random generator
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/GTriangle {
  gsave
  /mtrx CM def
  /colorA ED /colorB ED /colorC ED 	% save the colors
  /yA ED /xA ED               		% save the origin
  xA yA translate
  rotate       		        	% \psk@gangle
  /yB ED /xB ED /yC ED /xC ED   	% save other coordinates
  /ds [                % save data in a array
     0 0 0 colorA aload pop     	% fd x y xr xg xb
     0 xB xA sub yB yA sub colorB aload pop
     0 xC xA sub yC yA sub colorC aload pop
%     1 xC xB add yB colorA aload pop  	% for use with 4 points ABCD
  ] def
  newpath
  <<
  /ShadingType 4           % single Gouraud
  /ColorSpace [ /DeviceRGB ]
  /DataSource ds
  >> 
  shfill
  closepath
  mtrx
  setmatrix grestore} def
%
/RGBtoCMYK {    % on stack r g b -> C M Y K
  3 dict begin
  /Blue ED /Green ED /Red ED
  1 Red sub     % Cyan
  1 Green sub   % Magenta
  1 Blue sub    % Yellow
  0   		% Black  
  end
} def
%
/CMYKtoGRAY { % on stack c m y k -> gray
  exch 0.11 mul add
  exch 0.59 mul add
  exch 0.3 mul add
  dup 1 gt { pop 1 }  if 
  neg 1 add 
} def
%
/RGBtoGRAY { % on stack r g b -> gray
  0.11 mul
  exch 0.59 mul add
  exch 0.3 mul add 
} def
%
/HSBtoGRAY { 
  6 dict begin
  /b exch def 
  /s exch def 6 mul dup cvi dup 
  /i exch def sub 
  /f exch def
  /F [[0 1 f sub 1][f 0 1][1 0 1 f sub][1 f 0][1 f sub 1 0][0 1 f][0 1 1]] def
  F i get { s mul neg 1 add b mul} forall
  0.11 mul
  exch 0.59 mul add
  exch 0.3 mul add 
  end
} def
%
%% convertisseur longueur d'onde ->R,G,B       Manuel Luque
%% lambda max=780 nanometres
%% lambda min=380 nanometres
%% adaptation de :
%% http://www.physics.sfasu.edu/astro/color.html
%% www.efg2.com/lab
%
/Gamma 0.8 def
/calculateRGB {
  lambda 379 le {/Red 0 def /Green 0 def /Blue 0 def} if
  lambda 781 ge {/Red 0 def /Green 0 def /Blue 0 def} if
  lambda 380 ge {lambda 439 le {
    /R {lambda 440 sub neg 440 380 sub div} def
    /Red R factor mul Gamma exp def
    /G 0 def
    /Green G factor mul Gamma exp def
    /B 1 def
    /Blue B factor mul Gamma exp def} if
  } if
  lambda 440 ge { lambda 489 le {
    /G {lambda 440 sub 490 440 sub div} def
    /Green G factor mul Gamma exp def
    /R 0 def /Red 0 def
    /B 1 def
    /Blue B factor mul Gamma exp def } if
  } if
  lambda 490 ge {lambda 509 le {
    /B {lambda 510 sub neg 510 490 sub div} def
    /Blue B factor mul Gamma exp def
    /R 0 def /Red 0 def
    /G 1 def
    /Green G factor mul Gamma exp def } if
  } if
  lambda 510 ge {lambda 579 le {
    /R {lambda 510 sub 580 510 sub div } def
    /Red R factor mul Gamma exp def
    /Blue 0 def
    /G 1 def
    /Green G factor mul Gamma exp def } if
  } if
  lambda 580 ge {lambda 644 le {
    /G {lambda 645 sub neg 645 580 sub div } def
    /Green G factor mul Gamma exp def
    /Blue 0 def
    /R 1 def
    /Red R factor mul Gamma exp def } if
  } if
  lambda 645 ge { lambda 780 le {
    /Red 1 factor mul Gamma exp def
    /Blue 0 def
    /Green 0 def } if
  } if
} def
%
/factor {
  lambda 380 ge {lambda 419 le { 0.3 0.7 lambda 380 sub mul 420 380 sub div add} if } if
  lambda 420 ge {lambda 700 le { 1 } if } if
  lambda 701 ge {lambda 780 le { 0.3 0.7 780 lambda sub mul 780 700 sub div add} if } if
} def
%
/wavelengthToRGB { % the wavelength in nm must be on top of the stack
  cvi /lambda exch def % no floating point here
  calculateRGB
} def %  now the colors are saved in Red Green Blue
%
/wavelengthToGRAY { % the wavelength in nm must be on top of the stack
  cvi /lambda exch def % no floating point here
  calculateRGB
  Red Green Blue RGBtoGRAY
} def %  now the gray color is on the stack
%
/wavelengthToCMYK { % the wavelength in nm must be on top of the stack
  cvi /lambda exch def % no floating point here
  gsave
  calculateRGB Red Green Blue RGBtoCMYK 
  /Black ED /Yellow ED /Magenta ED /Cyan ED
  grestore
} def %  now the colors are saved in Cyan Magenta Yellow Black
%
/axfill {
    8 dict begin
    /xw exch def /nl exch def
    /C1 exch def /y1 exch def/x1 exch def
    /C0 exch def /y0 exch def/x0 exch def
    <<  /ShadingType 2
        /ColorSpace /DeviceRGB
        /Coords [ x0 y0 x1 y1 ]
        /EmulatorHints [ xw 2 div dup ]
        /Function <<
            /FunctionType 2
            /Domain [0 1]
            /C0 C0
            /C1 C1
            /N      1
        >>
    >> shfill
    end
} bind def
%
%/amplHand {.8} def 
%/dtHand 2 def
/varHand { rand sin amplHand mul add } def
/MovetoByHand { moveto } def 
%/MovetoByHand { /y0 ED /x0 ED x0 y0 moveto } def 
/LinetoByHand { 4 dict begin
  /y1 ED /x1 ED 
  currentpoint /y0 ED /x0 ED
  x0 x1 sub dup mul y0 y1 sub dup mul add sqrt /dEnd ED
  0 dtHand dEnd { dup
    x1 x0 sub mul dEnd div x0 add varHand exch  
    y1 y0 sub mul dEnd div y0 add varHand lineto
  } for
%  /x0 x1 def /y0 y1 def
  end
} def  
%
end
%
% END pstricks-add.pro

%%EndProcSet
%%BeginProcSet: pst-eucl.pro 0 0
%!
% PostScript prologue for pst-eucl.tex.
% Version 1.01 2012/09/21
% For distribution, see pstricks.tex.
%
/tx@EcldDict 40 dict def tx@EcldDict begin
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Pi
/Pi 3.14159265359 def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% e
/E 2.718281828459045 def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% x -> true (if |x| < 1E-6)
/ZeroEq { abs 1E-6 lt } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% x1 y1 x2 y2 -> a b c (ax-by+c=0 with a^2+b^2=1)
/EqDr {
  4 copy 3 -1 roll sub 7 1 roll exch sub 5 1 roll 4 -1 roll
  mul 3 1 roll mul exch sub
  2 index dup mul 2 index dup mul add sqrt
  4 -1 roll 1 index div exch
  4 -1 roll 1 index div exch
  4 -1 roll 1 index div exch pop
} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% orthogonal projection of M1 onto (OM2)
%% x1 y1 x2 y2 -> x3 y3
/Project {
  2 copy dup mul exch dup mul add 5 1 roll 2 copy 5 -1 roll mul exch
  5 -1 roll mul add 4 -1 roll div dup 4 -1 roll mul exch 3 -1 roll mul
} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a b c (ax2+bx+c=0) -> x1 y1
/SolvTrin {
  /c exch def /b exch def /a exch def
  b dup mul a c mul 4 mul sub dup 0 lt
  { pop 0 0 } %% no solutions
  {sqrt dup b neg add a 2 mul div exch b add neg 2 a mul div }
  ifelse } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% x1 y1 x2 y2 -> Dist
/ABDist { 3 -1 roll sub dup mul 3 1 roll sub dup mul add sqrt } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% x1 y1 x2 y2 -> x2-x1  y2-y1
/ABVect { 3 -1 roll exch sub 3 1 roll sub exch } bind def
%/ABVect { 3 -1 roll sub 3 1 roll exch sub exch } bind def  %% wrong version
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% x1 y1 x2 y2 x3 y3 x4 y4 -> x y
/InterLines {
  EqDr /D1c exch def /D1b exch def /D1a exch def
  EqDr /D2c exch def /D2b exch def /D2a exch def
  D1a D2b mul D1b D2a mul sub dup ZeroEq
%   { pop pop pop 0 0 } %% parallel lines  % --- hv 20110714
   { pop 0 0 } %% parallel lines             --- hv 20110714
   {
    /Det exch def
    D1b D2c mul D1c D2b mul sub Det div
    D1a D2c mul D2a D1c mul sub Det div
   } ifelse  } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a b c R -> x1 y1 x2 y2
/InterLineCircle {
  /CR exch def /Dc exch def neg /Db exch def /Da exch def
  ABVect /Vy exch def /Vx exch def
  %% Dc==0 then O belong to the line
  %% First project O on the line -> M (-ca;-cb)
  %% l'abscisse de M sur (OM) divisee par R donne le cosinus
  %Dc neg dup Db mul exch Da mul 2 copy 0 0
  %ABDist dup CR gt { pop pop pop 0 0 0 0 }
  %{ ZeroEq { pop pop Db Da } if Atan /alpha exch def
  Dc abs CR gt { 0 0 0 0 } 
  { Db neg Da neg Atan /alpha exch def
  Dc CR div dup dup mul 1 exch sub sqrt exch Atan /beta exch def
  alpha beta add dup cos CR mul exch sin CR mul
  alpha beta sub dup cos CR mul exch sin CR mul
  4 copy ABVect Vy mul 0 le exch Vx mul 0 le and
  { 4 2 roll } if } ifelse
 } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% R R' OO' -> x1 y1 x2 y2
/InterCircles {
  /OOP exch def /CRP exch def /CR exch def
  OOP dup mul CRP dup mul sub CR dup mul add OOP div 2 div
  dup dup mul CR dup mul exch sub dup
  0 lt { pop pop 0 0 0 0 } { sqrt 2 copy neg } ifelse
} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% x y theta -> x' y' (rotation of theta)
/Rotate {
  dup sin /sintheta exch def cos /costheta exch def /y exch def /x exch def
  x costheta mul y sintheta mul sub
  y costheta mul x sintheta mul add
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% N -> x y
/GetNode {
  tx@NodeDict begin
    tx@NodeDict 1 index known { load GetCenter } { pop 0 0 } ifelse
  end
} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% x -> ch(x)
/ch { dup Ex exch neg Ex add 2 div } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% x -> sh(x)
/sh { dup Ex exch neg Ex sub 2 div } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% x -> e^(x)
/Ex { E exch exp } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% x f g -> x y n
/NewtonSolving {
  /g exch def /f exch def 0
  { %%% STACK: x0 n
    1 add exch %% one more loop
    dup ZeroEq
    { dup 0.0005 add fgeval
      1 index 0.0005 sub fgeval sub .001 div }
    { dup 1.0005 mul fgeval
      1 index 0.9995 mul fgeval sub .001 2 index mul div } ifelse  %%% STACK: n x0 fg'(x0)
    %%% compute x1=x0-fg(x0)/fg'(x0)
    1 index fgeval exch div dup 4 1 roll sub exch %% stack: dx x0 n
    3 -1 roll ZeroEq              %% exit if root found
    1 index 100 eq or { exit } if %% or looping for more than 100 times
  } loop
  dup 100 lt { exch dup /x exch def f } { pop 0 0 } ifelse
  3 -1 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/fgeval { /x exch def f g sub } bind def
end
% END ps-euclide.pro

%%EndProcSet
%%BeginProcSet: pst-barcode.pro 0 0
%!PS-Adobe-2.0
%%Creator: Terry Burton
%%DocumentPaperSizes: a4
%%EndComments

% Barcode Writer in Pure PostScript - Version 2012-11-15
% http://www.terryburton.co.uk/barcodewriter/
%
% Copyright (c) 2004-2012 Terry Burton
%
% $Id: barcode.ps 2399 2012-11-15 13:18:46Z terry.burton $
%
% Permission is hereby granted, free of charge, to any
% person obtaining a copy of this software and associated
% documentation files (the "Software"), to deal in the
% Software without restriction, including without
% limitation the rights to use, copy, modify, merge,
% publish, distribute, sublicense, and/or sell copies of
% the Software, and to permit persons to whom the Software
% is furnished to do so, subject to the following
% conditions:
%
% The above copyright notice and this permission notice
% shall be included in all copies or substantial portions
% of the Software.
%
% THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY
% KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO
% THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
% PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
% THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
% DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
% CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
% CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
% IN THE SOFTWARE.

% Uncomment this next line to allow these named resource
% definitions to remain resident within a printer's
% PostScript virtual machine so that the barcode generation
% capability persists between jobs.

% serverdict begin 0 exitserver 

% --BEGIN TEMPLATE--

% --BEGIN PREAMBLE--
currentglobal
true setglobal
/Generic /Category findresource
dup length 1 add dict copy
dup /InstanceType /packedarraytype put
/uk.co.terryburton.bwipp exch /Category defineresource pop
setglobal
% --END PREAMBLE--

% --BEGIN RENDERER renlinear--
/setpacking where {pop currentpacking true setpacking} if
1 dict
begin
/renlinear {

    20 dict begin          % Confine variables to local scope

    /args exch def   % We are given some arguments

    % Default options
    /sbs [] def
    /bhs [] def
    /bbs [] def
    /txt [] def
    /barcolor (unset) def
    /includetext false def
    /textcolor (unset) def
    /textxalign (unset) def
    /textyalign (unset) def
    /textfont (Courier) def
    /textsize 10 def
    /textxoffset 0 def
    /textyoffset 0 def
    /textgaps 0 def
    /alttext () def
    /bordercolor (unset) def
    /backgroundcolor (unset) def
    /inkspread 0.15 def
    /width 0 def
    /barratio 1 def
    /spaceratio 1 def
    /showborder false def
    /borderleft 10 def
    /borderright 10 def
    /bordertop 1 def
    /borderbottom 1 def
    /borderwidth 0.5 def
    /guardwhitespace false def
    /guardleftpos 0 def
    /guardleftypos 0 def
    /guardrightpos 0 def
    /guardrightypos 0 def
    /guardwidth 6 def
    /guardheight 7 def
    
    % Apply the renderer options and the user options
    args {def} forall
    opt {def} forall 

    /barcolor barcolor cvlit def
    /textcolor textcolor cvlit def
    /textxalign textxalign cvlit def
    /textyalign textyalign cvlit def
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textxoffset textxoffset cvr def
    /textyoffset textyoffset cvr def
    /textgaps textgaps cvr def
    /alttext alttext cvlit def
    /bordercolor bordercolor cvlit def
    /backgroundcolor backgroundcolor cvlit def
    /inkspread inkspread cvr def
    /width width cvr def
    /barratio barratio cvr def
    /spaceratio spaceratio cvr def
    /borderleft borderleft cvr def
    /borderright borderright cvr def
    /bordertop bordertop cvr def
    /borderbottom borderbottom cvr def
    /borderwidth borderwidth cvr def
    /guardleftpos guardleftpos cvr def
    /guardleftypos guardleftypos cvr def
    /guardrightpos guardrightpos cvr def
    /guardrightypos guardrightypos cvr def
    /guardwidth guardwidth cvr def
    /guardheight guardheight cvr def
    
    % Create bar elements and put them into the bars array
    /bars sbs length 1 add 2 idiv array def
    /x 0.00 def /maxh 0 def
    0 1 sbs length 1 add 2 idiv 2 mul 2 sub {
        /i exch def
        i 2 mod 0 eq {           % i is even
            /d sbs i get barratio mul barratio sub 1 add def  % d=digit*r-r+1
            sbs i get 0 ne {
                /h bhs i 2 idiv get 72 mul def  % Height from bhs
                /c d 2 div x add def            % Centre of the bar = x + d/2
                /y bbs i 2 idiv get 72 mul def  % Baseline from bbs
                /w d inkspread sub def          % bar width = digit - inkspread
                bars i 2 idiv [h c y w] put     % Add the bar entry
                h y add maxh gt {/maxh h y add def} if
            } {
                bars i 2 idiv -1 put            % Dummy entry
            } ifelse
        } {
            /d sbs i get spaceratio mul spaceratio sub 1 add def  % d=digit*r-r+1 
        } ifelse
        /x x d add def  % x+=d
    } for

    gsave

    currentpoint translate

    % Force symbol to given width
    width 0 ne {
        width 72 mul x div 1 scale
    } if

    % Set RGB or CMYK color depending on length of given hex string
    /setanycolor {
        /anycolor exch def
        anycolor length 6 eq {
            (<      >) 8 string copy dup 1 anycolor putinterval cvx exec {255 div} forall setrgbcolor
        } if
        anycolor length 8 eq {
            (<        >) 10 string copy dup 1 anycolor putinterval cvx exec {255 div} forall setcmykcolor
        } if
    } bind def

    % Display the border and background
    newpath
    borderleft neg borderbottom neg moveto
    x borderleft add borderright add 0 rlineto
    0 maxh borderbottom add bordertop add rlineto
    x borderleft add borderright add neg 0 rlineto
    0 maxh borderbottom add bordertop add neg rlineto    
    closepath
    backgroundcolor (unset) ne { gsave backgroundcolor setanycolor fill grestore } if     
    showborder {
        gsave
        bordercolor (unset) ne { bordercolor setanycolor } if
        borderwidth setlinewidth stroke
        grestore
    } if    
   
    % Display the bars for elements in the bars array
    gsave
    0 setlinecap
    barcolor (unset) ne { barcolor setanycolor } if
    bars {
        dup -1 ne {
            aload pop newpath setlinewidth moveto 0 exch rlineto stroke
        } {
            pop
        } ifelse
    } forall
    grestore
    
    % Display the text for elements in the text array
    textcolor (unset) ne { textcolor setanycolor } if
    includetext {
        textxalign (unset) eq textyalign (unset) eq and alttext () eq and {
            /s 0 def /fn () def
            txt {
                {} forall
                2 copy s ne exch fn ne or {
                    2 copy /s exch def /fn exch def            
                    exch findfont exch scalefont setfont          
                } {
                    pop pop
                } ifelse
                moveto show
            } forall
        } {
            textfont findfont textsize scalefont setfont
            alttext () eq {
                /txt [ txt { 0 get {} forall } forall ] def
                /tstr txt length string def
                0 1 txt length 1 sub { dup txt exch get tstr 3 1 roll put } for
            } {
                /tstr alttext def
            } ifelse

            % Find true ascent of font
            tstr length 0 eq {
                0
            } {
                gsave
                newpath 0 0 moveto (0) false charpath pathbbox
                4 1 roll pop pop pop
                grestore
                currentfont /PaintType known {currentfont /PaintType get 2 eq} {false} ifelse
                currentfont /StrokeWidth known and {
                    currentfont /StrokeWidth get 2 div 0 exch
                    currentfont /FontMatrix get dtransform
                    dup mul exch dup mul add sqrt
                    add
                } if
            } ifelse
            /textascent exch def
            /textwidth tstr stringwidth pop tstr length 1 sub textgaps mul add def

            /textxpos textxoffset x textwidth sub 2 div add def
            textxalign (left) eq { /textxpos textxoffset def } if
            textxalign (right) eq { /textxpos x textxoffset sub textwidth sub def } if
            textxalign (offleft) eq { /textxpos textwidth textxoffset add neg def } if
            textxalign (offright) eq { /textxpos x textxoffset add def } if
            textxalign (justify) eq textwidth x lt and {
                /textxpos 0 def
                /textgaps x textwidth sub tstr length 1 sub div def
            } if
            /textypos textyoffset textascent add 1 add neg def
            textyalign (above) eq { /textypos textyoffset maxh add 1 add def } if
            textyalign (center) eq { /textypos textyoffset maxh textascent sub 2 div add def } if
            textxpos textypos moveto textgaps 0 tstr ashow
        } ifelse
    } if    

    % Display the guard elements
    guardwhitespace {
        0.75 setlinewidth
        guardleftpos 0 ne {
            newpath
            guardleftpos neg guardwidth add guardleftypos guardwidth 2 div add moveto
            guardwidth neg guardheight -2 div rlineto
            guardwidth guardheight -2 div rlineto
            stroke            
        } if
        guardrightpos 0 ne {
            newpath
            guardrightpos x add guardwidth sub guardrightypos guardheight 2 div add moveto
            guardwidth guardheight -2 div rlineto
            guardwidth neg guardheight -2 div rlineto
            stroke            
        } if
    } if
    
    grestore
    
    end

} bind def
/renlinear dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END RENDERER renlinear--

% --BEGIN RENDERER renmatrix--
/setpacking where {pop currentpacking true setpacking} if
1 dict
begin
/renmatrix {

    20 dict begin

    /args exch def

    % Default options
    /width 1 def
    /height 1 def
    /color (unset) def
    /backgroundcolor (unset) def

    % Apply the renderer options and the user options
    args {def} forall
    opt {def} forall

    /width width cvr def
    /height height cvr def
    /color color cvlit def
    /backgroundcolor backgroundcolor cvlit def

    % Extend bitmap horizontally to an 8-bit boundary
    /pixx8 pixx 8 div ceiling cvi 8 mul def
    /pixs8 [ pixx8 pixy mul {0} repeat ] def
    0 1 pixy 1 sub {
        /i exch def
        pixs8 pixx8 i mul pixs pixx i mul pixx getinterval putinterval
    } for
    /pixs pixs8 def

    % Convert bitmap into 8-bit sample string
    /imgstr pixs length 8 idiv string def
    0 1 pixs length 1 sub {
        /i exch def
        imgstr i 8 idiv 2 copy get 2 7 i 8 mod sub exp cvi pixs i get mul add put
    } for

    % Set RGB or CMYK color depending on length of given hex string
    /setanycolor {
        /anycolor exch def
        anycolor length 6 eq {
            (<      >) 8 string copy dup 1 anycolor putinterval cvx exec {255 div} forall setrgbcolor
        } if
        anycolor length 8 eq {
            (<        >) 10 string copy dup 1 anycolor putinterval cvx exec {255 div} forall setcmykcolor
        } if
    } bind def

    % Draw the image
    gsave
    currentpoint translate
    72 width mul 72 height mul scale
    .0001 .0001 moveto .9999 .0001 lineto .9999 .9999 lineto .0001 .9999 lineto closepath
    backgroundcolor (unset) ne { gsave backgroundcolor setanycolor fill grestore } if 
    color (unset) ne { color setanycolor } if
    pixx pixy true [ pixx 0 0 pixy neg 0 pixy ] {imgstr} imagemask
    grestore

    end

} bind def
/renmatrix dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END RENDERER renmatrix--

% --BEGIN RENDERER renmaximatrix--
/setpacking where {pop currentpacking true setpacking} if
1 dict
begin
/renmaximatrix {

    20 dict begin

    /args exch def   % We are given some arguments

    % Apply the renderer options and the user options
    args {def} forall
    opt {def} forall
 
    gsave

    currentpoint translate

    2.4945 dup scale  % from 1pt to 1.88mm
    0.5 0.5774 translate

    pixs {
        dup 
        /x exch 30 mod def 
        /y exch 30 idiv def
        y 2 mod 0 eq {x} {x 0.5 add} ifelse
        32 y sub 0.8661 mul
        moveto
        0     0.5774 rmoveto
        -0.5 -0.2887 rlineto
        0    -0.5774 rlineto
        0.5  -0.2887 rlineto
        0.5   0.2887 rlineto
        0     0.5774 rlineto
        -0.5  0.2887 rlineto
        closepath fill
    } forall

    % Plot the locator symbol
    newpath 14 13.8576 0.5774 0 360 arc closepath
    14 13.8576 1.3359 360 0 arcn closepath fill
    newpath 14 13.8576 2.1058 0 360 arc closepath
    14 13.8576 2.8644 360 0 arcn closepath fill
    newpath 14 13.8576 3.6229 0 360 arc closepath
    14 13.8576 4.3814 360 0 arcn closepath fill

    grestore

    end

} bind def
/renmaximatrix dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END RENDERER renmaximatrix--

% --BEGIN ENCODER ean5--
% --DESC: EAN-5 (5 digit addon)
% --EXAM: 90200
% --EXOP: includetext guardwhitespace
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/ean5 {

    20 dict begin

    /options exch def                   % We are given an option string
    /barcode exch def                   % We are given a barcode string

    /dontdraw false def
    /includetext false def              % Enable/disable text
    /textfont /Helvetica def
    /textsize 12 def
    /textxoffset 0 def
    /textyoffset (unset) def
    /height 0.7 def    
    
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall   
 
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /height height cvr def
    /textxoffset textxoffset cvr def
    textyoffset (unset) eq {
        /textyoffset height 72 mul 1 add def
    } {
        /textyoffset textyoffset cvr def
    } ifelse
    
    % Create an array containing the character mappings
    /encs
    [ (3211) (2221) (2122) (1411) (1132)
      (1231) (1114) (1312) (1213) (3112)
      (112) (11)
    ] def

    % Create a string of the available characters
    /barchars (0123456789) def

    % Determine the mirror map based on mod 10 checksum
    /mirrormaps
    [ (11000) (10100) (10010) (10001) (01100)
      (00110) (00011) (01010) (01001) (00101)
    ] def
    /checksum 0 def
    0 1 4 {
        /i exch def
        /barchar barcode i get 48 sub def
        i 2 mod 0 eq {
            /checksum barchar 3 mul checksum add def
        } {
            /checksum barchar 9 mul checksum add def
        } ifelse
    } for
    /checksum checksum 10 mod def
    /mirrormap mirrormaps checksum get def

    /sbs 31 string def
    /txt 5 array def
   
    0 1 4 {
        /i exch def

        % Prefix with either a start character or separator character
        i 0 eq {
            sbs 0 encs 10 get putinterval
        } {
            sbs i 1 sub 6 mul 7 add encs 11 get putinterval
        } ifelse

        % Lookup the encoding for the barcode character
        barcode i 1 getinterval barchars exch search
        pop                     % Discard true leaving pre
        length /indx exch def   % indx is the length of pre
        pop pop                 % Discard seek and post
        /enc encs indx get def  % Get the indxth encoding
        mirrormap i get 49 eq { % Reverse enc if 1 in this position in mirrormap
            /enclen enc length def
            /revenc enclen string def
            0 1 enclen 1 sub {
                /j exch def
                /char enc j get def
                revenc enclen j sub 1 sub char put
            } for
            /enc revenc def
        } if
        sbs i 6 mul 3 add enc putinterval   % Put encoded digit into sbs
        txt i [barcode i 1 getinterval i 1 sub 9 mul 13 add textxoffset add textyoffset textfont textsize] put
    } for

    % Return the arguments
    <<
    /ren //renlinear
    /sbs [sbs {48 sub} forall]
    /bhs [16{height}repeat]
    /bbs [16{0}repeat]
    includetext {
        /txt txt
    } if
    /opt options
    /guardrightpos 10
    /guardrightypos textyoffset 4 add
    /bordertop 10
    >>

    dontdraw not //renlinear if

    end

} bind def
/ean5 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER ean5--

% --BEGIN ENCODER ean2--
% --DESC: EAN-2 (2 digit addon)
% --EXAM: 05
% --EXOP: includetext guardwhitespace
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/ean2 {

    20 dict begin

    /options exch def                   % We are given an options string
    /barcode exch def                   % We are given a barcode string

    /dontdraw false def
    /includetext false def               % Enable/disable text
    /textfont /Helvetica def
    /textsize 12 def
    /textxoffset 0 def
    /textyoffset (unset) def
    /height 0.7 def
    
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
 
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /height height cvr def
    /textxoffset textxoffset cvr def
    textyoffset (unset) eq {
        /textyoffset height 72 mul 1 add def
    } {
        /textyoffset textyoffset cvr def
    } ifelse
    
    % Create an array containing the character mappings
    /encs
    [ (3211) (2221) (2122) (1411) (1132)
      (1231) (1114) (1312) (1213) (3112)
      (112) (11)
    ] def

    % Create a string of the available characters
    /barchars (0123456789) def

    % Determine the mirror map based on mod 4 checksum
    /mirrormap [(00) (01) (10) (11)] barcode 0 2 getinterval cvi 4 mod get def

    /sbs 13 string def
    /txt 2 array def
    
    0 1 1 {
        /i exch def

        % Prefix with either a start character or separator character
        i 0 eq {
            sbs 0 encs 10 get putinterval
        } {
            sbs i 1 sub 6 mul 7 add encs 11 get putinterval
        } ifelse

        % Lookup the encoding for the barcode character
        barcode i 1 getinterval barchars exch search
        pop                     % Discard true leaving pre
        length /indx exch def   % indx is the length of pre
        pop pop                 % Discard seek and post
        /enc encs indx get def  % Get the indxth encoding
        mirrormap i get 49 eq { % Reverse enc if 1 in this position in mirrormap    
            /enclen enc length def
            /revenc enclen string def
            0 1 enclen 1 sub {
                /j exch def
                /char enc j get def
                revenc enclen j sub 1 sub char put
            } for
            /enc revenc def
        } if
        sbs i 6 mul 3 add enc putinterval   % Put encoded digit into sbs
        txt i [barcode i 1 getinterval i 1 sub 9 mul 13 add textxoffset add textyoffset textfont textsize] put
    } for

    % Return the arguments
    <<
    /ren //renlinear
    /sbs [sbs {48 sub} forall]
    /bhs [12{height}repeat]
    /bbs [12{0}repeat]
    includetext {
        /txt txt
    } if
    /opt options
    /guardrightpos 10
    /guardrightypos textyoffset 4 add
    /bordertop 10
    >>

    dontdraw not //renlinear if

    end

} bind def
/ean2 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER ean2--

% --BEGIN ENCODER ean13--
% --SUGGESTS ean5 ean2--
% --DESC: EAN-13
% --EXAM: 2071473968010
% --EXOP: includetext guardwhitespace
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /ean2 dup /uk.co.terryburton.bwipp findresource put
dup /ean5 dup /uk.co.terryburton.bwipp findresource put
begin
/ean13 {

    20 dict begin

    /options exch def                  % We are given an option string
    /barcode exch def                  % We are given a barcode string

    /dontdraw false def
    /includetext false def             % Enable/disable text
    /textfont /Helvetica def
    /textsize 12 def
    /textyoffset -4 def
    /height 1 def
    /addongap 12 def

    % Parse the input options, either a string or a dict
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def
    /addongap addongap cvr def   

    % Split off the addon
    barcode ( ) search {
        /barcode exch def
        pop
        /addon exch def
    } {
        pop
        /addon () def
    } ifelse
 
    % Add checksum digit
    /pad 13 string def
    /checksum 0 def
    0 1 11 {
        /i exch def
        /barchar barcode i get 48 sub def
        i 2 mod 0 eq {
            /checksum barchar checksum add def
        } {
            /checksum barchar 3 mul checksum add def
        } ifelse
    } for
    /checksum 10 checksum 10 mod sub 10 mod def
    pad 0 barcode putinterval       % Add barcode to the start of the pad
    pad 12 checksum 48 add put      % Put ascii for checksum at end of pad
    /barcode pad def

    % Create an array containing the character mappings
    /encs
    [ (3211) (2221) (2122) (1411) (1132)
      (1231) (1114) (1312) (1213) (3112)
      (111) (11111) (111)
    ] def

    % Create a string of the available characters
    /barchars (0123456789) def

    % Digits to mirror on left side
    /mirrormaps
    [ (000000) (001011) (001101) (001110) (010011)
      (011001) (011100) (010101) (010110) (011010)
    ] def

    /sbs 59 string def
    /txt 13 array def
  
    % Put the start character
    sbs 0 encs 10 get putinterval

    % First digit - determine mirrormap by this and show before guard bars
    /mirrormap mirrormaps barcode 0 get 48 sub get def
    txt 0 [barcode 0 1 getinterval -10 textyoffset textfont textsize] put

    % Left side - performs mirroring
    1 1 6 {
        % Lookup the encoding for the each barcode character
        /i exch def
        barcode i 1 getinterval barchars exch search
        pop                            % Discard true leaving pre
        length /indx exch def          % indx is the length of pre
        pop pop                        % Discard seek and post
        /enc encs indx get def         % Get the indxth encoding
        mirrormap i 1 sub get 49 eq {   % Reverse enc if 1 in this position in mirrormap
            /enclen enc length def
            /revenc enclen string def
            0 1 enclen 1 sub {
                /j exch def
                /char enc j get def
                revenc enclen j sub 1 sub char put
            } for
            /enc revenc def
        } if
        sbs i 1 sub 4 mul 3 add enc putinterval   % Put encoded digit into sbs
        txt i [barcode i 1 getinterval i 1 sub 7 mul 4 add textyoffset textfont textsize] put
    } for

    % Put the middle character
    sbs 7 1 sub 4 mul 3 add encs 11 get putinterval

    % Right side
    7 1 12 {
        % Lookup the encoding for the each barcode character
        /i exch def
        barcode i 1 getinterval barchars exch search
        pop                            % Discard true leaving pre
        length /indx exch def          % indx is the length of pre
        pop pop                        % Discard seek and post
        /enc encs indx get def         % Get the indxth encoding
        sbs i 1 sub 4 mul 8 add enc putinterval  % Put encoded digit into sbs
        txt i [barcode i 1 getinterval i 1 sub 7 mul 8 add textyoffset textfont textsize] put
    } for

    % Put the end character
    sbs 56 encs 12 get putinterval

    /sbs [sbs {48 sub} forall] def
    includetext {
        /bhs [height height 12{height .075 sub}repeat height height 12{height .075 sub}repeat height height] def
        /bbs [0 0 12{.075}repeat 0 0 12{.075}repeat 0 0] def
    } {
        /bhs [30{height}repeat] def
        /bbs [30{0}repeat] def
        /txt [] def
    } ifelse
    /guardrightypos 0 def

    % Append the addon
    addon () ne {
        /addopts <<
            /dontdraw true
            /includetext true
            /height height 0.15 sub
            /textxoffset 95 addongap add
            /textsize textsize
            /textfont textfont
        >> def
        addon length 2 eq {addon addopts //ean2 exec} if
        addon length 5 eq {addon addopts //ean5 exec} if
        /addcode exch def
        /sbs [sbs aload pop addongap addcode (sbs) get aload pop] def
        /bhs [bhs aload pop addcode (bhs) get {.075 sub} forall] def
        /bbs [bbs aload pop addcode (bbs) get {.075 add} forall] def
        /txt [txt aload pop addcode (txt) get aload pop] def
        /guardrightypos height 72 mul 6 sub def
    } if 
   
    % Return the arguments
    <<
    /ren //renlinear
    /sbs sbs
    /bhs bhs
    /bbs bbs
    /txt txt
    /opt options
    /guardrightpos 10
    /guardrightypos guardrightypos
    /borderbottom 5
    >>

    dontdraw not //renlinear if

    end

} bind def
/ean13 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER ean13--

% --BEGIN ENCODER ean8--
% --SUGGESTS ean5 ean2--
% --DESC: EAN-8
% --EXAM: 01335583
% --EXOP: includetext guardwhitespace height=0.5
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /ean2 dup /uk.co.terryburton.bwipp findresource put
dup /ean5 dup /uk.co.terryburton.bwipp findresource put
begin
/ean8 {

    20 dict begin

    /options exch def                  % We are given an option string
    /barcode exch def                  % We are given a barcode string

    /dontdraw false def
    /includetext false def              % Enable/disable text
    /textfont /Helvetica def
    /textsize 12 def
    /textyoffset -4 def
    /height 1 def
    /addongap 12 def
    
    % Parse the input options, either a string or a dict
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
   
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def
    /addongap addongap cvr def   

    % Split off the addon
    barcode ( ) search {
        /barcode exch def
        pop
        /addon exch def
    } {
        pop
        /addon () def
    } ifelse

    % Add checksum digit
    /pad 8 string def
    /checksum 0 def
    0 1 6 {
        /i exch def
        /barchar barcode i get 48 sub def
        i 2 mod 0 ne {
            /checksum barchar checksum add def
        } {
            /checksum barchar 3 mul checksum add def
        } ifelse
    } for
    /checksum 10 checksum 10 mod sub 10 mod def
    pad 0 barcode putinterval      % Add barcode to the start of the pad
    pad 7 checksum 48 add put      % Put ascii for checksum at end of pad
    /barcode pad def
 
    % Create an array containing the character mappings
    /encs
    [ (3211) (2221) (2122) (1411) (1132)
      (1231) (1114) (1312) (1213) (3112)
      (111) (11111) (111)
    ] def

    % Create a string of the available characters
    /barchars (0123456789) def

    /sbs 43 string def
    /txt 8 array def
    
    % Put the start character
    sbs 0 encs 10 get putinterval

    % Left side
    0 1 3 {
        % Lookup the encoding for the each barcode character
        /i exch def
        barcode i 1 getinterval barchars exch search
        pop                                % Discard true leaving pre
        length /indx exch def              % indx is the length of pre
        pop pop                            % Discard seek and post
        /enc encs indx get def             % Get the indxth encoding
        sbs i 4 mul 3 add enc putinterval  % Put encoded digit into sbs
        txt i [barcode i 1 getinterval i 7 mul 4 add textyoffset textfont textsize] put
    } for

    % Put the middle character
    sbs 4 4 mul 3 add encs 11 get putinterval

    % Right side
    4 1 7 {
        % Lookup the encoding for the each barcode character
        /i exch def
        barcode i 1 getinterval barchars exch search
        pop                                % Discard true leaving pre
        length /indx exch def              % indx is the length of pre
        pop pop                            % Discard seek and post
        /enc encs indx get def             % Get the indxth encoding
        sbs i 4 mul 8 add enc putinterval  % Put encoded digit into sbs
        txt i [barcode i 1 getinterval i 7 mul 8 add textyoffset textfont textsize] put
    } for

    % Put the end character
    sbs 40 encs 12 get putinterval

    /sbs [sbs {48 sub} forall] def
    includetext {
        /bhs [height height 8{height .075 sub}repeat height height 8{height .075 sub}repeat height height] def
        /bbs [0 0 8{.075}repeat 0 0 8{.075}repeat 0 0] def
    } {
        /bhs [22{height}repeat] def
        /bbs [22{0}repeat] def
        /txt [] def
    } ifelse
    /guardrightypos 0 def

    % Append the addon
    addon () ne {
        /addopts <<
            /dontdraw true
            /includetext true
            /height height 0.15 sub
            /textxoffset 67 addongap add
            /textsize textsize
            /textfont textfont
        >> def
        addon length 2 eq {addon addopts //ean2 exec} if
        addon length 5 eq {addon addopts //ean5 exec} if
        /addcode exch def
        /sbs [sbs aload pop addongap addcode (sbs) get aload pop] def
        /bhs [bhs aload pop addcode (bhs) get {.075 sub} forall] def
        /bbs [bbs aload pop addcode (bbs) get {.075 add} forall] def
        /txt [txt aload pop addcode (txt) get aload pop] def
        /guardrightypos height 72 mul 6 sub def
    } if 

    % Return the arguments
    <<
    /ren //renlinear
    /sbs sbs
    /bhs bhs
    /bbs bbs
    /txt txt
    /opt options
    /guardleftpos 10
    /guardrightpos 10
    /guardrightypos guardrightypos
    /borderbottom 5
    >>

    dontdraw not //renlinear if

    end

} bind def
/ean8 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER ean8--

% --BEGIN ENCODER upca--
% --SUGGESTS ean5 ean2--
% --DESC: UPC-A
% --EXAM: 488581014973
% --EXOP: includetext
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /ean2 dup /uk.co.terryburton.bwipp findresource put
dup /ean5 dup /uk.co.terryburton.bwipp findresource put
begin
/upca {

    20 dict begin

    /options exch def
    /barcode exch def             % We are given a barcode string

    /dontdraw false def
    /includetext false def         % Enable/disable text
    /textfont /Helvetica def
    /textsize 12 def
    /textyoffset -4 def
    /height 1 def 
    /addongap 12 def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall    

    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def
    /addongap addongap cvr def
   
    % Split off the addon
    barcode ( ) search {
        /barcode exch def
        pop
        /addon exch def
    } {
        pop
        /addon () def
    } ifelse
 
    % Add checksum digit to barcode
    /pad 12 string def   % Create pad one bigger than barcode
    /checksum 0 def
    0 1 10 {
        /i exch def
        /barchar barcode i get 48 sub def
        i 2 mod 0 ne {
            /checksum checksum barchar add def
        } {
            /checksum checksum barchar 3 mul add def
        } ifelse
    } for
    /checksum 10 checksum 10 mod sub 10 mod def
    pad 0 barcode putinterval       % Add barcode to the start of the pad
    pad 11 checksum 48 add put      % Put ascii for checksum at end of pad
    /barcode pad def

    % Create an array containing the character mappings
    /encs
    [ (3211) (2221) (2122) (1411) (1132)
      (1231) (1114) (1312) (1213) (3112)
      (111) (11111) (111)
    ] def

    % Create a string of the available characters
    /barchars (0123456789) def

    /sbs 59 string def
    /txt 12 array def

    % Put the start character
    sbs 0 encs 10 get putinterval

    % Left side
    0 1 5 {
        % Lookup the encoding for the each barcode character
        /i exch def
        barcode i 1 getinterval barchars exch search
        pop                                % Discard true leaving pre
        length /indx exch def              % indx is the length of pre
        pop pop                            % Discard seek and post
        /enc encs indx get def             % Get the indxth encoding
        sbs i 4 mul 3 add enc putinterval  % Put encoded digit into sbs
        i 0 eq {      % First digit is before the guard bars
            txt 0 [barcode 0 1 getinterval -7 textyoffset textfont textsize 2 sub] put
        } {
            txt i [barcode i 1 getinterval i 7 mul 4 add textyoffset textfont textsize] put
        } ifelse
    } for

    % Put the middle character
    sbs 6 4 mul 3 add encs 11 get putinterval

    % Right side
    6 1 11 {
        % Lookup the encoding for the each barcode character
        /i exch def
        barcode i 1 getinterval barchars exch search
        pop                                % Discard true leaving pre
        length /indx exch def              % indx is the length of pre
        pop pop                            % Discard seek and post
        /enc encs indx get def             % Get the indxth encoding
        sbs i 4 mul 8 add enc putinterval  % Put encoded digit into sbs
        i 11 eq {       % Last digit is after guard bars
            txt 11 [barcode 11 1 getinterval 96 textyoffset textfont textsize 2 sub] put
        } {
            txt i [barcode i 1 getinterval i 7 mul 8 add textyoffset textfont textsize] put
        } ifelse
    } for

    % Put the end character
    sbs 56 encs 12 get putinterval

    /sbs [sbs {48 sub} forall] def
    includetext {
        /bhs [4{height}repeat 10{height .075 sub}repeat height height 10{height .075 sub}repeat 4{height}repeat] def
        /bbs [0 0 0 0 10{.075}repeat 0 0 10{.075}repeat 0 0 0 0] def
    } {
        /bhs [30{height}repeat] def
        /bbs [30{0}repeat] def
        /txt [] def
    } ifelse
    /guardrightypos 0 def

    % Append the addon
    addon () ne {
        /addopts <<
            /dontdraw true
            /includetext true
            /height height 0.15 sub
            /textxoffset 95 addongap add
            /textsize textsize
            /textfont textfont
        >> def
        addon length 2 eq {addon addopts //ean2 exec} if
        addon length 5 eq {addon addopts //ean5 exec} if
        /addcode exch def
        /sbs [sbs aload pop addongap addcode (sbs) get aload pop] def
        /bhs [bhs aload pop addcode (bhs) get {.075 sub} forall] def
        /bbs [bbs aload pop addcode (bbs) get {.075 add} forall] def
        /txt [txt aload pop addcode (txt) get aload pop] def
        /guardrightypos height 72 mul 6 sub def
    } if 

    % Return the arguments
    <<
    /ren //renlinear
    /sbs sbs
    /bhs bhs
    /bbs bbs
    /txt txt
    /opt options
    /guardrightpos 10
    /guardrightypos guardrightypos
    /borderbottom 5
    >>

    dontdraw not //renlinear if

    end

} bind def
/upca dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER upca--

% --BEGIN ENCODER upce--
% --SUGGESTS ean5 ean2--
% --DESC: UPC-E
% --EXAM: 00123457
% --EXOP: includetext height=0.4
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /ean2 dup /uk.co.terryburton.bwipp findresource put
dup /ean5 dup /uk.co.terryburton.bwipp findresource put
begin
/upce {

    20 dict begin

    /options exch def                   % We are given an option string
    /barcode exch def                   % We are given a barcode string

    /dontdraw false def
    /includetext false def               % Enable/disable text
    /textfont /Helvetica def
    /textsize 12 def
    /textyoffset -4 def
    /height 1 def
    /addongap 12 def   
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
 
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def
    /addongap addongap cvr def    

    % Ensure 0 or 1 number systems
    barcode 0 get dup 48 ne exch 49 ne and {
        /barcode () def
    } if

    % Split off the addon
    barcode ( ) search {
        /barcode exch def
        pop
        /addon exch def
    } {
        pop
        /addon () def
    } ifelse

    % Create an array containing the character mappings
    /encs
    [ (3211) (2221) (2122) (1411) (1132)
      (1231) (1114) (1312) (1213) (3112)
      (111) (111111)
    ] def

    % Create a string of the available characters
    /barchars (0123456789) def

    /mirrormaps
    [ (000111) (001011) (001101) (001110) (010011)
      (011001) (011100) (010101) (010110) (011010)
    ] def

    % Derive the equivalent UPC-A for its checksum
    /upcacode (00000000000) 11 string copy def
    upcacode 0 barcode 0 get put
    barcode 6 get 48 sub 2 le {
        upcacode 1 barcode 1 2 getinterval putinterval
        upcacode 3 barcode 6 1 getinterval putinterval
        upcacode 8 barcode 3 3 getinterval putinterval
    } if
    barcode 6 get 48 sub 3 eq {
        upcacode 1 barcode 1 3 getinterval putinterval
        upcacode 9 barcode 4 2 getinterval putinterval
    } if
    barcode 6 get 48 sub 4 eq {
        upcacode 1 barcode 1 4 getinterval putinterval
        upcacode 10 barcode 5 1 getinterval putinterval
    } if
    barcode 6 get 48 sub 5 ge {
        upcacode 1 barcode 1 5 getinterval putinterval
        upcacode 10 barcode 6 1 getinterval putinterval
    } if
    /checksum 0 def
    0 1 10 {
       /i exch def
       /barchar upcacode i get 48 sub def
       i 2 mod 0 ne {
           /checksum checksum barchar add def
       } {
           /checksum checksum barchar 3 mul add def
       } ifelse
    } for
    /checksum 10 checksum 10 mod sub 10 mod def
    /pad 8 string def
    pad 0 barcode putinterval       % Add barcode to the start of the pad
    pad 7 checksum 48 add put       % Put ascii for checksum at end of pad
    /barcode pad def
    /txt 8 array def
    txt 0 [barcode 0 1 getinterval -7 textyoffset textfont textsize 2 sub] put

    % Determine the mirror map based on checksum
    /mirrormap mirrormaps checksum get def

    % Invert the mirrormap if we are using a non-zero number system
    barcode 0 get 48 eq {
        /invt mirrormap length string def
        0 1 mirrormap length 1 sub {
            /i exch def
            mirrormap i get 48 eq {
                invt i 49 put
            } {
                invt i 48 put
            } ifelse
        } for
        /mirrormap invt def
    } if

    /sbs 33 string def

    % Put the start character
    sbs 0 encs 10 get putinterval

    1 1 6 {
        /i exch def
        % Lookup the encoding for the each barcode character
        barcode i 1 getinterval barchars exch search
        pop                            % Discard true leaving pre
        length /indx exch def          % indx is the length of pre
        pop pop                        % Discard seek and post
        /enc encs indx get def         % Get the indxth encoding
        mirrormap i 1 sub get 49 eq {  % Reverse enc if 1 in this position in mirrormap        
            /enclen enc length def
            /revenc enclen string def
            0 1 enclen 1 sub {
                /j exch def
                /char enc j get def
                revenc enclen j sub 1 sub char put
            } for
            /enc revenc def
        } if
        sbs i 1 sub 4 mul 3 add enc putinterval   % Put encoded digit into sbs
        txt i [barcode i 1 getinterval i 1 sub 7 mul 4 add textyoffset textfont textsize] put
    } for

    txt 7 [barcode 7 1 getinterval 6 7 mul 11 add textyoffset textfont textsize 2 sub] put

    % Put the end character
    sbs 27 encs 11 get putinterval

    /sbs [sbs {48 sub} forall] def
    includetext {
        /bhs [height height 12{height .075 sub}repeat height height height] def
        /bbs [0 0 12{.075}repeat 0 0 0] def
    } {
        /bhs [17{height}repeat] def
        /bbs [17{0}repeat] def
        /txt [] def
    } ifelse
    /guardrightypos 0 def

    % Append the addon
    addon () ne {
        /addopts <<
            /dontdraw true
            /includetext true
            /height height 0.15 sub
            /textxoffset 51 addongap add
            /textsize textsize
            /textfont textfont
        >> def
        addon length 2 eq {addon addopts //ean2 exec} if
        addon length 5 eq {addon addopts //ean5 exec} if
        /addcode exch def
        /sbs [sbs aload pop addongap addcode (sbs) get aload pop] def
        /bhs [bhs aload pop addcode (bhs) get {.075 sub} forall] def
        /bbs [bbs aload pop addcode (bbs) get {.075 add} forall] def
        /txt [txt aload pop addcode (txt) get aload pop] def
        /guardrightypos height 72 mul 6 sub def
    } if

    % Return the arguments
    <<
    /ren //renlinear
    /sbs sbs
    /bhs bhs
    /bbs bbs
    /txt txt
    /opt options
    /guardrightpos 10
    /guardrightypos guardrightypos
    /borderbottom 5
    >>

    dontdraw not //renlinear if

    end

} bind def
/upce dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER upce--

% --BEGIN ENCODER isbn--
% --REQUIRES ean13--
% --SUGGESTS ean5 ean2--
% --DESC: ISBN
% --EXAM: 978-1-56592-479 54495
% --EXOP: includetext guardwhitespace
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /ean13 dup /uk.co.terryburton.bwipp findresource put
begin
/isbn {

    20 dict begin

    /options exch def      % We are given an options string
    /isbntxt exch def      % We are given the isbn text with dashes

    /dontdraw false def
    /includetext false def  % Enable/disable ISBN text
    /isbnfont /Courier def
    /isbnsize 9 def
    /isbnpos (unset) def
    /height 1 def
    /addongap 12 def   
    /legacy false def
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
    
    /isbnfont isbnfont cvlit def
    /isbnsize isbnsize cvr def
    /height height cvr def
    /addongap addongap cvr def
    isbnpos (unset) eq {
        /isbnpos height 72 mul 3 add def
    } {
        /isbnpos isbnpos cvr def
    } ifelse

    % Split off the addon
    isbntxt ( ) search {
        /isbntxt exch def
        pop
        /addon exch def
    } {
        pop
        /addon () def
    } ifelse
 
    % Convert ISBN-10 to ISBN-13
    legacy not isbntxt length 13 le and {
        /pad isbntxt length 4 add string def
        pad 0 (978-) putinterval
        pad 4 isbntxt putinterval
        /isbntxt pad def
    } if

    % Read the digits from isbntxt and calculate checksums
    /isbn 13 string def
    /checksum10 0 def
    /checksum13 0 def
    /i 0 def /n 0 def
    { % loop
        /isbnchar isbntxt i get 48 sub def
        isbnchar -3 ne {     % Ignore dashes
            isbn n isbnchar 48 add put
            n 9 lt {
                /checksum10 checksum10 10 n sub isbnchar mul add def
            } if
            n 12 lt {
                n 2 mod 0 eq {
                    /checksum13 isbnchar checksum13 add def
                } {
                    /checksum13 isbnchar 3 mul checksum13 add def
                } ifelse
            } if
            /n n 1 add def
        } if
        /i i 1 add def
        i isbntxt length eq {exit} if
    } loop

    % Add the ISBN header to the isbntxt
    n 9 eq n 10 eq or {
        /checksum 11 checksum10 11 mod sub 11 mod def
        /isbn isbn 0 9 getinterval def
        /pad 18 string def
    } {
        /checksum 10 checksum13 10 mod sub 10 mod def
        /isbn isbn 0 12 getinterval def
        /pad 22 string def
    } ifelse
    pad 0 (ISBN ) putinterval
    pad 5 isbntxt putinterval  % Add isbntxt to the pad

    % Add checksum digit
    pad pad length 2 sub 45 put  % Put a dash
    checksum 10 eq {
        pad pad length 1 sub checksum 78 add put  % Check digit for 10 is X
    } {
        pad pad length 1 sub checksum 48 add put  % Put check digit
    } ifelse
    /isbntxt pad def

    % Convert ISBN digits to EAN-13
    /barcode 12 string def
    isbn length 9 eq {        
        barcode 0 (978) putinterval
        barcode 3 isbn putinterval
    } {
        barcode 0 isbn putinterval
    } ifelse

    % Append the addon
    addon () ne {
        12 addon length add 1 add string 
        dup 0 barcode putinterval
        dup 12 ( ) putinterval
        dup 13 addon putinterval
        /barcode exch def
    } if

    % Get the result of encoding with ean13
    options (dontdraw) true put
    options (addongap) addongap put 
    /args barcode options //ean13 exec def

    % Add the ISBN text
    includetext {
        isbn length 9 eq {
            /isbnxpos -1 def
        } {
            /isbnxpos -12 def
        } ifelse
        args (txt) known {
            /txt args (txt) get def
            /newtxt txt length 1 add array def
            newtxt 0 txt putinterval
            newtxt newtxt length 1 sub [isbntxt isbnxpos isbnpos isbnfont isbnsize] put
            args (txt) newtxt put
        } {
            args (txt) [ [isbntxt isbnxpos isbnpos isbnfont isbnsize] ] put
        } ifelse
    } if

    args (opt) options put
    args

    dontdraw not //renlinear if

    end
 
} bind def
/isbn dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER isbn--

% --BEGIN ENCODER ismn--
% --REQUIRES ean13--
% --SUGGESTS ean5 ean2--
% --DESC: ISMN
% --EXAM: 979-0-2600-0043
% --EXOP: includetext guardwhitespace
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /ean13 dup /uk.co.terryburton.bwipp findresource put
begin
/ismn {

    20 dict begin

    /options exch def      % We are given an options string
    /ismntxt exch def      % We are given the ismn text with dashes

    /dontdraw false def
    /includetext false def  % Enable/disable ISMN text
    /ismnfont /Courier def
    /ismnsize 9 def
    /ismnpos (unset) def
    /height 1 def
    /addongap 12 def   
    /legacy false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
    
    /ismnfont ismnfont cvlit def
    /ismnsize ismnsize cvr def
    /height height cvr def
    /addongap addongap cvr def
    ismnpos (unset) eq {
        /ismnpos height 72 mul 3 add def
    } {
        /ismnpos ismnpos cvr def
    } ifelse
   
    % Split off the addon
    ismntxt ( ) search {
        /ismntxt exch def
        pop
        /addon exch def
    } {
        pop
        /addon () def
    } ifelse

    % Convert old ISMN to ISMN-13
    /legacytxt () def
    ismntxt 0 1 getinterval (M) eq ismntxt length 13 le and {
        /legacytxt ismntxt def
        /pad ismntxt length 4 add string def
        pad 0 (979-0-) putinterval
        pad 6 ismntxt 2 ismntxt length 2 sub getinterval putinterval
        /ismntxt pad def
    } if

    % Read the digits from ismntxt and calculate checksums
    /ismn 13 string def
    /checksum 0 def
    /i 0 def /n 0 def
    { % loop
        /ismnchar ismntxt i get 48 sub def
        ismnchar -3 ne {           % Ignore dashes
            ismn n ismnchar 48 add put
            n 12 lt {
                n 2 mod 0 eq {
                    /checksum ismnchar checksum add def
                } {
                    /checksum ismnchar 3 mul checksum add def
                } ifelse
            } if
            /n n 1 add def
        } if
        /i i 1 add def
        i ismntxt length eq {exit} if
    } loop
    /checksum 10 checksum 10 mod sub 10 mod def

    % Add the ISMN header to the ismntxt
    legacy legacytxt () ne and {
        /ismntxt legacytxt def
        /pad 18 string def
    } {
        /pad 22 string def
    } ifelse
    pad 0 (ISMN ) putinterval
    pad 5 ismntxt putinterval  % Add ismntxt to the pad

    % Add checksum digit
    pad pad length 2 sub 45 put  % Put a dash
    pad pad length 1 sub checksum 48 add put  % Put check digit
    /ismntxt pad def

    % Convert ISMN digits to EAN-13
    /barcode ismn 0 12 getinterval def 

    % Append the addon
    addon () ne {
        12 addon length add 1 add string 
        dup 0 barcode putinterval
        dup 12 ( ) putinterval
        dup 13 addon putinterval
        /barcode exch def
    } if

    % Get the result of encoding with ean13
    options (dontdraw) true put
    options (addongap) addongap put 
    /args barcode options //ean13 exec def

    % Add the ISMN text
    includetext {
        ismntxt length 18 eq {
            /ismnxpos -1 def
        } {
            /ismnxpos -12 def
        } ifelse
        args (txt) known {
            /txt args (txt) get def
            /newtxt txt length 1 add array def
            newtxt 0 txt putinterval
            newtxt newtxt length 1 sub [ismntxt ismnxpos ismnpos ismnfont ismnsize] put
            args (txt) newtxt put
        } {
            args (txt) [ [ismntxt ismnxpos ismnpos ismnfont ismnsize] ] put
        } ifelse
    } if

    args (opt) options put
    args

    dontdraw not //renlinear if

    end
 
} bind def
/ismn dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER ismn--

% --BEGIN ENCODER issn--
% --REQUIRES ean13--
% --SUGGESTS ean2 ean5--
% --DESC: ISSN
% --EXAM: 0317-8471 00 05
% --EXOP: includetext guardwhitespace
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /ean13 dup /uk.co.terryburton.bwipp findresource put
begin
/issn {

    20 dict begin

    /options exch def      % We are given an options string
    /issntxt exch def      % We are given the issn text with dashes

    /dontdraw false def
    /includetext false def  % Enable/disable ISSN text
    /issnfont /Courier def
    /issnsize 9 def
    /issnpos (unset) def
    /height 1 def
    /addongap 12 def   

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
    
    /issnfont issnfont cvlit def
    /issnsize issnsize cvr def
    /height height cvr def
    /addongap addongap cvr def
    issnpos (unset) eq {
        /issnpos height 72 mul 3 add def
    } {
        /issnpos issnpos cvr def
    } ifelse
   
    % Split off the ISSN
    issntxt ( ) search {
        /issntxt exch def
        pop
        /seqvar exch def
    } if

    % Split off the sequence variant and 2 digit addon
    seqvar ( ) search {
        /seqvar exch def
        pop
        2 string dup exch 0 4 -1 roll putinterval /addon exch def
    } {
        pop
        /addon () def
    } ifelse

    % Read the digits from issntxt and calculate checksums
    /issn 8 string def
    /checksum 0 def
    /i 0 def /n 0 def
    { % loop
        /issnchar issntxt i get 48 sub def
        issnchar -3 ne {           % Ignore dashes
            issn n issnchar 48 add put
            n 7 lt {
                /checksum checksum issnchar 8 n sub mul add def
            } if
            /n n 1 add def
        } if
        /i i 1 add def
        i issntxt length eq {exit} if
    } loop
    /checksum 11 checksum 11 mod sub 11 mod def

    % Add the ISSN header to the issntxt
    /pad 14 string def
    pad 0 (ISSN ) putinterval
    pad 5 issntxt putinterval  % Add issntxt to the pad

    % Add checksum digit
    pad 13 checksum 48 add dup 58 eq {pop 88} if put  % Put check digit
    /issntxt pad def

    % Convert ISSN digits to EAN-13
    /barcode issn 0 7 getinterval def 

    % Append the sequence variant
    /barcode 12 string def
    barcode 0 (977) putinterval
    barcode 3 issn putinterval
    barcode 10 seqvar putinterval

    % Append the addon
    addon () ne {
        12 addon length add 1 add string 
        dup 0 barcode putinterval
        dup 12 ( ) putinterval
        dup 13 addon putinterval
        /barcode exch def
    } if

    % Get the result of encoding with ean13
    options (dontdraw) true put
    options (addongap) addongap put 
    /args barcode options //ean13 exec def

    % Add the ISSN text
    includetext {
        /issnxpos 10 def
        args (txt) known {
            /txt args (txt) get def
            /newtxt txt length 1 add array def
            newtxt 0 txt putinterval
            newtxt newtxt length 1 sub [issntxt issnxpos issnpos issnfont issnsize] put
            args (txt) newtxt put
        } {
            args (txt) [ [issntxt issnxpos issnpos issnfont issnsize] ] put
        } ifelse
    } if

    args (opt) options put
    args

    dontdraw not //renlinear if

    end
 
} bind def
/issn dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER issn--

% --BEGIN ENCODER code128--
% --DESC: Code 128
% --EXAM: Count01234567^FNC2!
% --EXOP: includetext parsefnc
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/code128 {

    20 dict begin                  % Confine variables to local scope

    /options exch def        % We are given an option string
    /barcode exch def        % We are given a barcode string

    /dontdraw false def
    /includetext false def    % Enable/disable text
    /textfont /Courier def
    /textsize 10 def
    /textxoffset 0 def
    /textyoffset -7 def
    /height 1 def
    /encoding (auto) def
    /raw false def
    /parse false def
    /parsefnc false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textxoffset textxoffset cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def

    % Parse ordinals of the form ^NNN to ASCII
    parse {
        /msg barcode length string def
        /j 0 def
        barcode
        { % loop
            (^) search {
                dup msg exch j exch putinterval
                length j add 1 add /j exch def
                pop
                dup 0 3 getinterval cvi msg exch j 1 sub exch put
                dup length 3 sub 3 exch getinterval
            } {
                dup msg exch j exch putinterval
                length j add /j exch def
                /barcode msg 0 j getinterval def
                exit
            } ifelse 
        } loop
    } if

    /barlen barcode length def

    % Special function characters
    /sta  -1 def  /stb  -2 def  /stc  -3 def 
    /swa  -4 def  /swb  -5 def  /swc  -6 def 
    /fn1  -7 def  /fn2  -8 def  /fn3  -9 def 
    /fn4 -10 def  /sft -11 def  /stp -12 def
    /lka -13 def  /lkc -14 def  % CC-A/B and CC-C linkage

    % Character maps for each state
    /charmaps [
      %  A    B    C         A    B    C         A    B    C
      [  32   32  (00) ]  [ (!)  (!)  (01) ]  [ (")  (")  (02) ]  % 0-2 
      [ (#)  (#)  (03) ]  [ ($)  ($)  (04) ]  [ (%)  (%)  (05) ]  % 3-5
      [ (&)  (&)  (06) ]  [ (')  (')  (07) ]  [  40   40  (08) ]  % 6-8
      [  41   41  (09) ]  [ (*)  (*)  (10) ]  [ (+)  (+)  (11) ]  % 9-11
      [ (,)  (,)  (12) ]  [ (-)  (-)  (13) ]  [ (.)  (.)  (14) ]  % 12-14
      [ (/)  (/)  (15) ]  [ (0)  (0)  (16) ]  [ (1)  (1)  (17) ]  % 15-17
      [ (2)  (2)  (18) ]  [ (3)  (3)  (19) ]  [ (4)  (4)  (20) ]  % 18-20
      [ (5)  (5)  (21) ]  [ (6)  (6)  (22) ]  [ (7)  (7)  (23) ]  % 21-23
      [ (8)  (8)  (24) ]  [ (9)  (9)  (25) ]  [ (:)  (:)  (26) ]  % 24-26
      [ (;)  (;)  (27) ]  [ (<)  (<)  (28) ]  [ (=)  (=)  (29) ]  % 27-29
      [ (>)  (>)  (30) ]  [ (?)  (?)  (31) ]  [ (@)  (@)  (32) ]  % 30-32
      [ (A)  (A)  (33) ]  [ (B)  (B)  (34) ]  [ (C)  (C)  (35) ]  % 33-35
      [ (D)  (D)  (36) ]  [ (E)  (E)  (37) ]  [ (F)  (F)  (38) ]  % 36-38
      [ (G)  (G)  (39) ]  [ (H)  (H)  (40) ]  [ (I)  (I)  (41) ]  % 39-41
      [ (J)  (J)  (42) ]  [ (K)  (K)  (43) ]  [ (L)  (L)  (44) ]  % 42-44
      [ (M)  (M)  (45) ]  [ (N)  (N)  (46) ]  [ (O)  (O)  (47) ]  % 45-47
      [ (P)  (P)  (48) ]  [ (Q)  (Q)  (49) ]  [ (R)  (R)  (50) ]  % 48-50
      [ (S)  (S)  (51) ]  [ (T)  (T)  (52) ]  [ (U)  (U)  (53) ]  % 51-53
      [ (V)  (V)  (54) ]  [ (W)  (W)  (55) ]  [ (X)  (X)  (56) ]  % 54-56
      [ (Y)  (Y)  (57) ]  [ (Z)  (Z)  (58) ]  [ ([)  ([)  (59) ]  % 57-59
      [  92   92  (60) ]  [ (])  (])  (61) ]  [ (^)  (^)  (62) ]  % 60-62
      [ (_)  (_)  (63) ]  [   0  (`)  (64) ]  [   1  (a)  (65) ]  % 63-65
      [   2  (b)  (66) ]  [   3  (c)  (67) ]  [   4  (d)  (68) ]  % 66-68
      [   5  (e)  (69) ]  [   6  (f)  (70) ]  [   7  (g)  (71) ]  % 69-71
      [   8  (h)  (72) ]  [   9  (i)  (73) ]  [  10  (j)  (74) ]  % 72-74
      [  11  (k)  (75) ]  [  12  (l)  (76) ]  [  13  (m)  (77) ]  % 75-77
      [  14  (n)  (78) ]  [  15  (o)  (79) ]  [  16  (p)  (80) ]  % 78-80
      [  17  (q)  (81) ]  [  18  (r)  (82) ]  [  19  (s)  (83) ]  % 81-83
      [  20  (t)  (84) ]  [  21  (u)  (85) ]  [  22  (v)  (86) ]  % 84-86
      [  23  (w)  (87) ]  [  24  (x)  (88) ]  [  25  (y)  (89) ]  % 87-89
      [  26  (z)  (90) ]  [  27  ({)  (91) ]  [  28  (|)  (92) ]  % 90-92
      [  29  (})  (93) ]  [  30  (~)  (94) ]  [  31  127  (95) ]  % 93-95
      [ fn3  fn3  (96) ]  [ fn2  fn2  (97) ]  [ sft  sft  (98) ]  % 96-98
      [ swc  swc  (99) ]  [ swb  fn4  swb  ]  [ fn4  swa  swa  ]  % 99-101
      [ fn1  fn1  fn1  ]  [ sta  sta  sta  ]  [ stb  stb  stb  ]  % 102-104
      [ stc  stc  stc  ]  [ stp  stp  stp  ]                      % 105-106
    ] def 
    
    % Invert charmaps to give character to value maps for each state
    /charvals [ 109 dict 109 dict 109 dict ] def
    0 1 charmaps length 1 sub {
        /i exch def
        /encs charmaps i get def
        0 1 2 {
            /j exch def
            encs j get dup type /stringtype eq {0 get} if  % convert string to ASCII if required
            charvals j get exch i put 
        } for
    } for
    /seta charvals 0 get def
    /setb charvals 1 get def
    /setc charvals 2 get def

    % Include pseudo characters for GS1-128 Composite linkage identifiers
    seta lka seta swb get put  seta lkc seta swc get put
    setb lka setb swc get put  setb lkc setb swa get put
    setc lka setc swa get put  setc lkc setc swb get put

    raw {/encoding (raw) def} if

    encoding (raw) eq {
        /cws barlen array def
        /i 0 def /j 0 def
        { % loop
            i barlen eq {exit} if
            /cw barcode i 1 add 3 getinterval cvi def
            cws j cw put
            /i i 4 add def
            /j j 1 add def
        } loop
        /cws cws 0 j getinterval def
        /text () def
    } if

    encoding (auto) eq { 

        /fncvals <<
            (FNC1) fn1
            (FNC2) fn2
            (FNC3) fn3
            (FNC4) fn4
            (LNKA) lka
            (LNKC) lkc
        >> def

        % Convert input into bytes accounting for FNC and LNK characters 
        /msg barlen array def
        /text barlen string def
        /i 0 def /j 0 def {
            i barlen eq {exit} if
            /char barcode i get def
            text j char put
            parsefnc char 94 eq and i barlen 4 sub lt and {
                barcode i 1 add get 94 ne {
                    /char fncvals barcode i 1 add 4 getinterval get def
                    text j ( ) putinterval
                    /i i 4 add def
                } {
                    /i i 1 add def
                } ifelse
            } if
            msg j char put
            /i i 1 add def
            /j j 1 add def
        } loop
        /msg msg 0 j getinterval def
        /msglen msg length def
        /text text 0 j getinterval def

        % Determine digit runlength and characters from given position
        /numsscr {
            /n 0 def /s 0 def
            /p exch def {
                p msglen ge {exit} if
                msg p get
                dup setc exch known not {pop exit} if
                fn1 eq {
                    % FNC1 in odd position of run like two digits
                    s 2 mod 0 eq {/s s 1 add def} {exit} ifelse
                } if
                /n n 1 add def
                /s s 1 add def
                /p p 1 add def
            } loop
            n s
        } bind def

        % Encoding for each alphabet
        /enca {
            seta exch get cws exch j exch put
            /j j 1 add def
        } bind def
        /encb {
            setb exch get cws exch j exch put
            /j j 1 add def
        } bind def
        /encc {
            dup type /arraytype ne {
                setc exch get
            } {
                aload pop 48 sub exch 48 sub 10 mul add
            } ifelse
            cws exch j exch put
            /j j 1 add def
        } bind def

        % Character exclusively in either alphabet A or B
        /anotb {dup seta exch known exch setb exch known not and} bind def
        /bnota {dup setb exch known exch seta exch known not and} bind def

        % Pre-compute relative position of next anotb and next bnota characters
        /nextanotb [ msg length {0} repeat 9999 ] def
        /nextbnota [ msg length {0} repeat 9999 ] def
        msg length 1 sub -1 0 {
            /i exch def
            msg i get anotb {
                nextanotb i 0 put
            } {
                nextanotb i nextanotb i 1 add get 1 add put
            } ifelse
            msg i get bnota {
                nextbnota i 0 put
            } {
                nextbnota i nextbnota i 1 add get 1 add put
            } ifelse
        } for

        % Does a-only come before b-only after given position and vice versa
        /abeforeb {dup nextanotb exch get exch nextbnota exch get lt} bind def
        /bbeforea {dup nextbnota exch get exch nextanotb exch get lt} bind def
        
        /cws barcode length 2 mul 3 add array def

        % Select start character
        /j 0 def
        msglen 0 gt {0 numsscr} {-1 -1} ifelse /nums exch def /nchars exch def
        {  % common exit
            msglen 0 eq {
                stb enca
                /cset (setb) def
                exit
            } if
            msglen 2 eq nums 2 eq and {
                stc enca
                /cset (setc) def
                exit
            } if
            nums 4 ge {
                stc enca
                /cset (setc) def
                exit
            } if
            0 abeforeb { 
                sta enca
                /cset (seta) def
                exit 
            } if 
            stb enca
            /cset (setb) def
            exit
        } loop

        % Main encoding loop
        /i 0 def {  
            i msglen eq {exit} if
        
            i numsscr /nums exch def /nchars exch def
        
            % Determine switches and shifts
            {  % common exit
                cset (seta) eq cset (setb) eq or nums 4 ge and 
                msg i get fn1 ne and {
                    nums 2 mod 0 eq {
                        swc cset (seta) eq {enca} {encb} ifelse
                        /cset (setc) def
                        exit
                    } {
                        msg i get cset (seta) eq {enca} {encb} ifelse
                        /i i 1 add def
                        swc cset (seta) eq {enca} {encb} ifelse
                        /cset (setc) def
                        exit
                    } ifelse
                } if
                cset (setb) eq msg i get anotb and { 
                    i msglen 1 sub lt {
                        i 1 add bbeforea { 
                            sft encb
                            msg i get enca
                            /i i 1 add def
                            exit
                        } if
                    } if
                    swa encb
                    /cset (seta) def
                    exit
                } if
                cset (seta) eq msg i get bnota and {
                    i msglen 1 sub lt {
                        i 1 add abeforeb {
                            sft enca
                            msg i get encb
                            /i i 1 add def
                            exit
                        } if
                    } if
                    swb enca
                    /cset (setb) def
                    exit
                } if
                cset (setc) eq nums 2 lt and {
                    i abeforeb {
                        swa encc
                        /cset (seta) def
                        exit
                    } if
                    swb encc
                    /cset (setb) def
                    exit
                } if
        
                % No switches or latches so encode
                cset (seta) eq {
                    msg i get enca
                    /i i 1 add def
                    exit
                } if
                cset (setb) eq {
                    msg i get encb
                    /i i 1 add def
                    exit
                } if
                cset (setc) eq {
                    msg i get fn1 eq {
                        fn1 encc
                        /i i 1 add def
                    } {
                        msg i 2 getinterval encc
                        /i i 2 add def 
                    } ifelse
                    exit
                } if
         
                exit
            } loop
        
        } loop
        /cws cws 0 j getinterval def
    } if  % auto encoding

    % Derive checksum and place stop character
    /cws j 2 add array dup 0 cws putinterval def
    /csum cws 0 get def
    1 1 j 1 sub {
        /i exch def
        /csum csum cws i get i mul add def
    } for
    /csum csum 103 mod def
    cws j csum put
    cws j 1 add seta stp get put

    % Create an array containing the character mappings
    /encs
    [ (212222) (222122) (222221) (121223) (121322) (131222) (122213)
      (122312) (132212) (221213) (221312) (231212) (112232) (122132)
      (122231) (113222) (123122) (123221) (223211) (221132) (221231)
      (213212) (223112) (312131) (311222) (321122) (321221) (312212)
      (322112) (322211) (212123) (212321) (232121) (111323) (131123)
      (131321) (112313) (132113) (132311) (211313) (231113) (231311)
      (112133) (112331) (132131) (113123) (113321) (133121) (313121)
      (211331) (231131) (213113) (213311) (213131) (311123) (311321)
      (331121) (312113) (312311) (332111) (314111) (221411) (431111)
      (111224) (111422) (121124) (121421) (141122) (141221) (112214)
      (112412) (122114) (122411) (142112) (142211) (241211) (221114)
      (413111) (241112) (134111) (111242) (121142) (121241) (114212)
      (124112) (124211) (411212) (421112) (421211) (212141) (214121)
      (412121) (111143) (111341) (131141) (114113) (114311) (411113)
      (411311) (113141) (114131) (311141) (411131) (211412) (211214)
      (211232) (2331112)
    ] def

    % Derive space bar succession
    /sbs cws length 6 mul 1 add string def
    0 1 cws length 1 sub {
        /i exch def
        sbs i 6 mul encs cws i get get putinterval
    } for

    % Return the arguments
    <<
    /ren //renlinear
    /sbs [sbs {48 sub} forall]
    /bhs [sbs length 1 add 2 idiv {height} repeat]
    /bbs [sbs length 1 add 2 idiv {0} repeat]
    /txt [ [text textxoffset textyoffset textfont textsize] ]
    /textxalign (center)
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/code128 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER code128--

% --BEGIN ENCODER gs1-128--
% --REQUIRES code128--
% --DESC: GS1-128
% --EXAM: (01)95012345678903(3103)000123
% --EXOP: includetext
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /code128 dup /uk.co.terryburton.bwipp findresource put
begin
/gs1-128 {

    20 dict begin            % Confine variables to local scope

    /options exch def  % We are given an option string
    /barcode exch def  % We are given a barcode string

    /dontdraw false def
    /includetext false def    % Enable/disable text
    /textfont /Courier def
    /textsize 10 def
    /textxoffset 0 def
    /textyoffset -7 def
    /height 0.5 def
    /linkagea false def
    /linkagec false def
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textxoffset textxoffset cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def 
   
    /text barcode def
 
    % Expand ordinals of the form ^NNN to ASCII
    /expand {
        /in exch def
        /out in length string def
        /j 0 def
        in
        { % loop
            (^) search {
                dup out exch j exch putinterval
                length j add 1 add /j exch def
                pop
                dup 0 3 getinterval cvi out exch j 1 sub exch put
                dup length 3 sub 3 exch getinterval
            } {
                dup out exch j exch putinterval
                length j add /j exch def
                out 0 j getinterval exit
            } ifelse 
        } loop
    } bind def
    
    % Parse out AIs
    /ais [] def
    /aival 2 dict def
    barcode dup length 1 sub 1 exch getinterval
    {  % loop
        dup () eq {exit} if
        (\)) search pop
        exch pop
        exch (\() search {
            exch pop exch 3 1 roll 
        } { 
            () 3 1 roll
        } ifelse
        [ ais aload pop counttomark 2 add index ] /ais exch def
        aival 3 1 roll expand put
    } loop
    pop

    % Pre-defined fixed length data field AIs
    % any AI whose prefix is not included in this table must be
    % terminated with "FNC1", even if it's fixed length
    /aifixed 23 dict def
    [
        0 1 4 {} for
    ] {
        (00) 2 string copy dup dup 1 5 -1 roll 48 add put aifixed 3 1 roll put
    } forall
    [
        11 1 20 {} for
        23
        31 1 36 {} for
        41
    ] {
        10 2 string cvrs dup aifixed 3 1 roll put
    } forall

    % Create the code128 data 
    /fnc1 -1 def
    /c128 [ fnc1 ] def
    0 1 ais length 1 sub {
        /i exch def
        /ai ais i get def
        /val aival ai get def
        c128 length ai length add val length add array
        dup 0 c128 putinterval
        dup c128 length ai [ exch {} forall ] putinterval
        dup c128 length ai length add val [ exch {} forall ] putinterval
        /c128 exch def
        i ais length 1 sub ne aifixed ai 0 2 getinterval known not and {  % Append FNC1
            c128 length 1 add array
            dup 0 c128 putinterval
            dup c128 length fnc1 put
            /c128 exch def
        } if
    } for

    % Compose input to code128
    /barcode c128 length 1 add 5 mul string def
    /i 0 def /j 0 def {
        i c128 length eq {exit} if
        c128 i get dup fnc1 eq {
            pop barcode j (^FNC1) putinterval
            /j j 4 add def
        } {
            barcode exch j exch put
        } ifelse
        /i i 1 add def
        /j j 1 add def
    } loop
    linkagea linkagec or {
        barcode j linkagea {(^LNKA)} {(^LNKC)} ifelse putinterval
        /j j 5 add def
    } if
    /barcode barcode 0 j getinterval def

    % Get the result of encoding with code128
    options (height) height put
    options (dontdraw) true put
    options (parsefnc) true put
    /args barcode options //code128 exec def

    args (txt) [ [text textxoffset textyoffset textfont textsize] ] put
    args (textxalign) (center) put
    args (opt) options put
    args
 
    dontdraw not //renlinear if
 
    end

} bind def
/gs1-128 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER gs1-128--

% --BEGIN ENCODER ean14--
% --REQUIRES code128--
% --DESC: GS1-14
% --EXAM: (01)04601234567893
% --EXOP: includetext
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /code128 dup /uk.co.terryburton.bwipp findresource put
begin
/ean14 {

    20 dict begin            % Confine variables to local scope

    /options exch def  % We are given an option string
    /barcode exch def  % We are given a barcode string

    /dontdraw false def
    /includetext false def    % Enable/disable text
    /textfont /Courier def
    /textsize 10 def
    /textxoffset 0 def
    /textyoffset -7 def
    /height 1 def
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textxoffset textxoffset cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def 

    % Calculate EAN checksum and add to end of barcode
    barcode length dup 17 eq exch 18 eq or 
    barcode 0 4 getinterval (\(01\)) eq and {
        /checksum 0 def
        0 1 12 {
            /i exch def
            /checksum checksum barcode i 4 add get 48 sub i 2 mod 0 eq {3 mul} if add def
        } for 
        /checksum 10 checksum 10 mod sub 10 mod def
        18 string
        dup 0 barcode 0 17 getinterval putinterval
        dup 17 checksum 48 add put
        /barcode exch def
        /gtin barcode 4 14 getinterval def
    } if

    % Compose input to code128
    /text barcode def
    /barcode 21 string def
    barcode 0 (^FNC101) putinterval
    barcode 7 gtin putinterval

    % Get the result of encoding with code128
    options (dontdraw) true put
    options (parsefnc) true put
    /args barcode options //code128 exec def

    args (txt) [ [text textxoffset textyoffset textfont textsize] ] put
    args (textxalign) (center) put
    args (opt) options put
    args
 
    dontdraw not //renlinear if
 
    end

} bind def
/ean14 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER ean14--

% --BEGIN ENCODER sscc18--
% --REQUIRES code128--
% --DESC: SSCC-18
% --EXAM: (00)006141411234567890
% --EXOP: includetext
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /code128 dup /uk.co.terryburton.bwipp findresource put
begin
/sscc18 {

    20 dict begin            % Confine variables to local scope

    /options exch def  % We are given an option string
    /barcode exch def  % We are given a barcode string

    /dontdraw false def
    /includetext false def    % Enable/disable text
    /textfont /Courier def
    /textsize 10 def
    /textxoffset 0 def
    /textyoffset -7 def
    /height 1 def
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textxoffset textxoffset cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def 

    % Calculate EAN checksum and add to end of barcode
    barcode length dup 21 eq exch 22 eq or 
    barcode 0 4 getinterval (\(00\)) eq and {
        /checksum 0 def
        0 1 16 {
            /i exch def
            /checksum checksum barcode i 4 add get 48 sub i 2 mod 0 eq {3 mul} if add def
        } for 
        /checksum 10 checksum 10 mod sub 10 mod def
        22 string
        dup 0 barcode 0 21 getinterval putinterval
        dup 21 checksum 48 add put
        /barcode exch def
        /sscc barcode 4 18 getinterval def
    } if

    % Compose input to code128
    /text barcode def
    /barcode 25 string def
    barcode 0 (^FNC100) putinterval
    barcode 7 sscc putinterval

    % Get the result of encoding with code128
    options (dontdraw) true put
    options (parsefnc) true put
    /args barcode options //code128 exec def

    args (txt) [ [text textxoffset textyoffset textfont textsize] ] put
    args (textxalign) (center) put
    args (opt) options put
    args
 
    dontdraw not //renlinear if
 
    end

} bind def
/sscc18 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER sscc18--

% --BEGIN ENCODER code39--
% --DESC: Code 39
% --EXAM: THIS IS CODE 39
% --EXOP: includetext includecheck includecheckintext
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/code39 {

    20 dict begin                 % Confine variables to local scope

    /options exch def       % We are given an option string
    /barcode exch def       % We are given a barcode string

    /dontdraw false def
    /includecheck false def  % Enable/disable checkdigit
    /includetext false def
    /includecheckintext false def
    /hidestars false def
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /height 1 def
    
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
 
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def
    
    % Create an array containing the character mappings
    /encs
    [ (1113313111) (3113111131) (1133111131) (3133111111) (1113311131)
      (3113311111) (1133311111) (1113113131) (3113113111) (1133113111)
      (3111131131) (1131131131) (3131131111) (1111331131) (3111331111)
      (1131331111) (1111133131) (3111133111) (1131133111) (1111333111)
      (3111111331) (1131111331) (3131111311) (1111311331) (3111311311)
      (1131311311) (1111113331) (3111113311) (1131113311) (1111313311)
      (3311111131) (1331111131) (3331111111) (1311311131) (3311311111)
      (1331311111) (1311113131) (3311113111) (1331113111) (1313131111)
      (1313111311) (1311131311) (1113131311) (1311313111)
    ] def

    % Create a string of the available characters
    /barchars (0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%*) def

    /barlen barcode length def  % Length of the code

    includecheck {
        /sbs barlen 10 mul 30 add string def
        /txt barlen 3 add array def
    } {
        /sbs barlen 10 mul 20 add string def
        /txt barlen 2 add array def
    } ifelse

    /checksum 0 def

    % Put the start character
    sbs 0 encs 43 get putinterval
    hidestars not {
        txt 0 [(*) 0 textyoffset textfont textsize] put
    } {
        txt 0 [() 0 textyoffset textfont textsize] put
    } ifelse

    0 1 barlen 1 sub {
        /i exch def
        % Lookup the encoding for the each barcode character
        barcode i 1 getinterval barchars exch search
        pop                                  % Discard true leaving pre
        length /indx exch def                % indx is the length of pre
        pop pop                              % Discard seek and post
        /enc encs indx get def               % Get the indxth encoding
        sbs i 10 mul 10 add enc putinterval  % Put encoded digit into sbs
        txt i 1 add [barcode i 1 getinterval i 1 add 16 mul textyoffset textfont textsize] put
        /checksum checksum indx add def
    } for

    % Put the checksum and end characters
    includecheck {
        /checksum checksum 43 mod def
        sbs barlen 10 mul 10 add encs checksum get putinterval
        includecheckintext {
            txt barlen 1 add [barchars checksum 1 getinterval barlen 1 add 16 mul textyoffset textfont textsize] put
        } {
            txt barlen 1 add [() barlen 1 add 16 mul textyoffset textfont textsize] put
        } ifelse
        sbs barlen 10 mul 20 add encs 43 get putinterval
        hidestars not {
            txt barlen 2 add [(*) barlen 2 add 16 mul textyoffset textfont textsize] put
        } {
            txt barlen 2 add [() barlen 2 add 16 mul textyoffset textfont textsize] put
        } ifelse
    } {
        sbs barlen 10 mul 10 add encs 43 get putinterval
        hidestars not {
            txt barlen 1 add [(*) barlen 1 add 16 mul textyoffset textfont textsize] put
        } {
            txt barlen 1 add [() barlen 1 add 16 mul textyoffset textfont textsize] put
        } ifelse
    } ifelse
    
    % Return the arguments
    <<
    /ren //renlinear
    /sbs [sbs {48 sub} forall]
    /bhs [sbs length 1 add 2 idiv {height} repeat]
    /bbs [sbs length 1 add 2 idiv {0} repeat]
    includetext {
        /txt txt
    } if
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/code39 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER code39--

% --BEGIN ENCODER code39ext--
% --REQUIRES code39--
% --DESC: Code 39 Extended
% --EXAM: Code39 Ext!
% --EXOP: includetext includecheck includecheckintext
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /code39 dup /uk.co.terryburton.bwipp findresource put
begin
/code39ext {

    20 dict begin

    /options exch def      % We are given an options string
    /barcode exch def      % We are given the code39extended text

    /dontdraw false def
    /includetext false def
    /parse false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    % Parse ordinals of the form ^NNN to ASCII
    parse {
        /msg barcode length string def
        /j 0 def
        barcode
        { % loop
            (^) search {
                dup msg exch j exch putinterval
                length j add 1 add /j exch def
                pop
                dup 0 3 getinterval cvi msg exch j 1 sub exch put
                dup length 3 sub 3 exch getinterval
            } {
                dup msg exch j exch putinterval
                length j add /j exch def
                /barcode msg 0 j getinterval def
                exit
            } ifelse 
        } loop
    } if

    /barlen barcode length def

    % Extended alphabet to non-extended alphabet
    /extencs
    [ (%U) ($A) ($B) ($C) ($D) ($E) ($F) ($G) ($H) ($I) ($J) ($K) ($L) ($M) ($N) ($O)
      ($P) ($Q) ($R) ($S) ($T) ($U) ($V) ($W) ($X) ($Y) ($Z) (%A) (%B) (%C) (%D) (%E)
      ( )  (/A) (/B) (/C) (/D) (/E) (/F) (/G) (/H) (/I) (/J) (/K) (/L) (-)  (.)  (/O)
      (0)  (1)  (2)  (3)  (4)  (5)  (6)  (7)  (8)  (9)  (/Z) (%F) (%G) (%H) (%I) (%J)
      (%V) (A)  (B)  (C)  (D)  (E)  (F)  (G)  (H)  (I)  (J)  (K)  (L)  (M)  (N)  (O)
      (P)  (Q)  (R)  (S)  (T)  (U)  (V)  (W)  (X)  (Y)  (Z)  (%K) (%L) (%M) (%N) (%O)
      (%W) (+A) (+B) (+C) (+D) (+E) (+F) (+G) (+H) (+I) (+J) (+K) (+L) (+M) (+N) (+O)
      (+P) (+Q) (+R) (+S) (+T) (+U) (+V) (+W) (+X) (+Y) (+Z) (%P) (%Q) (%R) (%S) (%T)
    ] def

    /newcode barlen 2 mul string def
    /newtext barlen 2 mul string def
    /j 0 def
    0 1 barlen 1 sub {
        /i exch def
        /extchar extencs barcode i get get def
        newcode j extchar putinterval
        newtext j barcode i get put
        extchar length 1 ne {newtext j 1 add ( ) putinterval} if
        /j j extchar length add def
    } for
    /newcode newcode 0 j getinterval def
    /newtext newtext 0 j getinterval def

    % Get the result of encoding with code39
    options (dontdraw) true put
    /args newcode options //code39 exec def

    % Replace chars in /txt with chars in newtext
    includetext {
        /txt args (txt) get def
        0 1 newtext length 1 sub {
            /i exch def
            /txtentry txt i 1 add get def
            txtentry 0 newtext i 1 getinterval put
            txt i 1 add txtentry put
        } for
        args (txt) txt put
    } if
    args (opt) options put
    args

    dontdraw not //renlinear if

    end

} bind def
/code39ext dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER code39ext--

% --BEGIN ENCODER code32--
% --REQUIRES code39--
% --DESC: Italian PharmaCode
% --EXAM: 01234567
% --EXOP: includetext
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /code39 dup /uk.co.terryburton.bwipp findresource put
begin
/code32 {

    20 dict begin

    /options exch def      % We are given an options string
    /barcode exch def      % We are given a barcode string

    /dontdraw false def
    /includetext false def  % Enable/disable code32 text
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /textxoffset 0 def
    /height 1 def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def

    /text 10 string def
    text 0 barcode 0 8 getinterval putinterval

    % calculate check digit
    text 8 0
    0 1 7 {
        dup text exch get 48 sub exch 1 and 1 add mul dup 9 gt {9 sub} if add
    } for
    10 mod 48 add put

    % convert number from base10 to base32
    /val text cvi 32 barcode cvrs def
    /barcode 6 string def
    0 1 5 {barcode exch 48 put} for
    barcode 6 val length sub val putinterval

    % convert base32 number to specified character set
    0 1 5 {
        dup barcode exch get
        dup (AEIO) {ge {1 add} if dup} forall pop
        barcode 3 1 roll put
    } for

    % format HRI
    text 1 text 0 9 getinterval putinterval
    text 0 65 put

    % Get the result of encoding with code39
    options (dontdraw) true put
    /args barcode options //code39 exec def

    args (txt) [ [text textxoffset textyoffset textfont textsize] ] put
    args (textxalign) (center) put
    args (opt) options put
    args

    dontdraw not //renlinear if

    end

} bind def
/code32 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER code32--

% --BEGIN ENCODER pzn--
% --REQUIRES code39--
% --DESC: Pharmazentralnummer (PZN)
% --EXAM: 123456
% --EXOP: includetext
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /code39 dup /uk.co.terryburton.bwipp findresource put
begin
/pzn {

    20 dict begin
 
    /options exch def      % We are given an options string
    /barcode exch def      % We are given a barcode string
 
    /dontdraw false def
    /includetext false def  % Enable/disable code32 text
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /textxoffset 0 def
    /height 1 def
    /pzn8 false def
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
 
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /textxoffset textxoffset cvr def
    /height height cvr def

    /msg pzn8 {9} {8} ifelse string def
    /msglen msg length def
    msg 0 45 put 
    msg 1 barcode 0 msglen 2 sub getinterval putinterval
 
    % calculate check digit
    0 
    1 1 msglen 2 sub {dup msg exch get 48 sub exch pzn8 not {1 add} if mul add} for
    11 mod 48 add
    msg exch msglen 1 sub exch put
 
    % Get the result of encoding with code39
    options (dontdraw) true put
    /args msg options //code39 exec def
 
    % format HRI
    /text msglen 5 add string def
    text 0 (PZN - ) putinterval
    text 6 msg 1 msglen 1 sub getinterval putinterval
 
    args (txt) [ [text textxoffset textyoffset textfont textsize] ] put
    args (textxalign) (center) put
    args (opt) options put
    args
 
    dontdraw not //renlinear if
 
    end
 
} bind def
/pzn dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER pzn--

% --BEGIN ENCODER code93--
% --DESC: Code 93
% --EXAM: THIS IS CODE 93
% --EXOP: includetext includecheck
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/code93 {

    20 dict begin                 % Confine variables to local scope

    /options exch def       % We are given an option string
    /barcode exch def       % We are given a barcode string

    /dontdraw false def
    /includecheck false def  % Enable/disable checkdigit
    /includetext false def   % Enable/disable text
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /height 1 def
    /parsefnc false def   
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
 
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def
    
    /encs
    [ (131112) (111213) (111312) (111411) (121113)
      (121212) (121311) (111114) (131211) (141111)
      (211113) (211212) (211311) (221112) (221211)
      (231111) (112113) (112212) (112311) (122112)
      (132111) (111123) (111222) (111321) (121122)
      (131121) (212112) (212211) (211122) (211221)
      (221121) (222111) (112122) (112221) (122121)
      (123111) (121131) (311112) (311211) (321111)
      (112131) (113121) (211131) (121221) (312111)
      (311121) (122211) (111141) (1111411)
    ] def

    % Create a string of the available characters
    /barchars (0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%) def

    /barlen barcode length def

    % Special function characters
    /sft1 -1 def  /sft2 -2 def  /sft3 -3 def  /sft4 -4 def
    /fncvals <<
        (SFT$) sft1
        (SFT%) sft2
        (SFT/) sft3
        (SFT+) sft4
    >> def

    % Convert input into bytes accounting for shift characters 
    /msg barlen array def
    /i 0 def /j 0 def {
        i barlen eq {exit} if
        /char barcode i get def
        parsefnc char 94 eq and i barlen 4 sub lt and {
            barcode i 1 add get 94 ne {
                /char fncvals barcode i 1 add 4 getinterval get def
                /i i 4 add def
            } {
                /i i 1 add def
            } ifelse
        } if
        msg j char put
        /i i 1 add def
        /j j 1 add def
    } loop
    /msg msg 0 j getinterval def
    /msglen msg length def

    includecheck {
        /sbs msglen 6 mul 25 add string def
    } {
        /sbs msglen 6 mul 13 add string def
    } ifelse
    /txt msglen array def

    % Put the start character
    sbs 0 encs 47 get putinterval
    
    /checksum1 0 def /checksum2 0 def
    0 1 msglen 1 sub {
        /i exch def
        % Lookup the encoding for the each barcode character
        msg i get dup 0 lt { 
            42 exch sub /indx exch def
            /char ( ) def
        } {
            1 string dup 0 4 -1 roll put /char exch def
            barchars char search
            pop                                  % Discard true leaving pre
            length /indx exch def                % indx is the length of pre
            pop pop                              % Discard seek and post
        } ifelse
        /enc encs indx get def                   % Get the indxth encoding
        sbs i 6 mul 6 add enc putinterval        % Put encoded digit into sbs
        txt i [char i 9 mul 9 add textyoffset textfont textsize] put
        /checksum1 checksum1 msglen i sub 1 sub 20 mod 1 add indx mul add def
        /checksum2 checksum2 msglen i sub 15 mod 1 add indx mul add def
    } for

    includecheck {
        % Put the first checksum character
        /checksum1 checksum1 47 mod def
        /checksum2 checksum2 checksum1 add 47 mod def
        sbs msglen 6 mul 6 add encs checksum1 get putinterval
        sbs msglen 6 mul 12 add encs checksum2 get putinterval
        % Put the end character
        sbs msglen 6 mul 18 add encs 48 get putinterval
    } {
        % Put the end character
        sbs msglen 6 mul 6 add encs 48 get putinterval      
    } ifelse

    % Return the arguments
    <<
    /ren //renlinear
    /sbs [sbs {48 sub} forall]
    /bhs [sbs length 1 add 2 idiv {height} repeat]
    /bbs [sbs length 1 add 2 idiv {0} repeat]
    includetext {
        /txt txt
    } if
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/code93 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER code93--

% --BEGIN ENCODER code93ext--
% --REQUIRES code93--
% --DESC: Code 93 Extended
% --EXAM: Code93 Ext!
% --EXOP: includetext includecheck
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /code93 dup /uk.co.terryburton.bwipp findresource put
begin
/code93ext {

    20 dict begin

    /options exch def      % We are given an options string
    /barcode exch def      % We are given the code39extended text

    /dontdraw false def
    /includetext false def
    /parse false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    % Parse ordinals of the form ^NNN to ASCII
    parse {
        /msg barcode length string def
        /j 0 def
        barcode
        { % loop
            (^) search {
                dup msg exch j exch putinterval
                length j add 1 add /j exch def
                pop
                dup 0 3 getinterval cvi msg exch j 1 sub exch put
                dup length 3 sub 3 exch getinterval
            } {
                dup msg exch j exch putinterval
                length j add /j exch def
                /barcode msg 0 j getinterval def
                exit
            } ifelse 
        } loop
    } if

    /barlen barcode length def

    % Extended alphabet to non-extended alphabet
    /extencs
    [ (^SFT%U) (^SFT$A) (^SFT$B) (^SFT$C) (^SFT$D) (^SFT$E) (^SFT$F) (^SFT$G) 
      (^SFT$H) (^SFT$I) (^SFT$J) (^SFT$K) (^SFT$L) (^SFT$M) (^SFT$N) (^SFT$O)
      (^SFT$P) (^SFT$Q) (^SFT$R) (^SFT$S) (^SFT$T) (^SFT$U) (^SFT$V) (^SFT$W)
      (^SFT$X) (^SFT$Y) (^SFT$Z) (^SFT%A) (^SFT%B) (^SFT%C) (^SFT%D) (^SFT%E)
      ( )      (^SFT/A) (^SFT/B) (^SFT/C) (^SFT/D) (^SFT/E) (^SFT/F) (^SFT/G)
      (^SFT/H) (^SFT/I) (^SFT/J) (^SFT/K) (^SFT/L) (-)      (.)      (^SFT/O)
      (0)      (1)      (2)      (3)      (4)      (5)      (6)      (7)
      (8)      (9)      (^SFT/Z) (^SFT%F) (^SFT%G) (^SFT%H) (^SFT%I) (^SFT%J)
      (^SFT%V) (A)      (B)      (C)      (D)      (E)      (F)      (G)
      (H)      (I)      (J)      (K)      (L)      (M)      (N)      (O)
      (P)      (Q)      (R)      (S)      (T)      (U)      (V)      (W)
      (X)      (Y)      (Z)      (^SFT%K) (^SFT%L) (^SFT%M) (^SFT%N) (^SFT%O)
      (^SFT%W) (^SFT+A) (^SFT+B) (^SFT+C) (^SFT+D) (^SFT+E) (^SFT+F) (^SFT+G)
      (^SFT+H) (^SFT+I) (^SFT+J) (^SFT+K) (^SFT+L) (^SFT+M) (^SFT+N) (^SFT+O)
      (^SFT+P) (^SFT+Q) (^SFT+R) (^SFT+S) (^SFT+T) (^SFT+U) (^SFT+V) (^SFT+W)
      (^SFT+X) (^SFT+Y) (^SFT+Z) (^SFT%P) (^SFT%Q) (^SFT%R) (^SFT%S) (^SFT%T)
    ] def

    /newcode barlen 6 mul string def
    /newtext barlen 6 mul string def
    /j 0 def /k 0 def
    0 1 barlen 1 sub {
        /i exch def
        /extchar extencs barcode i get get def
        /extlen extchar length def
        newcode j extchar putinterval
        newtext k barcode i get put
        extlen 1 ne {newtext k 1 add ( ) putinterval} if
        /j j extlen add def
        /k k extlen 1 eq {1} {2} ifelse add def
    } for
    /newcode newcode 0 j getinterval def
    /newtext newtext 0 k getinterval def

    % Get the result of encoding with code93
    options (dontdraw) true put
    options (parsefnc) true put
    /args newcode options //code93 exec def

    % Replace chars in /txt with chars in newtext
    includetext {
        /txt args (txt) get def
        0 1 newtext length 1 sub {
            /i exch def
            /txtentry txt i get def
            txtentry 0 newtext i 1 getinterval put
            txt i txtentry put
        } for
        args (txt) txt put
    } if
    args (opt) options put
    args

    dontdraw not //renlinear if

    end

} bind def
/code93ext dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER code93ext--

% --BEGIN ENCODER interleaved2of5--
% --DESC: Interleaved 2 of 5 (ITF)
% --EXAM: 2401234567
% --EXOP: height=0.5 includecheck includetext includecheckintext
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/interleaved2of5 {

    20 dict begin         % Confine variables to local scope

    /options exch def               % We are given an option string
    /barcode exch def               % We are given a barcode string

    /dontdraw false def
    /includecheck false def         % Enable/disable checkdigit
    /includetext false def          % Enable/disable text
    /includecheckintext false def
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /height 1 def
    
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
    
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def
    
    /barlen barcode length def      % Length of the code

    % Prefix 0 to barcode if length is even and including checkdigit
    % or length is odd and not including checkdigit
    barlen 2 mod 0 eq includecheck and          % even & includecheck
    barlen 2 mod 0 ne includecheck not and or { % odd  & !includecheck
        /pad barlen 1 add string def  % Create pad one bigger than barcode
        pad 0 48 put                  % Put ascii 0 at start of pad
        pad 1 barcode putinterval     % Add barcode to the end of pad
        /barcode pad def              % barcode=pad
        /barlen barlen 1 add def      % barlen++
    } if

    % Add checksum to end of barcode
    includecheck {
        /checksum 0 def
        0 1 barlen 1 sub {
            /i exch def
            i 2 mod 0 eq {
                /checksum checksum barcode i get 48 sub 3 mul add def
            } {
                /checksum checksum barcode i get 48 sub add def
            } ifelse
        } for
        /checksum 10 checksum 10 mod sub 10 mod def
        /pad barlen 1 add string def    % Create pad one bigger than barcode
        pad 0 barcode putinterval       % Add barcode to the start of pad
        pad barlen checksum 48 add put  % Add checksum to end of pad
        /barcode pad def                % barcode=pad
        /barlen barlen 1 add def        % barlen++
    } if

    % Create an array containing the character mappings
    /encs
    [ (11221) (21112) (12112) (22111) (11212)
      (21211) (12211) (11122) (21121) (12121)
      (1111)  (2111)
    ] def

    % Create a string of the available characters
    /barchars (0123456789) def
    /sbs barlen 5 mul 8 add string def
    /txt barlen array def

    % Put the start character
    sbs 0 encs 10 get putinterval

    0 2 barlen 1 sub {
    /i exch def
        % Lookup the encodings for two consecutive barcode characters
        barcode i 1 getinterval barchars exch search
        pop                           % Discard true leaving pre
        length /indx exch def         % indx is the length of pre
        pop pop                       % Discard seek and post
        /enca encs indx get def       % Get the indxth encoding

        barcode i 1 add 1 getinterval barchars exch search
        pop                           % Discard true leaving pre
        length /indx exch def         % indx is the length of pre
        pop pop                       % Discard seek and post
        /encb encs indx get def       % Get the indxth encoding

        % Interleave the two character encodings
        /intl enca length 2 mul string def
        0 1 enca length 1 sub {
            /j exch def
            /achar enca j get def
            /bchar encb j get def
            intl j 2 mul achar put
            intl j 2 mul 1 add bchar put
        } for

        sbs i 5 mul 4 add intl putinterval   % Put encoded digit into sbs
        txt i [barcode i 1 getinterval i 9 mul 4 add textyoffset textfont textsize] put
        includecheck includecheckintext not and barlen 2 sub i eq and {
            txt i 1 add [( ) i 1 add 9 mul 4 add textyoffset textfont textsize] put
        } {
            txt i 1 add [barcode i 1 add 1 getinterval i 1 add 9 mul 4 add textyoffset textfont textsize] put
        } ifelse
    } for

    % Put the end character
    sbs barlen 5 mul 4 add encs 11 get putinterval

    % Return the arguments
    <<
    /ren //renlinear
    /sbs [sbs {48 sub} forall]
    /bhs [sbs length 1 add 2 idiv {height} repeat]
    /bbs [sbs length 1 add 2 idiv {0} repeat]
    includetext {
        /txt txt
    } if
    /barratio 2
    /spaceratio 2
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/interleaved2of5 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER interleaved2of5--

% --BEGIN ENCODER itf14--
% --REQUIRES interleaved2of5--
% --DESC: ITF-14
% --EXAM: 04601234567893
% --EXOP: includetext
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /interleaved2of5 dup /uk.co.terryburton.bwipp findresource put
begin
/itf14 {

    20 dict begin            % Confine variables to local scope

    /options exch def  % We are given an option string
    /barcode exch def  % We are given a barcode string

    /dontdraw false def
    /includetext false def    % Enable/disable text
    /textfont /Courier def
    /textsize 10 def
    /textxoffset 0 def
    /textyoffset -7 def
    /height 1 def
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textxoffset textxoffset cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def 

    % Calculate EAN checksum and add to end of barcode
    barcode length dup 13 eq exch 14 eq or {
        /gtin barcode 0 13 getinterval def
    } if

    % Get the result of encoding with interleaved2of5
    options (dontdraw) true put
    options (showborder) true put
    options (borderwidth) 4 put
    options (borderleft) 15 put
    options (borderright) 15 put
    options (height) 0.5 put
    options (includecheck) true put
    options (includecheckintext) true put
    options (textyoffset) -10 put
    /args gtin options //interleaved2of5 exec def

    args (opt) options put
    args
 
    dontdraw not //renlinear if
 
    end

} bind def
/itf14 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER itf14--

% --BEGIN ENCODER identcode-- 
% --REQUIRES interleaved2of5--
% --DESC: Deutsche Post Identcode
% --EXAM: 563102430313
% --EXOP: includetext
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /interleaved2of5 dup /uk.co.terryburton.bwipp findresource put
begin
/identcode {

    20 dict begin            % Confine variables to local scope

    /options exch def  % We are given an option string
    /barcode exch def  % We are given a barcode string

    /dontdraw false def
    /includetext false def    % Enable/disable text
    /textfont /Courier def
    /textsize 10 def
    /textxoffset 0 def
    /textyoffset -7 def
    /height 1 def
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textxoffset textxoffset cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def 

    % Calculate checksum and add to end of barcode
    barcode length dup 11 eq exch 12 eq or {
        /checksum 0 def
        0 1 10 {
            /i exch def
            /checksum checksum barcode i get 48 sub i 2 mod 0 eq {4 mul} {9 mul} ifelse add def
        } for 
        /checksum 10 checksum 10 mod sub 10 mod def
        12 string
        dup 0 barcode 0 11 getinterval putinterval
        dup 11 checksum 48 add put
        /pad exch def
    } if
    /barcode pad def

    % Compose the human readable text
    /text (  .       .     ) 16 string copy def
    text  0 barcode  0 2 getinterval putinterval
    text  3 barcode  2 3 getinterval putinterval
    text  7 barcode  5 3 getinterval putinterval
    text 11 barcode  8 3 getinterval putinterval
    text 15 barcode 11 1 getinterval putinterval

    % Get the result of encoding with interleaved2of5
    options (dontdraw) true put
    options (includecheck) false put
    /args barcode options //interleaved2of5 exec def

    args (txt) [ [text textxoffset textyoffset textfont textsize] ] put
    args (textxalign) (center) put
    args (opt) options put
    args
 
    dontdraw not //renlinear if
 
    end

} bind def
/identcode dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER identcode--

% --BEGIN ENCODER leitcode-- 
% --REQUIRES interleaved2of5--
% --DESC: Deutsche Post Leitcode
% --EXAM: 21348075016401
% --EXOP: includetext
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /interleaved2of5 dup /uk.co.terryburton.bwipp findresource put
begin
/leitcode {

    20 dict begin            % Confine variables to local scope

    /options exch def  % We are given an option string
    /barcode exch def  % We are given a barcode string

    /dontdraw false def
    /includetext false def    % Enable/disable text
    /textfont /Courier def
    /textsize 10 def
    /textxoffset 0 def
    /textyoffset -7 def
    /height 1 def
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textxoffset textxoffset cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def 

    % Calculate checksum and add to end of barcode
    barcode length dup 13 eq exch 14 eq or {
        /checksum 0 def
        0 1 12 {
            /i exch def
            /checksum checksum barcode i get 48 sub i 2 mod 0 eq {4 mul} {9 mul} ifelse add def
        } for 
        /checksum 10 checksum 10 mod sub 10 mod def
        14 string
        dup 0 barcode 0 13 getinterval putinterval
        dup 13 checksum 48 add put
        /pad exch def
    } if
    /barcode pad def

    % Compose the human readable text
    /text (     .   .   .    ) 18 string copy def
    text  0 barcode  0 5 getinterval putinterval
    text  6 barcode  5 3 getinterval putinterval
    text 10 barcode  8 3 getinterval putinterval
    text 14 barcode 11 2 getinterval putinterval
    text 17 barcode 13 1 getinterval putinterval

    % Get the result of encoding with interleaved2of5
    options (dontdraw) true put
    options (includecheck) false put
    /args barcode options //interleaved2of5 exec def

    args (txt) [ [text textxoffset textyoffset textfont textsize] ] put
    args (textxalign) (center) put
    args (opt) options put
    args
 
    dontdraw not //renlinear if
 
    end

} bind def
/leitcode dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER leitcode--

% --BEGIN ENCODER databaromni--
% --DESC: GS1 DataBar Omnidirectional
% --EXAM: (01)24012345678905
% --EXOP:
% --RNDR: renlinear renmatrix
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/databaromni {

    20 dict begin            % Confine variables to local scope

    /options exch def  % We are given an option string
    /barcode exch def  % We are given a barcode string

    /dontdraw false def
    /height 33 72 div def
    /linkage false def
    /format (omni) def
    
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
  
    format (truncated) eq {/height 13 72 div def} if
    /height height cvr def

    % Strip the AI and optional check digit
    barcode length dup 17 eq exch 18 eq or {
        barcode 0 4 getinterval (\(01\)) eq {
            /binval [ 
                linkage {1} {0} ifelse
                barcode 4 13 getinterval {48 sub} forall
            ] def
        } if
    } if

    % Calculate EAN checksum and add to end of barcode
    /checksum 0 def
    0 1 12 {
        /i exch def
        /checksum checksum barcode i 4 add get 48 sub i 2 mod 0 eq {3 mul} if add def
    } for 
    /checksum 10 checksum 10 mod sub 10 mod def
    18 string
    dup 0 barcode 0 17 getinterval putinterval
    dup 17 checksum 48 add put
    /barcode exch def

    % Create the human readable text
    /txt barcode length array def
    0 1 barcode length 1 sub {
        /i exch def
        txt i [barcode i 1 getinterval 0 0 () 0] put
    } for

    /ncr {  % n r
        2 copy sub 2 copy lt {exch} if  % n r maxd mind
        1 1 5 3 roll  % mind j=1 v=1 n maxd
        1 add -1 exch {  % mind j v  n -1 maxd+1
            mul  % mind j v*i
            1 index 3 index le {
                1 index idiv exch 1 add exch
            } if
        } for
        {  % mind j v
            1 index 3 index gt {exit} if
            1 index idiv exch 1 add exch
        } loop
        exch pop exch pop
    } bind def
     
    /getRSSwidths {
        /oe exch def
        /el exch def
        /mw exch def
        /nm exch def
        /val exch def
        /out el array def
        /mask 0 def
        0 1 el 2 sub {
            /bar exch def
            /ew 1 def 
            /mask mask 1 bar bitshift or def {
                /sval nm ew sub 1 sub el bar sub 2 sub ncr def
                oe mask 0 eq and nm ew sub el 2 mul sub bar 2 mul add -2 ge and {
                    /sval sval nm ew sub el sub bar add el bar sub 2 sub ncr sub def
                } if
                el bar sub 2 gt {
                    /lval 0 def
                    nm ew sub el sub bar add 2 add -1 mw 1 add {
                        nm exch sub ew sub 1 sub el bar sub 3 sub ncr
                        /lval exch lval add def
                    } for
                    /sval sval lval el bar sub 1 sub mul sub def
                } {
                    nm ew sub mw gt {/sval sval 1 sub def} if
                } ifelse
                /val val sval sub def
                val 0 lt {exit} if
                /ew ew 1 add def
                /mask mask 1 bar bitshift not and def
            } loop  
            /val val sval add def
            /nm nm ew sub def
            out bar ew put 
        } for
        out el 1 sub nm put
        out
    } bind def
   
    0 1 12 {
        /i exch def
        binval i 1 add 2 copy get binval i get 4537077 mod 10 mul add put
        binval i binval i get 4537077 idiv put
    } for
    /right binval 13 get 4537077 mod def
    binval 13 2 copy get 4537077 idiv put

    /left 0 def
    /i true def
    0 1 13 {
        /j exch def
        binval j get
        dup 0 eq i and {
            pop
        } {
            /i false def
            /left left 3 -1 roll 10 13 j sub exp cvi mul add def
        } ifelse
    } for
    
    /d1 left 1597 idiv def
    /d2 left 1597 mod def
    /d3 right 1597 idiv def
    /d4 right 1597 mod def

    /tab164 [
        160   0     12 4   8 1  161   1
        960   161   10 6   6 3  80   10
        2014  961   8  8   4 5  31   34
        2714  2015  6  10  3 6  10   70
        2840  2715  4  12  1 8  1    126
    ] def

    /tab154 [
        335   0     5  10  2 7  4   84
        1035  336   7  8   4 5  20  35
        1515  1036  9  6   6 3  48  10
        1596  1516  11 4   8 1  81  1
    ] def

    /i 0 def {
        d1 tab164 i get le {
            tab164 i 1 add 7 getinterval {} forall
            /d1te exch def /d1to exch def
            /d1mwe exch def /d1mwo exch def
            /d1ele exch def /d1elo exch def
            /d1gs exch def
            exit
        } if
        /i i 8 add def
    } loop

    /i 0 def {
        d2 tab154 i get le {
            tab154 i 1 add 7 getinterval {} forall
            /d2te exch def /d2to exch def
            /d2mwe exch def /d2mwo exch def
            /d2ele exch def /d2elo exch def
            /d2gs exch def
            exit
        } if
        /i i 8 add def
    } loop

    /i 0 def {
        d3 tab164 i get le {
            tab164 i 1 add 7 getinterval {} forall
            /d3te exch def /d3to exch def
            /d3mwe exch def /d3mwo exch def
            /d3ele exch def /d3elo exch def
            /d3gs exch def
            exit
        } if
        /i i 8 add def
    } loop

    /i 0 def {
        d4 tab154 i get le {
            tab154 i 1 add 7 getinterval {} forall
            /d4te exch def /d4to exch def
            /d4mwe exch def /d4mwo exch def
            /d4ele exch def /d4elo exch def
            /d4gs exch def
            exit
        } if
        /i i 8 add def
    } loop
    
    /d1wo d1 d1gs sub d1te idiv d1elo d1mwo 4 false getRSSwidths def
    /d1we d1 d1gs sub d1te mod  d1ele d1mwe 4 true  getRSSwidths def
    /d2wo d2 d2gs sub d2to mod  d2elo d2mwo 4 true  getRSSwidths def
    /d2we d2 d2gs sub d2to idiv d2ele d2mwe 4 false getRSSwidths def
    /d3wo d3 d3gs sub d3te idiv d3elo d3mwo 4 false getRSSwidths def
    /d3we d3 d3gs sub d3te mod  d3ele d3mwe 4 true  getRSSwidths def
    /d4wo d4 d4gs sub d4to mod  d4elo d4mwo 4 true  getRSSwidths def
    /d4we d4 d4gs sub d4to idiv d4ele d4mwe 4 false getRSSwidths def

    /d1w 8 array def
    0 1 3 {
        /i exch def
        d1w i 2 mul d1wo i get put
        d1w i 2 mul 1 add d1we i get put
    } for

    /d2w 8 array def
    0 1 3 {
        /i exch def
        d2w 7 i 2 mul sub d2wo i get put
        d2w 6 i 2 mul sub d2we i get put
    } for
    
    /d3w 8 array def
    0 1 3 {
        /i exch def
        d3w 7 i 2 mul sub d3wo i get put
        d3w 6 i 2 mul sub d3we i get put
    } for
    
    /d4w 8 array def
    0 1 3 {
        /i exch def
        d4w i 2 mul d4wo i get put
        d4w i 2 mul 1 add d4we i get put
    } for

    /widths [
        d1w {} forall
        d2w {} forall
        d3w {} forall
        d4w {} forall
    ] def
    
    /checkweights [
        1   3   9   27  2   6   18  54
        58  72  24  8   29  36  12  4
        74  51  17  32  37  65  48  16
        64  34  23  69  49  68  46  59
    ] def

    /checkwidths [
        3 8 2 1 1   3 5 5 1 1   3 3 7 1 1
        3 1 9 1 1   2 7 4 1 1   2 5 6 1 1
        2 3 8 1 1   1 5 7 1 1   1 3 9 1 1
    ] def
    
    /checksum 0 def
    0 1 31 {
        /i exch def
        /checksum checksum widths i get checkweights i get mul add def 
    } for
    /checksum checksum 79 mod def    
    checksum 8 ge {/checksum checksum 1 add def} if
    checksum 72 ge {/checksum checksum 1 add def} if
    /checklt checkwidths checksum 9 idiv 5 mul 5 getinterval def
    /checkrtrev checkwidths checksum 9 mod 5 mul 5 getinterval def
    /checkrt 5 array def
    0 1 4 {
        /i exch def
        checkrt i checkrtrev 4 i sub get put
    } for

    % Stacked format
    format (omni) eq format (truncated) eq or {  % linear

        /sbs [
            1 d1w {} forall checklt {} forall d2w {} forall 
            d4w {} forall checkrt {} forall d3w {} forall 1 1
        ] def
        
        <<
        /ren //renlinear
        /sbs sbs
        /bhs [sbs length 1 add 2 idiv {height} repeat]
        /bbs [sbs length 1 add 2 idiv {0} repeat]
        /txt txt
        /textxalign (center)
        /opt options
        >>
    
        dontdraw not //renlinear if

    } {  % 2D - stacked or stackedomni

        /top [ 1 1 d1w {} forall checklt {} forall d2w {} forall 1 1 0 ] def
        /bot [ 1 1 d4w {} forall checkrt {} forall d3w {} forall 1 1 0 ] def 
        0 2 24 {
            /i exch def
            top i get {0} repeat
            top i 1 add get {1} repeat
        } for
        50 array astore /top exch def 
        0 2 24 {
            /i exch def
            bot i get {1} repeat
            bot i 1 add get {0} repeat
        } for
        50 array astore /bot exch def

        % Stacked
        format (stacked) eq {
            /sep [ 50 {0} repeat ] def
            4 1 45 {
                /i exch def
                top i get bot i get eq {
                    sep i 1 top i get sub put
                } {
                    sep i 1 sep i 1 sub get sub put
                } ifelse
            } for
            /pixs [
                5 {top aload pop} repeat
                sep aload pop
                7 {bot aload pop} repeat
            ] def
            /pixy pixs length 50 idiv def
        } if
    
        % Stacked omnidirectional
        format (stackedomni) eq {
            /sep1 [ top {1 exch sub} forall ] def
            sep1 0  [ 0 0 0 0 ] putinterval
            sep1 46 [ 0 0 0 0 ] putinterval
            18 1 30 {
                /i exch def
                top i get 0 eq {
                    top i 1 sub get 1 eq {
                        1
                    } {
                        sep1 i 1 sub get 0 eq {1} {0} ifelse
                    } ifelse
                } {
                    0
                } ifelse
                sep1 exch i exch put
            } for
            /sep2 [ 0 0 0 0 21 { 0 1 } repeat 0 0 0 0 ] def
            /sep3 [ bot {1 exch sub} forall ] def
            sep3 0  [ 0 0 0 0 ] putinterval
            sep3 46 [ 0 0 0 0 ] putinterval
            19 1 31 {
                /i exch def
                bot i get 0 eq {
                    bot i 1 sub get 1 eq {
                        1
                    } {
                        sep3 i 1 sub get 0 eq {1} {0} ifelse
                    } ifelse
                } {
                    0
                } ifelse
                sep3 exch i exch put
            } for
            /f3 [1 1 1 1 1 1 1 1 1 0 1 1 1] def
            true 0 1 12 {dup bot exch 19 add get exch f3 exch get eq and} for {
                % Right shifted module for value 3 finder
                sep3 19 [ 0 0 0 0 0 0 0 0 0 0 1 0 0 ] putinterval
            } if
            /pixs [
                33 {top aload pop} repeat
                sep1 aload pop
                sep2 aload pop
                sep3 aload pop
                33 {bot aload pop} repeat
            ] def
            /pixy pixs length 50 idiv def
        } if
    
        % Return the arguments
        <<
        /ren //renmatrix
        /pixs pixs
        /pixx 50
        /pixy pixy
        /height pixy 72 div
        /width 50 72 div
        /opt options
        >>
    
        dontdraw not //renmatrix if
     
    } ifelse
    
    end

} bind def
/databaromni dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER databaromni--

% --BEGIN ENCODER databarstacked--
% --REQUIRES databaromni--
% --DESC: GS1 DataBar Stacked
% --EXAM: (01)24012345678905
% --EXOP:
% --RNDR: renmatrix renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
dup /databaromni dup /uk.co.terryburton.bwipp findresource put
begin
/databarstacked {

    20 dict begin                 % Confine variables to local scope

    /options exch def       % We are given an option string
    /barcode exch def       % We are given a barcode string

    /dontdraw false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    % Get the result of encoding with databaromni with format=stacked
    options (dontdraw) true put
    options (format) (stacked) put

    /args barcode options //databaromni exec def

    args (opt) options put
    args
 
    dontdraw not //renmatrix if

    end

} bind def
/databarstacked dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER databarstacked--

% --BEGIN ENCODER databarstackedomni--
% --REQUIRES databaromni--
% --DESC: GS1 DataBar Stacked Omnidirectional
% --EXAM: (01)24012345678905
% --EXOP:
% --RNDR: renmatrix renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
dup /databaromni dup /uk.co.terryburton.bwipp findresource put
begin
/databarstackedomni {

    20 dict begin                 % Confine variables to local scope

    /options exch def       % We are given an option string
    /barcode exch def       % We are given a barcode string

    /dontdraw false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    % Get the result of encoding with databaromni with format=stackedomni
    options (dontdraw) true put
    options (format) (stackedomni) put

    /args barcode options //databaromni exec def

    args (opt) options put
    args
 
    dontdraw not //renmatrix if

    end

} bind def
/databarstackedomni dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER databarstackedomni--

% --BEGIN ENCODER databartruncated--
% --REQUIRES databaromni--
% --DESC: GS1 DataBar Truncated
% --EXAM: (01)24012345678905
% --EXOP:
% --RNDR: renlinear renmatrix
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /databaromni dup /uk.co.terryburton.bwipp findresource put
begin
/databartruncated {

    20 dict begin                 % Confine variables to local scope

    /options exch def       % We are given an option string
    /barcode exch def       % We are given a barcode string

    /dontdraw false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    % Get the result of encoding with databaromni with format=truncated
    options (dontdraw) true put
    options (format) (truncated) put

    /args barcode options //databaromni exec def

    args (opt) options put
    args
 
    dontdraw not //renlinear if

    end

} bind def
/databartruncated dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER databartruncated--

% --BEGIN ENCODER databarlimited--
% --DESC: GS1 DataBar Limited
% --EXAM: (01)15012345678907
% --EXOP:
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/databarlimited {

    20 dict begin            % Confine variables to local scope

    /options exch def  % We are given an option string
    /barcode exch def  % We are given a barcode string

    /dontdraw false def
    /height 10 72 div def
    /linkage false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
   
    /height height cvr def

    % Strip the AI and optional check digit
    barcode length dup 17 eq exch 18 eq or {
        barcode 0 5 getinterval dup (\(01\)0) eq exch (\(01\)1) eq or {
            /binval [ 
                barcode 4 13 getinterval {48 sub} forall
            ] def
            linkage {
                /linkval [ 2 0 1 5 1 3 3 5 3 1 0 9 6 ] def
                0 1 binval length 1 sub {
                    /i exch def
                    binval i binval i get linkval i get add put
                } for
            } if 
        } if
    } if

    % Calculate EAN checksum and add to end of barcode
    /checksum 0 def
    0 1 12 {
        /i exch def
        /checksum checksum barcode i 4 add get 48 sub i 2 mod 0 eq {3 mul} if add def
    } for 
    /checksum 10 checksum 10 mod sub 10 mod def
    18 string
    dup 0 barcode 0 17 getinterval putinterval
    dup 17 checksum 48 add put
    /barcode exch def

    % Create the human readable text
    /txt barcode length array def
    0 1 barcode length 1 sub {
        /i exch def
        txt i [barcode i 1 getinterval 0 0 () 0] put
    } for

    /ncr {  % n r
        2 copy sub 2 copy lt {exch} if  % n r maxd mind
        1 1 5 3 roll  % mind j=1 v=1 n maxd
        1 add -1 exch {  % mind j v  n -1 maxd+1
            mul  % mind j v*i
            1 index 3 index le {
                1 index idiv exch 1 add exch
            } if
        } for
        {  % mind j v
            1 index 3 index gt {exit} if
            1 index idiv exch 1 add exch
        } loop
        exch pop exch pop
    } bind def
    
    /getRSSwidths {
        /oe exch def
        /el exch def
        /mw exch def
        /nm exch def
        /val exch def
        /out el array def
        /mask 0 def
        0 1 el 2 sub {
            /bar exch def
            /ew 1 def 
            /mask mask 1 bar bitshift or def {
                /sval nm ew sub 1 sub el bar sub 2 sub ncr def
                oe mask 0 eq and nm ew sub el 2 mul sub bar 2 mul add -2 ge and {
                    /sval sval nm ew sub el sub bar add el bar sub 2 sub ncr sub def
                } if
                el bar sub 2 gt {
                    /lval 0 def
                    nm ew sub el sub bar add 2 add -1 mw 1 add {
                        nm exch sub ew sub 1 sub el bar sub 3 sub ncr
                        /lval exch lval add def
                    } for
                    /sval sval lval el bar sub 1 sub mul sub def
                } {
                    nm ew sub mw gt {/sval sval 1 sub def} if
                } ifelse
                /val val sval sub def
                val 0 lt {exit} if
                /ew ew 1 add def
                /mask mask 1 bar bitshift not and def
            } loop  
            /val val sval add def
            /nm nm ew sub def
            out bar ew put 
        } for
        out el 1 sub nm put
        out
    } bind def
   
    0 1 11 {
        /i exch def
        binval i 1 add 2 copy get binval i get 2013571 mod 10 mul add put
        binval i binval i get 2013571 idiv put
    } for
    /d2 binval 12 get 2013571 mod def
    binval 12 2 copy get 2013571 idiv put

    /d1 0 def
    /i true def
    0 1 12 {
        /j exch def
        binval j get
        dup 0 eq i and {
            pop
        } {
            /i false def
            /d1 d1 3 -1 roll 10 12 j sub exp cvi mul add def
        } ifelse
    } for
    
    /tab267 [
        183063   0        17 9   6 3  6538   28
        820063   183064   13 13  5 4  875    728
        1000775  820064   9  17  3 6  28     6454
        1491020  1000776  15 11  5 4  2415   203
        1979844  1491021  11 15  4 5  203    2408
        1996938  1979845  19 7   8 1  17094  1
        2013570  1996939  7  19  1 8  1      16632
    ] def

    /i 0 def {
        d1 tab267 i get le {
            tab267 i 1 add 7 getinterval {} forall
            /d1te exch def /d1to exch def
            /d1mwe exch def /d1mwo exch def
            /d1ele exch def /d1elo exch def
            /d1gs exch def
            exit
        } if
        /i i 8 add def
    } loop

    /i 0 def {
        d2 tab267 i get le {
            tab267 i 1 add 7 getinterval {} forall
            /d2te exch def /d2to exch def
            /d2mwe exch def /d2mwo exch def
            /d2ele exch def /d2elo exch def
            /d2gs exch def
            exit
        } if
        /i i 8 add def
    } loop

    /d1wo d1 d1gs sub d1te idiv d1elo d1mwo 7 false getRSSwidths def    
    /d1we d1 d1gs sub d1te mod  d1ele d1mwe 7 true  getRSSwidths def
    /d2wo d2 d2gs sub d2te idiv d2elo d2mwo 7 false getRSSwidths def    
    /d2we d2 d2gs sub d2te mod  d2ele d2mwe 7 true  getRSSwidths def

    /d1w 14 array def
    0 1 6 {
        /i exch def
        d1w i 2 mul d1wo i get put
        d1w i 2 mul 1 add d1we i get put
    } for

    /d2w 14 array def
    0 1 6 {
        /i exch def
        d2w i 2 mul d2wo i get put
        d2w i 2 mul 1 add d2we i get put
    } for

    /widths [
        d1w {} forall
        d2w {} forall
    ] def
    
    /checkweights [
        1  3  9  27 81 65 17 51 64 14 42 37 22 66
        20 60 2  6  18 54 73 41 34 13 39 28 84 74
    ] def

    /checkseq [
        0 1 43 {} for
        45 52 57
        63 1 66 {} for
        73 1 79 {} for
        82
        126 1 130 {} for
        132
        141 1 146 {} for
        210 1 217 {} for
        220
        316 1 320 {} for
        322 323
        326 337
    ] def
   
    /checksum 0 def
    0 1 27 {
        /i exch def
        /checksum checksum widths i get checkweights i get mul add def
    } for
    /checksum checksum 89 mod def
    /seq checkseq checksum get def
    /swidths seq 21 idiv 8 3 6 false getRSSwidths def
    /bwidths seq 21 mod  8 3 6 false getRSSwidths def

    /checkwidths [0 0 0 0 0 0 0 0 0 0 0 0 1 1] def
    0 1 5 {
        /i exch def
        checkwidths i 2 mul swidths i get put
        checkwidths i 2 mul 1 add bwidths i get put
    } for
    
    /sbs [
        1 d1w {} forall checkwidths {} forall d2w {} forall 1 1
    ] def
    
    % Return the arguments
    <<
    /ren //renlinear
    /sbs sbs
    /bhs [sbs length 1 add 2 idiv {height} repeat]
    /bbs [sbs length 1 add 2 idiv {0} repeat]
    /txt txt
    /textxalign (center)
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/databarlimited dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER databarlimited--

% --BEGIN ENCODER databarexpanded--
% --DESC: GS1 DataBar Expanded
% --EXAM: (01)95012345678903(3103)000123
% --EXOP:
% --RNDR: renlinear renmatrix
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/databarexpanded {

    20 dict begin            % Confine variables to local scope

    /options exch def  % We are given an option string
    /barcode exch def  % We are given a barcode string

    /dontdraw false def
    /height 34 72 div def
    /format (expanded) def
    /segments -1 def
    /linkage false def   
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
 
    /height height cvr def
    /segments segments cvi def

    segments -1 eq {
        /segments format (expandedstacked) eq {4} {22} ifelse def
    } if

    % Expand ordinals of the form ^NNN to ASCII
    /expand {
        /in exch def
        /out in length string def
        /j 0 def
        in
        { % loop
            (^) search {
                dup out exch j exch putinterval
                length j add 1 add /j exch def
                pop
                dup 0 3 getinterval cvi out exch j 1 sub exch put
                dup length 3 sub 3 exch getinterval
            } {
                dup out exch j exch putinterval
                length j add /j exch def
                out 0 j getinterval exit
            } ifelse 
        } loop
    } bind def
    
    % Parse out AIs
    /ais [] def
    /aival 2 dict def
    barcode dup length 1 sub 1 exch getinterval
    {  % loop
        dup () eq {exit} if
        (\)) search pop
        exch pop
        exch (\() search {
            exch pop exch 3 1 roll 
        } { 
            () 3 1 roll
        }  ifelse
        [ ais aload pop counttomark 2 add index ] /ais exch def
        aival 3 1 roll expand put
    } loop
    pop
    
    % Method selection
    {  % common exit
    
        % (01)9...(3103)...
        ais length 2 eq {
            ais 0 get (01) eq ais 1 get (3103) eq and { 
                aival (01) get 0 1 getinterval (9) eq aival (3103) get cvi 32767 le and {
                   (0100) false exit 
                } if
            } if
        } if
    
        % (01)9...(3202)...
        ais length 2 eq {
            ais 0 get (01) eq ais 1 get (3202) eq and {
                aival (01) get 0 1 getinterval (9) eq aival (3202) get cvi 9999 le and {
                    (0101) false exit
                } if
            } if
        } if
    
        % (01)9...(3203)...
        ais length 2 eq {
            ais 0 get (01) eq ais 1 get (3203) eq and {
                aival (01) get 0 1 getinterval (9) eq aival (3203) get cvi 22767 le and {
                    (0101) false exit
                } if
            } if
        } if
    
        % (01)9...(310x/320x)...[(11/13/15/17)...]
        ais length dup 2 eq exch 3 eq or {
           /ai310x false 3100 1 3109 {10 4 string cvrs ais 1 get eq or} for def
           /ai320x false 3200 1 3209 {10 4 string cvrs ais 1 get eq or} for def
           ais length 3 eq {
               /aibad true [ (11) (13) (15) (17) ] {ais 2 get ne and} forall def
           } {
               /aibad false def
           } ifelse
           ais 0 get (01) eq ai310x ai320x or and aibad not and {
               ais length 3 eq {
                   aival (01) get 0 1 getinterval (9) eq 
                   aival ais 1 get get cvi 99999 le and 
                   aival ais 2 get get cvi 999999 le and {
                       ai310x ais 2 get (11) eq and { (0111000) false exit } if
                       ai320x ais 2 get (11) eq and { (0111001) false exit } if
                       ai310x ais 2 get (13) eq and { (0111010) false exit } if
                       ai320x ais 2 get (13) eq and { (0111011) false exit } if
                       ai310x ais 2 get (15) eq and { (0111100) false exit } if
                       ai320x ais 2 get (15) eq and { (0111101) false exit } if
                       ai310x ais 2 get (17) eq and { (0111110) false exit } if
                       ai320x ais 2 get (17) eq and { (0111111) false exit } if
                   } if
               } {
                   aival (01) get 0 1 getinterval (9) eq 
                   aival ais 1 get get cvi 99999 le and {
                       ai310x { (0111000) false exit } if
                       ai320x { (0111001) false exit } if
                   } if
               } ifelse
           } if
        } if
    
        % (01)9...(392x)...
        ais length 2 ge {
            /ai392x false 3920 1 3923 {10 4 string cvrs ais 1 get eq or} for def
            ais 0 get (01) eq ai392x and {
                aival (01) get 0 1 getinterval (9) eq { (01100) true exit } if
            } if
        } if
    
        % (01)9...(393x)...
        ais length 2 ge {
            /ai393x false 3930 1 3933 {10 4 string cvrs ais 1 get eq or} for def
            ais 0 get (01) eq ai393x and {
                aival (01) get 0 1 getinterval (9) eq { (01101) true exit } if
            } if
        } if
    
        % (01)...
        ais 0 get (01) eq { (1) true exit } if
    
        % Freeform
        (00) true exit
    
    } loop
    /gpfallow exch def
    /method exch def
   
    /conv12to40 {
        (0000000000000000000000000000000000000000) 40 string copy
        2 copy  0 10 getinterval exch 0 3 getinterval cvi 2 10 string cvrs dup length 10 exch sub exch putinterval
        2 copy 10 10 getinterval exch 3 3 getinterval cvi 2 10 string cvrs dup length 10 exch sub exch putinterval
        2 copy 20 10 getinterval exch 6 3 getinterval cvi 2 10 string cvrs dup length 10 exch sub exch putinterval
        2 copy 30 10 getinterval exch 9 3 getinterval cvi 2 10 string cvrs dup length 10 exch sub exch putinterval
        exch pop
    } bind def
    
    /conv13to44 {
        (00000000000000000000000000000000000000000000) 44 string copy
        2 copy 0 4 getinterval exch 0 1 getinterval cvi 2 4 string cvrs dup length 4 exch sub exch putinterval
        dup 3 -1 roll 1 12 getinterval conv12to40 4 exch putinterval
    } bind def
    
    /tobin {
        string dup length 1 sub 0 exch 1 exch {1 index exch 48 put} for
        dup 3 -1 roll 2 2 index length string cvrs dup length 2 index length exch sub exch putinterval 
    } bind def
    
    method (00) eq {
        /cdf [] def
        /gpf [] def
    } if
    
    method (1) eq {
        /cdf aival (01) get 0 13 getinterval conv13to44 def
        /cdf [ cdf {48 sub} forall ] def
        /gpf [] def
        /ais ais 1 ais length 1 sub getinterval def
    } if
    
    method (0100) eq {
        /cdf 55 string def
        cdf 0 aival (01) get 1 12 getinterval conv12to40 putinterval
        cdf 40 aival (3103) get cvi 15 tobin putinterval
        /cdf [ cdf {48 sub} forall ] def
        /gpf [] def
        /ais [] def
    } if
    
    method (0101) eq {
        /cdf 55 string def
        cdf 0 aival (01) get 1 12 getinterval conv12to40 putinterval
        ais 1 get (3202) eq {
            aival (3202) get cvi 15 tobin
        } {
            aival (3203) get cvi 10000 add 15 tobin
        } ifelse
        cdf exch 40 exch putinterval
        /cdf [ cdf {48 sub} forall ] def
        /gpf [] def
        /ais [] def
    } if
    
    method length 7 eq {
        /cdf 76 string def
        cdf 0 aival (01) get 1 12 getinterval conv12to40 putinterval
        6 string dup 0 ais 1 get 3 1 getinterval putinterval
        dup aival ais 1 get get 1 5 getinterval 1 exch putinterval cvi 20 tobin
        cdf exch 40 exch putinterval
        ais length 3 eq {
            aival ais 2 get get
            dup 0 2 getinterval cvi 384 mul exch
            dup 2 2 getinterval cvi 1 sub 32 mul exch
            4 2 getinterval cvi add add 
        } {
            38400
        } ifelse
        16 tobin cdf exch 60 exch putinterval
        /cdf [ cdf {48 sub} forall ] def
        /gpf [] def
        /ais [] def
    } if
    
    method (01100) eq {
        /cdf 42 string def
        cdf 0 aival (01) get 1 12 getinterval conv12to40 putinterval
        cdf 40 ais 1 get 3 1 getinterval cvi 2 tobin putinterval
        /cdf [ cdf {48 sub} forall ] def
        /gpf [ aival ais 1 get get {} forall ] def
        /ais ais 2 ais length 2 sub getinterval def
    } if
    
    method (01101) eq {
        /cdf 52 string def
        cdf 0 aival (01) get 1 12 getinterval conv12to40 putinterval
        cdf 40 ais 1 get 3 1 getinterval cvi 2 tobin putinterval
        cdf 42 aival ais 1 get get 0 3 getinterval cvi 10 tobin putinterval
        /cdf [ cdf {48 sub} forall ] def
        /gpf [ aival ais 1 get get dup length 3 sub 3 exch getinterval {} forall ] def
        /ais ais 2 ais length 2 sub getinterval def
    } if
    
    % Variable length symbol field
    gpfallow {
        /vlf 2 array def
    } {
        /vlf [] def
    } ifelse
    
    % Pre-defined fixed length data field AIs
    % any AI whose prefix is not included in this table must be
    % terminated with "FNC1", even if it's fixed length
    /aifixed 23 dict def
    [
        0 1 4 {} for
    ] {
        (00) 2 string copy dup dup 1 5 -1 roll 48 add put aifixed 3 1 roll put
    } forall
    [
        11 1 20 {} for
        23
        31 1 36 {} for
        41
    ] {
        10 2 string cvrs dup aifixed 3 1 roll put
    } forall

    /fnc1 -1 def /lnumeric -2 def /lalphanumeric -3 def /liso646 -4 def
    
    /numeric <<
        0 1 119 {
            dup (00) 2 string copy dup 3 -1 roll 11 2 string cvrs
            dup length 2 exch sub exch putinterval 
            dup 0 get 65 eq {dup 0 94 put} if 
            dup 1 get 65 eq {dup 1 94 put} if 
            exch 8 add
            (0000000) 7 string copy dup 3 -1 roll 2 7 string cvrs 
            dup length 7 exch sub exch putinterval
        } for
        lalphanumeric (0000)
    >> def
    
    /alphanumeric <<
        48 1 57 {dup 43 sub 5 tobin} for
        fnc1 (01111)
        65 1 90 {dup 33 sub 6 tobin} for
        42 (111010)
        44 1 47 {dup 15 add 6 tobin} for
        lnumeric (000)
        liso646 (00100)
    >> def
    
    /iso646 <<
        48 1 57 {dup 43 sub 5 tobin} for
        fnc1 (01111)
        65 1 90 {dup 1 sub 7 tobin} for
        97 1 122 {dup 7 sub 7 tobin} for
        33 (11101000)
        34 (11101001)
        37 1 47 {dup 197 add 8 tobin} for
        58 1 63 {dup 187 add 8 tobin} for
        95 (11111011)
        32 (11111100)
        lnumeric (000)
        lalphanumeric (00100)
    >> def
    
    % Append the remaining AI data
    0 1 ais length 1 sub {
        /i exch def
        /ai ais i get def
        /val aival ai get def
        gpf length ai length add val length add array
        dup 0 gpf putinterval
        dup gpf length ai [ exch {} forall ] putinterval
        dup gpf length ai length add val [ exch {} forall ] putinterval
        /gpf exch def
        i ais length 1 sub ne aifixed ai 0 2 getinterval known not and {  % Append FNC1
            gpf length 1 add array
            dup 0 gpf putinterval
            dup gpf length fnc1 put
            /gpf exch def
        } if
    } for
    
    % Calculate the number of bits remaining to the next valid symbol size
    /rembits {
        dup
        12 div ceiling cvi 12 mul            % Round up to multiple of 12 
        48 2 copy lt {exch} if pop           % At least 4 symbols
        dup 12 idiv dup segments mod 1 eq {  % At least 2 symbols on last row of stacked symbol
            1 add 12 mul exch pop
        } {
            pop
        } ifelse 
        exch sub
    } bind def
    
    /encode {
        dup /raw ne {exch get} {pop} ifelse
        [ exch {48 sub} forall ]
        dup length exch
        gpfenc exch j exch putinterval
        /j exch j add def
    } bind def
   
    % Pre-compute alphanumeric and numeric runlengths and position of next ISO646-only characters
    /numericruns [ gpf length {0} repeat 0 -1 ] def
    /alphanumericruns [ gpf length {0} repeat 0 ] def
    /nextiso646only [ gpf length {0} repeat 9999 ] def
    gpf length 1 sub -1 0 {
        /i exch def
        gpf i get
        (00) 2 string copy
        dup 0 gpf i get dup fnc1 eq {pop 94} if put 
        i gpf length 1 sub lt {dup 1 gpf i 1 add get dup fnc1 eq {pop 94} if put} if
        numeric exch known {
            numericruns i numericruns i 2 add get 2 add put
        } {
            numericruns i 0 put
        } ifelse
        dup alphanumeric exch known {
            alphanumericruns i alphanumericruns i 1 add get 1 add put
        } {
            alphanumericruns i 0 put
        } ifelse
        dup iso646 exch known exch alphanumeric exch known not and {
            nextiso646only i 0 put
        } {
            nextiso646only i nextiso646only i 1 add get 1 add put
        } ifelse
    } for
   
    % Encode the general purpose field
    /gpfenc 252 array def
    /i 0 def /j 0 def /mode (numeric) def
    {  % loop
        i gpf length eq {exit} if
        {  % not a loop but common exit point
    
            mode (numeric) eq {
                i gpf length 2 sub le {
                    2 string 
                    dup 0 gpf i get dup fnc1 eq {pop 94} if put
                    dup 1 gpf i 1 add get dup fnc1 eq {pop 94} if put
                    dup numeric exch known {
                        numeric encode
                        /i i 2 add def
                        exit
                    } if
                    pop
                    lalphanumeric numeric encode 
                    /mode (alphanumeric) def
                    exit
                } {
                    gpf i get dup 48 lt exch 57 gt or {
                        lalphanumeric numeric encode
                        /mode (alphanumeric) def
                        exit
                    } if
                    /rem 12 1 add method length add vlf length add cdf length add j add rembits def
                    rem 4 ge rem 6 le and {  % C1 + 1 into 4 to 6 bits
                        (000000) 6 string copy 0 rem getinterval
                        dup gpf i get 47 sub 2 4 string cvrs
                        dup length 4 exch sub exch putinterval /raw encode
                        /i i 1 add def
                        exit
                    } {  % C1.FNC1
                        2 string dup 0 gpf i get put dup 1 94 put numeric encode 
                        /i i 1 add def
                        exit
                    } ifelse
                } ifelse
            } if
    
            mode (alphanumeric) eq {
                gpf i get fnc1 eq {
                    fnc1 alphanumeric encode
                    /i i 1 add def
                    exit
                } if
                gpf i get dup iso646 exch known exch alphanumeric exch known not and {
                     liso646 alphanumeric encode
                     /mode (iso646) def
                     exit
                } if
                numericruns i get 6 ge {
                    lnumeric alphanumeric encode
                    /mode (numeric) def
                    exit
                } if
                numericruns i get dup 4 ge exch i add gpf length eq and {
                    lnumeric alphanumeric encode
                    /mode (numeric) def
                    exit
                } if
                gpf i get alphanumeric encode
                /i i 1 add def
                exit
            } if
    
            mode (iso646) eq {
                gpf i get fnc1 eq {
                    fnc1 iso646 encode
                    /i i 1 add def
                    exit
                } if
                numericruns i get 4 ge nextiso646only i get 10 ge and {
                    lnumeric iso646 encode
                    /mode (numeric) def
                    exit
                } if
                alphanumericruns i get 5 ge nextiso646only i get 10 ge and {
                    lalphanumeric iso646 encode
                    /mode (alphanumeric) def
                    exit
                } if
                gpf i get iso646 encode
                /i i 1 add def
                exit
            } if
    
        } loop
    } loop
    /gpf gpfenc 0 j getinterval def
   
    % Complete the variable length field and create pad
    1 12 add method length add vlf length add cdf length add gpf length add 
    dup rembits dup array /pad exch def
    vlf length 0 ne {
        add 12 idiv
        dup 2 mod vlf exch 0 exch put
        14 le {0} {1} ifelse vlf exch 1 exch put
    } {
        pop pop
    } ifelse
    pad length 0 gt {
        0 5 pad length 1 sub {  % Fill with 00100
            /i exch def
            pad i [ 0 0 1 0 0 ] 0 pad length i sub 5 2 copy gt {exch} if pop getinterval putinterval 
        } for 
        mode (numeric) eq {  % Prefix shift from numeric to ASCII
            /pad [ 0 0 0 0 pad aload pop ] 0 pad length getinterval def
        } if
    } if
   
    % Concatinate fields
    /binval [
        linkage {1} {0} ifelse 
        method {48 sub} forall
        vlf aload pop
        cdf aload pop
        gpf aload pop
        pad aload pop
    ] def
    /datalen binval length 12 idiv def
    
    /ncr {  % n r
        2 copy sub 2 copy lt {exch} if  % n r maxd mind
        1 1 5 3 roll  % mind j=1 v=1 n maxd
        1 add -1 exch {  % mind j v  n -1 maxd+1
            mul  % mind j v*i
            1 index 3 index le {
                1 index idiv exch 1 add exch
            } if
        } for
        {  % mind j v
            1 index 3 index gt {exit} if
            1 index idiv exch 1 add exch
        } loop
        exch pop exch pop
    } bind def
    
    /getRSSwidths {
        /oe exch def
        /el exch def
        /mw exch def
        /nm exch def
        /val exch def
        /out el array def
        /mask 0 def
        0 1 el 2 sub {
            /bar exch def
            /ew 1 def 
            /mask mask 1 bar bitshift or def {
                /sval nm ew sub 1 sub el bar sub 2 sub ncr def
                oe mask 0 eq and nm ew sub el 2 mul sub bar 2 mul add -2 ge and {
                    /sval sval nm ew sub el sub bar add el bar sub 2 sub ncr sub def
                } if
                el bar sub 2 gt {
                    /lval 0 def
                    nm ew sub el sub bar add 2 add -1 mw 1 add {
                        nm exch sub ew sub 1 sub el bar sub 3 sub ncr
                        /lval exch lval add def
                    } for
                    /sval sval lval el bar sub 1 sub mul sub def
                } {
                    nm ew sub mw gt {/sval sval 1 sub def} if
                } ifelse
                /val val sval sub def
                val 0 lt {exit} if
                /ew ew 1 add def
                /mask mask 1 bar bitshift not and def
            } loop  
            /val val sval add def
            /nm nm ew sub def
            out bar ew put 
        } for
        out el 1 sub nm put
        out
    } bind def

    /tab174 [
        347   0     12 5   7 2  87  4
        1387  348   10 7   5 4  52  20
        2947  1388  8  9   4 5  30  52
        3987  2948  6  11  3 6  10  104
        4191  3988  4  13  1 8  1   204
    ] def

    /dxw datalen array def
    
    0 1 datalen 1 sub {

        /x exch def

        /d binval x 12 mul 12 getinterval def
        /d 0 0 1 11 {/j exch def 2 11 j sub exp cvi d j get mul add} for def

        /j 0 def {
            d tab174 j get le {
                tab174 j 1 add 7 getinterval {} forall
                /dte exch def /dto exch def
                /dmwe exch def /dmwo exch def
                /dele exch def /delo exch def
                /dgs exch def
                exit
            } if
            /j j 8 add def
        } loop

        /dwo d dgs sub dte idiv delo dmwo 4 true  getRSSwidths def
        /dwe d dgs sub dte mod  dele dmwe 4 false getRSSwidths def

        /dw 8 array def        
        x 2 mod 0 eq {                    
            0 1 3 {
                /j exch def
                dw 7 j 2 mul sub dwo j get put
                dw 6 j 2 mul sub dwe j get put
            } for
        } {           
            0 1 3 {
                /j exch def
                dw j 2 mul dwo j get put
                dw j 2 mul 1 add dwe j get put
            } for
        } ifelse

        dxw x dw put

    } for
    
    /finderwidths [
        1 8 4 1 1    1 1 4 8 1
        3 6 4 1 1    1 1 4 6 3
        3 4 6 1 1    1 1 6 4 3
        3 2 8 1 1    1 1 8 2 3
        2 6 5 1 1    1 1 5 6 2
        2 2 9 1 1    1 1 9 2 2
    ] def

    /finderseq [
        [0 1]
        [0 3 2]
        [0 5 2 7]
        [0 9 2 7 4]
        [0 9 2 7 6 11]
        [0 9 2 7 8 11 10]
        [0 1 2 3 4 5 6 7]
        [0 1 2 3 4 5 6 9 8]
        [0 1 2 3 4 5 6 9 10 11]
        [0 1 2 3 4 7 6 9 8 11 10]
    ] def

    /seq finderseq datalen 2 sub 2 idiv get def
    /fxw seq length array def
    0 1 seq length 1 sub {
        /x exch def
        fxw x finderwidths seq x get 5 mul 5 getinterval put
    } for

    /checkweights [
        -1   -1   -1   -1   -1   -1   -1   -1   % A1L
        77   96   32   81   27   9    3    1    % A1R
        20   60   180  118  143  7    21   63   % A2L
        205  209  140  117  39   13   145  189  % A2R
        193  157  49   147  19   57   171  91   % B1L 
        132  44   85   169  197  136  186  62   % B1R
        185  133  188  142  4    12   36   108  % B2L
        50   87   29   80   97   173  128  113  % B2R
        150  28   84   41   123  158  52   156  % C1L
        166  196  206  139  187  203  138  46   % C1R
        76   17   51   153  37   111  122  155  % C2L
        146  119  110  107  106  176  129  43   % C2R
        16   48   144  10   30   90   59   177  % D1L
        164  125  112  178  200  137  116  109  % D1R
        70   210  208  202  184  130  179  115  % D2L
        190  204  68   93   31   151  191  134  % D2R
        148  22   66   198  172  94   71   2    % E1L
        40   154  192  64   162  54   18   6    % E1R
        120  149  25   75   14   42   126  167  % E2L
        175  199  207  69   23   78   26   79   % E2R
        103  98   83   38   114  131  182  124  % F1L
        159  53   88   170  127  183  61   161  % F1R
        55   165  73   8    24   72   5    15   % F2L
        89   100  174  58   160  194  135  45   % F2R
    ] def

    /checkweightseq [
       seq {16 mul checkweights exch 16 getinterval aload pop} forall
    ] dup length 8 sub 8 exch getinterval def

    /widths [
        dxw {{} forall} forall
    ] def
   
    /checksum 0 def
    0 1 widths length 1 sub {
        /i exch def
        /checksum checksum widths i get checkweightseq i get mul add def 
    } for
    /checksum checksum 211 mod datalen 3 sub 211 mul add def

    /i 0 def {
        checksum tab174 i get le {
            tab174 i 1 add 7 getinterval {} forall
            /cte exch def /cto exch def
            /cmwe exch def /cmwo exch def
            /cele exch def /celo exch def
            /cgs exch def
            exit
        } if
        /i i 8 add def
    } loop

    /cwo checksum cgs sub cte idiv celo cmwo 4 true  getRSSwidths def
    /cwe checksum cgs sub cte mod  cele cmwe 4 false getRSSwidths def

    /cw 8 array def        
    0 1 3 {
        /i exch def
        cw i 2 mul cwo i get put
        cw i 2 mul 1 add cwe i get put
    } for

    22 array dup dup
    0 cw put 1 dxw putinterval 0 datalen 1 add getinterval
    /dxw exch def
    /datalen dxw length def

    % Encode row runlengths
    /rows datalen segments div ceiling cvi array def
    /numrows rows length def
    0 1 numrows 1 sub {
        /r exch def
        mark
        segments 4 mod 0 ne r 2 mod 1 eq and {0} if
        1 1
        0 1 segments 1 sub {
            /pos exch r segments mul add def
            pos datalen lt {
                dxw pos get {} forall                 
                pos 2 mod 0 eq {fxw pos 2 idiv get {} forall} if
            } if
        } for
        1 1
        counttomark array astore rows exch r exch put pop
    } for

    format (expandedstacked) ne {  % Linear

        % Remove leading space
        /sbs rows 0 get dup length 1 sub 1 exch getinterval def

        /sbs [
            1
            0 1 datalen 1 sub {
                /i exch def
                dxw i get {} forall
                i 2 mod 0 eq {fxw i 2 idiv get {} forall} if
            } for
            1 1
        ] def

        <<
        /ren //renlinear
        /sbs sbs
        /bhs [sbs length 1 add 2 idiv {height} repeat]
        /bbs [sbs length 1 add 2 idiv {0} repeat]
        /opt options
        >>

        dontdraw not //renlinear if

    } {  % expandedstacked

        /seps numrows array def
        0 1 numrows 1 sub {

            /r exch def
            /row rows r get def

            % Sample runlengths into bitmap
            mark
            0 2 row length 1 sub {
                /i exch def
                row i get {0} repeat
                i row length 1 sub lt {row i 1 add get {1} repeat} if
            } for
            counttomark array astore /row exch def pop

            % Derive the separator pattern
            /sep [ row {1 exch sub} forall ] def
            sep 0 [ 0 0 0 0 ] putinterval
            sep row length 4 sub [ 0 0 0 0 ] putinterval
            /finderpos [  % Finder pattern module positions
                19 98 row length 13 sub {} for
                68 98 row length 13 sub {} for
            ] def 
            finderpos {
                dup 14 add 1 exch {
                    /i exch def
                    row i get 0 eq {
                        row i 1 sub get 1 eq {
                            1
                        } {
                            sep i 1 sub get 0 eq {1} {0} ifelse
                        } ifelse
                    } {
                        0
                    } ifelse
                    sep exch i exch put
                } for
            } forall

            % For even segment-pair symbols reverse alternate rows
            segments 4 mod 0 eq r 2 mod 1 eq and {
                rows r get length rows 0 get length ne  % Except partial width last row
                finderpos length 2 mod 1 eq and {       % with odd finders
                    /row [ 0 row aload pop ] def
                    /sep [ 0 sep aload pop ] def
                } {
                    row length 1 sub -1 0 {row exch get} for
                    row astore pop
                    sep length 1 sub -1 0 {sep exch get} for
                    sep astore pop
                } ifelse
            } if

            rows r row put
            seps r sep put

        } for

        % Extend last row and separator to fill width of symbol
        /pixx rows 0 get length def
        [ pixx {0} repeat ] dup 0 rows numrows 1 sub get putinterval
        rows exch numrows 1 sub exch put 
        [ pixx {0} repeat ] dup 0 seps numrows 1 sub get putinterval
        seps exch numrows 1 sub exch put 

        % Middle separator pattern
        /sep [ pixx 2 idiv 1 add { 0 1 } repeat ] 0 pixx getinterval def
        sep 0 [0 0 0 0] putinterval
        sep pixx 4 sub [0 0 0 0] putinterval

        % Compose the symbol
        /pixs [
            0 1 numrows 1 sub {
                /r exch def
                r 0 ne {
                    seps r get aload pop
                } if
                34 {rows r get aload pop} repeat
                r numrows 1 sub ne {
                    seps r get aload pop
                    sep aload pop
                } if
            } for
        ] def

        <<
        /ren //renmatrix
        /pixs pixs
        /pixx pixx
        /pixy pixs length pixx idiv
        /height pixs length pixx idiv 72 div
        /width pixx 72 div
        /opt options
        >>

        dontdraw not //renmatrix if

    } ifelse

    end

} bind def
/databarexpanded dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER databarexpanded--

% --BEGIN ENCODER databarexpandedstacked--
% --REQUIRES databarexpanded--
% --DESC: GS1 DataBar Expanded Stacked
% --EXAM: (01)95012345678903(3103)000123
% --EXOP: segments=4
% --RNDR: renmatrix renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
dup /databarexpanded dup /uk.co.terryburton.bwipp findresource put
begin
/databarexpandedstacked {

    20 dict begin                 % Confine variables to local scope

    /options exch def       % We are given an option string
    /barcode exch def       % We are given a barcode string

    /dontdraw false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    % Get the result of encoding with databarexpanded with format=expandedstacked
    options (dontdraw) true put
    options (format) (expandedstacked) put

    /args barcode options //databarexpanded exec def

    args (opt) options put
    args
 
    dontdraw not //renmatrix if

    end

} bind def
/databarexpandedstacked dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER databarexpandedstacked--

% --BEGIN ENCODER pharmacode--
% --DESC: Pharmaceutical Binary Code
% --EXAM: 117480
% --EXOP: showborder
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/pharmacode {

    20 dict begin                 % Confine variables to local scope

    /options exch def       % We are given an option string
    /barcode exch def       % We are given a barcode string

    /dontdraw false def
    /height 8 2.835 mul 72 div def
    /nwidth 0.5 2.835 mul def
    /wwidth 1.5 2.835 mul def
    /swidth 1.0 2.835 mul def    

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
 
    /height height cvr def
    /nwidth nwidth cvr def
    /wwidth wwidth cvr def
    /swidth swidth cvr def

    % Create the human readable text
    /txt barcode length array def
    0 1 barcode length 1 sub {
        /i exch def
        txt i [barcode i 1 getinterval 0 0 () 0] put
    } for

    % Convert the integer into the paramacode string 
    /barcode barcode cvi 1 add 2 17 string cvrs def
    /barcode barcode 1 barcode length 1 sub getinterval def

    /barlen barcode length def  % Length of the code
    /sbs barlen 2 mul array def

    0 1 barlen 1 sub {
        /i exch def
        /enc barcode i 1 getinterval def
        enc (0) eq {
            sbs i 2 mul nwidth put
        } {
            sbs i 2 mul wwidth put
        } ifelse
        sbs i 2 mul 1 add swidth put
    } for

    % Return the arguments
    <<
    /ren //renlinear
    /sbs sbs
    /bhs [sbs length 1 add 2 idiv {height} repeat]
    /bbs [sbs length 1 add 2 idiv {0} repeat]
    /txt txt
    /textxalign (center)
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/pharmacode dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER pharmacode--

% --BEGIN ENCODER pharmacode2--
% --DESC: Two-track Pharmacode
% --EXAM: 117480
% --EXOP: includetext showborder
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/pharmacode2 {

    20 dict begin

    /options exch def           % We are given an option string
    /barcode exch def           % We are given a barcode string

    /dontdraw false def
    /includetext false def      % Enable/disable text
    /height 4 def               % Height of short bars in millimetres

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /height height cvr def

    % Create the human readable text
    /txt barcode length array def
    0 1 barcode length 1 sub {
        /i exch def
        txt i [barcode i 1 getinterval 0 0 () 0] put
    } for

    /encstr 16 string def
    /bhs 16 array def
    /bbs 16 array def
    /sbs 32 array def
    /bar 1 25.4 div height mul def     % bar height (mm)
    /spc 1 25.4 div 72 mul def         % bar width & spacing (1mm)
 
    % Convert number into a base3 representation
    /i 15 def
    /val barcode cvi def
    {  % loop
        val 0 eq {exit} if
        val 3 mod dup
        [3 1 2] exch get val exch sub 3 idiv /val exch def
        encstr i [2 0 1] 4 -1 roll get put
        /i i 1 sub def
    } loop
    /encstr encstr i 1 add 15 i sub getinterval def
 
    % Generate the bar pattern
    0 1 encstr length 1 sub {
        /i exch def
        encstr i get dup
        bhs i bar [1 1 2] 5 -1 roll get mul put
        bbs i [0 bar 0] 4 -1 roll get put
    } for
     
    % Return the arguments
    <<
    /ren //renlinear
    /bhs bhs
    /bbs bbs
    /sbs [encstr length 2 mul {spc} repeat]
    /txt txt
    /textxalign (center)
    /textyoffset 4
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/pharmacode2 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER pharmacode2--

% --BEGIN ENCODER code2of5--
% --DESC: Code 25
% --EXAM: 01234567
% --EXOP: version=iata includetext includecheck includecheckintext
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/code2of5 {

    20 dict begin                 % Confine variable to local scope

    /options exch def       % We are given an option string
    /barcode exch def       % We are given a barcode string

    /dontdraw false def
    /includecheck false def
    /includetext false def   % Enable/disable text
    /includecheckintext false def
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /height 1 def
    /version (industrial) def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def

    % Create an array containing the character mappings
    << 
    /industrial
        [ (1111313111) (3111111131) (1131111131) (3131111111)
          (1111311131) (3111311111) (1131311111) (1111113131)
          (3111113111) (1131113111) (313111)     (31113)
        ] 
    /iata
        [ (1111313111) (3111111131) (1131111131) (3131111111)
          (1111311131) (3111311111) (1131311111) (1111113131)
          (3111113111) (1131113111) (1111)       (311)
        ]
    /matrix
        [ (113311) (311131) (131131) (331111) (113131) (313111)
          (133111) (111331) (311311) (131311) (311111) (31111)
        ]
    /coop
        [ (331111) (111331) (113131) (113311) (131131) (131311)
          (133111) (311131) (311311) (313111) (3131)   (133)
        ]
    /datalogic
        [ (113311) (311131) (131131) (331111) (113131) (313111)
          (133111) (111331) (311311) (131311) (1111)   (311)
        ]
    >>
    version get /encs exch def
    /cs encs 0 get length def
    /cw 0 encs 0 get {48 sub add} forall def
    /ss encs dup length 2 sub get length def
    /sw 0 encs dup length 2 sub get {48 sub add} forall def

    % Create a string of the available characters
    /barchars (0123456789) def

    /barlen barcode length def            % Length of the code

    includecheck {
        /sbs barlen 1 add cs mul ss add ss add string def
        /txt barlen 1 add array def
    } {
        /sbs barlen cs mul ss add ss add string def
        /txt barlen array def
    } ifelse

    % Put the start character
    sbs 0 encs 10 get putinterval

    /checksum 0 def

    0 1 barlen 1 sub {
        /i exch def
        % Lookup the encoding for the each barcode character
        barcode i 1 getinterval barchars exch search
        pop                                 % Discard true leaving pre
        length /indx exch def               % indx is the length of pre
        pop pop                             % Discard seek and post
        /enc encs indx get def              % Get the indxth encoding
        sbs i cs mul ss add enc putinterval % Put encoded digit into sbs
        txt i [barcode i 1 getinterval i cw mul sw add textyoffset textfont textsize] put
        barlen i sub 2 mod 0 eq {
            /checksum checksum indx add def
        } {
            /checksum checksum indx 3 mul add def
        } ifelse
    } for

    % Put the checksum and end characters
    includecheck {
        /checksum 10 checksum 10 mod sub 10 mod def
        sbs barlen cs mul ss add encs checksum get putinterval
        sbs barlen cs mul cs add ss add encs 11 get putinterval
        includecheckintext {
            txt barlen [barchars checksum 1 getinterval barlen cw mul sw add textyoffset textfont textsize] put
        } {
            txt barlen [( ) barlen cw mul sw add textyoffset textfont textsize] put
        } ifelse
    } {
        sbs barlen cs mul ss add encs 11 get putinterval
    } ifelse

    % Return the arguments
    <<
    /ren //renlinear
    /sbs [sbs {48 sub} forall]
    /bhs [sbs length 1 add 2 idiv {height} repeat]
    /bbs [sbs length 1 add 2 idiv {0} repeat]
    includetext {
        /txt txt
    } if
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/code2of5 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER code2of5--

% --BEGIN ENCODER code11--
% --DESC: Code 11
% --EXAM: 0123456789
% --EXOP: includetext includecheck includecheckintext
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/code11 {

    20 dict begin            % Confine variables to local scope

    /options exch def  % We are given an option string
    /barcode exch def  % We are given a barcode string

    /dontdraw false def
    /includecheck false def
    /includetext false def
    /includecheckintext false def
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /height 1 def
    
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
 
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def
    
    % Create an array containing the character mappings
    /encs
    [ (111131) (311131) (131131) (331111) (113131)
      (313111) (133111) (111331) (311311) (311111)
      (113111) (113311)
    ] def

    % Create a string of the available characters
    /barchars (0123456789-) def

    /barlen barcode length def        % Length of the code

    includecheck {
        barlen 10 ge {
            /sbs barlen 6 mul 24 add string def
            /txt barlen 2 add array def
        } {
            /sbs barlen 6 mul 18 add string def
            /txt barlen 1 add array def
        } ifelse
    } {
        /sbs barlen 6 mul 12 add string def
        /txt barlen array def
    } ifelse

    % Put the start character
    sbs 0 encs 11 get putinterval

    /checksum1 0 def /checksum2 0 def
    
    /xpos 8 def
    0 1 barlen 1 sub {
        /i exch def
        % Lookup the encoding for the each barcode character
        barcode i 1 getinterval barchars exch search
        pop                                % Discard true leaving pre
        length /indx exch def              % indx is the length of pre
        pop pop                            % Discard seek and post
        /enc encs indx get def             % Get the indxth encoding
        sbs i 6 mul 6 add enc putinterval  % Put encoded digit into sbs
        txt i [barcode i 1 getinterval xpos textyoffset textfont textsize] put
        0 1 5 {       % xpos+=width of the character
            /xpos exch enc exch get 48 sub xpos add def
        } for
        /checksum1 checksum1 barlen i sub 1 sub 10 mod 1 add indx mul add def
        /checksum2 checksum2 barlen i sub 9 mod 1 add indx mul add def
    } for
   
    % Put the checksum and end characters
    includecheck {
        /checksum1 checksum1 11 mod def        
        barlen 10 ge {
            /checksum2 checksum2 checksum1 add 11 mod def
            sbs barlen 6 mul 6 add encs checksum1 get putinterval        
            sbs barlen 6 mul 12 add encs checksum2 get putinterval
            includecheckintext {
                txt barlen [barchars checksum1 1 getinterval xpos textyoffset textfont textsize] put
                /enc encs checksum1 get def   
                0 1 5 {       % xpos+=width of the character
                    /xpos exch enc exch get 48 sub xpos add def
                } for
                txt barlen 1 add [barchars checksum2 1 getinterval xpos textyoffset textfont textsize] put
            } {
                txt barlen [() xpos textyoffset textfont textsize] put
                txt barlen 1 add [() xpos textyoffset textfont textsize] put
            } ifelse
            sbs barlen 6 mul 18 add encs 11 get putinterval
        } {
            sbs barlen 6 mul 6 add encs checksum1 get putinterval          
            includecheckintext {
                txt barlen [barchars checksum1 1 getinterval xpos textyoffset textfont textsize] put
            } {
                txt barlen [() xpos textyoffset textfont textsize] put
            } ifelse
            sbs barlen 6 mul 12 add encs 11 get putinterval
        } ifelse
    } {
        sbs barlen 6 mul 6 add encs 11 get putinterval
    } ifelse

    % Return the arguments
    <<
    /ren //renlinear
    /sbs [sbs {48 sub} forall]
    /bhs [sbs length 1 add 2 idiv {height} repeat]
    /bbs [sbs length 1 add 2 idiv {0} repeat]
    includetext {
        /txt txt
    } if
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/code11 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER code11--

% --BEGIN ENCODER bc412--
% --DESC: BC412
% --EXAM: BC412
% --EXOP: semi includetext includecheckintext
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/bc412 {

    20 dict begin                 % Confine variables to local scope

    /options exch def       % We are given an option string
    /barcode exch def       % We are given a barcode string

    /dontdraw false def
    /includecheck false def  % Enable/disable checkdigit
    /includetext false def
    /includecheckintext false def
    /includestartstop false def
    /semi false def
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /height 1 def
    
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
 
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def
   
    semi {
        /includecheck true def
        /includestartstop true def
    } if
 
    % Create an array containing the character mappings
    /encs
    [ (11111115) (13111212) (11131113) (12111213) (12121311)
      (13131111) (12111312) (11131212) (11121411) (11151111)
      (15111111) (11111511) (12131211) (13121112) (13111212)
      (11111214) (12121113) (11111313) (13111113) (11121213)
      (11141112) (11121312) (11141211) (14121111) (12121212)
      (11131311) (13121211) (12111411) (14111211) (11111412)
      (12111114) (14111112) (12141111) (11121114) (12131112)
      (12) (111)
    ] def

    % Create a string of the available characters
    /barchars (0R9GLVHA8EZ4NTS1J2Q6C7DYKBUIX3FWP5M) def

    /barlen barcode length def  % Length of the code

    /sbs barlen 1 add 8 mul 5 add string def
    includecheck {
        /txt barlen 1 add array def
    } {
        /txt barlen array def
    } ifelse

    % Put the start character
    includestartstop {
        sbs 0 encs 35 get putinterval
        /pos 2 def
        /txtpos 3 def
    } {
        /pos 0 def
        /txtpos 0 def
    } ifelse

    /checksum 0 def
    0 1 barlen 1 sub {
        /i exch def
        % Lookup the encoding for the each barcode character
        barcode i 1 getinterval barchars exch search
        pop                                  % Discard true leaving pre
        length /indx exch def                % indx is the length of pre
        pop pop                              % Discard seek and post
        /enc encs indx get def               % Get the indxth encoding
        sbs pos enc putinterval  % Put encoded digit into sbs
        txt i [barcode i 1 getinterval i 12 mul txtpos add textyoffset textfont textsize] put
        /checksum checksum indx add def
        /pos pos 8 add def
    } for

    % Put the checksum
    includecheck {
        /checksum checksum 35 mod def
        sbs pos encs checksum get putinterval
        includecheckintext {
            txt barlen [barchars checksum 1 getinterval barlen 12 mul txtpos add textyoffset textfont textsize] put
        } {
            txt barlen [() barlen 12 mul txtpos add textyoffset textfont textsize] put
        } ifelse
        /pos pos 8 add def
    } if 

    % Put the stop character
    includestartstop { 
        sbs pos encs 36 get putinterval
        /pos pos 2 add def
    } if

    % Return the arguments
    /sbs sbs 0 pos getinterval def 
    <<
    /ren //renlinear
    /sbs [sbs {48 sub} forall]
    /bhs [sbs length 1 add 2 idiv {height} repeat]
    /bbs [sbs length 1 add 2 idiv {0} repeat]
    includetext {
        /txt txt
    } if
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/bc412 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER bc412--

% --BEGIN ENCODER rationalizedCodabar--
% --DESC: Rationalized Codabar
% --EXAM: A0123456789B
% --EXOP: includetext includecheck includecheckintext
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/rationalizedCodabar {

    20 dict begin                    % Confine variables to local scope

    /options exch def          % We are given an option string
    /barcode exch def          % We are given a barcode string

    /dontdraw false def
    /includecheck false def     % Enable/disable checkdigit
    /includetext false def      % Enable/disable text
    /includecheckintext false def
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /height 1 def
    
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
    
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def
    
    % Create an array containing the character mappings
    /encs
    [ (11111331) (11113311) (11131131) (33111111) (11311311)
      (31111311) (13111131) (13113111) (13311111) (31131111)
      (11133111) (11331111) (31113131) (31311131) (31313111)
      (11313131) (11331311) (13131131) (11131331) (11133311)
    ] def

    % Create a string of the available characters
    /barchars (0123456789-$:/.+ABCD) def

    /barlen barcode length def    % Length of the code

    includecheck {
        /sbs barlen 8 mul 8 add string def
        /txt barlen 1 add array def
    } {
        /sbs barlen 8 mul string def
        /txt barlen array def
    } ifelse

    /checksum 0 def
    /xpos 0 def
    0 1 barlen 2 sub {
        /i exch def
        % Lookup the encoding for the each barcode character
        barcode i 1 getinterval barchars exch search
        pop                          % Discard true leaving pre
        length /indx exch def        % indx is the length of pre
        pop pop                      % Discard seek and post
        /enc encs indx get def       % Get the indxth encoding
        sbs i 8 mul enc putinterval  % Put encoded digit into sbs
        txt i [barcode i 1 getinterval xpos textyoffset textfont textsize] put
        0 1 7 {       % xpos+=width of the character
            /xpos exch enc exch get 48 sub xpos add def
        } for
        /checksum checksum indx add def
    } for

    % Find index of last character
    barcode barlen 1 sub 1 getinterval barchars exch search
    pop                          % Discard true leaving pre
    length /indx exch def        % indx is the length of pre
    pop pop                      % Discard seek and post

    includecheck {
        % Put the checksum character
        /checksum checksum indx add def
        /checksum 16 checksum 16 mod sub 16 mod def
        sbs barlen 8 mul 8 sub encs checksum get putinterval
        includecheckintext {
            txt barlen 1 sub [barchars checksum 1 getinterval xpos textyoffset textfont textsize] put
        } {
            txt barlen 1 sub [( ) xpos textyoffset textfont textsize] put
        } ifelse
        0 1 7 {       % xpos+=width of the character
            /xpos exch encs checksum get exch get 48 sub xpos add def
        } for
        % Put the end character
        /enc encs indx get def            % Get the indxth encoding
        sbs barlen 8 mul enc putinterval  % Put encoded digit into sbs
        txt barlen [barcode barlen 1 sub 1 getinterval xpos textyoffset textfont textsize] put
    } {
        % Put the end character
        /enc encs indx get def                  % Get the indxth encoding
        sbs barlen 8 mul 8 sub enc putinterval  % Put encoded digit into sbs
        txt barlen 1 sub [barcode barlen 1 sub 1 getinterval xpos textyoffset textfont textsize] put
    } ifelse

    % Return the arguments
    <<
    /ren //renlinear
    /sbs [sbs {48 sub} forall]
    /bhs [sbs length 1 add 2 idiv {height} repeat]
    /bbs [sbs length 1 add 2 idiv {0} repeat]
    includetext {
        /txt txt
    } if
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/rationalizedCodabar dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER rationalizedCodabar--

% --BEGIN ENCODER onecode--
% --DESC: United States Postal Service Intelligent Mail
% --EXAM: 0123456709498765432101234567891
% --EXOP: barcolor=FF0000
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/onecode {

    20 dict begin

    /options exch def              % We are given an option string
    /barcode exch def              % We are given a barcode string

    /dontdraw false def
    /height 0.15 def
    
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
 
    /height height cvr def

    /barlen barcode length def
 
    % Create the human readable text
    /txtdict <<
        2 dup
        5 dup
        barcode 5 1 getinterval (9) eq {14} {11} ifelse dup
        20 dup
        25 dup
        29 dup
    >> def
    /txt barlen 6 add array def
    /spacecnt 0 def
    0 1 barlen 1 sub {
        /i exch def
        txtdict i known {
            txt i spacecnt add [( ) 0 0 () 0] put
            /spacecnt spacecnt 1 add def
        } if
        txt i spacecnt add [barcode i 1 getinterval 0 0 () 0] put
    } for
    /txt txt 0 barcode length spacecnt add getinterval def

    /normalize {
        /base exch def
        /num exch def
        num length 1 sub -1 1 {
            /i exch def        
            num i 1 sub 2 copy get num i get base idiv add put
            num i num i get base mod put
        } for
        { %loop - extend input as necessary
            num 0 get base lt {exit} if
            /num [0 num {} forall] def        
            num 0 num 0 get num 1 get base idiv add put
            num 1 num 1 get base mod put
        } loop
        % Trim leading zeros
        /num [/i true def num {dup 0 eq i and {pop} {/i false def} ifelse} forall] def   
        num length 0 eq {/num [0] def} if
        num
    } bind def

    /bigadd {
        2 copy length exch length
        2 copy sub abs /offset exch def
        lt {exch} if
        /a exch def /b exch def    
        0 1 b length 1 sub {
            dup a exch offset add 2 copy get b 5 -1 roll get add put
        } for
        a
    } bind def

    % Conversion of data fields into binary data
    barlen 20 eq {[0]} if
    barlen 25 eq {[1]} if
    barlen 29 eq {[1 0 0 0 0 1]} if
    barlen 31 eq {[1 0 0 0 1 0 0 0 0 1]} if
    /binval exch [barcode 20 barlen 20 sub getinterval {48 sub} forall] bigadd def
    /binval [binval {} forall barcode 0 get 48 sub] def
    /binval [binval {5 mul} forall] [barcode 1 get 48 sub] bigadd 10 normalize def
    /binval [binval {} forall barcode 2 18 getinterval {48 sub} forall] def

    % Conversion of binary data into byte array
    /bytes 13 array def
    /bintmp [binval {} forall] def
    12 -1 0 {
        /i exch def
        0 1 bintmp length 2 sub {
            /j exch def
            bintmp j 1 add 2 copy get bintmp j get 256 mod 10 mul add put
            bintmp j bintmp j get 256 idiv put
        } for
        bytes i bintmp bintmp length 1 sub get 256 mod put
        bintmp bintmp length 1 sub 2 copy get 256 idiv put    
    } for

    % Generation of 11-bit CRC on byte array
    /fcs 2047 def
    /dat bytes 0 get 5 bitshift def
    6 {
        fcs dat xor 1024 and 0 ne {
            /fcs fcs 1 bitshift 3893 xor def 
        } {
            /fcs fcs 1 bitshift def
        } ifelse
        /fcs fcs 2047 and def
        /dat dat 1 bitshift def
    } repeat
    1 1 12 {
        bytes exch get 3 bitshift /dat exch def    
        8 {        
            fcs dat xor 1024 and 0 ne {
                /fcs fcs 1 bitshift 3893 xor def 
            } {
                /fcs fcs 1 bitshift def
            } ifelse
            /fcs fcs 2047 and def
            /dat dat 1 bitshift def
        } repeat
    } for

    % Conversion from binary data to codewords
    /codewords 10 array def
    9 -1 0 {
        /i exch def
        i 9 eq {
            /b 636 def
        } {
            /b 1365 def
        } ifelse
        0 1 binval length 2 sub {
            /j exch def
            binval j 1 add 2 copy get binval j get b mod 10 mul add put
            binval j binval j get b idiv put
        } for   
        codewords i binval binval length 1 sub get b mod put
        binval binval length 1 sub 2 copy get b idiv put
    } for

    % Inserting additional information into codewords
    codewords 9 codewords 9 get 2 mul put
    fcs 1024 and 0 ne {
        codewords 0 codewords 0 get 659 add put
    } if

    % Conversion from codewords to characters
    /tab513 [
        31 7936   47 7808   55 7552   59 7040   61 6016   62 3968   79 7744   87 
      7488   91 6976   93 5952   94 3904  103 7360  107 6848  109 5824  110 3776 
       115 6592  117 5568  118 3520  121 5056  122 3008  124 1984  143 7712  151 
      7456  155 6944  157 5920  158 3872  167 7328  171 6816  173 5792  174 3744 
       179 6560  181 5536  182 3488  185 5024  186 2976  188 1952  199 7264  203 
      6752  205 5728  206 3680  211 6496  213 5472  214 3424  217 4960  218 2912 
       220 1888  227 6368  229 5344  230 3296  233 4832  234 2784  236 1760  241 
      4576  242 2528  244 1504  248  992  271 7696  279 7440  283 6928  285 5904 
       286 3856  295 7312  299 6800  301 5776  302 3728  307 6544  309 5520  310 
      3472  313 5008  314 2960  316 1936  327 7248  331 6736  333 5712  334 3664 
       339 6480  341 5456  342 3408  345 4944  346 2896  348 1872  355 6352  357 
      5328  358 3280  361 4816  362 2768  364 1744  369 4560  370 2512  372 1488 
       376  976  391 7216  395 6704  397 5680  398 3632  403 6448  405 5424  406 
      3376  409 4912  410 2864  412 1840  419 6320  421 5296  422 3248  425 4784 
       426 2736  428 1712  433 4528  434 2480  436 1456  440  944  451 6256  453 
      5232  454 3184  457 4720  458 2672  460 1648  465 4464  466 2416  468 1392 
       472  880  481 4336  482 2288  484 1264  488  752  527 7688  535 7432  539 
      6920  541 5896  542 3848  551 7304  555 6792  557 5768  558 3720  563 6536 
       565 5512  566 3464  569 5000  570 2952  572 1928  583 7240  587 6728  589 
      5704  590 3656  595 6472  597 5448  598 3400  601 4936  602 2888  604 1864 
       611 6344  613 5320  614 3272  617 4808  618 2760  620 1736  625 4552  626 
      2504  628 1480  632  968  647 7208  651 6696  653 5672  654 3624  659 6440 
       661 5416  662 3368  665 4904  666 2856  668 1832  675 6312  677 5288  678 
      3240  681 4776  682 2728  684 1704  689 4520  690 2472  692 1448  696  936 
       707 6248  709 5224  710 3176  713 4712  714 2664  716 1640  721 4456  722 
      2408  724 1384  728  872  737 4328  738 2280  740 1256  775 7192  779 6680 
       781 5656  782 3608  787 6424  789 5400  790 3352  793 4888  794 2840  796 
      1816  803 6296  805 5272  806 3224  809 4760  810 2712  812 1688  817 4504 
       818 2456  820 1432  824  920  835 6232  837 5208  838 3160  841 4696  842 
      2648  844 1624  849 4440  850 2392  852 1368  865 4312  866 2264  868 1240 
       899 6200  901 5176  902 3128  905 4664  906 2616  908 1592  913 4408  914 
      2360  916 1336  929 4280  930 2232  932 1208  961 4216  962 2168  964 1144 
      1039 7684 1047 7428 1051 6916 1053 5892 1054 3844 1063 7300 1067 6788 1069 
      5764 1070 3716 1075 6532 1077 5508 1078 3460 1081 4996 1082 2948 1084 1924 
      1095 7236 1099 6724 1101 5700 1102 3652 1107 6468 1109 5444 1110 3396 1113 
      4932 1114 2884 1116 1860 1123 6340 1125 5316 1126 3268 1129 4804 1130 2756 
      1132 1732 1137 4548 1138 2500 1140 1476 1159 7204 1163 6692 1165 5668 1166 
      3620 1171 6436 1173 5412 1174 3364 1177 4900 1178 2852 1180 1828 1187 6308 
      1189 5284 1190 3236 1193 4772 1194 2724 1196 1700 1201 4516 1202 2468 1204 
      1444 1219 6244 1221 5220 1222 3172 1225 4708 1226 2660 1228 1636 1233 4452 
      1234 2404 1236 1380 1249 4324 1250 2276 1287 7188 1291 6676 1293 5652 1294 
      3604 1299 6420 1301 5396 1302 3348 1305 4884 1306 2836 1308 1812 1315 6292 
      1317 5268 1318 3220 1321 4756 1322 2708 1324 1684 1329 4500 1330 2452 1332 
      1428 1347 6228 1349 5204 1350 3156 1353 4692 1354 2644 1356 1620 1361 4436 
      1362 2388 1377 4308 1378 2260 1411 6196 1413 5172 1414 3124 1417 4660 1418 
      2612 1420 1588 1425 4404 1426 2356 1441 4276 1442 2228 1473 4212 1474 2164 
      1543 7180 1547 6668 1549 5644 1550 3596 1555 6412 1557 5388 1558 3340 1561 
      4876 1562 2828 1564 1804 1571 6284 1573 5260 1574 3212 1577 4748 1578 2700 
      1580 1676 1585 4492 1586 2444 1603 6220 1605 5196 1606 3148 1609 4684 1610 
      2636 1617 4428 1618 2380 1633 4300 1634 2252 1667 6188 1669 5164 1670 3116 
      1673 4652 1674 2604 1681 4396 1682 2348 1697 4268 1698 2220 1729 4204 1730 
      2156 1795 6172 1797 5148 1798 3100 1801 4636 1802 2588 1809 4380 1810 2332 
      1825 4252 1826 2204 1857 4188 1858 2140 1921 4156 1922 2108 2063 7682 2071 
      7426 2075 6914 2077 5890 2078 3842 2087 7298 2091 6786 2093 5762 2094 3714 
      2099 6530 2101 5506 2102 3458 2105 4994 2106 2946 2119 7234 2123 6722 2125 
      5698 2126 3650 2131 6466 2133 5442 2134 3394 2137 4930 2138 2882 2147 6338 
      2149 5314 2150 3266 2153 4802 2154 2754 2161 4546 2162 2498 2183 7202 2187 
      6690 2189 5666 2190 3618 2195 6434 2197 5410 2198 3362 2201 4898 2202 2850 
      2211 6306 2213 5282 2214 3234 2217 4770 2218 2722 2225 4514 2226 2466 2243 
      6242 2245 5218 2246 3170 2249 4706 2250 2658 2257 4450 2258 2402 2273 4322 
      2311 7186 2315 6674 2317 5650 2318 3602 2323 6418 2325 5394 2326 3346 2329 
      4882 2330 2834 2339 6290 2341 5266 2342 3218 2345 4754 2346 2706 2353 4498 
      2354 2450 2371 6226 2373 5202 2374 3154 2377 4690 2378 2642 2385 4434 2401 
      4306 2435 6194 2437 5170 2438 3122 2441 4658 2442 2610 2449 4402 2465 4274 
      2497 4210 2567 7178 2571 6666 2573 5642 2574 3594 2579 6410 2581 5386 2582 
      3338 2585 4874 2586 2826 2595 6282 2597 5258 2598 3210 2601 4746 2602 2698 
      2609 4490 2627 6218 2629 5194 2630 3146 2633 4682 2641 4426 2657 4298 2691 
      6186 2693 5162 2694 3114 2697 4650 2705 4394 2721 4266 2753 4202 2819 6170 
      2821 5146 2822 3098 2825 4634 2833 4378 2849 4250 2881 4186 2945 4154 3079 
      7174 3083 6662 3085 5638 3086 3590 3091 6406 3093 5382 3094 3334 3097 4870 
      3107 6278 3109 5254 3110 3206 3113 4742 3121 4486 3139 6214 3141 5190 3145 
      4678 3153 4422 3169 4294 3203 6182 3205 5158 3209 4646 3217 4390 3233 4262 
      3265 4198 3331 6166 3333 5142 3337 4630 3345 4374 3361 4246 3393 4182 3457 
      4150 3587 6158 3589 5134 3593 4622 3601 4366 3617 4238 3649 4174 3713 4142 
      3841 4126 4111 7681 4119 7425 4123 6913 4125 5889 4135 7297 4139 6785 4141 
      5761 4147 6529 4149 5505 4153 4993 4167 7233 4171 6721 4173 5697 4179 6465 
      4181 5441 4185 4929 4195 6337 4197 5313 4201 4801 4209 4545 4231 7201 4235 
      6689 4237 5665 4243 6433 4245 5409 4249 4897 4259 6305 4261 5281 4265 4769 
      4273 4513 4291 6241 4293 5217 4297 4705 4305 4449 4359 7185 4363 6673 4365 
      5649 4371 6417 4373 5393 4377 4881 4387 6289 4389 5265 4393 4753 4401 4497 
      4419 6225 4421 5201 4425 4689 4483 6193 4485 5169 4489 4657 4615 7177 4619 
      6665 4621 5641 4627 6409 4629 5385 4633 4873 4643 6281 4645 5257 4649 4745 
      4675 6217 4677 5193 4739 6185 4741 5161 4867 6169 4869 5145 5127 7173 5131 
      6661 5133 5637 5139 6405 5141 5381 5155 6277 5157 5253 5187 6213 5251 6181 
      5379 6165 5635 6157 6151 7171 6155 6659 6163 6403 6179 6275 6211 5189 4681 
      4433 4321 3142 2634 2386 2274 1612 1364 1252  856  744  496 
    ] def

    /tab213 [
         3 6144    5 5120    6 3072    9 4608   10 2560   12 1536   17 4352   18 
      2304   20 1280   24  768   33 4224   34 2176   36 1152   40  640   48  384 
        65 4160   66 2112   68 1088   72  576   80  320   96  192  129 4128  130 
      2080  132 1056  136  544  144  288  257 4112  258 2064  260 1040  264  528 
       513 4104  514 2056  516 1032 1025 4100 1026 2052 2049 4098 4097 2050 1028 
       520  272  160
    ] def

    /chars 10 array def
    0 1 9 {
        /i exch def
        codewords i get dup 1286 le {
            tab513 exch get 
        } {
            tab213 exch 1287 sub get
        } ifelse
        chars i 3 -1 roll put
    } for

    9 -1 0 {
        /i exch def
        2 i exp cvi fcs and 0 ne {
            chars i chars i get 8191 xor put
        } if
    } for

    % Conversion from characters to the OneCode encoding
    /barmap [
        7 2 4 3    1 10 0 0   9 12 2 8   5 5 6 11   8 9 3 1
        0 1 5 12   2 5 1 8    4 4 9 11   6 3 8 10   3 9 7 6
        5 11 1 4   8 5 2 12   9 10 0 2   7 1 6 7    3 6 4 9
        0 3 8 6    6 4 2 7    1 1 9 9    7 10 5 2   4 0 3 8
        6 2 0 4    8 11 1 0   9 8 3 12   2 6 7 7    5 1 4 10
        1 12 6 9   7 3 8 0    5 8 9 7    4 6 2 10   3 4 0 5
        8 4 5 7    7 11 1 9   6 0 9 6    0 6 4 8    2 1 3 2
        5 9 8 12   4 11 6 1   9 5 7 4    3 3 1 2    0 7 2 0
        1 3 4 1    6 10 3 5   8 7 9 4    2 11 5 6   0 8 7 12
        4 2 8 1    5 10 3 0   9 3 0 9    6 5 2 4    7 8 1 7
        5 0 4 5    2 3 0 10   6 12 9 2   3 11 1 6   8 8 7 9
        5 4 0 11   1 5 2 2    9 1 4 12   8 3 6 6    7 0 3 7
        4 7 7 5    0 12 1 11  2 9 9 0    6 8 5 3    3 10 8 2
    ] def

    /bbs 65 array def    
    /bhs 65 array def
    0 1 64 {
        /i exch def
        /dec chars barmap i 4 mul get get 2 barmap i 4 mul 1 add get exp cvi and 0 ne def
        /asc chars barmap i 4 mul 2 add get get 2 barmap i 4 mul 3 add get exp cvi and 0 ne def
        dec not asc not and {
            bbs i 3 height mul 8 div put
            bhs i 2 height mul 8 div put
        } if
        dec not asc and {
            bbs i 3 height mul 8 div put
            bhs i 5 height mul 8 div put        
        } if
        dec asc not and {
            bbs i 0 height mul 8 div put
            bhs i 5 height mul 8 div put        
        } if
        dec asc and {
            bbs i 0 height mul 8 div put
            bhs i 8 height mul 8 div put        
        } if
    } for
    
    % Return the arguments
    <<
    /ren //renlinear
    /bbs bbs
    /bhs bhs
    /sbs [bhs length 1 sub {1.44 1.872} repeat 1.44]
    /txt txt
    /textxalign (left)
    /textfont /Helvetica
    /textyoffset 1
    /textxoffset -0.3
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/onecode dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER onecode--

% --BEGIN ENCODER postnet--
% --DESC: United States Postal Service POSTNET
% --EXAM: 01234
% --EXOP: includetext includecheckintext
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/postnet {

    20 dict begin

    /options exch def              % We are given an option string
    /barcode exch def              % We are given a barcode string

    /dontdraw false def
    /includetext false def          % Enable/disable text
    /includecheckintext false def
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /height 0.125 def
    
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
 
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def
    
    /barlen barcode length def

    % Ensure 5, 9 or 11 digits
    barlen 5 lt {
        /barlen -1 def  % Error
    } {
        barlen 11 ge {
            /barlen 11 def
        } if
        barlen 10 eq {
            /barlen 9 def
        } if
        barlen 8 le {
            /barlen 5 def
        } if
    } ifelse

    % Create an array containing the character mappings
    /encs
    [ (55222) (22255) (22525) (22552) (25225)
      (25252) (25522) (52225) (52252) (52522)
      (5) (5)
    ] def

    % Create a string of the available characters
    /barchars (0123456789) def

    /bhs barlen 5 mul 7 add array def
    /txt barlen 1 add array def

    % Put start character
    /enc encs 10 get def
    /heights enc length array def
    0 1 enc length 1 sub {
        /j exch def
        heights j enc j 1 getinterval cvi height mul 5 div put
    } for
    bhs 0 heights putinterval   % Put encoded digit into sbs

    /checksum 0 def
    0 1 barlen 1 sub {
        /i exch def
        % Lookup the encoding for the each barcode character
        barcode i 1 getinterval barchars exch search
        pop                                 % Discard true leaving pre
        length /indx exch def               % indx is the length of pre
        pop pop                             % Discard seek and post
        /enc encs indx get def              % Get the indxth encoding
        /heights enc length array def
        0 1 enc length 1 sub {
            /j exch def
            heights j enc j 1 getinterval cvi height mul 5 div put
        } for
        bhs i 5 mul 1 add heights putinterval   % Put encoded digit into sbs
        txt i [barcode i 1 getinterval i 5 mul 1 add 3.312 mul textyoffset textfont textsize] put
        /checksum checksum indx add def     % checksum+=indx
    } for

    % Put the checksum character
    /checksum 10 checksum 10 mod sub 10 mod def
    /enc encs checksum get def
    /heights enc length array def
    0 1 enc length 1 sub {
        /j exch def
        heights j enc j 1 getinterval cvi height mul 5 div put
    } for
    bhs barlen 5 mul 1 add heights putinterval  
    
    includecheckintext {
        txt barlen [barchars checksum 1 getinterval barlen 5 mul 1 add 3.312 mul textyoffset textfont textsize] put
    } {
        txt barlen [( ) barlen 5 mul 1 add 72 mul 25 div textyoffset textfont textsize] put
    } ifelse
    
    % Put end character
    /enc encs 11 get def
    /heights enc length array def
    0 1 enc length 1 sub {
        /j exch def
        heights j enc j 1 getinterval cvi height mul 5 div put
    } for
    bhs barlen 5 mul 6 add heights putinterval  

    % Return the arguments
    <<
    /ren //renlinear
    /bhs bhs
    /bbs [bhs length {0} repeat]
    /sbs [bhs length 1 sub {1.44 1.872} repeat 1.44]
    includetext {
        /txt txt
    } if
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/postnet dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER postnet--

% --BEGIN ENCODER planet--
% --DESC: United States Postal Service PLANET
% --EXAM: 01234567890
% --EXOP: includetext includecheckintext
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/planet {

    20 dict begin

    /options exch def              % We are given an option string
    /barcode exch def              % We are given a barcode string

    /dontdraw false def
    /includetext false def          % Enable/disable text
    /includecheckintext false def
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /height 0.125 def
    
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
 
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def
    
    /barlen barcode length def

    % Ensure 11 or 13 digits
    barlen 11 lt {
        /barlen -1 def  % Error
    } {
        barlen 13 ge {
            /barlen 13 def
        } {
            /barlen 11 def
        } ifelse
    } ifelse

    % Create an array containing the character mappings
    /encs
    [ (22555) (55522) (55252) (55225) (52552)
      (52525) (52255) (25552) (25525) (25255)
      (5) (5)
    ] def

    % Create a string of the available characters
    /barchars (0123456789) def

    /bhs barlen 5 mul 7 add array def
    /txt barlen 1 add array def

    % Put start character
    /enc encs 10 get def
    /heights enc length array def
    0 1 enc length 1 sub {
        /j exch def
        heights j enc j 1 getinterval cvi height mul 5 div put
    } for
    bhs 0 heights putinterval   % Put encoded digit into sbs

    /checksum 0 def
    0 1 barlen 1 sub {
        /i exch def
        % Lookup the encoding for the each barcode character
        barcode i 1 getinterval barchars exch search
        pop                                 % Discard true leaving pre
        length /indx exch def               % indx is the length of pre
        pop pop                             % Discard seek and post
        /enc encs indx get def              % Get the indxth encoding
        /heights enc length array def
        0 1 enc length 1 sub {
            /j exch def
            heights j enc j 1 getinterval cvi height mul 5 div put
        } for
        bhs i 5 mul 1 add heights putinterval   % Put encoded digit into sbs
        txt i [barcode i 1 getinterval i 5 mul 1 add 3.312 mul textyoffset textfont textsize] put
        /checksum checksum indx add def     % checksum+=indx
    } for

    % Put the checksum character
    /checksum 10 checksum 10 mod sub 10 mod def
    /enc encs checksum get def
    /heights enc length array def
    0 1 enc length 1 sub {
        /j exch def
        heights j enc j 1 getinterval cvi height mul 5 div put
    } for
    bhs barlen 5 mul 1 add heights putinterval  
    
    includecheckintext {
        txt barlen [barchars checksum 1 getinterval barlen 5 mul 1 add 3.312 mul textyoffset textfont textsize] put
    } {
        txt barlen [( ) barlen 5 mul 1 add 72 mul 25 div textyoffset textfont textsize] put
    } ifelse
    
    % Put end character
    /enc encs 11 get def
    /heights enc length array def
    0 1 enc length 1 sub {
        /j exch def
        heights j enc j 1 getinterval cvi height mul 5 div put
    } for
    bhs barlen 5 mul 6 add heights putinterval  

    % Return the arguments
    <<
    /ren //renlinear
    /bhs bhs
    /bbs [bhs length {0} repeat]
    /sbs [bhs length 1 sub {1.44 1.872} repeat 1.44]
    includetext {
        /txt txt
    } if
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/planet dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER planet--

% --BEGIN ENCODER royalmail--
% --DESC: Royal Mail 4 State Customer Code (RM4SCC)
% --EXAM: LE28HS9Z
% --EXOP: includetext includecheckintext barcolor=FF0000
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/royalmail {

    20 dict begin

    /options exch def              % We are given an option string
    /barcode exch def              % We are given a barcode string

    /dontdraw false def
    /includetext false def          % Enable/disable text
    /includecheckintext false def
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /height 0.175 def
    
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
 
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def
    
    % Create an array containing the character mappings
    /encs
    [ (3300) (2211) (2301) (2310) (3201) (3210) 
      (1122) (0033) (0123) (0132) (1023) (1032) 
      (1302) (0213) (0303) (0312) (1203) (1212) 
      (1320) (0231) (0321) (0330) (1221) (1230) 
      (3102) (2013) (2103) (2112) (3003) (3012) 
      (3120) (2031) (2121) (2130) (3021) (3030) 
      (2) (3)
    ] def

    % Create a string of the available characters
    /barchars (ZUVWXY501234B6789AHCDEFGNIJKLMTOPQRS) def

    /barlen barcode length def
    /encstr barlen 4 mul 6 add string def
    /txt barlen 1 add array def

    % Put start character
    encstr 0 encs 36 get putinterval
    
    /checksumrow 0 def
    /checksumcol 0 def
    0 1 barlen 1 sub {
        /i exch def
        % Lookup the encoding for the each barcode character
        barcode i 1 getinterval barchars exch search
        pop                                 % Discard true leaving pre
        length /indx exch def               % indx is the length of pre
        pop pop                             % Discard seek and post
        /enc encs indx get def              % Get the indxth encoding
        encstr i 4 mul 1 add enc putinterval
        txt i [barcode i 1 getinterval i 4 mul 1 add 3.312 mul textyoffset textfont textsize] put
        /checksumrow checksumrow indx 6 idiv add def
        /checksumcol checksumcol indx 6 mod add def 
    } for

    % Put the checksum character
    /checksum checksumrow 6 mod 6 mul checksumcol 6 mod add def
    /enc encs checksum get def
    encstr barlen 4 mul 1 add enc putinterval
    includecheckintext {
        txt barlen [barchars checksum 1 getinterval barlen 4 mul 1 add 3.312 mul textyoffset textfont textsize] put
    } {
        txt barlen [( ) barlen 4 mul 1 add 3.312 mul textyoffset textfont textsize] put
    } ifelse
    
    % Put end character
    encstr barlen 4 mul 5 add encs 37 get putinterval  

    /bbs encstr length array def    
    /bhs encstr length array def
    0 1 encstr length 1 sub {
        /i exch def
        /enc encstr i 1 getinterval def
        enc (0) eq {
            bbs i 3 height mul 8 div put
            bhs i 2 height mul 8 div put
        } if
        enc (1) eq {
            bbs i 0 height mul 8 div put
            bhs i 5 height mul 8 div put
        } if
        enc (2) eq {
            bbs i 3 height mul 8 div put
            bhs i 5 height mul 8 div put
        } if
        enc (3) eq {
            bbs i 0 height mul 8 div put
            bhs i 8 height mul 8 div put
        } if
    } for
    
    % Return the arguments
    <<
    /ren //renlinear
    /bbs bbs
    /bhs bhs
    /sbs [bhs length 1 sub {1.44 1.872} repeat 1.44]
    includetext {
        /txt txt
    } if
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/royalmail dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER royalmail--

% --BEGIN ENCODER auspost--
% --DESC: AusPost 4 State Customer Code
% --EXAM: 5956439111ABA 9
% --EXOP: includetext custinfoenc=character
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/auspost {

    20 dict begin

    /options exch def              % We are given an option string
    /barcode exch def              % We are given a barcode string

    /dontdraw false def
    /includetext false def         % Enable/disable text
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /height 0.175 def
    /custinfoenc (character) def
    
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
 
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def

    % Create an array containing the character mappings
    /encs
    [ (000) (001) (002) (010) (011) (012) (020) (021)
      (022) (100) (101) (102) (110) (111) (112) (120)
      (121) (122) (200) (201) (202) (210) (211) (212)
      (220) (221) (222) (300) (301) (302) (310) (311)
      (312) (320) (321) (322) (023) (030) (031) (032)
      (033) (103) (113) (123) (130) (131) (132) (133)
      (203) (213) (223) (230) (231) (232) (233) (303)
      (313) (323) (330) (331) (332) (333) (003) (013)
      (00) (01) (02) (10) (11) (12) (20) (21) (22) (30)
      (13) (3)
    ] def

    % Create a string of the available characters
    /barchars (ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz #) def
    
    /barlen barcode length def
    barcode 0 2 getinterval (11) eq {37} if
    barcode 0 2 getinterval (45) eq {37} if
    barcode 0 2 getinterval (59) eq {52} if
    barcode 0 2 getinterval (62) eq {67} if
    /encstr exch string def
    /txt barlen 2 sub array def

    % Put start character
    encstr 0 encs 74 get putinterval

    % Encode the FCC
    0 1 1 {
        /i exch def       
        encs barcode i 1 getinterval cvi 64 add get
        encstr i 2 mul 2 add 3 2 roll putinterval
    } for
    
    % Encode the DPID
    2 1 9 {
        /i exch def       
        encs barcode i 1 getinterval cvi 64 add get
        encstr i 2 mul 2 add 3 2 roll putinterval
        txt i 2 sub [barcode i 1 getinterval i 2 sub 2 mul 6 add 3.312 mul textyoffset textfont textsize] put
    } for
    
    % Encode the customer information   
    custinfoenc (numeric) eq {
        0 1 barlen 11 sub {
            /i exch def
            encs barcode i 10 add 1 getinterval cvi 64 add get
            encstr i 2 mul 22 add 3 2 roll putinterval
            txt i 8 add [barcode i 10 add 1 getinterval i 2 mul 22 add 3.312 mul textyoffset textfont textsize] put
        } for        
        /ciflen barlen 10 sub 2 mul def
    } {
        0 1 barlen 11 sub {
            /i exch def           
            barcode i 10 add 1 getinterval barchars exch search
            pop                                
            length /indx exch def           
            pop pop                            
            /enc encs indx get def          
            encstr i 3 mul 22 add enc putinterval
            txt i 8 add [barcode i 10 add 1 getinterval i 3 mul 22 add 3.312 mul textyoffset textfont textsize] put
        } for        
        /ciflen barlen 10 sub 3 mul def
    } ifelse

    % Add any filler characters
    22 ciflen add 1 encstr length 14 sub {        
        encstr exch encs 75 get putinterval
    } for
    
    % Create the 64x64 Reed-Solomon table
    /rstable 64 64 mul array def
    rstable 0 [ 64 {0} repeat ] putinterval
    rstable 64 [ 0 1 63 {} for ] putinterval
    /prev 1 def
    64 {       
        /next prev 1 bitshift def
        next 64 and 0 ne {
            /next next 67 xor def
        } if        
        0 1 63 {
            /j exch def
            /nextcell {rstable 64 next mul j add} def
            nextcell rstable 64 prev mul j add get 1 bitshift put
            nextcell get 64 and 0 ne {
                nextcell nextcell get 67 xor put
            } if
        } for
        /prev next def
    } repeat
    
    % Calculate the Reed-Solomon codes for triples
    /rscodes encstr length 16 sub 3 idiv 4 add array def
    rscodes 0 [ 4 {0} repeat ] putinterval
    2 3 encstr length 16 sub {
        /i exch def
        rscodes rscodes length i 2 sub 3 idiv sub 1 sub
        encstr i 1 getinterval cvi 16 mul
        encstr i 1 add 1 getinterval cvi 4 mul add
        encstr i 2 add 1 getinterval cvi add        
        put
    } for    
    rscodes length 5 sub -1 0 {
       /i exch def
       0 1 4 {
           /j exch def
           rscodes i j add rscodes i j add get
           rstable 64 [48 17 29 30 1] j get mul rscodes i 4 add get add get
           xor put
       } for
    } for
    /checkcode (000000000000) 12 string copy def
    0 1 3 {
        /i exch def
        /enc rscodes 3 i sub get 4 3 string cvrs def
        checkcode i 3 mul 3 enc length sub add enc putinterval
    } for
    
    % Put checkcode and end characters
    encstr encstr length 14 sub checkcode putinterval
    encstr encstr length 2 sub encs 74 get putinterval 

    /bbs encstr length array def    
    /bhs encstr length array def
    0 1 encstr length 1 sub {
        /i exch def
        /enc encstr i 1 getinterval def
        enc (0) eq {
            bbs i 0 height mul 8 div put
            bhs i 8 height mul 8 div put
        } if
        enc (1) eq {
            bbs i 3 height mul 8 div put
            bhs i 5 height mul 8 div put
        } if
        enc (2) eq {
            bbs i 0 height mul 8 div put
            bhs i 5 height mul 8 div put
        } if
        enc (3) eq {
            bbs i 3 height mul 8 div put
            bhs i 2 height mul 8 div put
        } if
    } for   
    
    % Return the arguments
    <<
    /ren //renlinear
    /bbs bbs
    /bhs bhs
    /sbs [bhs length 1 sub {1.44 1.872} repeat 1.44]
    includetext {
        /txt txt
    } if
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/auspost dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER auspost--

% --BEGIN ENCODER kix--
% --DESC: Royal Dutch TPG Post KIX 4-State Barcode
% --EXAM: 1231FZ13XHS
% --EXOP: includetext includecheckintext
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/kix {

    20 dict begin

    /options exch def              % We are given an option string
    /barcode exch def              % We are given a barcode string

    /dontdraw false def
    /includetext false def          % Enable/disable text
    /includecheckintext false def
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /height 0.175 def
    
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
 
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def
    
    % Create an array containing the character mappings
    /encs
    [ (0033) (0123) (0132) (1023) (1032) (1122)
      (0213) (0303) (0312) (1203) (1212) (1302) 
      (0231) (0321) (0330) (1221) (1230) (1320)
      (2013) (2103) (2112) (3003) (3012) (3102)
      (2031) (2121) (2130) (3021) (3030) (3120) 
      (2211) (2301) (2310) (3201) (3210) (3300) 
    ] def

    % Create a string of the available characters
    /barchars (0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ) def

    /barlen barcode length def
    /encstr barlen 4 mul string def
    /txt barlen array def
    
    0 1 barlen 1 sub {
        /i exch def
        % Lookup the encoding for the each barcode character
        barcode i 1 getinterval barchars exch search
        pop                                 % Discard true leaving pre
        length /indx exch def               % indx is the length of pre
        pop pop                             % Discard seek and post
        /enc encs indx get def              % Get the indxth encoding
        encstr i 4 mul enc putinterval
        txt i [barcode i 1 getinterval i 4 mul 3.312 mul textyoffset textfont textsize] put
    } for

    /bbs encstr length array def    
    /bhs encstr length array def
    0 1 encstr length 1 sub {
        /i exch def
        /enc encstr i 1 getinterval def
        enc (0) eq {
            bbs i 3 height mul 8 div put
            bhs i 2 height mul 8 div put
        } if
        enc (1) eq {
            bbs i 0 height mul 8 div put
            bhs i 5 height mul 8 div put
        } if
        enc (2) eq {
            bbs i 3 height mul 8 div put
            bhs i 5 height mul 8 div put
        } if
        enc (3) eq {
            bbs i 0 height mul 8 div put
            bhs i 8 height mul 8 div put
        } if
    } for
    
    % Return the arguments
    <<
    /ren //renlinear
    /bbs bbs
    /bhs bhs
    /sbs [bhs length 1 sub {1.44 1.872} repeat 1.44]
    includetext {
        /txt txt
    } if
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/kix dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER kix--

% --BEGIN ENCODER japanpost--
% --DESC: Japan Post 4 State Customer Code
% --EXAM: 6540123789-A-K-Z
% --EXOP: includetext includecheckintext
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/japanpost {

    20 dict begin

    /options exch def              % We are given an option string
    /barcode exch def              % We are given a barcode string

    /dontdraw false def
    /includetext false def          % Enable/disable text
    /includecheckintext false def
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /height 0.175 def
  
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
 
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def
    
    % Create an array containing the character mappings
    % 0123456789- C1C2C3C4C5C6C7C8 ST EN
    /encs
    [ (300) (330) (312) (132) (321) (303) (123) (231) (213) (033) (030)
      (120) (102) (210) (012) (201) (021) (003) (333) 
      (31) (13)
    ] def

    % Create a string of the available characters
    /barchars (0123456789-ABCDEFGHIJKLMNOPQRSTUVWXYZ) def
    /barlen barcode length def
    
    /encstr 20 1 add 3 mul 4 add string def
    /digits 20 array def
    /txt barlen 1 add array def

    % Put start character
    encstr 0 encs 19 get putinterval

    /checksum 0 def
    /j 0 def /i 0 def
    0 1 barlen 1 sub {
        /i exch def
        barcode i 1 getinterval barchars exch search
        pop                                  % Discard true leaving pre
        length /indx exch def                % indx is the length of pre
        pop pop                              % Discard match and post
        indx 11 ge indx 37 lt and {          % Insert escape
            j 18 gt {exit} if                % Should fit in 20 chars
                                             % 11-20: C1 (11)
                                             % 21-30: C2 (12)
                                             % 31-36: C3 (13)
            /digit indx 1 sub 10 idiv 10 add def
            encstr j 3 mul 2 add encs digit get putinterval
            /checksum checksum digit add def
            digits j digit put
            /j j 1 add def
        } if
        j 19 gt {exit} if                    % Should fit in 20 chars
        /digit 0 def
        indx 37 eq {
            /digit 14 def                    % space (C14)
        } if
        indx 11 ge indx 37 lt and {
            /digit indx 1 sub 10 mod def
        } if
        indx 11 lt {
            /digit indx def
        } if
        encstr j 3 mul 2 add encs digit get putinterval % space
        /checksum checksum digit add def
        digits j digit put
        txt i [barcode i 1 getinterval j 3 mul 2 add 3.312 mul textyoffset textfont textsize] put
        /j j 1 add def
    } for

    % Fill spaces (c14) at right end
    j 1 20 1 sub {
        /k exch def
        encstr k 3 mul 2 add encs 14 get putinterval
        /checksum checksum 14 add def
        digits k 14 put
    } for

    % Put the checksum character
    /checksum checksum 19 mod 19 exch sub def
    encstr 2 20 3 mul add encs checksum get putinterval

    % Put end character
    encstr 2 21 3 mul add encs 20 get putinterval
    /checkdigit ( ) def
    includecheckintext {
        /checkdigit barchars checksum 1 getinterval def
    } if
    txt i 1 add [ checkdigit 20 3 mul 2 add 3.312 mul textyoffset textfont textsize] put

    % Put end character
    encstr 20 1 add 3 mul 2 add encs 20 get putinterval

    /bbs 21 3 mul 4 add array def
    /bhs bbs length array def
    0 1 bbs length 1 sub {
        /i exch def
        /enc encstr i 1 getinterval def
        /bunit 0 def
        /hunit 0 def
        enc (0) eq {
            /bunit 3 def
            /hunit 2 def
        } if
        enc (1) eq {
            /bunit 0 def
            /hunit 5 def
        } if
        enc (2) eq {
            /bunit 3 def
            /hunit 5 def
        } if
        enc (3) eq {
            /bunit 0 def
            /hunit 8 def
        } if
        bbs i bunit height mul 8 div put
        bhs i hunit height mul 8 div put
    } for

    % Return the arguments
    <<
    /ren //renlinear
    /bbs bbs
    /bhs bhs
    /sbs [bhs length 1 sub {1.44 1.872} repeat 1.44]
    includetext {
        /txt txt
    } if
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/japanpost dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER japanpost--

% --BEGIN ENCODER msi--
% --DESC: MSI Modified Plessey
% --EXAM: 0123456789
% --EXOP: includetext includecheck includecheckintext
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/msi {

    20 dict begin                 % Confine variables to local scope

    /options exch def       % We are given an option string
    /barcode exch def       % We are given a barcode string

    /dontdraw false def
    /includecheck false def  % Enable/disable checkdigit
    /includetext false def   % Enable/disable text
    /includecheckintext false def
    /checktype (mod10) def
    /badmod11 false def
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /height 1 def
    
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
    
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def
    
    % Create an array containing the character mappings
    /encs
    [ (12121212) (12121221) (12122112) (12122121) (12211212)
      (12211221) (12212112) (12212121) (21121212) (21121221)
      (21) (121)
    ] def

    % Create a string of the available characters
    /barchars (0123456789) def

    /barlen barcode length def     % Length of the code
    /txtlen barlen def

    /mod10 {
        /code exch def
        0 0 code {48 sub exch 10 mul add exch} forall pop 2 mul  
        0 {1 index 10 mod add exch 10 idiv dup 0 eq {pop exit} if exch} loop
        0 0 code {48 sub add exch} forall exch pop add
        10 mod 10 exch sub 10 mod
        code length 1 add string dup 0 code putinterval dup code length 4 -1 roll 48 add put
    } bind def

    /mod11 {
        /code exch def
        code length 1 sub code {48 sub exch dup 1 sub exch 6 mod 2 add exch} forall pop
        0 code length {3 1 roll mul add} repeat 
        11 mod 11 exch sub 11 mod
        dup 10 eq badmod11 and {
            pop code length 2 add string dup 0 code putinterval dup code length (10) putinterval
        } {
            code length 1 add string dup 0 code putinterval dup code length 4 -1 roll 48 add put
        } ifelse
    } bind def

    /ncrmod11 {
        /code exch def
        code length 1 sub code {48 sub exch dup 1 sub exch 8 mod 2 add exch} forall pop
        0 code length {3 1 roll mul add} repeat 
        11 mod 11 exch sub 11 mod
        dup 10 eq badmod11 and {
            pop code length 2 add string dup 0 code putinterval dup code length (10) putinterval
        } {
            code length 1 add string dup 0 code putinterval dup code length 4 -1 roll 48 add put
        } ifelse
    } bind def

    % Calculate checksum
    includecheck {
        checktype (mod10) eq      {barcode mod10} if
        checktype (mod1010) eq    {barcode mod10 mod10} if
        checktype (mod11) eq      {barcode mod11} if
        checktype (ncrmod11) eq   {barcode ncrmod11} if
        checktype (mod1110) eq    {barcode mod11 mod10} if
        checktype (ncrmod1110) eq {barcode ncrmod11 mod10} if
        /barcode exch def
        /barlen barcode length def
        includecheckintext {/txtlen barlen def} if
    } if

    /sbs barlen 8 mul 5 add string def
    /txt barlen array def

    % Put start character
    sbs 0 encs 10 get putinterval

    0 1 barlen 1 sub {
        /i exch def
        % Lookup the encoding for the each barcode character
        barcode i 1 getinterval barchars exch search
        pop                                % Discard true leaving pre
        length /indx exch def              % indx is the length of pre
        pop pop                            % Discard seek and post
        /enc encs indx get def             % Get the indxth encoding
        sbs i 8 mul 2 add enc putinterval  % Put encoded digit into sbs
        txt i [barcode i 1 getinterval i 12 mul 3 add textyoffset textfont textsize] put
    } for

    % Put the end character
    sbs barlen 8 mul 2 add encs 11 get putinterval

    % Return the arguments
    <<
    /ren //renlinear
    /sbs [sbs {48 sub} forall]
    /bhs [sbs length 1 add 2 idiv {height} repeat]
    /bbs [sbs length 1 add 2 idiv {0} repeat]
    includetext {
        /txt txt 0 txtlen getinterval
    } if
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/msi dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER msi--

% --BEGIN ENCODER plessey--
% --DESC: Plessey UK
% --EXAM: 01234ABCD
% --EXOP: includetext includecheckintext
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/plessey {

    20 dict begin                  % Confine variables to local scope

    /options exch def        % We are given an option string
    /barcode exch def        % We are given a barcode string

    /dontdraw false def
    /includetext false def    % Enable/disable text
    /includecheckintext false def
    /unidirectional false def
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /height 1 def
    
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
 
    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def
    
    % Create an array containing the character mappings
    /encs
    [ (14141414) (32141414) (14321414) (32321414)
      (14143214) (32143214) (14323214) (32323214)
      (14141432) (32141432) (14321432) (32321432)
      (14143232) (32143232) (14323232) (32323232)
      (32321432) (541412323) (323)
    ] def

    % Create a string of the available characters
    /barchars (0123456789ABCDEF) def

    /barlen barcode length def     % Length of the code
    unidirectional {
        /sbs barlen 8 mul 27 add string def
    } {
        /sbs barlen 8 mul 33 add string def
    } ifelse
    /txt barlen 2 add array def
    /checkbits barlen 4 mul 8 add array def
    checkbits barlen 4 mul [ 0 0 0 0 0 0 0 0 ] putinterval

    % Put start character
    sbs 0 encs 16 get putinterval

    0 1 barlen 1 sub {
        /i exch def
        % Lookup the encoding for the each barcode character
        barcode i 1 getinterval barchars exch search
        pop                                % Discard true leaving pre
        length /indx exch def              % indx is the length of pre
        pop pop                            % Discard seek and post
        /enc encs indx get def             % Get the indxth encoding
        sbs i 8 mul 8 add enc putinterval  % Put encoded digit into sbs
        txt i [barcode i 1 getinterval i 20 mul 20 add textyoffset textfont textsize] put
        checkbits i 4 mul [
                indx 1 and
                indx -1 bitshift 1 and
                indx -2 bitshift 1 and
                indx -3 bitshift
        ] putinterval
    } for

    % Checksum is last 8 bits of a CRC using a salt
    /checksalt [ 1 1 1 1 0 1 0 0 1 ] def
    0 1 barlen 4 mul 1 sub {
        /i exch def
        checkbits i get 1 eq {
            0 1 8 {
                /j exch def
                checkbits i j add checkbits i j add get checksalt j get xor put
            } for
        } if
    } for

    % Calculate the value of the checksum digits
    /checkval 0 def
    0 1 7 {
        /i exch def
        /checkval checkval 2 i exp cvi checkbits barlen 4 mul i add get mul add def
    } for

    % Put the checksum characters
    /checksum1 checkval 15 and def
    /checksum2 checkval -4 bitshift def
    sbs barlen 8 mul 8 add encs checksum1 get putinterval
    sbs barlen 8 mul 16 add encs checksum2 get putinterval
    includecheckintext {
        txt barlen [barchars checksum1 1 getinterval barlen 20 mul 20 add textyoffset textfont textsize] put
        txt barlen 1 add [barchars checksum2 1 getinterval barlen 1 add 20 mul 20 add textyoffset textfont textsize] put
    } {
        txt barlen [( ) barlen 20 mul 20 add textyoffset textfont textsize] put
        txt barlen 1 add [( ) barlen 1 add 20 mul 20 add textyoffset textfont textsize] put
    } ifelse

    % Put end character
    unidirectional {
        sbs barlen 8 mul 24 add encs 18 get putinterval
    } {
        sbs barlen 8 mul 24 add encs 17 get putinterval
    } ifelse

    % Return the arguments
    <<
    /ren //renlinear
    /sbs [sbs {48 sub} forall]
    /bhs [sbs length 1 add 2 idiv {height} repeat]
    /bbs [sbs length 1 add 2 idiv {0} repeat]
    includetext {
        /txt txt
    } if
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/plessey dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER plessey--

% --BEGIN ENCODER telepen--
% --DESC: Telepen
% --EXAM: 123456
% --EXOP: numeric includetext
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/telepen {

    20 dict begin                  % Confine variables to local scope

    /options exch def        % We are given an option string
    /barcode exch def        % We are given a barcode string

    /numeric false def
    /dontdraw false def
    /includetext false def    % Enable/disable text
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /height 1 def
    /parse false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def

    % Parse ordinals of the form ^NNN to ASCII
    parse {
        /msg barcode length string def
        /j 0 def
        barcode
        { % loop
            (^) search {
                dup msg exch j exch putinterval
                length j add 1 add /j exch def
                pop
                dup 0 3 getinterval cvi msg exch j 1 sub exch put
                dup length 3 sub 3 exch getinterval
            } {
                dup msg exch j exch putinterval
                length j add /j exch def
                /barcode msg 0 j getinterval def
                exit
            } ifelse 
        } loop
    } if

    % Create an array containing the character mappings
    /encs
    [ (31313131)        (1131313111)     (33313111)       (1111313131)
      (3111313111)      (11333131)       (13133131)       (111111313111)
      (31333111)        (1131113131)     (33113131)       (1111333111)
      (3111113131)      (1113133111)     (1311133111)     (111111113131)
      (3131113111)      (11313331)       (333331)         (111131113111)
      (31113331)        (1133113111)     (1313113111)     (1111113331)
      (31131331)        (113111113111)   (3311113111)     (1111131331)
      (311111113111)    (1113111331)     (1311111331)     (11111111113111)
      (31313311)        (1131311131)     (33311131)       (1111313311)
      (3111311131)      (11333311)       (13133311)       (111111311131)
      (31331131)        (1131113311)     (33113311)       (1111331131)
      (3111113311)      (1113131131)     (1311131131)     (111111113311)
      (3131111131)      (1131131311)     (33131311)       (111131111131)
      (3111131311)      (1133111131)     (1313111131)     (111111131311)
      (3113111311)      (113111111131)   (3311111131)     (111113111311)
      (311111111131)    (111311111311)   (131111111311)   (11111111111131)
      (3131311111)      (11313133)       (333133)         (111131311111)
      (31113133)        (1133311111)     (1313311111)     (1111113133)
      (313333)          (113111311111)   (3311311111)     (11113333)
      (311111311111)    (11131333)       (13111333)       (11111111311111)
      (31311133)        (1131331111)     (33331111)       (1111311133)
      (3111331111)      (11331133)       (13131133)       (111111331111)
      (3113131111)      (1131111133)     (33111133)       (111113131111)
      (3111111133)      (111311131111)   (131111131111)   (111111111133)
      (31311313)        (113131111111)   (3331111111)     (1111311313)
      (311131111111)    (11331313)       (13131313)       (11111131111111)
      (3133111111)      (1131111313)     (33111313)       (111133111111)
      (3111111313)      (111313111111)   (131113111111)   (111111111313)
      (313111111111)    (1131131113)     (33131113)       (11113111111111)
      (3111131113)      (113311111111)   (131311111111)   (111111131113)
      (3113111113)      (11311111111111) (331111111111)   (111113111113)
      (31111111111111)  (111311111113)   (131111111113)   (1111111111111111)
    ] def

    /barlen barcode length def    % Length of the code
    /sbs barlen 16 mul 48 add string def
    /txt barlen array def

    % Put the start character ASCII 95
    /enc encs 95 get def
    sbs 0 enc putinterval
    /l enc length def

    /checksum 0 def
    /i 0 def /j 0 def
    { % loop
        i barlen eq {exit} if
        numeric {  % numeric mode: 00-99 & 0X-9X
            barcode i get 16 gt { 
                /np barcode i 2 getinterval def
                np 1 1 getinterval (X) eq {  % X in even position amongst digits
                    /indx np 0 1 getinterval cvi 17 add def
                } {
                    /indx np cvi 27 add def
                } ifelse
                txt j [np j 16 mul 16 add textyoffset textfont textsize] put
                /i i 2 add def
            } {
                /indx barcode i get def
                txt j [( ) j 16 mul 16 add textyoffset textfont textsize] put
                /i i 1 add def
            } ifelse
        } {  % ASCII mode
            /indx barcode i get def
            indx 32 ge indx 126 le and {
                txt j [barcode i 1 getinterval j 16 mul 16 add textyoffset textfont textsize] put
            } {
                txt j [( ) j 16 mul 16 add textyoffset textfont textsize] put
            } ifelse
            /i i 1 add def
        } ifelse
        /checksum checksum indx add def
        /enc encs indx get def
        sbs l enc putinterval          % Put encoded digit into sbs
        /l l enc length add def
        /j j 1 add def
    } loop

    % Put the checksum character
    /checksum 127 checksum 127 mod sub 127 mod def
    /enc encs checksum get def
    sbs l enc putinterval
    /l l enc length add def

    % Put the end character ASCII 122
    /enc encs 122 get def
    sbs l enc putinterval
    /l l enc length add def

    % Shrink sbs and txt to fit exactly
    /sbs sbs 0 l getinterval def
    /txt txt 0 j getinterval def

    % Return the arguments
    <<
    /ren //renlinear
    /sbs [sbs {48 sub} forall]
    /bhs [sbs length 1 add 2 idiv {height} repeat]
    /bbs [sbs length 1 add 2 idiv {0} repeat]
    includetext {
        /txt txt
    } if
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/telepen dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER telepen--

% --BEGIN ENCODER posicode--
% --DESC: PosiCode
% --EXAM: ABC123
% --EXOP: version=b inkspread=-0.5 parsefnc includetext
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/posicode {

    20 dict begin                  % Confine variables to local scope

    /options exch def        % We are given an option string
    /barcode exch def        % We are given a barcode string

    /dontdraw false def
    /includetext false def    % Enable/disable text
    /textfont /Courier def
    /textsize 10 def
    /textxoffset 0 def
    /textyoffset -7 def
    /height 1 def
    /encoding (auto) def
    /version (a) def
    /checkoffset 0 def
    /raw false def
    /parse false def
    /parsefnc false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textxoffset textxoffset cvr def
    /textyoffset textyoffset cvr def
    /encoding encoding cvlit def
    /version version cvlit def
    /checkoffset checkoffset cvi def
    /height height cvr def

    % Parse ordinals of the form ^NNN to ASCII
    parse {
        /msg barcode length string def
        /j 0 def
        barcode
        { % loop
            (^) search {
                dup msg exch j exch putinterval
                length j add 1 add /j exch def
                pop
                dup 0 3 getinterval cvi msg exch j 1 sub exch put
                dup length 3 sub 3 exch getinterval
            } {
                dup msg exch j exch putinterval
                length j add /j exch def
                /barcode msg 0 j getinterval def
                exit
            } ifelse 
        } loop
    } if

    /barlen barcode length def

    % Special function characters
    /la0  -1 def  /la1  -2 def  /la2  -3 def 
    /sf0  -4 def  /sf1  -5 def  /sf2  -6 def 
    /fn1  -7 def  /fn2  -8 def  /fn3  -9 def  /fn4 -10 def

    % Character maps for each state
    <<
    /normal
      [
          %  0    1    2        0    1    2        0    1    2
          [ (0)  (^)  (') ]  [ (1)  (;)   27 ]  [ (2)  (<)   28 ]  % 0-2 
          [ (3)  (=)   29 ]  [ (4)  (>)   30 ]  [ (5)  (?)   31 ]  % 3-5
          [ (6)  (@)  (!) ]  [ (7)  ([)  (") ]  [ (8)   92  (#) ]  % 6-8
          [ (9)  (])  (&) ]  [ (A)  (a)    1 ]  [ (B)  (b)    2 ]  % 9-11
          [ (C)  (c)    3 ]  [ (D)  (d)    4 ]  [ (E)  (e)    5 ]  % 12-14
          [ (F)  (f)    6 ]  [ (G)  (g)    7 ]  [ (H)  (h)    8 ]  % 15-17
          [ (I)  (i)    9 ]  [ (J)  (j)   10 ]  [ (K)  (k)   11 ]  % 18-20
          [ (L)  (l)   12 ]  [ (M)  (m)   13 ]  [ (N)  (n)   14 ]  % 21-23
          [ (O)  (o)   15 ]  [ (P)  (p)   16 ]  [ (Q)  (q)   17 ]  % 24-26
          [ (R)  (r)   18 ]  [ (S)  (s)   19 ]  [ (T)  (t)   20 ]  % 27-29
          [ (U)  (u)   21 ]  [ (V)  (v)   22 ]  [ (W)  (w)   23 ]  % 30-32
          [ (X)  (x)   24 ]  [ (Y)  (y)   25 ]  [ (Z)  (z)   26 ]  % 33-35
          [ (-)  (_)   40 ]  [ (.)  (`)   41 ]  [ ( )  127    0 ]  % 36-38
          [ ($)  ({)  (*) ]  [ (/)  (|)  (,) ]  [ (+)  (})  (:) ]  % 39-41
          [ (%)  (~)  fn1 ]  [ la1  la0  fn2 ]  [ sf1  sf0  fn3 ]  % 42-44
          [ sf2  sf2  fn4 ]                                        % 45
      ]
    /limited
      [
          [ (0)  -98  -98 ]  [ (1)  -98   -98 ]  [ (2)  -98  -98 ]  % 0-2
          [ (3)  -98  -98 ]  [ (4)  -98   -98 ]  [ (5)  -98  -98 ]  % 3-5
          [ (6)  -98  -98 ]  [ (7)  -98   -98 ]  [ (8)  -98  -98 ]  % 6-8
          [ (9)  -98  -98 ]  [ (A)  -98   -98 ]  [ (B)  -98  -98 ]  % 9-11
          [ (C)  -98  -98 ]  [ (D)  -98   -98 ]  [ (E)  -98  -98 ]  % 12-14
          [ (F)  -98  -98 ]  [ (G)  -98   -98 ]  [ (H)  -98  -98 ]  % 15-17
          [ (I)  -98  -98 ]  [ (J)  -98   -98 ]  [ (K)  -98  -98 ]  % 18-20
          [ (L)  -98  -98 ]  [ (M)  -98   -98 ]  [ (N)  -98  -98 ]  % 21-23
          [ (O)  -98  -98 ]  [ (P)  -98   -98 ]  [ (Q)  -98  -98 ]  % 24-26
          [ (R)  -98  -98 ]  [ (S)  -98   -98 ]  [ (T)  -98  -98 ]  % 27-29
          [ (U)  -98  -98 ]  [ (V)  -98   -98 ]  [ (W)  -98  -98 ]  % 30-32
          [ (X)  -98  -98 ]  [ (Y)  -98   -98 ]  [ (Z)  -98  -98 ]  % 33-35
          [ (-)  -98  -98 ]  [ (.)  -98   -98 ]                     % 36-37
      ]
    >> 
    version (a) eq version (b) eq or {/normal} {/limited} ifelse get 
    /charmaps exch def

    % Invert charmaps to give character to value maps for each state
    /charvals [
        charmaps length dict charmaps length dict charmaps length dict
    ] def
    0 1 charmaps length 1 sub {
        /i exch def
        /encs charmaps i get def
        0 1 2 {
            /j exch def
            encs j get dup type /stringtype eq {0 get} if  % convert string to ASCII if required
            charvals j get exch i put 
        } for
    } for
    /set0 charvals 0 get def
    /set1 charvals 1 get def
    /set2 charvals 2 get def

    raw {/encoding (raw) def} if

    encoding (raw) eq {
        /cws barlen array def
        /i 0 def /j 0 def
        { % loop
            i barlen eq {exit} if
            /cw barcode i 1 add 3 getinterval cvi def
            cws j cw put
            /i i 4 add def
            /j j 1 add def
        } loop
        /cws cws 0 j getinterval def
        /text () def
    } if

    encoding (auto) eq { 

        /fncvals <<
            (FNC1) fn1
            (FNC2) fn2
            (FNC3) fn3
            (FNC4) fn4
        >> def

        % Convert input into bytes accounting for FNC characters 
        /msg barlen array def
        /text barlen string def
        /i 0 def /j 0 def {
            i barlen eq {exit} if
            /char barcode i get def
            text j char put
            parsefnc char 94 eq and i barlen 4 sub lt and {
                barcode i 1 add get 94 ne {
                    /char fncvals barcode i 1 add 4 getinterval get def
                    text j ( ) putinterval
                    /i i 4 add def
                } {
                    /i i 1 add def
                } ifelse
            } if
            msg j char put
            /i i 1 add def
            /j j 1 add def
        } loop
        /msg msg 0 j getinterval def
        /msglen msg length def
        /text text 0 j getinterval def

        % Convert the input message to codewords
        /enc {
            exch get cws exch j exch put
            /j j 1 add def
        } bind def

        /cws barcode length 2 mul array def
        /i 0 def /j 0 def /cset (set0) def
        {
            i msglen eq {exit} if
       
            {  % common exit

                % Read next two characters
                /char1 msg i get def
                /char2 i 1 add msglen lt {msg i 1 add get} {-99} ifelse def

                % If current mode is sufficient then directly encode
                cset load char1 known { 
                    char1 cset load enc
                    /i i 1 add def
                    exit
                } if

                % If char1 is in set2 then shift encode
                set2 char1 known {
                    sf2 cset load enc
                    char1 set2 enc
                    /i i 1 add def
                    exit
                } if 

                % If char2 is also not in this set then latch else shift encode
                cset load char2 known not {
                    cset (set0) eq {
                       la1 cset load enc
                       /cset (set1) def
                    } {
                       la0 cset load enc
                       /cset (set0) def
                    } ifelse
                    exit
                } { 
                    cset (set0) eq {
                        sf1 cset load enc
                        char1 set1 enc
                    } {
                        sf0 cset load enc
                        char1 set0 enc
                    } ifelse 
                    /i i 1 add def
                    exit
                } ifelse

                exit
            } loop
        
        } loop
        /cws cws 0 j getinterval def
    } if  % auto encoding

    % Create an array containing the character mappings
    <<   % ";"=11, "<"=12
    /a
        [ (141112) (131212) (121312) (111412) (131113)
          (121213) (111313) (121114) (111214) (111115)
          (181111) (171211) (161311) (151411) (141511)
          (131611) (121711) (111811) (171112) (161212)
          (151312) (141412) (131512) (121612) (111712)
          (161113) (151213) (141313) (131413) (121513)
          (111613) (151114) (141214) (131314) (121414)
          (111514) (141115) (131215) (121315) (111415)
          (131116) (121216) (111316) (121117) (111217)
          (111118) (1<111112) (111111111;1)
        ]
    /b
        [ (151213) (141313) (131413) (121513) (141214)
          (131314) (121414) (131215) (121315) (121216)
          (191212) (181312) (171412) (161512) (151612)
          (141712) (131812) (121912) (181213) (171313)
          (161413) (151513) (141613) (131713) (121813)
          (171214) (161314) (151414) (141514) (131614)
          (121714) (161215) (151315) (141415) (131515)
          (121615) (151216) (141316) (131416) (121516)
          (141217) (131317) (121417) (131218) (121318)
          (121219) (1<121312) (121212121<1)
        ]
    /limiteda
        [ (111411) (111312) (111213) (111114) (121311)
          (121212) (121113) (141111) (131211) (131112)
          (171111) (161211) (151311) (141411) (131511)
          (121611) (111711) (161112) (151212) (141312)
          (131412) (121512) (111612) (151113) (141213)
          (131313) (121413) (111513) (141114) (131214)
          (121314) (111414) (131115) (121215) (111315)
          (121116) (111216) (111117) (151111) (1)
        ]
    /limitedb
        [ (121512) (121413) (121314) (121215) (131412)
          (131313) (131214) (151212) (141312) (141213)
          (181212) (171312) (161412) (151512) (141612)
          (131712) (121812) (171213) (161313) (151413)
          (141513) (131613) (121713) (161214) (151314)
          (141414) (131514) (121614) (151215) (141315)
          (131415) (121515) (141216) (131316) (121416)
          (131217) (121317) (121218) (141212) (1)
        ]
    >>
    version get /encs exch def

    /c2w [
        [ 495 330 210 126  70  35  15   5 ]
        [ 165 120  84  56  35  20  10   4 ]
        [  45  36  28  21  15  10   6   3 ] 
        [   9   8   7   6   5   4   3   2 ]
        [   1   1   1   1   1   1   1   1 ]
    ] def
    /v 0 def
    cws {
        /cw exch def
        6 {
            cw v xor 1 and 0 ne {
                /v v 7682 xor def
            } if
            /v v -1 bitshift def
            /cw cw -1 bitshift def
        } repeat 
    } forall
    /v v checkoffset add def

    version (limiteda) eq version (limitedb) eq or {
        /v v 1023 and def
        v 824 gt v 853 lt and {
            /v v 292 add def
        } if 
    } {
        /v v 1023 and 45 add def
    } ifelse

    /d [ 2 2 2 2 2 2 ] def
    /r 0 def /c 0 def /w 0 def /sum 0 def
    {
        sum v eq {exit} if
        /t sum c2w r get c get add def
        t v eq {
            /w w 1 add def
            d r w 2 add put
            /sum t def
        } if
        t v gt {
            d r w 2 add put
            /r r 1 add def
            /w 0 def
        } if
        t v lt {
            /c c 1 add def
            /w w 1 add def
            /sum t def
        } if
    } loop
    20 0 1 4 {d exch get sub} for
    d exch 5 exch put
    version (b) eq version (limitedb) eq or {  
        /d [ d {1 add} forall ] def
    } if
    /cbs (111111111111) 12 string copy def
    5 -1 0 {
        /i exch def
        cbs 5 i sub 2 mul 1 add d i get 47 add put
    } for

    % Concatenate the space bar successions
    /sbs cws length 6 mul 31 add string def
    encs encs length 2 sub get dup 
    sbs exch 0 exch putinterval 
    length /j exch def
    0 1 cws length 1 sub {
        /i exch def
        sbs j encs cws i get get putinterval
        /j j 6 add def
    } for
    sbs j cbs putinterval
    /j j 12 add def
    encs encs length 1 sub get dup
    sbs exch j exch putinterval
    length j add /j exch def
    /sbs sbs 0 j getinterval def

    % Return the arguments
    <<
    /ren //renlinear
    /sbs [sbs {48 sub} forall]
    /bhs [sbs length 1 add 2 idiv {height} repeat]
    /bbs [sbs length 1 add 2 idiv {0} repeat]
    /txt [ [text textxoffset textyoffset textfont textsize] ]
    /textxalign (center)
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/posicode dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER posicode--

% --BEGIN ENCODER codablockf--
% --DESC: Codablock F
% --EXAM: CODABLOCK F 34567890123456789010040digit
% --EXOP: columns=8
% --RNDR: renmatrix
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/codablockf {

    20 dict begin

    /options exch def
    /barcode exch def

    /dontdraw false def
    /rows -1 def
    /columns 8 def
    /rowheight 10 def
    /sepheight 1 def
    /encoding (auto) def
    /parse false def
    /parsefnc false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /rows rows cvi def
    /columns columns cvi def
    /rowheight rowheight cvi def
    /sepheight sepheight cvi def

    columns 4 ge columns 62 le and 
    rows 2 ge rows 44 le and rows -1 eq or and {/c columns def} if

    % Parse ordinals of the form ^NNN to ASCII
    parse {
        /msg barcode length string def
        /j 0 def
        barcode
        { % loop
            (^) search {
                dup msg exch j exch putinterval
                length j add 1 add /j exch def
                pop
                dup 0 3 getinterval cvi msg exch j 1 sub exch put
                dup length 3 sub 3 exch getinterval
            } {
                dup msg exch j exch putinterval
                length j add /j exch def
                /barcode msg 0 j getinterval def
                exit
            } ifelse 
        } loop
    } if

    /barlen barcode length def

    % Convert input into bytes accounting for FNC characters 
    /swa -1 def  /swb -2 def  /swc -3 def  /sft -4 def
    /fn1 -5 def  /fn2 -6 def  /fn3 -7 def  /fn4 -8 def
    /sta -9 def  /stp -10 def

    % Character maps for each state
    /charmaps [
      %  A    B    C         A    B    C         A    B    C
      [  32   32  (00) ]  [ (!)  (!)  (01) ]  [ (")  (")  (02) ]  % 0-2 
      [ (#)  (#)  (03) ]  [ ($)  ($)  (04) ]  [ (%)  (%)  (05) ]  % 3-5
      [ (&)  (&)  (06) ]  [ (')  (')  (07) ]  [  40   40  (08) ]  % 6-8
      [  41   41  (09) ]  [ (*)  (*)  (10) ]  [ (+)  (+)  (11) ]  % 9-11
      [ (,)  (,)  (12) ]  [ (-)  (-)  (13) ]  [ (.)  (.)  (14) ]  % 12-14
      [ (/)  (/)  (15) ]  [ (0)  (0)  (16) ]  [ (1)  (1)  (17) ]  % 15-17
      [ (2)  (2)  (18) ]  [ (3)  (3)  (19) ]  [ (4)  (4)  (20) ]  % 18-20
      [ (5)  (5)  (21) ]  [ (6)  (6)  (22) ]  [ (7)  (7)  (23) ]  % 21-23
      [ (8)  (8)  (24) ]  [ (9)  (9)  (25) ]  [ (:)  (:)  (26) ]  % 24-26
      [ (;)  (;)  (27) ]  [ (<)  (<)  (28) ]  [ (=)  (=)  (29) ]  % 27-29
      [ (>)  (>)  (30) ]  [ (?)  (?)  (31) ]  [ (@)  (@)  (32) ]  % 30-32
      [ (A)  (A)  (33) ]  [ (B)  (B)  (34) ]  [ (C)  (C)  (35) ]  % 33-35
      [ (D)  (D)  (36) ]  [ (E)  (E)  (37) ]  [ (F)  (F)  (38) ]  % 36-38
      [ (G)  (G)  (39) ]  [ (H)  (H)  (40) ]  [ (I)  (I)  (41) ]  % 39-41
      [ (J)  (J)  (42) ]  [ (K)  (K)  (43) ]  [ (L)  (L)  (44) ]  % 42-44
      [ (M)  (M)  (45) ]  [ (N)  (N)  (46) ]  [ (O)  (O)  (47) ]  % 45-47
      [ (P)  (P)  (48) ]  [ (Q)  (Q)  (49) ]  [ (R)  (R)  (50) ]  % 48-50
      [ (S)  (S)  (51) ]  [ (T)  (T)  (52) ]  [ (U)  (U)  (53) ]  % 51-53
      [ (V)  (V)  (54) ]  [ (W)  (W)  (55) ]  [ (X)  (X)  (56) ]  % 54-56
      [ (Y)  (Y)  (57) ]  [ (Z)  (Z)  (58) ]  [ ([)  ([)  (59) ]  % 57-59
      [  92   92  (60) ]  [ (])  (])  (61) ]  [ (^)  (^)  (62) ]  % 60-62
      [ (_)  (_)  (63) ]  [   0  (`)  (64) ]  [   1  (a)  (65) ]  % 63-65
      [   2  (b)  (66) ]  [   3  (c)  (67) ]  [   4  (d)  (68) ]  % 66-68
      [   5  (e)  (69) ]  [   6  (f)  (70) ]  [   7  (g)  (71) ]  % 69-71
      [   8  (h)  (72) ]  [   9  (i)  (73) ]  [  10  (j)  (74) ]  % 72-74
      [  11  (k)  (75) ]  [  12  (l)  (76) ]  [  13  (m)  (77) ]  % 75-77
      [  14  (n)  (78) ]  [  15  (o)  (79) ]  [  16  (p)  (80) ]  % 78-80
      [  17  (q)  (81) ]  [  18  (r)  (82) ]  [  19  (s)  (83) ]  % 81-83
      [  20  (t)  (84) ]  [  21  (u)  (85) ]  [  22  (v)  (86) ]  % 84-86
      [  23  (w)  (87) ]  [  24  (x)  (88) ]  [  25  (y)  (89) ]  % 87-89
      [  26  (z)  (90) ]  [  27  ({)  (91) ]  [  28  (|)  (92) ]  % 90-92
      [  29  (})  (93) ]  [  30  (~)  (94) ]  [  31  127  (95) ]  % 93-95
      [ fn3  fn3  (96) ]  [ fn2  fn2  (97) ]  [ sft  sft  (98) ]  % 96-98
      [ swc  swc  (99) ]  [ swb  fn4  swb  ]  [ fn4  swa  swa  ]  % 99-101
      [ fn1  fn1  fn1  ]  [ sta  sta  sta  ]  [ stp  stp  stp  ]  % 102-104
    ] def
    
    % Invert charmaps to give character to value maps for each state
    /charvals [ 105 dict 105 dict 105 dict ] def
    0 1 charmaps length 1 sub {
        /i exch def
        /encs charmaps i get def
        0 1 2 {
            /j exch def
            encs j get dup type /stringtype eq {0 get} if  % convert string to ASCII if required
            charvals j get exch i put 
        } for
    } for
    /seta charvals 0 get def
    /setb charvals 1 get def
    /setc charvals 2 get def
    
    /fncvals <<
        (FNC1) fn1
        (FNC2) fn2
        (FNC3) fn3
        (FNC4) fn4
    >> def
    /msg barlen array def
    /i 0 def /j 0 def {
        i barlen eq {exit} if
        /char barcode i get def
        parsefnc char 94 eq and i barlen 4 sub lt and {
            barcode i 1 add get 94 ne {
                /char fncvals barcode i 1 add 4 getinterval get def
                /i i 4 add def
            } {
                /i i 1 add def
            } ifelse
        } if
        msg j char put
        /i i 1 add def
        /j j 1 add def
    } loop
    /msg msg 0 j getinterval def
    /msglen msg length def

    % Determine digit runlength and characters from given position
    /numsscr {
        /n 0 def /s 0 def
        /p exch def {
            p msglen ge {exit} if
            msg p get
            dup setc exch known not {pop exit} if
            fn1 eq {
                % FNC1 in odd position of run like two digits
                s 2 mod 0 eq {/s s 1 add def} {exit} ifelse
            } if
            /n n 1 add def
            /s s 1 add def
            /p p 1 add def
        } loop
        n s
    } bind def

    % Encoding for each alphabet
    /enca {
        seta exch get cws exch j exch put
        /j j 1 add def
    } bind def
    /encb {
        setb exch get cws exch j exch put
        /j j 1 add def
    } bind def
    /encc {
        dup type /arraytype ne {
            setc exch get
        } {
            aload pop 48 sub exch 48 sub 10 mul add
        } ifelse
        cws exch j exch put
        /j j 1 add def
    } bind def

    % Character exclusively in either alphabet A or B
    /anotb {dup seta exch known exch setb exch known not and} bind def
    /bnota {dup setb exch known exch seta exch known not and} bind def

    % Pre-compute relative position of next anotb and next bnota characters
    /nextanotb [ msg length {0} repeat 9999 ] def
    /nextbnota [ msg length {0} repeat 9999 ] def
    msg length 1 sub -1 0 {
        /i exch def
        msg i get anotb {
            nextanotb i 0 put
        } {
            nextanotb i nextanotb i 1 add get 1 add put
        } ifelse
        msg i get bnota {
            nextbnota i 0 put
        } {
            nextbnota i nextbnota i 1 add get 1 add put
        } ifelse
    } for

    % Does a-only come before b-only after given position and vice versa
    /abeforeb {dup nextanotb exch get exch nextbnota exch get lt} bind def
    /bbeforea {dup nextbnota exch get exch nextanotb exch get lt} bind def

    % Add padding to row
    /padrow {
        {
           {  % common exit
               cset (seta) eq {swc enca /cset (setc) def exit} if
               cset (setb) eq {swc encb /cset (setc) def exit} if
               cset (setc) eq {swb encc /cset (setb) def exit} if
           } loop
        } repeat
    } bind def

    % Convert message to codewords
    /cws c 5 add rows -1 ne {rows} {44} ifelse mul array def

    /i 0 def /j 0 def /r 1 def
    /lastrow false def {
        
        lastrow {exit} if

        % Add start character and code subset selector
        sta enca
        i msglen lt {i numsscr} {-1 -1} ifelse /nums exch def /nchars exch def
        {  % common exit
            msglen 0 eq {
                swb enca
                /cset (setb) def
                exit
            } if
            nums 2 ge {
                swc enca
                /cset (setc) def
                exit
            } if
            i abeforeb { 
                sft enca
                /cset (seta) def
                exit 
            } if 
            swb enca
            /cset (setb) def
            exit
        } loop
        /j j 1 add def  % Skip row indicator position

        % Main encoding loop
        /endofrow false def {
            /rem c 3 add j c 5 add mod sub def  % Codewords to end of row

            i msglen eq endofrow or {exit} if
        
            i numsscr /nums exch def /nchars exch def

            % Determine switches and shifts
            {  % common exit
                cset (seta) eq cset (setb) eq or nums 4 ge and 
                msg i get fn1 ne and {
                    nums 2 mod 0 eq
                    rem 3 ge and {
                        swc cset (seta) eq {enca} {encb} ifelse
                        /cset (setc) def
                        2 {
                            msg i get fn1 eq {
                                fn1 encc
                                /i i 1 add def
                            } {
                                msg i 2 getinterval encc
                                /i i 2 add def
                            } ifelse
                        } repeat
                        exit
                    } if
                    nums 2 mod 0 ne
                    rem 4 ge and {
                        msg i get cset (seta) eq {enca} {encb} ifelse
                        /i i 1 add def
                        swc cset (seta) eq {enca} {encb} ifelse
                        /cset (setc) def
                        2 {
                            msg i get fn1 eq {
                                fn1 encc
                                /i i 1 add def
                            } {
                                msg i 2 getinterval encc
                                /i i 2 add def
                            } ifelse
                        } repeat
                        exit
                    } if
                } if
                cset (setb) eq msg i get anotb and 
                rem 2 ge and { 
                    i msglen 1 sub lt {
                        i 1 add bbeforea { 
                            sft encb
                            msg i get enca
                            /i i 1 add def
                            exit
                        } if
                    } if
                    swa encb
                    /cset (seta) def
                    msg i get enca
                    /i i 1 add def
                    exit
                } if
                cset (seta) eq msg i get bnota and
                rem 2 ge and {
                    i msglen 1 sub lt {
                        i 1 add abeforeb {
                            sft enca
                            msg i get encb
                            /i i 1 add def
                            exit
                        } if
                    } if
                    swb enca
                    /cset (setb) def
                    msg i get encb
                    /i i 1 add def
                    exit
                } if
                cset (setc) eq nums 2 lt and
                rem 2 ge and {
                    i abeforeb {
                        swa encc
                        /cset (seta) def
                        msg i get enca
                        /i i 1 add def
                        exit
                    } if
                    swb encc
                    /cset (setb) def
                    msg i get encb
                    /i i 1 add def
                    exit
                } if
        
                % No switches or latches so try to encode
                cset (seta) eq seta msg i get known and
                rem 1 ge and {
                    msg i get enca
                    /i i 1 add def
                    exit
                } if
                cset (setb) eq setb msg i get known and
                rem 1 ge and {
                    msg i get encb
                    /i i 1 add def
                    exit
                } if
                cset (setc) eq nums 2 ge and
                rem 1 ge and {
                    msg i get fn1 eq {
                        fn1 encc
                        /i i 1 add def
                    } {
                        msg i 2 getinterval encc
                        /i i 2 add def 
                    } ifelse
                    exit
                } if

                % Encoding does not fit in the row
                /endofrow true def
                exit

            } loop  % common exit

        } loop

        % Determine whether this is the final row
        r rows eq rows -1 eq or r 1 gt and i msglen eq and rem 2 ge and {
            rem 2 sub padrow
            /j j 3 add def  % Skip symbol and row checksum character positions
            stp enca
            /lastrow true def
        } {
            rem padrow
            /j j 1 add def  % Skip row checksum character positions
            stp enca
            /r r 1 add def
        } ifelse

    } loop
    /cws cws 0 j getinterval def

    % Maps for row indicators and symbol checksums
    /abmap [
        64 1 95 {} for
         0 1 15 {} for
        26 1 63 {} for
    ] def
    /cmap [ 0 1 85 {} for ] def
    
    % Add symbol check characters to last row
    /chkmsg msglen array def
    /j 0 def
    0 1 msglen 1 sub {
        /i exch def
        /char msg i get def
        char 0 ge {chkmsg j char put /j j 1 add def} if
        char fn1 eq i 0 ne and {chkmsg j 29 put /j j 1 add def} if
    } for
    /t1 0 def /t2 0 def /k1 0 def /k2 0 def
    0 1 j 1 sub {
        /i exch def
        /t1 chkmsg i get i mul 86 mod def
        /t2 t1 chkmsg i get add 86 mod def
        /k1 k1 t2 add 86 mod def
        /k2 k2 t1 add 86 mod def
    } for
    cws cws length 4 sub cset (setc) ne {abmap} {cmap} ifelse k1 get put
    cws cws length 3 sub cset (setc) ne {abmap} {cmap} ifelse k2 get put

    % Populate row indicators
    cws 2 2 copy 1 sub get 99 ne {abmap} {cmap} ifelse r 2 sub get put
    1 1 r 1 sub {
        /i exch def
        cws i c 5 add mul 2 add 2 copy 1 sub get 99 ne {abmap} {cmap} ifelse i 42 add get put
    } for

    % Calculate row check characters
    0 1 r 1 sub {
        cws exch c 5 add mul c 4 add getinterval /rcws exch def
        /csum rcws 0 get def
        1 1 rcws length 2 sub {
            /i exch def
            /csum csum rcws i get i mul add def
        } for
        rcws rcws length 1 sub csum 103 mod put
    } for

    % Create an array containing the character mappings
    /encs
    [ (212222) (222122) (222221) (121223) (121322) (131222) (122213)
      (122312) (132212) (221213) (221312) (231212) (112232) (122132)
      (122231) (113222) (123122) (123221) (223211) (221132) (221231)
      (213212) (223112) (312131) (311222) (321122) (321221) (312212)
      (322112) (322211) (212123) (212321) (232121) (111323) (131123)
      (131321) (112313) (132113) (132311) (211313) (231113) (231311)
      (112133) (112331) (132131) (113123) (113321) (133121) (313121)
      (211331) (231131) (213113) (213311) (213131) (311123) (311321)
      (331121) (312113) (312311) (332111) (314111) (221411) (431111)
      (111224) (111422) (121124) (121421) (141122) (141221) (112214)
      (112412) (122114) (122411) (142112) (142211) (241211) (221114)
      (413111) (241112) (134111) (111242) (121142) (121241) (114212)
      (124112) (124211) (411212) (421112) (421211) (212141) (214121)
      (412121) (111143) (111341) (131141) (114113) (114311) (411113)
      (411311) (113141) (114131) (311141) (411131) (211412) (2331112)
    ] def

    % Derive the bits for each row
    /rowbits r array def
    0 1 r 1 sub {
        /i exch def
        /sbs [
            cws i c 5 add mul c 5 add getinterval {
                encs exch get {48 sub} forall
            } forall 
        ] def
        mark
        0 sbs {1 index 1 eq {{0}} {{1}} ifelse repeat} forall
        counttomark 1 sub array astore exch pop exch pop
        rowbits i 3 -1 roll put
    } for

    % Populate the bitmap
    /symwid c 11 mul 57 add def
    /pixs [
        symwid sepheight mul {1} repeat
        0 1 r 2 sub {
            /i exch def
            rowheight {rowbits i get aload pop} repeat
            sepheight {
                1 1 0 1 0 0 0 0 1 0 0
                symwid 24 sub {1} repeat
                1 1 0 0 0 1 1 1 0 1 0 1 1
            } repeat
        } for
        rowheight {rowbits r 1 sub get aload pop} repeat
        symwid sepheight mul {1} repeat
    ] def
    
    % Return the arguments
    <<
    /ren //renmatrix
    /pixs pixs
    /pixx symwid
    /pixy pixs length symwid idiv
    /height pixs length symwid idiv 72 div
    /width symwid 72 div
    /opt options
    >>

    dontdraw not //renmatrix if

    end

} bind def
/codablockf dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER codablockf--

% --BEGIN ENCODER code16k--
% --DESC: Code 16K
% --EXAM: Abcd-1234567890-wxyZ
% --EXOP:
% --RNDR: renmatrix
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/code16k {

    20 dict begin

    /options exch def
    /barcode exch def

    /dontdraw false def
    /mode -1 def
    /pos -1 def
    /rows 0 def
    /rowheight 8 def
    /sepheight 1 def
    /encoding (auto) def
    /raw false def
    /parse false def
    /parsefnc false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /mode mode cvi def
    /pos pos cvi def
    /rows rows cvi def
    /rowheight rowheight cvi def
    /sepheight sepheight cvi def

    pos -1 ne {/rows 16 def} if

    % Parse ordinals of the form ^NNN to ASCII
    parse {
        /msg barcode length string def
        /j 0 def
        barcode
        { % loop
            (^) search {
                dup msg exch j exch putinterval
                length j add 1 add /j exch def
                pop
                dup 0 3 getinterval cvi msg exch j 1 sub exch put
                dup length 3 sub 3 exch getinterval
            } {
                dup msg exch j exch putinterval
                length j add /j exch def
                /barcode msg 0 j getinterval def
                exit
            } ifelse 
        } loop
    } if

    /barlen barcode length def

    % Convert input into bytes accounting for FNC characters 
    /swa  -1 def  /swb  -2 def  /swc  -3 def 
    /sa1  -4 def  /sb1  -5 def  /sc1  -6 def 
    /sa2  -7 def  /sb2  -8 def  /sc2  -9 def 
    /pad -10 def  /sb3 -11 def  /sc3 -12 def
    /fn1 -13 def  /fn2 -14 def  /fn3 -15 def  /fn4 -16 def

    % Character maps for each state
    /charmaps [
      %  A    B    C         A    B    C         A    B    C
      [  32   32  (00) ]  [ (!)  (!)  (01) ]  [ (")  (")  (02) ]  % 0-2 
      [ (#)  (#)  (03) ]  [ ($)  ($)  (04) ]  [ (%)  (%)  (05) ]  % 3-5
      [ (&)  (&)  (06) ]  [ (')  (')  (07) ]  [  40   40  (08) ]  % 6-8
      [  41   41  (09) ]  [ (*)  (*)  (10) ]  [ (+)  (+)  (11) ]  % 9-11
      [ (,)  (,)  (12) ]  [ (-)  (-)  (13) ]  [ (.)  (.)  (14) ]  % 12-14
      [ (/)  (/)  (15) ]  [ (0)  (0)  (16) ]  [ (1)  (1)  (17) ]  % 15-17
      [ (2)  (2)  (18) ]  [ (3)  (3)  (19) ]  [ (4)  (4)  (20) ]  % 18-20
      [ (5)  (5)  (21) ]  [ (6)  (6)  (22) ]  [ (7)  (7)  (23) ]  % 21-23
      [ (8)  (8)  (24) ]  [ (9)  (9)  (25) ]  [ (:)  (:)  (26) ]  % 24-26
      [ (;)  (;)  (27) ]  [ (<)  (<)  (28) ]  [ (=)  (=)  (29) ]  % 27-29
      [ (>)  (>)  (30) ]  [ (?)  (?)  (31) ]  [ (@)  (@)  (32) ]  % 30-32
      [ (A)  (A)  (33) ]  [ (B)  (B)  (34) ]  [ (C)  (C)  (35) ]  % 33-35
      [ (D)  (D)  (36) ]  [ (E)  (E)  (37) ]  [ (F)  (F)  (38) ]  % 36-38
      [ (G)  (G)  (39) ]  [ (H)  (H)  (40) ]  [ (I)  (I)  (41) ]  % 39-41
      [ (J)  (J)  (42) ]  [ (K)  (K)  (43) ]  [ (L)  (L)  (44) ]  % 42-44
      [ (M)  (M)  (45) ]  [ (N)  (N)  (46) ]  [ (O)  (O)  (47) ]  % 45-47
      [ (P)  (P)  (48) ]  [ (Q)  (Q)  (49) ]  [ (R)  (R)  (50) ]  % 48-50
      [ (S)  (S)  (51) ]  [ (T)  (T)  (52) ]  [ (U)  (U)  (53) ]  % 51-53
      [ (V)  (V)  (54) ]  [ (W)  (W)  (55) ]  [ (X)  (X)  (56) ]  % 54-56
      [ (Y)  (Y)  (57) ]  [ (Z)  (Z)  (58) ]  [ ([)  ([)  (59) ]  % 57-59
      [  92   92  (60) ]  [ (])  (])  (61) ]  [ (^)  (^)  (62) ]  % 60-62
      [ (_)  (_)  (63) ]  [   0  (`)  (64) ]  [   1  (a)  (65) ]  % 63-65
      [   2  (b)  (66) ]  [   3  (c)  (67) ]  [   4  (d)  (68) ]  % 66-68
      [   5  (e)  (69) ]  [   6  (f)  (70) ]  [   7  (g)  (71) ]  % 69-71
      [   8  (h)  (72) ]  [   9  (i)  (73) ]  [  10  (j)  (74) ]  % 72-74
      [  11  (k)  (75) ]  [  12  (l)  (76) ]  [  13  (m)  (77) ]  % 75-77
      [  14  (n)  (78) ]  [  15  (o)  (79) ]  [  16  (p)  (80) ]  % 78-80
      [  17  (q)  (81) ]  [  18  (r)  (82) ]  [  19  (s)  (83) ]  % 81-83
      [  20  (t)  (84) ]  [  21  (u)  (85) ]  [  22  (v)  (86) ]  % 84-86
      [  23  (w)  (87) ]  [  24  (x)  (88) ]  [  25  (y)  (89) ]  % 87-89
      [  26  (z)  (90) ]  [  27  ({)  (91) ]  [  28  (|)  (92) ]  % 90-92
      [  29  (})  (93) ]  [  30  (~)  (94) ]  [  31  127  (95) ]  % 93-95
      [ fn3  fn3  (96) ]  [ fn2  fn2  (97) ]  [ sb1  sa1  (98) ]  % 96-98
      [ swc  swc  (99) ]  [ swb  fn4  swb  ]  [ fn4  swa  swa  ]  % 99-101
      [ fn1  fn1  fn1  ]  [ pad  pad  pad  ]  [ sb2  sa2  sb1  ]  % 102-104
      [ sc2  sc2  sb2  ]  [ sc3  sc3  sb3  ]                      % 105-106
    ] def 
    
    % Invert charmaps to give character to value maps for each state
    /charvals [ 109 dict 109 dict 109 dict ] def
    0 1 charmaps length 1 sub {
        /i exch def
        /encs charmaps i get def
        0 1 2 {
            /j exch def
            encs j get dup type /stringtype eq {0 get} if  % convert string to ASCII if required
            charvals j get exch i put 
        } for
    } for
    /seta charvals 0 get def
    /setb charvals 1 get def
    /setc charvals 2 get def

    raw {/encoding (raw) def} if

    encoding (raw) eq {
        /cws barlen array def
        /i 0 def /j 0 def
        { % loop
            i barlen eq {exit} if
            /cw barcode i 1 add 3 getinterval cvi def
            cws j cw put
            /i i 4 add def
            /j j 1 add def
        } loop
        /cws cws 0 j getinterval def
        /text () def
    } if

    encoding (auto) eq { 

        /fncvals <<
            (FNC1) fn1
            (FNC2) fn2
            (FNC3) fn3
            (FNC4) fn4
        >> def
        /msg barlen array def
        /i 0 def /j 0 def {
            i barlen eq {exit} if
            /char barcode i get def
            parsefnc char 94 eq and i barlen 4 sub lt and {
                barcode i 1 add get 94 ne {
                    /char fncvals barcode i 1 add 4 getinterval get def
                    /i i 4 add def
                } {
                    /i i 1 add def
                } ifelse
            } if
            msg j char put
            /i i 1 add def
            /j j 1 add def
        } loop
        /msg msg 0 j getinterval def
        /msglen msg length def
    
        % Determine digit runlength and characters from given position
        /numsscr {
            /n 0 def /s 0 def
            /p exch def {
                p msglen ge {exit} if
                msg p get
                dup setc exch known not {pop exit} if
                fn1 eq {
                    % FNC1 in odd position of run like two digits
                    s 2 mod 0 eq {/s s 1 add def} {exit} ifelse
                } if
                /n n 1 add def
                /s s 1 add def
                /p p 1 add def
            } loop
            n s
        } bind def

        % Encoding for each alphabet
        /enca {
            seta exch get cws exch j exch put
            /j j 1 add def
        } bind def
        /encb {
            setb exch get cws exch j exch put
            /j j 1 add def
        } bind def
        /encc {
            dup type /arraytype ne {
                setc exch get
            } {
                aload pop 48 sub exch 48 sub 10 mul add
            } ifelse
            cws exch j exch put
            /j j 1 add def
        } bind def

        % Character exclusively in either alphabet A or B
        /anotb {dup seta exch known exch setb exch known not and} bind def
        /bnota {dup setb exch known exch seta exch known not and} bind def

        % Pre-compute relative position of next anotb and next bnota characters
        /nextanotb [ msg length {0} repeat 9999 ] def
        /nextbnota [ msg length {0} repeat 9999 ] def
        msg length 1 sub -1 0 {
            /i exch def
            msg i get anotb {
                nextanotb i 0 put
            } {
                nextanotb i nextanotb i 1 add get 1 add put
            } ifelse
            msg i get bnota {
                nextbnota i 0 put
            } {
                nextbnota i nextbnota i 1 add get 1 add put
            } ifelse
        } for

        % Does a-only come before b-only after given position and vice versa
        /abeforeb {dup nextanotb exch get exch nextbnota exch get lt} bind def
        /bbeforea {dup nextbnota exch get exch nextanotb exch get lt} bind def
 
        /cws barcode length 2 mul 3 add array def
       
        % Select mode and encode first characters
        /i 0 def /j 0 def
        {  % common exit
            % extended data length
            pos -1 ne {
                % encode one and two
                cws 0 pos 10 idiv 1 sub put
                cws 1 pos 10 mod 1 sub put 
                /j 2 def
                /cset (setb) def
                /mode 7 def
                exit
            } if
            % empty => b
            msglen 0 eq {
                /cset (setb) def
                /mode 1 def
                exit
            } if
            % FNC1 . 2+ nums => c fnc1
            msglen 2 ge {
                msg 0 get fn1 eq 1 numsscr exch pop 2 ge and {
                    /cset (setc) def
                    /mode 4 def
                    /i 1 def
                    exit
                } if
            } if
            % FNC1 => b fnc1
            msg 0 get fn1 eq {
                /cset (setb) def
                /mode 3 def
                /i 1 def
                exit
            } if
            msglen 2 ge {
                % 2+ even nums => c
                0 numsscr exch pop dup 2 ge exch 2 mod 0 eq and {
                    /cset (setc) def
                    /mode 2 def
                    exit
                } if
                % 3+ odd nums => c sb1 encode
                0 numsscr exch pop dup 3 ge exch 2 mod 1 eq and {
                    msg 0 get encb
                    /cset (setc) def
                    /mode 5 def
                    /i 1 def
                    exit
                } if
                % b . 2+ even nums => c sb1 encode
                setb msg 0 get known
                1 numsscr exch pop dup 2 ge exch 2 mod 0 eq and and {
                    msg 0 get encb
                    /cset (setc) def
                    /mode 5 def
                    /i 1 def
                    exit
                } if
                % b . 3+ odd nums => c sb2 encode 
                setb msg 0 get known
                1 numsscr exch pop dup 3 ge exch 2 mod 1 eq and and {
                    msg 0 get encb
                    msg 1 get encb
                    /cset (setc) def
                    /mode 6 def
                    /i 2 def
                    exit
                } if
                % b . b . 2+ even nums => c sb2 encode
                setb msg 0 get known
                setb msg 1 get known and
                2 numsscr exch pop dup 2 ge exch 2 mod 0 eq and and {
                    msg 0 get encb
                    msg 1 get encb
                    /cset (setc) def
                    /mode 6 def
                    /i 2 def
                    exit
                } if
            } if
            % anotb before bnota => a
            0 abeforeb {
                /cset (seta) def
                /mode 0 def
                exit
            } if
            % otherwise => b
            /cset (setb) def
            /mode 1 def
            exit
        } loop

        {  % Encode remainder
            i msglen eq {exit} if
        
            i numsscr /nums exch def /nchars exch def
        
            % Determine switches and shifts
            {  % common exit
                cset (seta) eq {
                    % bnota . anotb before bnota => sb1 encode
                    i msglen 1 sub lt {
                        msg i get bnota
                        i 1 add abeforeb and {
                            sb1 enca
                            msg i get encb
                            /i i 1 add def
                            exit
                        } if
                    } if
                    % bnota . bnota . anotb before bnota => sb2 encode
                    i msglen 2 sub lt {
                        msg i get bnota
                        msg i 1 add get bnota and
                        i 2 add abeforeb and {
                            sb2 enca
                            msg i get encb
                            msg i 1 add get encb
                            /i i 2 add def
                            exit
                        } if
                    } if
                    % bnota => swb
                    msg i get bnota {
                        swb enca
                        /cset (setb) def
                        exit
                    } if
                    % 4 nums . a => sc2 encode
                    i msglen 4 sub lt {
                        nums 4 eq 
                        seta msg i 4 add get known and {
                            sc2 enca
                            2 {
                                msg i get fn1 eq {
                                    fn1 encc
                                    /i i 1 add def
                                } {
                                    msg i 2 getinterval encc
                                    /i i 2 add def 
                                } ifelse
                            } repeat
                            exit
                        } if
                    } if
                    % 6 nums . a => sc3 encode
                    i msglen 6 sub lt { 
                        nums 6 eq 
                        seta msg i 6 add get known and {
                            sc3 enca
                            3 {
                                msg i get fn1 eq {
                                    fn1 encc
                                    /i i 1 add def
                                } {
                                    msg i 2 getinterval encc
                                    /i i 2 add def
                                } ifelse
                            } repeat
                            exit
                        } if
                    } if
                    % 4+ even nums => swc
                    nums 4 ge nums 2 mod 0 eq and {
                        swc enca
                        /cset (setc) def
                        exit
                    } if
                    % otherwise => encode
                    msg i get enca
                    /i i 1 add def
                    exit
                } if
                cset (setb) eq {
                    % anotb . bnota before anotb => sa1 encode
                    i msglen 1 sub lt {
                        msg i get anotb
                        i 1 add bbeforea and {
                            sa1 encb
                            msg i get enca
                            /i i 1 add def
                            exit
                        } if
                    } if
                    % anotb . anotb . bnota before anotb => sa2 encode
                    i msglen 2 sub lt {
                        msg i get anotb 
                        msg i 1 add get anotb and
                        i 2 add bbeforea and {
                            sa2 encb
                            msg i get enca
                            msg i 1 add get enca
                            /i i 2 add def
                            exit
                        } if
                    } if
                    % anotb => swa
                    msg i get anotb {
                        swa encb
                        /cset (seta) def
                        exit
                    } if
                    % 4 nums . b => sc2 encode
                    i msglen 4 sub lt {
                        nums 4 eq
                        setb msg i 4 add get known and {
                            sc2 encb
                            2 {
                                msg i get fn1 eq {
                                    fn1 encc
                                    /i i 1 add def
                                } {
                                    msg i 2 getinterval encc
                                    /i i 2 add def
                                } ifelse
                            } repeat
                            exit
                        } if
                    } if
                    % 6 nums . b => sc3 encode
                    i msglen 6 sub lt {
                        nums 6 eq
                        setb msg i 6 add get known and {
                            sc3 encb
                            3 {
                                msg i get fn1 eq {
                                    fn1 encc
                                    /i i 1 add def
                                } {
                                    msg i 2 getinterval encc
                                    /i i 2 add def
                                } ifelse
                            } repeat
                            exit
                        } if
                    } if
                    % 4+ even nums => swc
                    nums 4 ge nums 2 mod 0 eq and {
                        swc encb
                        /cset (setc) def
                        exit
                    } if
                    % otherwise => encode
                    msg i get encb
                    /i i 1 add def
                    exit 
                } if
                cset (setc) eq {
                    % 2+ nums => encode
                    nums 2 ge {
                        msg i get fn1 eq {
                            fn1 encc
                            /i i 1 add def
                        } {
                            msg i 2 getinterval encc
                            /i i 2 add def
                        } ifelse
                        exit
                    } if
                    % b . 2+ even nums => sb1 encode
                    i msglen 1 sub lt {
                        setb msg i get known
                        i 1 add numsscr exch pop dup 2 ge exch 2 mod 0 eq and and {
                            sb1 encc
                            msg i get encb
                            /i i 1 add def
                            exit
                        } if
                    } if
                    % b . 3+ odd nums => sb2 encode
                    i msglen 1 sub lt {
                        setb msg i get known
                        i 1 add numsscr exch pop dup 3 ge exch 2 mod 1 eq and and {
                            sb2 encc
                            msg i get encb
                            msg i 1 add get encb
                            /i i 2 add def
                            exit
                        } if
                    } if
                    % b . b . 2+ even nums => sb2 encode
                    i msglen 2 sub lt {
                        setb msg i get known
                        setb msg i 1 add get known and
                        i 2 add numsscr exch pop dup 2 ge exch 2 mod 0 eq and and {
                            sb2 encc
                            msg i get encb
                            msg i 1 add get encb
                            /i i 2 add def
                            exit
                        } if
                    } if
                    % b . b . 3+ odd nums => sb3 encode
                    i msglen 3 sub lt {
                        setb msg i get known
                        setb msg i 1 add get known and
                        i 2 add numsscr exch pop dup 3 ge exch 2 mod 1 eq and and {
                            sb3 encc
                            msg i get encb
                            msg i 1 add get encb
                            msg i 2 add get encb
                            /i i 3 add def
                            exit
                        } if
                    } if
                    % b . b . b . 2+ even nums => sb3 encode
                    i msglen 3 sub lt {
                        setb msg i get known 
                        setb msg i 1 add get known and
                        setb msg i 2 add get known and
                        i 3 add numsscr exch pop dup 2 ge exch 2 mod 0 eq and and {
                            sb3 encc
                            msg i get encb
                            msg i 1 add get encb
                            msg i 2 add get encb
                            /i i 3 add def
                            exit 
                        } if
                    } if
                    % anotb before bnota => swa
                    i abeforeb {
                        swa encc
                        /cset (seta) def
                        exit
                    } if
                    % otherwise => swb
                    swb encc
                    /cset (setb) def
                    exit
                } if
                exit
            } loop
        
        } loop
        /cws cws 0 j getinterval def
    } if  % auto encoding
    
    % Basic metrics for the each symbol
    %     r  dcws 
    /metrics [
        [  2    7 ]
        [  3   12 ]
        [  4   17 ]
        [  5   22 ]
        [  6   27 ]
        [  7   32 ]
        [  8   37 ]
        [  9   42 ]
        [ 10   47 ]
        [ 11   52 ]
        [ 12   57 ]
        [ 13   62 ]
        [ 14   67 ]
        [ 15   72 ]
        [ 16   77 ]
    ] def

    % Select metrics of an appropriate symbol
    /urows rows def
    /i 0 def
    { % loop
        /m metrics i get def
        /r    m 0 get def        % Columns in symbol
        /dcws m 1 get def        % Data codewords in symbol
        /okay true def
        urows 0 ne urows r ne and {/okay false def} if
        cws length dcws gt {/okay false def} if
        okay {exit} if
        /i i 1 add def
    } loop

    % Extend cws to ncws codewords by addition of pad characters
    /cws [ cws aload pop dcws cws length sub {103} repeat ] def

    % Add the start character
    /cws [ r 2 sub 7 mul mode add cws aload pop ] def

    % Calculate the check characters
    0 0 1 dcws {dup 2 add exch cws exch get mul add} for 
    107 mod /c1 exch def
    0 0 1 dcws {dup 1 add exch cws exch get mul add} for 
    c1 dcws 2 add mul add 107 mod /c2 exch def
    /cws [ cws aload pop c1 c2 ] def

    % Create an array containing the character mappings
    /encs
    [ (212222) (222122) (222221) (121223) (121322) (131222) (122213)
      (122312) (132212) (221213) (221312) (231212) (112232) (122132)
      (122231) (113222) (123122) (123221) (223211) (221132) (221231)
      (213212) (223112) (312131) (311222) (321122) (321221) (312212)
      (322112) (322211) (212123) (212321) (232121) (111323) (131123)
      (131321) (112313) (132113) (132311) (211313) (231113) (231311)
      (112133) (112331) (132131) (113123) (113321) (133121) (313121)
      (211331) (231131) (213113) (213311) (213131) (311123) (311321)
      (331121) (312113) (312311) (332111) (314111) (221411) (431111)
      (111224) (111422) (121124) (121421) (141122) (141221) (112214)
      (112412) (122114) (122411) (142112) (142211) (241211) (221114)
      (413111) (241112) (134111) (111242) (121142) (121241) (114212)
      (124112) (124211) (411212) (421112) (421211) (212141) (214121)
      (412121) (111143) (111341) (131141) (114113) (114311) (411113)
      (411311) (113141) (114131) (311141) (411131) (211412) (211214)
      (211232) (211133)
    ] def

    % Start/stop character encodings
    /startencs [ 
        (3211) (2221) (2122) (1411) (1132) (1231) (1114) (3112)
        (3211) (2221) (2122) (1411) (1132) (1231) (1114) (3112)
    ] def
    /stopencsodd [
        (3211) (2221) (2122) (1411) (1132) (1231) (1114) (3112)
        (1132) (1231) (1114) (3112) (3211) (2221) (2122) (1411)
    ] def
    /stopencseven [
        (2122) (1411) (1132) (1231) (1114) (3112) (1132) (1231)
        (1114) (3112) (3211) (2221) (2122) (1411) (3211) (2221)
    ] def
    pos -1 eq pos 10 idiv 2 mod 1 eq or {
        /stopencs stopencsodd def
    } {
        /stopencs stopencseven def
    } ifelse
 
    % Derive the bits for each row
    /rowbits r array def
    0 1 r 1 sub {
        /i exch def
        /sbs [
            10
            startencs i get {48 sub} forall
            1
            cws i 5 mul 5 getinterval {
                encs exch get {48 sub} forall
            } forall 
            stopencs i get {48 sub} forall
            1
        ] def
        mark
        1 sbs {1 index 0 eq {{1}} {{0}} ifelse repeat} forall
        counttomark 1 sub array astore exch pop exch pop
        rowbits i 3 -1 roll put
    } for

    % Populate the bitmap
    /pixs [
        81 sepheight mul {1} repeat
        0 1 r 2 sub {
            /i exch def
            rowheight {rowbits i get aload pop} repeat
            sepheight {10 {0} repeat 70 {1} repeat 0} repeat
        } for
        rowheight {rowbits r 1 sub get aload pop} repeat
        81 sepheight mul {1} repeat
    ] def
    
    % Return the arguments
    <<
    /ren //renmatrix
    /pixs pixs
    /pixx 81
    /pixy pixs length 81 idiv
    /height pixs length 81 idiv 72 div
    /width 81 72 div
    /opt options
    >>

    dontdraw not //renmatrix if

    end

} bind def
/code16k dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER code16k--

% --BEGIN ENCODER code49--
% --DESC: Code 49
% --EXAM: MULTIPLE ROWS IN CODE 49
% --EXOP:
% --RNDR: renmatrix
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/code49 {

    20 dict begin

    /options exch def
    /barcode exch def

    /dontdraw false def
    /mode -1 def
    /pos -1 def
    /rows 0 def
    /rowheight 8 def
    /sepheight 1 def
    /parse false def
    /parsefnc false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /mode mode cvi def
    /pos pos cvi def
    /rows rows cvi def
    /rowheight rowheight cvi def
    /sepheight sepheight cvi def

    % Parse ordinals of the form ^NNN to ASCII
    parse {
        /msg barcode length string def
        /j 0 def
        barcode
        { % loop
            (^) search {
                dup msg exch j exch putinterval
                length j add 1 add /j exch def
                pop
                dup 0 3 getinterval cvi msg exch j 1 sub exch put
                dup length 3 sub 3 exch getinterval
            } {
                dup msg exch j exch putinterval
                length j add /j exch def
                /barcode msg 0 j getinterval def
                exit
            } ifelse 
        } loop
    } if

    /barlen barcode length def

    % Convert input into bytes accounting for FNC characters 
    /s1 -1 def /s2 -2 def /fn1 -3 def /fn2 -4 def /fn3 -5 def /ns -6 def
    /fncvals <<
        (FNC1) fn1
        (FNC2) fn2
        (FNC3) fn3
    >> def
    /msg barlen array def
    /i 0 def /j 0 def {
        i barlen eq {exit} if
        /char barcode i get def
        parsefnc char 94 eq and i barlen 4 sub lt and {
            barcode i 1 add get 94 ne {
                /char fncvals barcode i 1 add 4 getinterval get def
                /i i 4 add def
            } {
                /i i 1 add def
            } ifelse
        } if
        msg j char put
        /i i 1 add def
        /j j 1 add def
    } loop
    /msg msg 0 j getinterval def
    /msglen msg length def

    % Character encodings
    /charmap [
        (0) (1) (2) (3) (4) (5) (6) (7) (8) (9)
        (A) (B) (C) (D) (E) (F) (G) (H) (I) (J) (K) (L) (M)
        (N) (O) (P) (Q) (R) (S) (T) (U) (V) (W) (X) (Y) (Z)
        (-) (.) ( ) ($) (/) (+) (%)
        s1  s2  fn1 fn2 fn3 ns
    ] def

    % Invert charmap to give character to value map
    /charvals 49 dict def
    0 1 48 {
        /i exch def
        charmap i get 
        dup type /stringtype eq {0 get} if  % convert string to ASCII if required
        charvals exch i put 
    } for

    % Shifted character encodings
    /combos
    [ (1 ) (1A) (1B) (1C) (1D) (1E) (1F) (1G) (1H) (1I) (1J) (1K) (1L) (1M) (1N) (1O)
      (1P) (1Q) (1R) (1S) (1T) (1U) (1V) (1W) (1X) (1Y) (1Z) (11) (12) (13) (14) (15)
      (  ) (16) (17) (18) ( $) ( %) (19) (10) (1-) (1.) (1$) ( +) (1/) ( -) ( .) ( /)
      ( 0) ( 1) ( 2) ( 3) ( 4) ( 5) ( 6) ( 7) ( 8) ( 9) (1+) (21) (22) (23) (24) (25)
      (26) ( A) ( B) ( C) ( D) ( E) ( F) ( G) ( H) ( I) ( J) ( K) ( L) ( M) ( N) ( O)
      ( P) ( Q) ( R) ( S) ( T) ( U) ( V) ( W) ( X) ( Y) ( Z) (27) (28) (29) (20) (2-)
      (2.) (2A) (2B) (2C) (2D) (2E) (2F) (2G) (2H) (2I) (2J) (2K) (2L) (2M) (2N) (2O)
      (2P) (2Q) (2R) (2S) (2T) (2U) (2V) (2W) (2X) (2Y) (2Z) (2$) (2/) (2+) (2%) (2 )
    ] def
    0 1 127 {
        /i exch def
        combos i get dup 0 get /c1 exch def 1 get /c2 exch def
        c1 49 eq {  % s1 char
            charvals i [ charvals s1 get charvals c2 get ] put
        } if
        c1 50 eq {  % s2 char
            charvals i [ charvals s2 get charvals c2 get ] put
        } if
    } for

    /encodealpha {
        charvals exch get
        dup type /arraytype ne {1 array astore} if
        dup cws exch j exch putinterval
        length j add /j exch def
    } bind def

    /base48 {
        0 exch {48 sub exch 10 mul add} forall
        [ 3 1 roll exch 1 sub {dup 48 mod exch 48 idiv} repeat ]
        [ exch dup length 1 sub -1 0 {1 index exch get exch} for pop ]
        dup cws exch j exch putinterval
        length j add /j exch def
    } bind def

    /encodenumeric {
        /nums exch def
        /pre nums length dup 5 mod dup 2 ne {sub} {sub 5 sub} ifelse def
        0 5 pre 1 sub {nums exch 5 getinterval 3 exch base48} for
        /nums nums pre nums length pre sub getinterval def
        nums length
        dup 1 eq {nums i get encodealpha} if
        dup 3 eq {2 nums base48} if
        dup 4 eq {3 [49 48 nums aload pop] base48} if
        7 eq {
            3 [49 48 nums 0 4 getinterval aload pop] base48
            2 nums 4 3 getinterval base48
        } if
    } bind def

    % Pre-compute alphanumeric and numeric runlengths
    /numericruns [ msglen {0} repeat 0 ] def
    msglen 1 sub -1 0 {
        /i exch def
        msg i get
        dup 48 ge exch 57 le and {
            numericruns i numericruns i 1 add get 1 add put
        } {
            numericruns i 0 put
        } ifelse
    } for

    % Autoselect mode
    mode -1 eq {
        {  % common exit
            pos -1 ne {/mode 3 def exit} if
            numericruns 0 get 5 ge {/mode 2 def exit} if
            charvals msg 0 get get
            dup type /arraytype ne {pop /mode 0 def exit} if
            0 get 43 eq {4} {5} ifelse /mode exch def
            exit
        } loop
    } if

    /cws msglen 2 mul 1 add array def
    /method (alpha) def /i -1 def /j -1 def

    % Handle start for each mode
    mode 0 eq mode 1 eq or {/method (alpha) def /i 0 def /j 0 def} if 
    mode 2 eq {/method (numeric) def /i 0 def /j 0 def} if
    mode 3 eq {
        /posval [ 
            12 22
            13 23 33
            14 24 34 44
            15 25 35 45 55
            16 26 36 46 56 66
            17 27 37 47 57 67 77 
            18 28 38 48 58 68 78 88 
            19 29 39 49 59 69 79 89 99
        ] def
        cws 0 0 1 43 {dup posval exch get pos ne {pop} if} for 1 add put
        /method (alpha) def /i 0 def /j 1 def
    } if
    mode 4 eq mode 5 eq or {
        cws 0 charvals msg 0 get get 1 get put
        /method (alpha) def /i 1 def /j 1 def
    } if

    % Encode remainder
    {
        i msglen eq {exit} if
        {  % not a loop but common exit point
            method (alpha) eq {
                numericruns i get 5 ge {
                    ns encodealpha
                    /method (numeric) def
                    exit
                } if
                msg i get encodealpha
                /i i 1 add def
                exit
            } if
            method (numeric) eq {
                numericruns i get 5 lt {
                    ns encodealpha
                    /method (alpha) def
                    exit
                } if
                msg i numericruns i get getinterval encodenumeric
                /i i numericruns i get add def
                exit
            } if
        } loop
    } loop
    /cws cws 0 j getinterval def

    % Basic metrics for the each symbol
    %     r dcws 
    /metrics [
        [ 2    9 ]
        [ 3   16 ]
        [ 4   23 ]
        [ 5   30 ]
        [ 6   37 ]
        [ 7   42 ]
        [ 8   49 ]
    ] def

    % Select metrics of an appropriate symbol
    /urows rows def
    /i 0 def
    { % loop
        /m metrics i get def
        /r    m 0 get def        % Columns in symbol
        /dcws m 1 get def        % Data codewords in symbol
        /okay true def
        urows 0 ne urows r ne and {/okay false def} if
        cws length dcws gt {/okay false def} if
        okay {exit} if
        /i i 1 add def
    } loop

    % Extend cws to ncws codewords by addition of pad characters
    /cws [ cws aload pop dcws cws length sub {48} repeat ] def

    % Populate code character array and add row check characters
    /ccs r 8 mul array def
    /j 0 def
    0 1 r 2 sub {
        /i exch def
        /cc cws j 7 getinterval def
        ccs i 8 mul cc putinterval       
        ccs i 8 mul 7 add 0 cc {add} forall 49 mod put
        /j j 7 add def
    } for
    j dcws lt {
        ccs ccs length 8 sub cws j dcws j sub getinterval putinterval
    } if

    % Place row count character
    /cr7 r 2 sub 7 mul mode add def
    ccs ccs length 2 sub cr7 put

    % Calculate the symbol check characters
    [  1  9 31 26  2 12 17 23 37 18 22  6 27 44 15 43 39
      11 13  5 41 33 36  8  4 32  3 19 40 25 29 10 24 30 ]
    dup [ exch 20 exch 0 32 getinterval aload pop ] /weightx exch def
    dup [ exch 16 exch 1 32 getinterval aload pop ] /weighty exch def
        [ exch 38 exch 2 32 getinterval aload pop ] /weightz exch def
    /calccheck {
        /weights exch def
        /score 0 def
        0 1 r 1 sub 8 mul 2 idiv 1 sub {
            /i exch def
            ccs i 2 mul get 49 mul ccs i 2 mul 1 add get add 
            weights i 1 add get mul /score exch score add def
        } for
        score
    } bind def
    /lastrow ccs ccs length 8 sub 8 getinterval def

    % wr1 check character
    r 7 ge {
        cr7 weightz 0 get mul weightz calccheck add 2401 mod
        dup 49 idiv exch 49 mod 2 array astore
        lastrow 0 3 -1 roll putinterval
    } if
    /wr1 lastrow 0 get 49 mul lastrow 1 get add def

    % wr2 check character
    cr7 weighty 0 get mul weighty calccheck add 
    wr1 weighty r 4 mul 3 sub get mul add
    2401 mod dup /wr2 exch def
    dup 49 idiv exch 49 mod 2 array astore        
    lastrow 2 3 -1 roll putinterval

    % wr3 check character
    cr7 weightx 0 get mul weightx calccheck add
    wr1 weightx r 4 mul 3 sub get mul add
    wr2 weightx r 4 mul 2 sub get mul add
    2401 mod
    dup 49 idiv exch 49 mod 2 array astore        
    lastrow 4 3 -1 roll putinterval

    % Place last row check character
    ccs ccs length 8 sub 7 getinterval 0 exch {add} forall 49 mod
    ccs ccs length 1 sub 3 -1 roll put

    /patterns [
        [  % Even parity
            (11521132) (25112131) (14212132) (25121221) (14221222) (12412132) (23321221)
            (12421222) (21521221) (15112222) (15121312) (13312222) (24221311) (13321312)
            (11512222) (22421311) (11521312) (25112311) (14212312) (23312311) (12412312)
            (21512311) (16121131) (14321131) (12521131) (15212131) (15221221) (13412131)
            (13421221) (11612131) (16112221) (16121311) (14312221) (14321311) (12512221)
            (12521311) (15212311) (13412311) (11612311) (11131135) (31131133) (51131131)
            (21122134) (41122132) (21131224) (41131222) (11113135) (31113133) (51113131)
            (11122225) (31122223) (51122221) (11131315) (31131313) (51131311) (21113224)
            (41113222) (21122314) (41122312) (11113315) (31113313) (51113311) (12131134)
            (32131132) (21231133) (41231131) (22122133) (42122131) (11222134) (22131223)
            (42131221) (11231224) (31231222) (12113134) (32113132) (12122224) (32122222)
            (12131314) (32131312) (21231313) (41231311) (22113223) (42113221) (11213224)
            (22122313) (42122311) (11222314) (31222312) (12113314) (32113312) (21213313)
            (41213311) (13131133) (33131131) (22231132) (11331133) (31331131) (23122132)
            (12222133) (23131222) (12231223) (32231221) (21331222) (13113133) (33113131)
            (13122223) (33122221) (11313133) (13131313) (33131311) (11322223) (22231312)
            (11331313) (31331311) (23113222) (12213223) (23122312) (12222313) (32222311)
            (21322312) (13113313) (33113311) (22213312) (11313313) (31313311) (14131132)
            (23231131) (12331132) (21431131) (24122131) (13222132) (24131221) (13231222)
            (11422132) (22331221) (11431222) (14113132) (14122222) (12313132) (14131312)
            (12322222) (23231311) (12331312) (21431311) (24113221) (13213222) (24122311)
            (13222312) (11413222) (22322311) (11422312) (14113312) (23213311) (12313312)
            (21413311) (15131131) (13331131) (14222131) (14231221) (12422131) (12431221)
            (15113131) (15122221) (13313131) (15131311) (13322221) (11513131) (13331311)
            (11522221) (14213221) (14222311) (12413221) (12422311) (15113311) (13313311)
            (11513311) (11141134) (31141132) (21132133) (41132131) (21141223) (41141221)
            (11123134) (31123132) (11132224) (31132222) (11141314) (31141312) (21114133)
            (41114131) (21123223) (41123221) (21132313) (41132311) (11114224) (31114222)
            (11123314) (31123312) (21114313) (41114311) (12141133) (32141131) (21241132)
            (22132132) (11232133) (22141222) (11241223) (31241221) (12123133) (32123131)
            (12132223) (32132221) (12141313) (32141311) (21241312) (22114132) (11214133)
            (22123222) (11223223) (22132312) (11232313) (31232311) (12114223) (32114221)
            (12123313) (32123311) (21223312) (22114312) (11214313) (31214311) (13141132)
            (22241131) (11341132) (23132131) (12232132) (23141221) (12241222) (21341221)
            (13123132) (13132222) (11323132) (13141312) (11332222) (22241311) (11341312)
            (23114131) (12214132) (23123221) (12223222) (23132311) (12232312) (21332311)
            (13114222) (13123312) (11314222) (22223311) (11323312) (23114311) (12214312)
            (21314311) (14141131) (12341131) (13232131) (13241221) (11432131) (14123131)
            (14132221) (12323131) (14141311) (12332221) (12341311) (13214131) (13223221)
            (11414131) (13232311) (11423221) (11432311) (14114221) (14123311) (12314221)
            (12323311) (13214311) (11414311) (11151133) (31151131) (21142132) (21151222)
            (11133133) (31133131) (11142223) (31142221) (11151313) (31151311) (21124132)
            (21133222) (21142312) (11115133) (31115131) (11124223) (31124221) (11133313)
            (31133311) (21115222) (21124312) (12151132) (21251131) (22142131) (11242132)
            (22151221) (11251222) (12133132) (12142222) (12151312) (21251311) (22124131)
            (11224132) (22133221) (11233222) (22142311) (11242312) (12115132) (12124222)
            (12133312) (21233311) (22115221) (11215222) (22124311) (11224312) (13151131)
            (12242131) (12251221) (13133131) (13142221) (11333131) (13151311) (11342221)
            (12224131) (12233221) (12242311) (13115131) (13124221) (11315131) (13133311)
            (11324221) (11333311) (12215221) (12224311) (11161132) (21152131) (21161221)
            (11143132) (11152222) (11161312) (21134131) (21143221) (21152311) (11125132)
            (11134222) (11143312) (21116131) (21125221) (21134311) (12161131) (11252131)
            (12143131) (12152221) (12161311) (11234131) (11243221) (11252311) (12125131)
            (12134221) (12143311) (11216131) (11225221) (11234311) (11111236) (31111234)
            (51111232) (21111325) (41111323) (61111321) (11111416) (31111414) (51111412)
            (31211143) (51211141) (12111235) (32111233) (52111231) (21211234) (41211232)
            (22111324) (42111322) (11211325) (31211323) (51211321) (12111415) (32111413)
            (52111411) (21211414) (41211412) (12211144) (32211142) (21311143) (41311141)
            (13111234) (33111232) (22211233) (42211231) (11311234) (31311232) (23111323)
            (43111321) (12211324) (32211322) (21311323) (41311321) (13111414) (33111412)
            (22211413) (42211411) (11311414) (31311412) (13211143) (33211141) (22311142)
            (11411143) (31411141) (14111233) (34111231) (23211232) (12311233) (32311231)
            (21411232) (24111322) (13211323) (33211321) (22311322) (11411323) (31411321)
            (14111413) (34111411) (23211412) (12311413) (32311411) (21411412) (14211142)
            (23311141) (12411142) (21511141) (15111232) (24211231) (13311232) (22411231)
            (11511232) (25111321) (14211322) (23311321) (12411322) (21511321) (15111412)
            (24211411) (13311412) (22411411) (11511412) (15211141) (13411141) (11611141)
            (16111231) (14311231) (12511231) (15211321) (13411321) (11611321) (16111411)
            (14311411) (12511411) (21121144) (41121142) (11112145) (31112143) (51112141)
            (11121235) (31121233) (51121231) (21112234) (41112232) (21121324) (41121322)
            (11112325) (31112323) (51112321) (11121415) (31121413) (51121411) (21112414)
            (41112412) (22121143) (42121141) (11221144) (31221142) (12112144) (32112142)
            (12121234) (32121232) (21221233) (41221231) (22112233) (42112231) (11212234)
            (22121323) (42121321) (11221324) (31221322) (12112324) (32112322) (12121414)
            (32121412) (21221413) (41221411) (22112413) (42112411) (11212414) (31212412)
            (23121142) (12221143) (32221141) (21321142) (13112143) (33112141) (13121233)
            (33121231) (11312143) (22221232) (11321233) (31321231) (23112232) (12212233)
            (23121322) (12221323) (32221321) (21321322) (13112323) (33112321) (13121413)
            (33121411) (11312323) (22221412) (11321413) (31321411) (23112412) (12212413)
            (32212411) (21312412) (24121141) (13221142) (22321141) (11421142) (14112142)
            (14121232) (12312142) (23221231) (12321232) (21421231) (24112231) (13212232)
            (24121321) (13221322) (11412232) (22321321) (11421322) (14112322) (14121412)
            (12312322) (23221411) (12321412) (21421411) (24112411) (13212412) (22312411)
            (11412412) (14221141) (12421141) (15112141) (15121231) (13312141) (13321231)
            (11512141) (11521231) (14212231) (14221321) (12412231) (12421321) (15112321)
            (15121411) (13312321) (13321411) (11512321) (11521411) (14212411) (12412411)
            (21131143) (41131141) (11122144) (31122142) (11131234) (31131232) (21113143)
            (41113141) (21122233) (41122231) (21131323) (41131321) (11113234) (31113232)
            (11122324) (31122322) (11131414) (31131412) (21113323) (41113321) (21122413)
            (41122411) (11113414) (31113412) (22131142) (11231143) (31231141) (12122143)
            (32122141) (12131233) (32131231) (21231232) (22113142) (11213143) (22122232)
            (11222233) (22131322) (11231323) (31231321) (12113233) (32113231) (12122323)
            (32122321) (12131413) (32131411) (21231412) (22113322) (11213323) (22122412)
            (11222413) (31222411) (12113413) (32113411) (21213412) (23131141) (12231142)
            (21331141) (13122142) (13131232) (11322142) (22231231) (11331232) (23113141)
            (12213142) (23122231) (12222232) (23131321) (12231322) (21331321) (13113232)
            (13122322) (11313232) (13131412) (11322322) (22231411) (11331412) (23113321)
            (12213322) (23122411) (12222412) (21322411) (13113412) (22213411) (11313412)
            (13231141) (11431141) (14122141) (14131231) (12322141) (12331231) (13213141)
            (13222231) (11413141) (13231321) (11422231) (11431321) (14113231) (14122321)
            (12313231) (14131411) (12322321) (12331411) (13213321) (13222411) (11413321)
            (11422411) (14113411) (12313411) (21141142) (11132143) (31132141) (11141233)
            (31141231) (21123142) (21132232) (21141322) (11114143) (31114141) (11123233)
            (31123231) (11132323) (31132321) (11141413) (31141411) (21114232) (21123322)
            (21132412) (11114323) (31114321) (11123413) (31123411) (22141141) (11241142)
            (12132142) (12141232) (21241231) (22123141) (11223142) (22132231) (11232232)
            (22141321) (11241322) (12114142) (12123232) (12132322) (12141412) (21241411)
            (22114231) (11214232) (22123321) (11223322) (22132411) (11232412) (12114322)
            (12123412) (21223411) (12241141) (13132141) (13141231) (11332141) (11341231)
            (12223141) (12232231) (12241321) (13114141) (13123231) (11314141) (13132321)
            (11323231) (13141411) (11332321) (11341411) (12214231) (12223321) (12232411)
            (13114321) (13123411) (11314321) (11323411) (21151141) (11142142) (11151232)
            (21133141) (21142231) (21151321) (11124142) (11133232) (11142322) (11151412)
            (21115141) (21124231) (21133321) (21142411) (11115232) (11124322) (11133412)
            (11251141) (12142141) (12151231) (11233141) (11242231) (11251321) (12124141)
            (12133231) (12142321) (12151411) (11215141) (11224231) (11233321) (11242411)
            (12115231) (12124321) (12133411) (11152141) (11161231) (11134141) (11143231)
            (11152321) (11161411) (11116141) (11125231) (11134321) (11143411) (21111244)
            (41111242) (11111335) (31111333) (51111331) (21111424) (41111422) (11111515)
            (31111513) (51111511) (21211153) (41211151) (22111243) (42111241) (11211244)
            (31211242) (12111334) (32111332) (21211333) (41211331) (22111423) (42111421)
            (11211424) (31211422) (12111514) (32111512) (21211513) (41211511) (22211152)
            (11311153) (31311151) (23111242) (12211243) (32211241) (21311242) (13111333)
            (33111331) (22211332) (11311333) (31311331) (23111422) (12211423) (32211421)
            (21311422) (13111513) (33111511) (22211512) (11311513) (31311511) (23211151)
            (12311152) (21411151) (24111241) (13211242) (22311241) (11411242) (14111332)
            (23211331) (12311332) (21411331) (24111421) (13211422) (22311421) (11411422)
            (14111512) (23211511) (12311512) (21411511) (13311151) (11511151) (14211241)
            (12411241) (15111331) (13311331) (11511331) (14211421) (12411421) (15111511)
            (13311511) (11511511) (31121152) (21112153) (41112151) (21121243) (41121241)
            (11112244) (31112242) (11121334) (31121332) (21112333) (41112331) (21121423)
            (41121421) (11112424) (31112422) (11121514) (31121512) (21112513) (41112511)
            (12121153) (32121151) (21221152) (22112152) (11212153) (22121242) (11221243)
            (31221241) (12112243) (32112241) (12121333) (32121331) (21221332) (22112332)
            (11212333) (22121422) (11221423) (31221421) (12112423) (32112421) (12121513)
            (32121511) (21221512) (22112512) (11212513) (31212511) (13121152) (22221151)
            (11321152) (23112151) (12212152) (23121241) (12221242) (21321241) (13112242)
            (13121332) (11312242) (22221331) (11321332) (23112331) (12212332) (23121421)
            (12221422) (21321421) (13112422) (13121512) (11312422) (22221511) (11321512)
            (23112511) (12212512) (21312511) (14121151) (12321151) (13212151) (13221241)
            (11412151) (11421241) (14112241) (14121331) (12312241) (12321331) (13212331)
            (13221421) (11412331) (11421421) (14112421) (14121511) (12312421) (12321511)
            (13212511) (11412511) (11131153) (31131151) (21122152) (21131242) (11113153)
            (31113151) (11122243) (31122241) (11131333) (31131331) (21113242) (21122332)
            (21131422) (11113333) (31113331) (11122423) (31122421) (11131513) (31131511)
            (21113422) (21122512) (12131152) (21231151) (22122151) (11222152) (22131241)
            (11231242) (12113152) (12122242) (12131332) (21231331) (22113241) (11213242)
            (22122331) (11222332) (22131421) (11231422) (12113332) (12122422) (12131512)
            (21231511) (22113421) (11213422) (22122511) (11222512) (13131151) (11331151)
            (12222151) (12231241) (13113151) (13122241) (11313151) (13131331) (11322241)
            (11331331) (12213241) (12222331) (12231421) (13113331) (13122421) (11313331)
            (13131511) (11322421) (11331511) (12213421) (12222511) (11141152) (21132151)
            (21141241) (11123152) (11132242) (11141332) (21114151) (21123241) (21132331)
            (21141421) (11114242) (11123332) (11132422) (11141512) (21114331) (21123421)
            (21132511) (12141151) (11232151) (11241241) (12123151) (12132241) (12141331)
            (11214151) (11223241) (11232331) (11241421) (12114241) (12123331) (12132421)
            (12141511) (11214331) (11223421) (11232511) (11151151) (11133151) (11142241)
            (11151331) (11115151) (11124241) (11133331) (11142421) (11151511) (11111254)
            (31111252) (21111343) (41111341) (11111434) (31111432) (21111523) (41111521)
            (11111614) (31111612) (31211161) (12111253) (32111251) (21211252) (22111342)
            (11211343) (31211341) (12111433) (32111431) (21211432) (22111522) (11211523)
            (31211521) (12111613) (32111611) (21211612) (12211162) (21311161) (13111252)
            (22211251) (11311252) (23111341) (12211342) (21311341) (13111432) (22211431)
            (11311432) (23111521) (12211522) (21311521) (13111612) (22211611) (11311612)
            (13211161) (11411161) (14111251) (12311251) (13211341) (11411341) (14111431)
            (12311431) (13211521) (11411521) (14111611) (12311611) (21121162) (11112163)
            (31112161) (11121253) (31121251) (21112252) (21121342) (11112343) (31112341)
            (11121433) (31121431) (21112432) (21121522) (11112523) (31112521) (11121613)
            (31121611) (22121161) (11221162) (12112162) (12121252) (21221251) (22112251)
            (11212252) (22121341) (11221342) (12112342) (12121432) (21221431) (22112431)
            (11212432) (22121521) (11221522) (12112522) (12121612) (21221611) (12221161)
            (13112161) (13121251) (11312161) (11321251) (32121115) (52121113) (21221116)
            (41221114) (61221112) (22112116) (42112114) (31212115) (51212113) (13121116)
            (33121114) (22221115) (42221113) (11321116) (31321114) (51321112) (23112115)
            (43112113) (12212116) (32212114) (52212112) (21312115) (41312113) (61312111)
            (14121115) (34121113) (23221114) (43221112) (12321115) (32321113) (52321111)
            (21421114) (41421112) (24112114) (13212115) (33212113) (22312114) (42312112)
            (11412115) (31412113) (51412111) (15121114) (24221113) (13321114) (33321112)
            (22421113) (42421111) (11521114) (31521112) (25112113) (14212114) (34212112)
            (23312113) (43312111) (12412114) (32412112) (21512113) (41512111) (16121113)
            (25221112) (14321113) (34321111) (23421112) (12521113) (32521111) (15212113)
            (24312112) (13412113) (33412111) (22512112) (11612113) (31612111) (31131115)
            (51131113) (21122116) (41122114) (61122112) (31113115) (51113113) (12131116)
            (32131114) (52131112) (21231115) (41231113) (61231111) (22122115) (42122113)
            (11222116) (31222114) (51222112) (12113116) (32113114) (52113112) (21213115)
            (41213113) (61213111) (13131115) (33131113) (22231114) (42231112) (11331115)
            (31331113) (51331111) (23122114) (43122112) (12222115) (32222113) (52222111)
            (21322114) (41322112) (13113115) (33113113) (22213114) (42213112) (11313115)
            (31313113) (51313111) (14131114) (34131112) (23231113) (43231111) (12331114)
            (32331112) (21431113) (41431111) (24122113) (13222114) (33222112) (22322113)
            (42322111) (11422114) (31422112) (14113114) (34113112) (23213113) (43213111)
            (12313114) (32313112) (21413113) (41413111) (15131113) (24231112) (13331113)
            (33331111) (22431112) (25122112) (14222113) (34222111) (23322112) (12422113)
            (32422111) (21522112) (15113113) (24213112) (13313113) (33313111) (22413112)
            (11513113) (31513111) (16131112) (25231111) (14331112) (23431111) (15222112)
            (24322111) (13422112) (22522111) (16113112) (25213111) (14313112) (23413111)
            (12513112) (21613111) (11141116) (31141114) (51141112) (21132115) (41132113)
            (61132111) (11123116) (31123114) (51123112) (21114115) (41114113) (61114111)
            (12141115) (32141113) (52141111) (21241114) (41241112) (22132114) (42132112)
            (11232115) (31232113) (51232111) (12123115) (32123113) (52123111) (21223114)
            (41223112) (22114114) (42114112) (11214115) (31214113) (51214111) (13141114)
            (33141112) (22241113) (42241111) (11341114) (31341112) (23132113) (43132111)
            (12232114) (32232112) (21332113) (41332111) (13123114) (33123112) (22223113)
            (42223111) (11323114) (31323112) (23114113) (43114111) (12214114) (32214112)
            (21314113) (41314111) (14141113) (34141111) (23241112) (12341113) (32341111)
            (24132112) (13232113) (33232111) (22332112) (11432113) (31432111) (14123113)
            (34123111) (23223112) (12323113) (32323111) (21423112) (24114112) (13214113)
            (33214111) (22314112) (11414113) (31414111) (15141112) (24241111) (13341112)
            (25132111) (14232112) (23332111) (12432112) (15123112) (24223111) (13323112)
            (22423111) (11523112) (25114111) (14214112) (23314111) (12414112) (21514111)
            (16141111) (14341111) (15232111) (13432111) (16123111) (14323111) (12523111)
            (15214111) (13414111) (11614111) (11151115) (31151113) (51151111) (21142114)
            (41142112) (11133115) (31133113) (51133111) (21124114) (41124112) (11115115)
            (31115113) (51115111) (12151114) (32151112) (21251113) (41251111) (22142113)
            (42142111) (11242114) (31242112) (12133114) (32133112) (21233113) (41233111)
            (22124113) (42124111) (11224114) (31224112) (12115114) (32115112) (21215113)
            (41215111) (13151113) (33151111) (22251112) (23142112) (12242113) (32242111)
            (21342112) (13133113) (33133111) (22233112) (11333113) (31333111) (23124112)
            (12224113) (32224111) (21324112) (13115113) (33115111) (22215112) (11315113)
            (31315111) (14151112) (23251111) (24142111) (13242112) (22342111) (14133112)
            (23233111) (12333112) (21433111) (24124111) (13224112) (22324111) (11424112)
            (14115112) (23215111) (12315112) (21415111) (15151111) (14242111) (15133111)
            (13333111) (14224111) (12424111) (15115111) (13315111) (11515111) (11161114)
            (31161112) (21152113) (41152111) (11143114) (31143112) (21134113) (41134111)
            (11125114) (31125112) (21116113) (41116111) (12161113) (32161111) (22152112)
            (11252113) (31252111) (12143113) (32143111) (21243112) (22134112) (11234113)
            (31234111) (12125113) (32125111) (21225112) (22116112) (11216113) (31216111)
            (13161112) (23152111) (12252112) (13143112) (22243111) (11343112) (23134111)
            (12234112) (21334111) (13125112) (22225111) (11325112) (23116111) (12216112)
            (21316111) (14161111) (13252111) (14143111) (12343111) (13234111) (11434111)
            (14125111) (12325111) (13216111) (11416111) (31111216) (51111214) (31211125)
            (51211123) (32111215) (52111213) (21211216) (41211214) (61211212) (12211126)
            (32211124) (52211122) (21311125) (41311123) (61311121) (13111216) (33111214)
            (22211215) (42211213) (11311216) (31311214) (51311212) (13211125) (33211123)
            (22311124) (42311122) (11411125) (31411123) (51411121) (14111215) (34111213)
            (23211214) (43211212) (12311215) (32311213) (52311211) (21411214) (41411212)
            (14211124) (34211122) (23311123) (43311121) (12411124) (32411122) (21511123)
            (41511121) (15111214) (24211213) (13311214) (33311212) (22411213) (42411211)
            (11511214) (31511212) (15211123) (24311122) (13411123) (33411121) (22511122)
            (11611123) (31611121) (16111213) (25211212) (14311213) (34311211) (23411212)
            (12511213) (32511211) (21611212) (21121126) (41121124) (61121122) (31112125)
            (51112123) (31121215) (51121213) (21112216) (41112214) (61112212) (22121125)
            (42121123) (11221126) (31221124) (51221122) (12112126) (32112124) (52112122)
            (12121216) (32121214) (52121212) (21221215) (41221213) (61221211) (22112215)
            (42112213) (11212216) (31212214) (51212212) (23121124) (43121122) (12221125)
            (32221123) (52221121) (21321124) (41321122) (13112125) (33112123) (13121215)
            (33121213) (11312125) (22221214) (42221212) (11321215) (31321213) (51321211)
            (23112214) (43112212) (12212215) (32212213) (52212211) (21312214) (41312212)
            (24121123) (13221124) (33221122) (22321123) (42321121) (11421124) (31421122)
            (14112124) (34112122) (14121214) (34121212) (12312124) (23221213) (43221211)
            (12321214) (32321212) (21421213) (41421211) (24112213) (13212214) (33212212)
            (22312213) (42312211) (11412214) (31412212) (25121122) (14221123) (34221121)
            (23321122) (12421123) (32421121) (21521122) (15112123) (15121213) (13312123)
            (24221212) (13321213) (33321211) (11512123) (22421212) (11521213) (31521211)
            (25112212) (14212213) (34212211) (23312212) (12412213) (32412211) (21512212)
            (15221122) (24321121) (13421122) (22521121) (16112122) (16121212) (14312122)
            (25221211) (14321212) (12512122) (23421211) (12521212) (15212212) (24312211)
            (13412212) (22512211) (11612212) (21131125) (41131123) (61131121) (11122126)
            (31122124) (51122122) (11131216) (31131214) (51131212) (21113125) (41113123)
            (61113121) (21122215) (41122213) (61122211) (11113216) (31113214) (51113212)
            (22131124) (42131122) (11231125) (31231123) (51231121) (12122125) (32122123)
            (52122121) (12131215) (32131213) (52131211) (21231214) (41231212) (22113124)
            (42113122) (11213125) (22122214) (42122212) (11222215) (31222213) (51222211)
            (12113215) (32113213) (52113211) (21213214) (41213212) (23131123) (43131121)
            (12231124) (32231122) (21331123) (41331121) (13122124) (33122122) (13131214)
            (33131212) (11322124) (22231213) (42231211) (11331214) (31331212) (23113123)
            (43113121) (12213124) (23122213) (43122211) (12222214) (32222212) (21322213)
            (41322211) (13113214) (33113212) (22213213) (42213211) (11313214) (31313212)
            (24131122) (13231123) (33231121) (22331122) (11431123) (31431121) (14122123)
            (34122121) (14131213) (34131211) (12322123) (23231212) (12331213) (32331211)
            (21431212) (24113122) (13213123) (24122212) (13222213) (33222211) (11413123)
            (22322212) (11422213) (31422211) (14113213) (34113211) (23213212) (12313213)
            (32313211) (21413212) (25131121) (14231122) (23331121) (12431122) (15122122)
            (15131212) (13322122) (24231211) (13331212) (11522122) (22431211) (25113121)
            (14213122) (25122211) (14222212) (12413122) (23322211) (12422212) (21522211)
            (15113212) (24213211) (13313212) (22413211) (11513212) (15231121) (13431121)
            (16122121) (16131211) (14322121) (14331211) (12522121) (15213121) (15222211)
            (13413121) (13422211) (11613121) (16113211) (14313211) (12513211) (21141124)
            (41141122) (11132125) (31132123) (51132121) (11141215) (31141213) (51141211)
            (21123124) (41123122) (21132214) (41132212) (11114125) (31114123) (51114121)
            (11123215) (31123213) (51123211) (21114214) (41114212) (22141123) (42141121)
            (11241124) (31241122) (12132124) (32132122) (12141214) (32141212) (21241213)
            (41241211) (22123123) (42123121) (11223124) (22132213) (42132211) (11232214)
            (31232212) (12114124) (32114122) (12123214) (32123212) (21223213) (41223211)
            (22114213) (42114211) (11214214) (31214212) (23141122) (12241123) (32241121)
            (21341122) (13132123) (33132121) (13141213) (33141211) (11332123) (22241212)
            (11341213) (31341211) (23123122) (12223123) (23132212) (12232213) (32232211)
            (21332212) (13114123) (33114121) (13123213) (33123211) (11314123) (22223212)
            (11323213) (31323211) (23114212) (12214213) (32214211) (21314212) (24141121)
            (13241122) (22341121) (14132122) (14141212) (12332122) (23241211) (12341212)
            (24123121) (13223122) (24132211) (13232212) (11423122) (22332211) (11432212)
            (14114122) (14123212) (12314122) (23223211) (12323212) (21423211) (24114211)
            (13214212) (22314211) (11414212) (14241121) (15132121) (15141211) (13332121)
            (13341211) (14223121) (14232211) (12423121) (12432211) (15114121) (15123211)
            (13314121) (13323211) (11514121) (11523211) (14214211) (12414211) (21151123)
            (41151121) (11142124) (31142122) (11151214) (31151212) (21133123) (41133121)
            (21142213) (41142211) (11124124) (31124122) (11133214) (31133212) (21115123)
            (41115121) (21124213) (41124211) (11115214) (31115212) (22151122) (11251123)
            (31251121) (12142123) (32142121) (12151213) (32151211) (21251212) (22133122)
            (11233123) (22142212) (11242213) (31242211) (12124123) (32124121) (12133213)
            (32133211) (21233212) (22115122) (11215123) (22124212) (11224213) (31224211)
            (12115213) (32115211) (21215212) (23151121) (12251122) (13142122) (13151212)
            (11342122) (22251211) (23133121) (12233122) (23142211) (12242212) (21342211)
            (13124122) (13133212) (11324122) (22233211) (11333212) (23115121) (12215122)
            (23124211) (12224212) (21324211) (13115212) (22215211) (11315212) (13251121)
            (14142121) (14151211) (12342121) (13233121) (13242211) (11433121) (14124121)
            (14133211) (12324121) (12333211) (13215121) (13224211) (11415121) (11424211)
            (14115211) (12315211) (21161122) (11152123) (31152121) (11161213) (31161211)
            (21143122) (21152212) (11134123) (31134121) (11143213) (31143211) (21125122)
            (21134212) (11116123) (31116121) (11125213) (31125211) (22161121) (12152122)
            (12161212) (22143121) (11243122) (22152211) (11252212) (12134122) (12143212)
            (21243211) (22125121) (11225122) (22134211) (11234212) (12116122) (12125212)
            (21225211) (13152121) (13161211) (12243121) (12252211) (13134121) (13143211)
            (11334121) (11343211) (12225121) (12234211) (13116121) (13125211) (11316121)
            (11325211) (21111226) (41111224) (61111222) (31111315) (51111313) (21211135)
            (41211133) (61211131) (22111225) (42111223) (11211226) (31211224) (51211222)
            (12111316) (32111314) (52111312) (21211315) (41211313) (61211311) (22211134)
            (42211132) (11311135) (31311133) (51311131) (23111224) (43111222) (12211225)
            (32211223) (52211221) (21311224) (41311222) (13111315) (33111313) (22211314)
            (42211312) (11311315) (31311313) (51311311) (23211133) (43211131) (12311134)
            (32311132) (21411133) (41411131) (24111223) (13211224) (33211222) (22311223)
            (42311221) (11411224) (31411222) (14111314) (34111312) (23211313) (43211311)
            (12311314) (32311312) (21411313) (41411311) (24211132) (13311133) (33311131)
            (22411132) (11511133) (31511131) (25111222) (14211223) (34211221) (23311222)
            (12411223) (32411221) (21511222) (15111313) (24211312) (13311313) (33311311)
            (22411312) (11511313) (31511311) (25211131) (14311132) (23411131) (12511132)
            (21611131) (15211222) (24311221) (13411222) (22511221) (11611222) (16111312)
            (25211311) (14311312) (23411311) (12511312) (21611311) (31121134) (51121132)
            (21112135) (41112133) (61112131) (21121225) (41121223) (61121221) (11112226)
            (31112224) (51112222) (11121316) (31121314) (51121312) (21112315) (41112313)
            (61112311) (12121135) (32121133) (52121131) (21221134) (41221132) (22112134)
            (42112132) (11212135) (22121224) (42121222) (11221225) (31221223) (51221221)
            (12112225) (32112223) (52112221) (12121315) (32121313) (52121311) (21221314)
            (41221312) (22112314) (42112312) (11212315) (31212313) (51212311) (13121134)
            (33121132) (22221133) (42221131) (11321134) (31321132) (23112133) (43112131)
            (12212134) (23121223) (43121221) (12221224) (32221222) (21321223) (41321221)
            (13112224) (33112222) (13121314) (33121312) (11312224) (22221313) (42221311)
            (11321314) (31321312) (23112313) (43112311) (12212314) (32212312) (21312313)
            (41312311) (14121133) (34121131) (23221132) (12321133) (32321131) (21421132)
            (24112132) (13212133) (24121222) (13221223) (33221221) (11412133) (22321222)
            (11421223) (31421221) (14112223) (34112221) (14121313) (34121311) (12312223)
            (23221312) (12321313) (32321311) (21421312) (24112312) (13212313) (33212311)
            (22312312) (11412313) (31412311) (15121132) (24221131) (13321132) (22421131)
        ] [  % Odd parity
            (22121116) (42121114) (31221115) (51221113) (32112115) (52112113) (21212116)
            (41212114) (61212112) (23121115) (43121113) (12221116) (32221114) (52221112)
            (21321115) (41321113) (61321111) (13112116) (33112114) (22212115) (42212113)
            (11312116) (31312114) (51312112) (24121114) (13221115) (33221113) (22321114)
            (42321112) (11421115) (31421113) (51421111) (14112115) (34112113) (23212114)
            (43212112) (12312115) (32312113) (52312111) (21412114) (41412112) (25121113)
            (14221114) (34221112) (23321113) (43321111) (12421114) (32421112) (21521113)
            (41521111) (15112114) (24212113) (13312114) (33312112) (22412113) (42412111)
            (11512114) (31512112) (15221113) (24321112) (13421113) (33421111) (22521112)
            (16112113) (25212112) (14312113) (34312111) (23412112) (12512113) (32512111)
            (21612112) (21131116) (41131114) (61131112) (31122115) (51122113) (21113116)
            (41113114) (61113112) (22131115) (42131113) (11231116) (31231114) (51231112)
            (12122116) (32122114) (52122112) (21222115) (41222113) (61222111) (22113115)
            (42113113) (11213116) (31213114) (51213112) (23131114) (43131112) (12231115)
            (32231113) (52231111) (21331114) (41331112) (13122115) (33122113) (22222114)
            (42222112) (11322115) (31322113) (51322111) (23113114) (43113112) (12213115)
            (32213113) (52213111) (21313114) (41313112) (24131113) (13231114) (33231112)
            (22331113) (42331111) (11431114) (31431112) (14122114) (34122112) (23222113)
            (43222111) (12322114) (32322112) (21422113) (41422111) (24113113) (13213114)
            (33213112) (22313113) (42313111) (11413114) (31413112) (25131112) (14231113)
            (34231111) (23331112) (12431113) (32431111) (15122113) (24222112) (13322113)
            (33322111) (22422112) (11522113) (31522111) (25113112) (14213113) (34213111)
            (23313112) (12413113) (32413111) (21513112) (15231112) (24331111) (13431112)
            (16122112) (25222111) (14322112) (23422111) (12522112) (15213112) (24313111)
            (13413112) (22513111) (11613112) (21141115) (41141113) (61141111) (11132116)
            (31132114) (51132112) (21123115) (41123113) (61123111) (11114116) (31114114)
            (51114112) (22141114) (42141112) (11241115) (31241113) (51241111) (12132115)
            (32132113) (52132111) (21232114) (41232112) (22123114) (42123112) (11223115)
            (31223113) (51223111) (12114115) (32114113) (52114111) (21214114) (41214112)
            (23141113) (43141111) (12241114) (32241112) (21341113) (41341111) (13132114)
            (33132112) (22232113) (42232111) (11332114) (31332112) (23123113) (43123111)
            (12223114) (32223112) (21323113) (41323111) (13114114) (33114112) (22214113)
            (42214111) (11314114) (31314112) (24141112) (13241113) (33241111) (22341112)
            (14132113) (34132111) (23232112) (12332113) (32332111) (21432112) (24123112)
            (13223113) (33223111) (22323112) (11423113) (31423111) (14114113) (34114111)
            (23214112) (12314113) (32314111) (21414112) (25141111) (14241112) (23341111)
            (15132112) (24232111) (13332112) (22432111) (25123111) (14223112) (23323111)
            (12423112) (21523111) (15114112) (24214111) (13314112) (22414111) (11514112)
            (15241111) (16132111) (14332111) (15223111) (13423111) (16114111) (14314111)
            (12514111) (21151114) (41151112) (11142115) (31142113) (51142111) (21133114)
            (41133112) (11124115) (31124113) (51124111) (21115114) (41115112) (22151113)
            (42151111) (11251114) (31251112) (12142114) (32142112) (21242113) (41242111)
            (22133113) (42133111) (11233114) (31233112) (12124114) (32124112) (21224113)
            (41224111) (22115113) (42115111) (11215114) (31215112) (23151112) (12251113)
            (32251111) (13142113) (33142111) (22242112) (11342113) (31342111) (23133112)
            (12233113) (32233111) (21333112) (13124113) (33124111) (22224112) (11324113)
            (31324111) (23115112) (12215113) (32215111) (21315112) (24151111) (13251112)
            (14142112) (23242111) (12342112) (24133111) (13233112) (22333111) (11433112)
            (14124112) (23224111) (12324112) (21424111) (24115111) (13215112) (22315111)
            (11415112) (14251111) (15142111) (13342111) (14233111) (12433111) (15124111)
            (13324111) (11524111) (14215111) (12415111) (21161113) (41161111) (11152114)
            (31152112) (21143113) (41143111) (11134114) (31134112) (21125113) (41125111)
            (11116114) (31116112) (22161112) (12152113) (32152111) (21252112) (22143112)
            (11243113) (31243111) (12134113) (32134111) (21234112) (22125112) (11225113)
            (31225111) (12116113) (32116111) (21216112) (23161111) (13152112) (22252111)
            (23143111) (12243112) (21343111) (13134112) (22234111) (11334112) (23125111)
            (12225112) (21325111) (13116112) (22216111) (11316112) (14152111) (13243111)
            (14134111) (12334111) (13225111) (11425111) (14116111) (12316111) (41111215)
            (61111213) (21211126) (41211124) (61211122) (22111216) (42111214) (31211215)
            (51211213) (22211125) (42211123) (11311126) (31311124) (51311122) (23111215)
            (43111213) (12211216) (32211214) (52211212) (21311215) (41311213) (61311211)
            (23211124) (43211122) (12311125) (32311123) (52311121) (21411124) (41411122)
            (24111214) (13211215) (33211213) (22311214) (42311212) (11411215) (31411213)
            (51411211) (24211123) (13311124) (33311122) (22411123) (42411121) (11511124)
            (31511122) (25111213) (14211214) (34211212) (23311213) (43311211) (12411214)
            (32411212) (21511213) (41511211) (25211122) (14311123) (34311121) (23411122)
            (12511123) (32511121) (21611122) (15211213) (24311212) (13411213) (33411211)
            (22511212) (11611213) (31611211) (31121125) (51121123) (21112126) (41112124)
            (61112122) (21121216) (41121214) (61121212) (31112215) (51112213) (12121126)
            (32121124) (52121122) (21221125) (41221123) (61221121) (22112125) (42112123)
            (11212126) (22121215) (42121213) (11221216) (31221214) (51221212) (12112216)
            (32112214) (52112212) (21212215) (41212213) (61212211) (13121125) (33121123)
            (22221124) (42221122) (11321125) (31321123) (51321121) (23112124) (43112122)
            (12212125) (23121214) (43121212) (12221215) (32221213) (52221211) (21321214)
            (41321212) (13112215) (33112213) (22212214) (42212212) (11312215) (31312213)
            (51312211) (14121124) (34121122) (23221123) (43221121) (12321124) (32321122)
            (21421123) (41421121) (24112123) (13212124) (24121213) (13221214) (33221212)
            (11412124) (22321213) (42321211) (11421214) (31421212) (14112214) (34112212)
            (23212213) (43212211) (12312214) (32312212) (21412213) (41412211) (15121123)
            (24221122) (13321123) (33321121) (22421122) (11521123) (31521121) (25112122)
            (14212123) (25121212) (14221213) (34221211) (12412123) (23321212) (12421213)
            (32421211) (21521212) (15112213) (24212212) (13312213) (33312211) (22412212)
            (11512213) (31512211) (16121122) (25221121) (14321122) (23421121) (12521122)
            (15212122) (15221212) (13412122) (24321211) (13421212) (11612122) (22521211)
            (16112212) (25212211) (14312212) (23412211) (12512212) (21612211) (11131126)
            (31131124) (51131122) (21122125) (41122123) (61122121) (21131215) (41131213)
            (61131211) (11113126) (31113124) (51113122) (11122216) (31122214) (51122212)
            (21113215) (41113213) (61113211) (12131125) (32131123) (52131121) (21231124)
            (41231122) (22122124) (42122122) (11222125) (22131214) (42131212) (11231215)
            (31231213) (51231211) (12113125) (32113123) (52113121) (12122215) (32122213)
            (52122211) (21222214) (41222212) (22113214) (42113212) (11213215) (31213213)
            (51213211) (13131124) (33131122) (22231123) (42231121) (11331124) (31331122)
            (23122123) (43122121) (12222124) (23131213) (43131211) (12231214) (32231212)
            (21331213) (41331211) (13113124) (33113122) (13122214) (33122212) (11313124)
            (22222213) (42222211) (11322214) (31322212) (23113213) (43113211) (12213214)
            (32213212) (21313213) (41313211) (14131123) (34131121) (23231122) (12331123)
            (32331121) (21431122) (24122122) (13222123) (24131212) (13231213) (33231211)
            (11422123) (22331212) (11431213) (31431211) (14113123) (34113121) (14122213)
            (34122211) (12313123) (23222212) (12322213) (32322211) (21422212) (24113212)
            (13213213) (33213211) (22313212) (11413213) (31413211) (15131122) (24231121)
            (13331122) (22431121) (25122121) (14222122) (25131211) (14231212) (12422122)
            (23331211) (12431212) (15113122) (15122212) (13313122) (24222211) (13322212)
            (11513122) (22422211) (11522212) (25113211) (14213212) (23313211) (12413212)
            (21513211) (16131121) (14331121) (15222121) (15231211) (13422121) (13431211)
            (16113121) (16122211) (14313121) (14322211) (12513121) (12522211) (15213211)
            (13413211) (11613211) (11141125) (31141123) (51141121) (21132124) (41132122)
            (21141214) (41141212) (11123125) (31123123) (51123121) (11132215) (31132213)
            (51132211) (21114124) (41114122) (21123214) (41123212) (11114215) (31114213)
            (51114211) (12141124) (32141122) (21241123) (41241121) (22132123) (42132121)
            (11232124) (22141213) (42141211) (11241214) (31241212) (12123124) (32123122)
            (12132214) (32132212) (21232213) (41232211) (22114123) (42114121) (11214124)
            (22123213) (42123211) (11223214) (31223212) (12114214) (32114212) (21214213)
            (41214211) (13141123) (33141121) (22241122) (11341123) (31341121) (23132122)
            (12232123) (23141212) (12241213) (32241211) (21341212) (13123123) (33123121)
            (13132213) (33132211) (11323123) (22232212) (11332213) (31332211) (23114122)
            (12214123) (23123212) (12223213) (32223211) (21323212) (13114213) (33114211)
            (22214212) (11314213) (31314211) (14141122) (23241121) (12341122) (24132121)
            (13232122) (24141211) (13241212) (11432122) (22341211) (14123122) (14132212)
            (12323122) (23232211) (12332212) (21432211) (24114121) (13214122) (24123211)
            (13223212) (11414122) (22323211) (11423212) (14114212) (23214211) (12314212)
            (21414211) (15141121) (13341121) (14232121) (14241211) (12432121) (15123121)
            (15132211) (13323121) (13332211) (11523121) (14214121) (14223211) (12414121)
            (12423211) (15114211) (13314211) (11514211) (11151124) (31151122) (21142123)
            (41142121) (21151213) (41151211) (11133124) (31133122) (11142214) (31142212)
            (21124123) (41124121) (21133213) (41133211) (11115124) (31115122) (11124214)
            (31124212) (21115213) (41115211) (12151123) (32151121) (21251122) (22142122)
            (11242123) (22151212) (11251213) (31251211) (12133123) (32133121) (12142213)
            (32142211) (21242212) (22124122) (11224123) (22133212) (11233213) (31233211)
            (12115123) (32115121) (12124213) (32124211) (21224212) (22115212) (11215213)
            (31215211) (13151122) (22251121) (23142121) (12242122) (23151211) (12251212)
            (13133122) (13142212) (11333122) (22242211) (11342212) (23124121) (12224122)
            (23133211) (12233212) (21333211) (13115122) (13124212) (11315122) (22224211)
            (11324212) (23115211) (12215212) (21315211) (14151121) (13242121) (13251211)
            (14133121) (14142211) (12333121) (12342211) (13224121) (13233211) (11424121)
            (11433211) (14115121) (14124211) (12315121) (12324211) (13215211) (11415211)
            (11161123) (31161121) (21152122) (21161212) (11143123) (31143121) (11152213)
            (31152211) (21134122) (21143212) (11125123) (31125121) (11134213) (31134211)
            (21116122) (21125212) (12161122) (22152121) (11252122) (22161211) (12143122)
            (12152212) (21252211) (22134121) (11234122) (22143211) (11243212) (12125122)
            (12134212) (21234211) (22116121) (11216122) (22125211) (11225212) (13161121)
            (12252121) (13143121) (13152211) (11343121) (12234121) (12243211) (13125121)
            (13134211) (11325121) (11334211) (12216121) (12225211) (31111225) (51111223)
            (21111316) (41111314) (61111312) (31211134) (51211132) (12111226) (32111224)
            (52111222) (21211225) (41211223) (61211221) (22111315) (42111313) (11211316)
            (31211314) (51211312) (12211135) (32211133) (52211131) (21311134) (41311132)
            (13111225) (33111223) (22211224) (42211222) (11311225) (31311223) (51311221)
            (23111314) (43111312) (12211315) (32211313) (52211311) (21311314) (41311312)
            (13211134) (33211132) (22311133) (42311131) (11411134) (31411132) (14111224)
            (34111222) (23211223) (43211221) (12311224) (32311222) (21411223) (41411221)
            (24111313) (13211314) (33211312) (22311313) (42311311) (11411314) (31411312)
            (14211133) (34211131) (23311132) (12411133) (32411131) (21511132) (15111223)
            (24211222) (13311223) (33311221) (22411222) (11511223) (31511221) (25111312)
            (14211313) (34211311) (23311312) (12411313) (32411311) (21511312) (15211132)
            (24311131) (13411132) (22511131) (11611132) (16111222) (25211221) (14311222)
            (23411221) (12511222) (21611221) (15211312) (24311311) (13411312) (22511311)
            (11611312) (21121135) (41121133) (61121131) (11112136) (31112134) (51112132)
            (11121226) (31121224) (51121222) (21112225) (41112223) (61112221) (21121315)
            (41121313) (61121311) (11112316) (31112314) (51112312) (22121134) (42121132)
            (11221135) (31221133) (51221131) (12112135) (32112133) (52112131) (12121225)
            (32121223) (52121221) (21221224) (41221222) (22112224) (42112222) (11212225)
            (22121314) (42121312) (11221315) (31221313) (51221311) (12112315) (32112313)
            (52112311) (21212314) (41212312) (23121133) (43121131) (12221134) (32221132)
            (21321133) (41321131) (13112134) (33112132) (13121224) (33121222) (11312134)
            (22221223) (42221221) (11321224) (31321222) (23112223) (43112221) (12212224)
            (23121313) (43121311) (12221314) (32221312) (21321313) (41321311) (13112314)
            (33112312) (22212313) (42212311) (11312314) (31312312) (24121132) (13221133)
            (33221131) (22321132) (11421133) (31421131) (14112133) (34112131) (14121223)
            (34121221) (12312133) (23221222) (12321223) (32321221) (21421222) (24112222)
            (13212223) (24121312) (13221313) (33221311) (11412223) (22321312) (11421313)
            (31421311) (14112313) (34112311) (23212312) (12312313) (32312311) (21412312)
            (25121131) (14221132) (23321131) (12421132) (21521131) (15112132) (15121222)
            (13312132) (24221221) (13321222) (11512132) (22421221) (11521222) (25112221)
            (14212222) (25121311) (14221312) (12412222) (23321311) (12421312) (21521311)
            (15112312) (24212311) (13312312) (22412311) (11512312) (15221131) (13421131)
            (16112131) (16121221) (14312131) (14321221) (12512131) (12521221) (15212221)
            (15221311) (13412221) (13421311) (11612221) (16112311) (14312311) (12512311)
            (21131134) (41131132) (11122135) (31122133) (51122131) (11131225) (31131223)
            (51131221) (21113134) (41113132) (21122224) (41122222) (21131314) (41131312)
            (11113225) (31113223) (51113221) (11122315) (31122313) (51122311) (21113314)
            (41113312) (22131133) (42131131) (11231134) (31231132) (12122134) (32122132)
            (12131224) (32131222) (21231223) (41231221) (22113133) (42113131) (11213134)
            (22122223) (42122221) (11222224) (22131313) (42131311) (11231314) (31231312)
            (12113224) (32113222) (12122314) (32122312) (21222313) (41222311) (22113313)
            (42113311) (11213314) (31213312) (23131132) (12231133) (32231131) (21331132)
            (13122133) (33122131) (13131223) (33131221) (11322133) (22231222) (11331223)
            (31331221) (23113132) (12213133) (23122222) (12222223) (23131312) (12231313)
            (32231311) (21331312) (13113223) (33113221) (13122313) (33122311) (11313223)
            (22222312) (11322313) (31322311) (23113312) (12213313) (32213311) (21313312)
            (24131131) (13231132) (22331131) (11431132) (14122132) (14131222) (12322132)
            (23231221) (12331222) (21431221) (24113131) (13213132) (24122221) (13222222)
            (24131311) (11413132) (13231312) (11422222) (22331311) (11431312) (14113222)
            (14122312) (12313222) (23222311) (12322312) (21422311) (24113311) (13213312)
            (22313311) (11413312) (14231131) (12431131) (15122131) (15131221) (13322131)
            (13331221) (11522131) (14213131) (14222221) (12413131) (14231311) (12422221)
            (12431311) (15113221) (15122311) (13313221) (13322311) (11513221) (11522311)
            (14213311) (12413311) (21141133) (41141131) (11132134) (31132132) (11141224)
            (31141222) (21123133) (41123131) (21132223) (41132221) (21141313) (41141311)
            (11114134) (31114132) (11123224) (31123222) (11132314) (31132312) (21114223)
            (41114221) (21123313) (41123311) (11114314) (31114312) (22141132) (11241133)
            (31241131) (12132133) (32132131) (12141223) (32141221) (21241222) (22123132)
            (11223133) (22132222) (11232223) (22141312) (11241313) (31241311) (12114133)
            (32114131) (12123223) (32123221) (12132313) (32132311) (21232312) (22114222)
            (11214223) (22123312) (11223313) (31223311) (12114313) (32114311) (21214312)
            (23141131) (12241132) (21341131) (13132132) (13141222) (11332132) (22241221)
            (11341222) (23123131) (12223132) (23132221) (12232222) (23141311) (12241312)
            (21341311) (13114132) (13123222) (11314132) (13132312) (11323222) (22232311)
            (11332312) (23114221) (12214222) (23123311) (12223312) (21323311) (13114312)
            (22214311) (11314312) (13241131) (14132131) (14141221) (12332131) (12341221)
            (13223131) (13232221) (11423131) (13241311) (11432221) (14114131) (14123221)
            (12314131) (14132311) (12323221) (12332311) (13214221) (13223311) (11414221)
            (11423311) (14114311) (12314311) (21151132) (11142133) (31142131) (11151223)
            (31151221) (21133132) (21142222) (21151312) (11124133) (31124131) (11133223)
            (31133221) (11142313) (31142311) (21115132) (21124222) (21133312) (11115223)
            (31115221) (11124313) (31124311) (22151131) (11251132) (12142132) (12151222)
            (21251221) (22133131) (11233132) (22142221) (11242222) (22151311) (11251312)
            (12124132) (12133222) (12142312) (21242311) (22115131) (11215132) (22124221)
            (11224222) (22133311) (11233312) (12115222) (12124312) (21224311) (12251131)
            (13142131) (13151221) (11342131) (12233131) (12242221) (12251311) (13124131)
            (13133221) (11324131) (13142311) (11333221) (11342311) (12215131) (12224221)
            (12233311) (13115221) (13124311) (11315221) (11324311) (21161131) (11152132)
            (11161222) (21143131) (21152221) (21161311) (11134132) (11143222) (11152312)
            (21125131) (21134221) (21143311) (11116132) (11125222) (11134312) (12152131)
            (12161221) (11243131) (11252221) (12134131) (12143221) (12152311) (11225131)
            (11234221) (11243311) (12116131) (12125221) (12134311) (21111235) (41111233)
            (61111231) (11111326) (31111324) (51111322) (21111415) (41111413) (61111411)
            (21211144) (41211142) (22111234) (42111232) (11211235) (31211233) (51211231)
            (12111325) (32111323) (52111321) (21211324) (41211322) (22111414) (42111412)
            (11211415) (31211413) (51211411) (22211143) (42211141) (11311144) (31311142)
            (23111233) (43111231) (12211234) (32211232) (21311233) (41311231) (13111324)
            (33111322) (22211323) (42211321) (11311324) (31311322) (23111413) (43111411)
            (12211414) (32211412) (21311413) (41311411) (23211142) (12311143) (32311141)
            (21411142) (24111232) (13211233) (33211231) (22311232) (11411233) (31411231)
            (14111323) (34111321) (23211322) (12311323) (32311321) (21411322) (24111412)
            (13211413) (33211411) (22311412) (11411413) (31411411) (24211141) (13311142)
            (22411141) (11511142) (25111231) (14211232) (23311231) (12411232) (21511231)
            (15111322) (24211321) (13311322) (22411321) (11511322) (25111411) (14211412)
            (23311411) (12411412) (21511411) (14311141) (12511141) (15211231) (13411231)
            (11611231) (16111321) (14311321) (12511321) (15211411) (13411411) (11611411)
            (31121143) (51121141) (21112144) (41112142) (21121234) (41121232) (11112235)
            (31112233) (51112231) (11121325) (31121323) (51121321) (21112324) (41112322)
            (21121414) (41121412) (11112415) (31112413) (51112411) (12121144) (32121142)
            (21221143) (41221141) (22112143) (42112141) (11212144) (22121233) (42121231)
            (11221234) (31221232) (12112234) (32112232) (12121324) (32121322) (21221323)
            (41221321) (22112323) (42112321) (11212324) (22121413) (42121411) (11221414)
            (31221412) (12112414) (32112412) (21212413) (41212411) (13121143) (33121141)
            (22221142) (11321143) (31321141) (23112142) (12212143) (23121232) (12221233)
            (32221231) (21321232) (13112233) (33112231) (13121323) (33121321) (11312233)
            (22221322) (11321323) (31321321) (23112322) (12212323) (23121412) (12221413)
            (32221411) (21321412) (13112413) (33112411) (22212412) (11312413) (31312411)
            (14121142) (23221141) (12321142) (21421141) (24112141) (13212142) (24121231)
            (13221232) (11412142) (22321231) (11421232) (14112232) (14121322) (12312232)
            (23221321) (12321322) (21421321) (24112321) (13212322) (24121411) (13221412)
            (11412322) (22321411) (11421412) (14112412) (23212411) (12312412) (21412411)
            (15121141) (13321141) (11521141) (14212141) (14221231) (12412141) (12421231)
            (15112231) (15121321) (13312231) (13321321) (11512231) (11521321) (14212321)
            (14221411) (12412321) (12421411) (15112411) (13312411) (11512411) (11131144)
            (31131142) (21122143) (41122141) (21131233) (41131231) (11113144) (31113142)
            (11122234) (31122232) (11131324) (31131322) (21113233) (41113231) (21122323)
            (41122321) (21131413) (41131411) (11113324) (31113322) (11122414) (31122412)
            (21113413) (41113411) (12131143) (32131141) (21231142) (22122142) (11222143)
            (22131232) (11231233) (31231231) (12113143) (32113141) (12122233) (32122231)
            (12131323) (32131321) (21231322) (22113232) (11213233) (22122322) (11222323)
            (22131412) (11231413) (31231411) (12113323) (32113321) (12122413) (32122411)
            (21222412) (22113412) (11213413) (31213411) (13131142) (22231141) (11331142)
            (23122141) (12222142) (23131231) (12231232) (21331231) (13113142) (13122232)
            (11313142) (13131322) (11322232) (22231321) (11331322) (23113231) (12213232)
            (23122321) (12222322) (23131411) (12231412) (21331411) (13113322) (13122412)
            (11313322) (22222411) (11322412) (23113411) (12213412) (21313411) (14131141)
            (12331141) (13222141) (13231231) (11422141) (11431231) (14113141) (14122231)
            (12313141) (14131321) (12322231) (12331321) (13213231) (13222321) (11413231)
            (13231411) (11422321) (11431411) (14113321) (14122411) (12313321) (12322411)
            (13213411) (11413411) (11141143) (31141141) (21132142) (21141232) (11123143)
            (31123141) (11132233) (31132231) (11141323) (31141321) (21114142) (21123232)
            (21132322) (21141412) (11114233) (31114231) (11123323) (31123321) (11132413)
            (31132411) (21114322) (21123412) (12141142) (21241141) (22132141) (11232142)
            (22141231) (11241232) (12123142) (12132232) (12141322) (21241321) (22114141)
            (11214142) (22123231) (11223232) (22132321) (11232322) (22141411) (11241412)
            (12114232) (12123322) (12132412) (21232411) (22114321) (11214322) (22123411)
            (11223412) (13141141) (11341141) (12232141) (12241231) (13123141) (13132231)
            (11323141) (13141321) (11332231) (11341321) (12214141) (12223231) (12232321)
            (12241411) (13114231) (13123321) (11314231) (13132411) (11323321) (11332411)
            (12214321) (12223411) (11151142) (21142141) (21151231) (11133142) (11142232)
            (11151322) (21124141) (21133231) (21142321) (21151411) (11115142) (11124232)
            (11133322) (11142412) (21115231) (21124321) (21133411) (12151141) (11242141)
            (11251231) (12133141) (12142231) (12151321) (11224141) (11233231) (11242321)
            (11251411) (12115141) (12124231) (12133321) (12142411) (11215231) (11224321)
            (11233411) (11161141) (11143141) (11152231) (11161321) (11125141) (11134231)
            (11143321) (11152411) (11111245) (31111243) (51111241) (21111334) (41111332)
            (11111425) (31111423) (51111421) (21111514) (41111512) (31211152) (12111244)
            (32111242) (21211243) (41211241) (22111333) (42111331) (11211334) (31211332)
            (12111424) (32111422) (21211423) (41211421) (22111513) (42111511) (11211514)
            (31211512) (12211153) (32211151) (21311152) (13111243) (33111241) (22211242)
            (11311243) (31311241) (23111332) (12211333) (32211331) (21311332) (13111423)
            (33111421) (22211422) (11311423) (31311421) (23111512) (12211513) (32211511)
            (21311512) (13211152) (22311151) (11411152) (14111242) (23211241) (12311242)
            (21411241) (24111331) (13211332) (22311331) (11411332) (14111422) (23211421)
            (12311422) (21411421) (24111511) (13211512) (22311511) (11411512) (14211151)
            (12411151) (15111241) (13311241) (11511241) (14211331) (12411331) (15111421)
            (13311421) (11511421) (14211511) (12411511) (21121153) (41121151) (11112154)
            (31112152) (11121244) (31121242) (21112243) (41112241) (21121333) (41121331)
            (11112334) (31112332) (11121424) (31121422) (21112423) (41112421) (21121513)
            (41121511) (11112514) (31112512) (22121152) (11221153) (31221151) (12112153)
            (32112151) (12121243) (32121241) (21221242) (22112242) (11212243) (22121332)
            (11221333) (31221331) (12112333) (32112331) (12121423) (32121421) (21221422)
            (22112422) (11212423) (22121512) (11221513) (31221511) (12112513) (32112511)
            (21212512) (23121151) (12221152) (21321151) (13112152) (13121242) (11312152)
            (22221241) (11321242) (23112241) (12212242) (23121331) (12221332) (21321331)
            (13112332) (13121422) (11312332) (22221421) (11321422) (23112421) (12212422)
            (23121511) (12221512) (21321511) (13112512) (22212511) (11312512) (13221151)
            (11421151) (14112151) (14121241) (12312151) (12321241) (13212241) (13221331)
            (11412241) (11421331) (14112331) (14121421) (12312331) (12321421) (13212421)
            (13221511) (11412421) (11421511) (14112511) (12312511) (21131152) (11122153)
            (31122151) (11131243) (31131241) (21113152) (21122242) (21131332) (11113243)
            (31113241) (11122333) (31122331) (11131423) (31131421) (21113332) (21122422)
            (21131512) (11113423) (31113421) (11122513) (31122511) (22131151) (11231152)
            (12122152) (12131242) (21231241) (22113151) (11213152) (22122241) (11222242)
            (22131331) (11231332) (12113242) (12122332) (12131422) (21231421) (22113331)
            (11213332) (22122421) (11222422) (22131511) (11231512) (12113422) (12122512)
            (21222511) (12231151) (13122151) (13131241) (11322151) (11331241) (12213151)
            (12222241) (12231331) (13113241) (13122331) (11313241) (13131421) (11322331)
            (11331421) (12213331) (12222421) (12231511) (13113421) (13122511) (11313421)
            (11322511) (21141151) (11132152) (11141242) (21123151) (21132241) (21141331)
            (11114152) (11123242) (11132332) (11141422) (21114241) (21123331) (21132421)
            (21141511) (11114332) (11123422) (11132512) (11241151) (12132151) (12141241)
            (11223151) (11232241) (11241331) (12114151) (12123241) (12132331) (12141421)
            (11214241) (11223331) (11232421) (11241511) (12114331) (12123421) (12132511)
            (11142151) (11151241) (11124151) (11133241) (11142331) (11151421) (11115241)
            (11124331) (11133421) (11142511) (21111253) (41111251) (11111344) (31111342)
            (21111433) (41111431) (11111524) (31111522) (21111613) (41111611) (21211162)
            (22111252) (11211253) (31211251) (12111343) (32111341) (21211342) (22111432)
            (11211433) (31211431) (12111523) (32111521) (21211522) (22111612) (11211613)
            (31211611) (22211161) (11311162) (23111251) (12211252) (21311251) (13111342)
            (22211341) (11311342) (23111431) (12211432) (21311431) (13111522) (22211521)
            (11311522) (23111611) (12211612) (21311611) (12311161) (13211251) (11411251)
            (14111341) (12311341) (13211431) (11411431) (14111521) (12311521) (13211611)
            (11411611) (31121161) (21112162) (21121252) (11112253) (31112251) (11121343)
            (31121341) (21112342) (21121432) (11112433) (31112431) (11121523) (31121521)
            (21112522) (21121612) (12121162) (21221161) (22112161) (11212162) (22121251)
            (11221252) (12112252) (12121342) (21221341) (22112341) (11212342) (22121431)
            (11221432) (12112432) (12121522) (21221521) (22112521) (11212522) (22121611)
            (11221612) (13121161) (11321161) (12212161) (12221251) (13112251) (13121341)
            (11312251) (11321341) (12212341) (12221431) (13112431) (13121521) (11312431)
            (11321521) (12212521) (12221611) (11131162) (21122161) (21131251) (11113162)
        ]
    ] def

    /parity [
        (1001) (0101) (1100) (0011) (1010) (0110) (1111) (0000)
    ] def

    % Derive the bits for each row
    /rowbits r array def
    0 1 r 1 sub {
        /i exch def
        /p i r 1 sub ne {parity i get} {(0000)} ifelse def
        /ccrow ccs i 8 mul 8 getinterval def
        /scrow [
            0 2 7 {ccrow exch 2 getinterval aload pop exch 49 mul add} for
        ] def
        /sbs [
            10 1 1
            0 1 3 {
                /j exch def
                patterns p j get 48 sub get scrow j get get {48 sub} forall
            } for
            4 1
        ] def
        mark
        1 sbs {1 index 0 eq {{1}} {{0}} ifelse repeat} forall
        counttomark 1 sub array astore exch pop exch pop
        rowbits i 3 -1 roll put
    } for

    % Populate the bitmap
    /pixs [
        81 sepheight mul {1} repeat
        0 1 r 2 sub {
            /i exch def
            rowheight {rowbits i get aload pop} repeat
            sepheight {10 {0} repeat 70 {1} repeat 0} repeat
        } for
        rowheight {rowbits r 1 sub get aload pop} repeat
        81 sepheight mul {1} repeat
    ] def

    % Return the arguments
    <<
    /ren //renmatrix
    /pixs pixs
    /pixx 81
    /pixy pixs length 81 idiv
    /height pixs length 81 idiv 72 div
    /width 81 72 div
    /opt options
    >>

    dontdraw not //renmatrix if

    end

} bind def
/code49 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER code49--

% --BEGIN ENCODER channelcode--
% --DESC: Channel Code
% --EXAM: 3493
% --EXOP: height=0.5 includetext 
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/channelcode {

    20 dict begin                 % Confine variables to local scope

    /options exch def       % We are given an option string
    /barcode exch def       % We are given a barcode string

    /dontdraw false def
    /shortfinder false def
    /includetext false def
    /includecheck false def
    /height 1 def
    
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /height height cvr def
  
    /barlen barcode length def

    barlen 2 ge barlen 7 le and {
        /channels barlen 1 add def
    } if

    % Determine finder
    shortfinder {
        /finder [ 1 1 1 1 1 ] def
    } {
        /finder [ 1 1 1 1 1 1 1 1 1 ] def
    } ifelse

    /nextb {
        dup
        dup s exch get exch
        dup b exch 1 sub get exch
        dup s exch 1 sub get exch
        b exch 2 sub get exch
        add add add 4 gt {1} {2} ifelse
        1 index chan 2 add lt {
            dup 1 4 index {
                b 3 index 2 index put
                3 index exch sub 1 add 4 index 3 index 1 add nexts
            } for
        } {
            dup 3 index le {
                b 2 index 4 index put
                value target eq {
                    /out [ 
                        3 1 10 {dup s exch get exch b exch get} for
                    ] 0 chan 2 mul getinterval def 
                } if
                /value value 1 add def
            } if
        } ifelse 
        pop pop pop pop
    } bind def

    /nexts {
        dup chan 2 add lt {1} {1 index} ifelse 1 3 index {
            s 2 index 2 index put
            2 index exch sub 1 add 3 index 2 index nextb
        } for
        pop pop pop
    } bind def

    /encode {
        /chan exch def
        /target exch def
        /value 0 def
        /out -1 def
        /b [ 1 1 1 0 0 0 0 0 0 0 0 ] def
        /s [ 0 1 1 0 0 0 0 0 0 0 0 ] def
        chan dup 3 nexts
        out
    } bind def

    % Encode the main data
    /data barcode cvi channels encode def

    % Determine check data
    /check [] def
    includecheck {
        /mod23 [
            [] [] []
            [ 13 12  4  9  3  1 ]
            [ 13  2 12  3 18 16  4  1 ]
            [ 11 16 17  8 20  4 10  2  5  1 ]
            [  1  4 16 18  3 12  2  8  9 13  6  1 ]
            [ 20 16 22 13 15 12  5  4  8  9 21  3  7  1 ]
            [  2  6 18  8  1  3  9  4 12 13 16  2  6 18  8  1 ]
        ] channels get def
        0
        0 1 data length 1 sub {
            dup data exch get 1 sub exch mod23 exch get mul add
        } for
        23 mod 3 encode /check exch def
    } if

    % Construct the symbol
    /sbs [
        finder aload pop
        data aload pop
        check aload pop
    ] def

    % Create the human readable text
    /txt barlen array def
    0 1 barlen 1 sub {
        /i exch def
        txt i [barcode i 1 getinterval 0 0 () 0] put
    } for

    % Return the arguments
    <<
    /ren //renlinear
    /sbs sbs
    /bhs [sbs length 1 add 2 idiv {height} repeat]
    /bbs [sbs length 1 add 2 idiv {0} repeat]
    /txt txt
    /textxalign (center)
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/channelcode dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER channelcode--

% --BEGIN ENCODER flattermarken--
% --DESC: Flattermarken
% --EXAM: 12345
% --EXOP: inkspread=-0.25
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/flattermarken {

    20 dict begin                 % Confine variable to local scope

    /options exch def       % We are given an option string
    /barcode exch def       % We are given a barcode string

    /dontdraw false def
    /includetext false def   % Enable/disable text
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /height 0.3 def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /height height cvr def

    % Create an array containing the character mappings
    /encs
    [ (0018) (0117) (0216) (0315) (0414) (0513) (0612) (0711) (0810)
      (0900)
    ] def

    % Create a string of the available characters
    /barchars (1234567890) def

    /barlen barcode length def            % Length of the code

    /sbs barlen 4 mul string def
    /txt barlen array def

    0 1 barlen 1 sub {
        /i exch def
        % Lookup the encoding for the each barcode character
        barcode i 1 getinterval barchars exch search
        pop                                 % Discard true leaving pre
        length /indx exch def               % indx is the length of pre
        pop pop                             % Discard seek and post
        /enc encs indx get def              % Get the indxth encoding
        sbs i 4 mul enc putinterval         % Put encoded digit into sbs
        txt i [barcode i 1 getinterval i 9 mul textyoffset textfont textsize] put
    } for

    % Return the arguments
    <<
    /ren //renlinear
    /sbs [sbs {48 sub} forall]
    /bhs [sbs length 1 add 2 idiv {height} repeat]
    /bbs [sbs length 1 add 2 idiv {0} repeat]
    /txt txt
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/flattermarken dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER flattermarken--

% --BEGIN ENCODER raw--
% --DESC: Raw bar space succession for custom symbologies 
% --EXAM: 331132131313411122131311333213114131131221323
% --EXOP: height=0.5
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/raw {

    20 dict begin                  % Confine variables to local scope

    /options exch def        % We are given an option string
    /sbs exch def        % We are given a barcode string

    /dontdraw false def
    /height 1 def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /height height cvr def

    % Return the arguments
    <<
    /ren //renlinear
    /sbs [sbs {48 sub} forall]
    /bhs [sbs length 1 add 2 idiv {height} repeat]
    /bbs [sbs length 1 add 2 idiv {0} repeat]
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/raw dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER raw--

% --BEGIN ENCODER daft--
% --DESC: Raw DAFT succession for custom 4 state symbologies
% --EXAM: FATDAFTDAD
% --EXOP:
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/daft {

    20 dict begin

    /options exch def              % We are given an option string
    /barcode exch def              % We are given a barcode string

    /dontdraw false def
    /height 0.175 def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /height height cvr def

    /barlen barcode length def

    /bbs barlen array def
    /bhs barlen array def
    0 1 barlen 1 sub {
        /i exch def
        /enc barcode i 1 getinterval def
        enc (D) eq {
            bbs i 0 height mul 8 div put
            bhs i 5 height mul 8 div put
        } if
        enc (A) eq {
            bbs i 3 height mul 8 div put
            bhs i 5 height mul 8 div put
        } if
        enc (F) eq {
            bbs i 0 height mul 8 div put
            bhs i 8 height mul 8 div put
        } if
        enc (T) eq {
            bbs i 3 height mul 8 div put
            bhs i 2 height mul 8 div put
        } if
    } for

    % Return the arguments
    <<
    /ren //renlinear
    /bbs bbs
    /bhs bhs
    /sbs [bhs length 1 sub {1.44 1.872} repeat 1.44]
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/daft dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER daft--

% --BEGIN ENCODER symbol--
% --DESC: Miscellaneous symbols
% --EXAM: fima
% --EXOP: backgroundcolor=DD000011
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
begin
/symbol {

    20 dict begin            % Confine variables to local scope

    /options exch def  % We are given an option string
    /barcode exch def  % We are given a barcode string

    /dontdraw false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    barcode (fima) eq {
        /sbs [2.25 2.25 2.25 11.25 2.25 11.25 2.25 2.25 2.25] def
        /bhs [.625 .625 .625 .625 .625] def
        /bbs [0 0 0 0 0] def
    } if

    barcode (fimb) eq {
        /sbs [2.25 6.75 2.25 2.25 2.25 6.25 2.25 2.25 2.25 6.75 2.25] def
        /bhs [.625 .625 .625 .625 .625 .625] def
        /bbs [0 0 0 0 0 0] def
    } if

    barcode (fimc) eq {
        /sbs [2.25 2.25 2.25 6.75 2.25 6.75 2.25 6.75 2.25 2.25 2.25] def
        /bhs [.625 .625 .625 .625 .625 .625] def
        /bbs [0 0 0 0 0 0] def
    } if
    
    barcode (fimd) eq {
        /sbs [2.25 2.25 2.25 2.25 2.25 6.75 2.25 6.75 2.25 2.25 2.25 2.25 2.25] def
        /bhs [.625 .625 .625 .625 .625 .625 .625] def
        /bbs [0 0 0 0 0 0 0] def
    } if
    
    % Return the arguments
    <<
    /ren //renlinear
    /sbs sbs
    /bhs bhs
    /bbs bbs
    /opt options
    >>

    dontdraw not //renlinear if

    end

} bind def
/symbol dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER symbol--

% --BEGIN ENCODER pdf417--
% --DESC: PDF417
% --EXAM: This is PDF417
% --EXOP:
% --RNDR: renmatrix
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/pdf417 {

    20 dict begin

    /options exch def
    /barcode exch def

    /dontdraw false def
    /compact false def
    /eclevel -1 def
    /columns 0 def
    /rows 0 def
    /rowmult 3 def
    /ccc false def
    /raw false def
    /parse false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /eclevel eclevel cvi def
    /columns columns cvi def
    /rows rows cvi def
    /rowmult rowmult cvr def

    % Parse ordinals of the form ^NNN to ASCII
    parse {
        /msg barcode length string def
        /j 0 def
        barcode
        { % loop
            (^) search {
                dup msg exch j exch putinterval
                length j add 1 add /j exch def
                pop
                dup 0 3 getinterval cvi msg exch j 1 sub exch put
                dup length 3 sub 3 exch getinterval
            } {
                dup msg exch j exch putinterval
                length j add /j exch def
                /barcode msg 0 j getinterval def
                exit
            } ifelse 
        } loop
    } if

    % Convert input into array of codewords
    raw {
        /datcws barcode length array def
        /i 0 def /j 0 def
        { % loop
            i barcode length eq {exit} if
            /cw barcode i 1 add 3 getinterval cvi def
            datcws j cw put
            /i i 4 add def
            /j j 1 add def
        } loop
        /datcws datcws 0 j getinterval def
    } {  % Simple autoencoder from input to codewords using byte mode
        /barlen barcode length def
        barlen 6 mod 0 eq {
            /datcws barlen 6 idiv 5 mul 1 add array def
            datcws 0 924 put
        } {
            /datcws barlen 6 idiv 5 mul barlen 6 mod add 1 add array def
            datcws 0 901 put 
        } ifelse

        % Rebase groups of 6 bytes splitting into 3 byte chunks
        0 1 barlen 6 idiv 1 sub {
            /i exch def
            /msbs [ barcode i 6 mul 3 getinterval {} forall ] def
            /mscs [
                msbs aload pop exch 256 mul add exch 65536 mul add 
                3 {dup 900 mod exch 900 idiv} repeat 
            ] def
            /lsbs [barcode i 6 mul 3 add 3 getinterval {} forall] def
            /lscs [
                lsbs aload pop exch 256 mul add exch 65536 mul add
                3 {dup 900 mod exch 900 idiv} repeat
            ] def
            /cws 5 array def
            lscs 0 get mscs 0 get 316 mul add
            cws 4 2 index 900 mod put
            900 idiv lscs 1 get add mscs 0 get 641 mul add mscs 1 get 316 mul add
            cws 3 2 index 900 mod put 
            900 idiv lscs 2 get add mscs 0 get 20 mul add mscs 1 get 641 mul add mscs 2 get 316 mul add 
            cws 2 2 index 900 mod put
            900 idiv lscs 3 get add mscs 1 get 20 mul add mscs 2 get 641 mul add
            cws 1 2 index 900 mod put
            900 idiv mscs 2 get 20 mul add
            cws 0 3 -1 roll 900 mod put
            datcws i 5 mul 1 add cws putinterval 
        } for

        % Add the remaining bytes to the end of the codewords
        /rem barlen 6 mod def
        rem 0 ne {
            datcws datcws length rem sub 
            [ barcode barlen rem sub rem getinterval {} forall ] 
            putinterval
        } if

        ccc {/datcws [920 datcws aload pop] def} if

    } ifelse

    % Determine the error correction level if unspecified
    /m datcws length def
    eclevel -1 eq {
        m  40 le              {/eclevel 2 def} if
        m  41 ge m 160 le and {/eclevel 3 def} if
        m 161 ge m 320 le and {/eclevel 4 def} if
        m 321 ge              {/eclevel 5 def} if
    } if

    % Reduce the error level so that it does not cause an excessive number of codewords
    /maxeclevel 928 1 sub m sub ln 2 ln div cvi 1 sub def
    eclevel maxeclevel gt {/eclevel maxeclevel def} if
    /k 2 eclevel 1 add exp cvi def

    % To determine size of matrix, number of columns if given by user...
    columns 0 eq {/columns m k add 3 div sqrt round cvi def} if
    columns 1 ge columns 30 le and {/c columns def} if

    % ... and rows is greater of those required and that given by user within limits
    /r m k add 1 add columns div ceiling cvi def  % Required
    r rows lt rows 90 le and {/r rows def} if
    r 3 lt {/r 3 def} if

    % Opportunistically raise the error level if a better fit to the matrix is possible
    /maxeclevel c r mul 1 sub m sub ln 2 ln div cvi 1 sub 8 2 copy gt {exch} if pop def
    maxeclevel eclevel gt {
      /eclevel maxeclevel def
      /k 2 eclevel 1 add exp cvi def
    } if

    % Create codewords array with one extra working space element and add padding
    /n c r mul k sub def
    /cws c r mul 1 add array def
    cws 0 n put
    cws 1 datcws putinterval
    cws m 1 add [ n m sub 1 sub {900} repeat ] putinterval
    cws n [ k {0} repeat 0 ] putinterval

    % Calculate the log and anti-log tables
    /rsalog [ 1 928 {dup 3 mul 929 mod} repeat ] def
    /rslog 929 array def
    1 1 928 {dup rsalog exch get exch rslog 3 1 roll put} for

    % Function to calculate the product in the field
    /rsprod {
        2 copy 0 ne exch 0 ne and {
            rslog exch get exch rslog exch get add 928 mod rsalog exch get
        } {
            pop pop 0
        } ifelse
    } bind def

    % Generate the coefficients
    /coeffs [ 1 k {0} repeat ] def
    1 1 k {
        /i exch def 
        coeffs i coeffs i 1 sub get put
        i 1 sub -1 1 {
            /j exch def
            coeffs j coeffs j 1 sub get coeffs j get rsalog i get rsprod add 929 mod put
        } for 
        coeffs 0 coeffs 0 get rsalog i get rsprod put
    } for
    /coeffs coeffs 0 coeffs length 1 sub getinterval def
    coeffs length 1 sub -2 0 {coeffs exch 2 copy get 929 exch sub put} for

    % Derive the error codewords
    0 1 n 1 sub {
        /t exch cws exch get cws n get add 929 mod def
        0 1 k 1 sub {
            /j exch def
            cws n j add cws n j add 1 add get 929 t coeffs k j sub 1 sub get mul 929 mod sub add 929 mod put
        } for
    } for
    n 1 n k add { dup cws exch 929 cws 5 -1 roll get sub 929 mod put } for

    % Trim the working space from the end of the codewords
    /cws cws 0 cws length 1 sub getinterval def

    % Base 10 encoding of the bar space successions for the codewords in each cluster
    /clusters [
        [
            120256 125680 128380 120032 125560 128318 108736 119920 108640  86080 108592  86048
            110016 120560 125820 109792 120440 125758  88256 109680  88160  89536 110320 120700
             89312 110200 120638  89200 110140  89840 110460  89720 110398  89980 128506 119520
            125304 128190 107712 119408 125244 107616 119352  84032 107568 119324  84000 107544
             83984 108256 119672 125374  85184 108144 119612  85088 108088 119582  85040 108060
             85728 108408 119742  85616 108348  85560 108318  85880 108478  85820  85790 107200
            119152 125116 107104 119096 125086  83008 107056 119068  82976 107032  82960  82952
             83648 107376 119228  83552 107320 119198  83504 107292  83480  83468  83824 107452
             83768 107422  83740  83900 106848 118968 125022  82496 106800 118940  82464 106776
            118926  82448 106764  82440 106758  82784 106936 119006  82736 106908  82712 106894
             82700  82694 106974  82830  82240 106672 118876  82208 106648 118862  82192 106636
             82184 106630  82180  82352  82328  82316  82080 118830 106572 106566  82050 117472
            124280 127678 103616 117360 124220 103520 117304 124190  75840 103472  75808 104160
            117624 124350  76992 104048 117564  76896 103992  76848  76824  77536 104312 117694
             77424 104252  77368  77340  77688 104382  77628  77758 121536 126320 128700 121440
            126264 128670 111680 121392 126236 111648 121368 126222 111632 121356 103104 117104
            124092 112320 103008 117048 124062 112224 121656 126366  93248  74784 102936 117006
             93216 112152  93200  75456 103280 117180  93888  75360 103224 117150  93792 112440
            121758  93744  75288  93720  75632 103356  94064  75576 103326  94008 112542  93980
             75708  94140  75678  94110 121184 126136 128606 111168 121136 126108 111136 121112
            126094 111120 121100 111112 111108 102752 116920 123998 111456 102704 116892  91712
             74272 121244 116878  91680  74256 102668  91664 111372 102662  74244  74592 102840
            116958  92000  74544 102812  91952 111516 102798  91928  74508  74502  74680 102878
             92088  74652  92060  74638  92046  92126 110912 121008 126044 110880 120984 126030
            110864 120972 110856 120966 110852 110850  74048 102576 116828  90944  74016 102552
            116814  90912 111000 121038  90896  73992 102534  90888 110982  90884  74160 102620
             91056  74136 102606  91032 111054  91020  74118  91014  91100  91086 110752 120920
            125998 110736 120908 110728 120902 110724 110722  73888 102488 116782  90528  73872
            102476  90512 110796 102470  90504  73860  90500  73858  73944  90584  90572  90566
            120876 120870 110658 102444  73800  90312  90308  90306 101056 116080 123580 100960
            116024  70720 100912 115996  70688 100888  70672  70664  71360 101232 116156  71264
            101176 116126  71216 101148  71192  71180  71536 101308  71480 101278  71452  71612
             71582 118112 124600 127838 105024 118064 124572 104992 118040 124558 104976 118028
            104968 118022 100704 115896 123486 105312 100656 115868  79424  70176 118172 115854
             79392 105240 100620  79376  70152  79368  70496 100792 115934  79712  70448 118238
             79664 105372 100750  79640  70412  79628  70584 100830  79800  70556  79772  70542
             70622  79838 122176 126640 128860 122144 126616 128846 122128 126604 122120 126598
            122116 104768 117936 124508 113472 104736 126684 124494 113440 122264 126670 113424
            104712 117894 113416 122246 104706  69952 100528 115804  78656  69920 100504 115790
             96064  78624 104856 117966  96032 113560 122318 100486  96016  78600 104838  96008
             69890  70064 100572  78768  70040 100558  96176  78744 104910  96152 113614  70022
             78726  70108  78812  70094  96220  78798 122016 126552 128814 122000 126540 121992
            126534 121988 121986 104608 117848 124462 113056 104592 126574 113040 122060 117830
            113032 104580 113028 104578 113026  69792 100440 115758  78240  69776 100428  95136
             78224 104652 100422  95120 113100  69764  95112  78212  69762  78210  69848 100462
             78296  69836  95192  78284  69830  95180  78278  69870  95214 121936 126508 121928
            126502 121924 121922 104528 117804 112848 104520 117798 112840 121958 112836 104514
            112834  69712 100396  78032  69704 100390  94672  78024 104550  94664 112870  69698
             94660  78018  94658  78060  94700  94694 126486 121890 117782 104484 104482  69672
             77928  94440  69666  77922  99680  68160  99632  68128  99608 115342  68112  99596
             68104  99590  68448  99768 115422  68400  99740  68376  99726  68364  68358  68536
             99806  68508  68494  68574 101696 116400 123740 101664 116376 101648 116364 101640
            116358 101636  67904  99504 115292  72512  67872 116444 115278  72480 101784 116430
             72464  67848  99462  72456 101766  67842  68016  99548  72624  67992  99534  72600
            101838  72588  67974  68060  72668  68046  72654 118432 124760 127918 118416 124748
            118408 124742 118404 118402 101536 116312 105888 101520 116300 105872 118476 116294
            105864 101508 105860 101506 105858  67744  99416  72096  67728 116334  80800  72080
            101580  99398  80784 105932  67716  80776  72068  67714  72066  67800  99438  72152
             67788  80856  72140  67782  80844  72134  67822  72174  80878 126800 128940 126792
            128934 126788 126786 118352 124716 122576 126828 124710 122568 126822 122564 118338
            122562 101456 116268 105680 101448 116262 114128 105672 118374 114120 122598 101442
            114116 105666 114114  67664  99372  71888  67656  99366  80336  71880 101478  97232
             80328 105702  67650  97224 114150  71874  97220  67692  71916  67686  80364  71910
             97260  80358  97254 126760 128918 126756 126754 118312 124694 122472 126774 122468
            118306 122466 101416 116246 105576 101412 113896 105572 101410 113892 105570 113890
             67624  99350  71784 101430  80104  71780  67618  96744  80100  71778  96740  80098
             96738  71798  96758 126738 122420 122418 105524 113780 113778  71732  79988  96500
             96498  66880  66848  98968  66832  66824  66820  66992  66968  66956  66950  67036
             67022 100000  99984 115532  99976 115526  99972  99970  66720  98904  69024 100056
             98892  69008 100044  69000 100038  68996  66690  68994  66776  98926  69080 100078
             69068  66758  69062  66798  69102 116560 116552 116548 116546  99920 102096 116588
            115494 102088 116582 102084  99906 102082  66640  68816  66632  98854  73168  68808
             66628  73160  68804  66626  73156  68802  66668  68844  66662  73196  68838  73190
            124840 124836 124834 116520 118632 124854 118628 116514 118626  99880 115478 101992
            116534 106216 101988  99874 106212 101986 106210  66600  98838  68712  99894  72936
             68708  66594  81384  72932  68706  81380  72930  66614  68726  72950  81398 128980
            128978 124820 126900 124818 126898 116500 118580 116498 122740 118578 122738  99860
            101940  99858 106100 101938 114420
        ] [
            128352 129720 125504 128304 129692 125472 128280 129678 125456 128268 125448 128262
            125444 125792 128440 129758 120384 125744 128412 120352 125720 128398 120336 125708
            120328 125702 120324 120672 125880 128478 110144 120624 125852 110112 120600 125838
            110096 120588 110088 120582 110084 110432 120760 125918  89664 110384 120732  89632
            110360 120718  89616 110348  89608 110342  89952 110520 120798  89904 110492  89880
            110478  89868  90040 110558  90012  89998 125248 128176 129628 125216 128152 129614
            125200 128140 125192 128134 125188 125186 119616 125360 128220 119584 125336 128206
            119568 125324 119560 125318 119556 119554 108352 119728 125404 108320 119704 125390
            108304 119692 108296 119686 108292 108290  85824 108464 119772  85792 108440 119758
             85776 108428  85768 108422  85764  85936 108508  85912 108494  85900  85894  85980
             85966 125088 128088 129582 125072 128076 125064 128070 125060 125058 119200 125144
            128110 119184 125132 119176 125126 119172 119170 107424 119256 125166 107408 119244
            107400 119238 107396 107394  83872 107480 119278  83856 107468  83848 107462  83844
             83842  83928 107502  83916  83910  83950 125008 128044 125000 128038 124996 124994
            118992 125036 118984 125030 118980 118978 106960 119020 106952 119014 106948 106946
             82896 106988  82888 106982  82884  82882  82924  82918 124968 128022 124964 124962
            118888 124982 118884 118882 106728 118902 106724 106722  82408 106742  82404  82402
            124948 124946 118836 118834 106612 106610 124224 127664 129372 124192 127640 129358
            124176 127628 124168 127622 124164 124162 117568 124336 127708 117536 124312 127694
            117520 124300 117512 124294 117508 117506 104256 117680 124380 104224 117656 124366
            104208 117644 104200 117638 104196 104194  77632 104368 117724  77600 104344 117710
             77584 104332  77576 104326  77572  77744 104412  77720 104398  77708  77702  77788
             77774 128672 129880  93168 128656 129868  92664 128648 129862  92412 128644 128642
            124064 127576 129326 126368 124048 129902 126352 128716 127558 126344 124036 126340
            124034 126338 117152 124120 127598 121760 117136 124108 121744 126412 124102 121736
            117124 121732 117122 121730 103328 117208 124142 112544 103312 117196 112528 121804
            117190 112520 103300 112516 103298 112514  75680 103384 117230  94112  75664 103372
             94096 112588 103366  94088  75652  94084  75650  75736 103406  94168  75724  94156
             75718  94150  75758 128592 129836  91640 128584 129830  91388 128580  91262 128578
            123984 127532 126160 123976 127526 126152 128614 126148 123970 126146 116944 124012
            121296 116936 124006 121288 126182 121284 116930 121282 102864 116972 111568 102856
            116966 111560 121318 111556 102850 111554  74704 102892  92112  74696 102886  92104
            111590  92100  74690  92098  74732  92140  74726  92134 128552 129814  90876 128548
             90750 128546 123944 127510 126056 128566 126052 123938 126050 116840 123958 121064
            116836 121060 116834 121058 102632 116854 111080 121078 111076 102626 111074  74216
            102646  91112  74212  91108  74210  91106  74230  91126 128532  90494 128530 123924
            126004 123922 126002 116788 120948 116786 120946 102516 110836 102514 110834  73972
             90612  73970  90610 128522 123914 125978 116762 120890 102458 110714 123552 127320
            129198 123536 127308 123528 127302 123524 123522 116128 123608 127342 116112 123596
            116104 123590 116100 116098 101280 116184 123630 101264 116172 101256 116166 101252
            101250  71584 101336 116206  71568 101324  71560 101318  71556  71554  71640 101358
             71628  71622  71662 127824 129452  79352 127816 129446  79100 127812  78974 127810
            123472 127276 124624 123464 127270 124616 127846 124612 123458 124610 115920 123500
            118224 115912 123494 118216 124646 118212 115906 118210 100816 115948 105424 100808
            115942 105416 118246 105412 100802 105410  70608 100844  79824  70600 100838  79816
            105446  79812  70594  79810  70636  79852  70630  79846 129960  95728 113404 129956
             95480 113278 129954  95356  95294 127784 129430  78588 128872 129974  95996  78462
            128868 127778  95870 128866 123432 127254 124520 123428 126696 128886 123426 126692
            124514 126690 115816 123446 117992 115812 122344 117988 115810 122340 117986 122338
            100584 115830 104936 100580 113640 104932 100578 113636 104930 113634  70120 100598
             78824  70116  96232  78820  70114  96228  78818  96226  70134  78838 129940  94968
            113022 129938  94844  94782 127764  78206 128820 127762  95102 128818 123412 124468
            123410 126580 124466 126578 115764 117876 115762 122100 117874 122098 100468 104692
            100466 113140 104690 113138  69876  78324  69874  95220  78322  95218 129930  94588
             94526 127754 128794 123402 124442 126522 115738 117818 121978 100410 104570 112890
             69754  78074  94714  94398 123216 127148 123208 127142 123204 123202 115408 123244
            115400 123238 115396 115394  99792 115436  99784 115430  99780  99778  68560  99820
             68552  99814  68548  68546  68588  68582 127400 129238  72444 127396  72318 127394
            123176 127126 123752 123172 123748 123170 123746 115304 123190 116456 115300 116452
            115298 116450  99560 115318 101864  99556 101860  99554 101858  68072  99574  72680
             68068  72676  68066  72674  68086  72694 129492  80632 105854 129490  80508  80446
            127380  72062 127924 127378  80766 127922 123156 123700 123154 124788 123698 124786
            115252 116340 115250 118516 116338 118514  99444 101620  99442 105972 101618 105970
             67828  72180  67826  80884  72178  80882  97008 114044  96888 113982  96828  96798
            129482  80252 130010  97148  80190  97086 127370 127898 128954 123146 123674 124730
            126842 115226 116282 118394 122618  99386 101498 105722 114170  67706  71930  80378
             96632 113854  96572  96542  80062  96702  96444  96414  96350 123048 123044 123042
            115048 123062 115044 115042  99048 115062  99044  99042  67048  99062  67044  67042
             67062 127188  68990 127186 123028 123316 123026 123314 114996 115572 114994 115570
             98932 100084  98930 100082  66804  69108  66802  69106 129258  73084  73022 127178
            127450 123018 123290 123834 114970 115514 116602  98874  99962 102138  66682  68858
             73210  81272 106174  81212  81182  72894  81342  97648 114364  97592 114334  97564
             97550  81084  97724  81054  97694  97464 114270  97436  97422  80990  97502  97372
             97358  97326 114868 114866  98676  98674  66292  66290 123098 114842 115130  98618
             99194  66170  67322  69310  73404  73374  81592 106334  81564  81550  73310  81630
             97968 114524  97944 114510  97932  97926  81500  98012  81486  97998  97880 114478
             97868  97862  81454  97902  97836  97830  69470  73564  73550  81752 106414  81740
             81734  73518  81774  81708  81702
        ] [
            109536 120312  86976 109040 120060  86496 108792 119934  86256 108668  86136 129744
             89056 110072 129736  88560 109820 129732  88312 109694 129730  88188 128464 129772
             89592 128456 129766  89340 128452  89214 128450 125904 128492 125896 128486 125892
            125890 120784 125932 120776 125926 120772 120770 110544 120812 110536 120806 110532
             84928 108016 119548  84448 107768 119422  84208 107644  84088 107582  84028 129640
             85488 108284 129636  85240 108158 129634  85116  85054 128232 129654  85756 128228
             85630 128226 125416 128246 125412 125410 119784 125430 119780 119778 108520 119798
            108516 108514  83424 107256 119166  83184 107132  83064 107070  83004  82974 129588
             83704 107390 129586  83580  83518 128116  83838 128114 125172 125170 119284 119282
            107508 107506  82672 106876  82552 106814  82492  82462 129562  82812  82750 128058
            125050 119034  82296 106686  82236  82206  82366  82108  82078  76736 103920 117500
             76256 103672 117374  76016 103548  75896 103486  75836 129384  77296 104188 129380
             77048 104062 129378  76924  76862 127720 129398  77564 127716  77438 127714 124392
            127734 124388 124386 117736 124406 117732 117730 104424 117750 104420 104418 112096
            121592 126334  92608 111856 121468  92384 111736 121406  92272 111676  92216 111646
             92188  75232 103160 117118  93664  74992 103036  93424 112252 102974  93304  74812
             93244  74782  93214 129332  75512 103294 129908 129330  93944  75388 129906  93820
             75326  93758 127604  75646 128756 127602  94078 128754 124148 126452 124146 126450
            117236 121844 117234 121842 103412 103410  91584 111344 121212  91360 111224 121150
             91248 111164  91192 111134  91164  91150  74480 102780  91888  74360 102718  91768
            111422  91708  74270  91678 129306  74620 129850  92028  74558  91966 127546 128634
            124026 126202 116986 121338 102906  90848 110968 121022  90736 110908  90680 110878
             90652  90638  74104 102590  91000  74044  90940  74014  90910  74174  91070  90480
            110780  90424 110750  90396  90382  73916  90556  73886  90526  90296 110686  90268
             90254  73822  90334  90204  90190  71136 101112 116094  70896 100988  70776 100926
             70716  70686 129204  71416 101246 129202  71292  71230 127348  71550 127346 123636
            123634 116212 116210 101364 101362  79296 105200 118140  79072 105080 118078  78960
            105020  78904 104990  78876  78862  70384 100732  79600  70264 100670  79480 105278
             79420  70174  79390 129178  70524 129466  79740  70462  79678 127290 127866 123514
            124666 115962 118266 100858 113376 122232 126654  95424 113264 122172  95328 113208
            122142  95280 113180  95256 113166  95244  78560 104824 117950  95968  78448 104764
             95856 113468 104734  95800  78364  95772  78350  95758  70008 100542  78712  69948
             96120  78652  69918  96060  78622  96030  70078  78782  96190  94912 113008 122044
             94816 112952 122014  94768 112924  94744 112910  94732  94726  78192 104636  95088
             78136 104606  95032 113054  95004  78094  94990  69820  78268  69790  95164  78238
             95134  94560 112824 121950  94512 112796  94488 112782  94476  94470  78008 104542
             94648  77980  94620  77966  94606  69726  78046  94686  94384 112732  94360 112718
             94348  94342  77916  94428  77902  94414  94296 112686  94284  94278  77870  94318
             94252  94246  68336  99708  68216  99646  68156  68126  68476  68414 127162 123258
            115450  99834  72416 101752 116414  72304 101692  72248 101662  72220  72206  67960
             99518  72568  67900  72508  67870  72478  68030  72638  80576 105840 118460  80480
            105784 118430  80432 105756  80408 105742  80396  80390  72048 101564  80752  71992
            101534  80696  71964  80668  71950  80654  67772  72124  67742  80828  72094  80798
            114016 122552 126814  96832 113968 122524  96800 113944 122510  96784 113932  96776
            113926  96772  80224 105656 118366  97120  80176 105628  97072 114076 105614  97048
             80140  97036  80134  97030  71864 101470  80312  71836  97208  80284  71822  97180
             80270  97166  67678  71902  80350  97246  96576 113840 122460  96544 113816 122446
             96528 113804  96520 113798  96516  96514  80048 105564  96688  80024 105550  96664
            113870  96652  80006  96646  71772  80092  71758  96732  80078  96718  96416 113752
            122414  96400 113740  96392 113734  96388  96386  79960 105518  96472  79948  96460
             79942  96454  71726  79982  96494  96336 113708  96328 113702  96324  96322  79916
             96364  79910  96358  96296 113686  96292  96290  79894  96310  66936  99006  66876
             66846  67006  68976 100028  68920  99998  68892  68878  66748  69052  66718  69022
             73056 102072 116574  73008 102044  72984 102030  72972  72966  68792  99934  73144
             68764  73116  68750  73102  66654  68830  73182  81216 106160 118620  81184 106136
            118606  81168 106124  81160 106118  81156  81154  72880 101980  81328  72856 101966
             81304 106190  81292  72838  81286  68700  72924  68686  81372  72910  81358 114336
            122712 126894 114320 122700 114312 122694 114308 114306  81056 106072 118574  97696
             81040 106060  97680 114380 106054  97672  81028  97668  81026  97666  72792 101934
             81112  72780  97752  81100  72774  97740  81094  97734  68654  72814  81134  97774
            114256 122668 114248 122662 114244 114242  80976 106028  97488  80968 106022  97480
            114278  97476  80962  97474  72748  81004  72742  97516  80998  97510 114216 122646
            114212 114210  80936 106006  97384  80932  97380  80930  97378  72726  80950  97398
            114196 114194  80916  97332  80914  97330  66236  66206  67256  99166  67228  67214
             66142  67294  69296 100188  69272 100174  69260  69254  67164  69340  67150  69326
             73376 102232 116654  73360 102220  73352 102214  73348  73346  69208 100142  73432
            102254  73420  69190  73414  67118  69230  73454 106320 118700 106312 118694 106308
            106306  73296 102188  81616 106348 102182  81608  73284  81604  73282  81602  69164
             73324  69158  81644  73318  81638 122792 126934 122788 122786 106280 118678 114536
            106276 114532 106274 114530  73256 102166  81512  73252  98024  81508  73250  98020
             81506  98018  69142  73270  81526  98038 122772 122770 106260 114484 106258 114482
             73236  81460  73234  97908  81458  97906 122762 106250 114458  73226  81434  97850
             66396  66382  67416  99246  67404  67398  66350  67438  69456 100268  69448 100262
             69444  69442  67372  69484  67366  69478 102312 116694 102308 102306  69416 100246
             73576 102326  73572  69410  73570  67350  69430  73590 118740 118738 102292 106420
            102290 106418  69396  73524  69394  81780  73522  81778 118730 102282 106394  69386
             73498  81722  66476  66470  67496  99286  67492  67490  66454  67510 100308 100306
             67476  69556  67474  69554 116714
        ]
    ] def

    % Return the 17 bits for a codeword in a given cluster
    /cwtobits {
        clusters exch get exch get /v exch def
        [ 17 {0} repeat v 2 17 string cvrs {48 sub} forall ]
        dup length 17 sub 17 getinterval
    } bind def

    % Populate bitmap for the image
    compact {
        /rwid 17 c mul 17 add 17 add 1 add def
    } {
        /rwid 17 c mul 17 add 17 add 17 add 18 add def
    } ifelse
    /pixs rwid r mul array def

   0 1 r 1 sub {
        /i exch def

        i 3 mod 0 eq {
            /lcw i 3 idiv 30 mul r 1 sub 3 idiv add def
            /rcw i 3 idiv 30 mul c add 1 sub def
        } if
        i 3 mod 1 eq {
            /lcw i 3 idiv 30 mul eclevel 3 mul add r 1 sub 3 mod add def
            /rcw i 3 idiv 30 mul r 1 sub 3 idiv add def
        } if
        i 3 mod 2 eq {
            /lcw i 3 idiv 30 mul c add 1 sub def
            /rcw i 3 idiv 30 mul eclevel 3 mul add r 1 sub 3 mod add def
        } if

        pixs rwid i mul [
            1 1 1 1 1 1 1 1 0 1 0 1 0 1 0 0 0
            lcw i 3 mod cwtobits {} forall
            cws c i mul c getinterval { i 3 mod cwtobits {} forall } forall
            compact {
                1
            } {
                rcw i 3 mod cwtobits {} forall
                1 1 1 1 1 1 1 0 1 0 0 0 1 0 1 0 0 1
            } ifelse
        ] putinterval

    } for

    % Return the arguments
    <<
    /ren //renmatrix
    /pixs pixs
    /pixx rwid
    /pixy r
    /height r 72 div rowmult mul
    /width rwid 72 div
    /opt options
    >>

    dontdraw not //renmatrix if

    end

} bind def
/pdf417 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER pdf417--

% --BEGIN ENCODER micropdf417--
% --DESC: MicroPDF417
% --EXAM: MicroPDF417
% --EXOP:
% --RNDR: renmatrix
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/micropdf417 {

    20 dict begin

    /options exch def
    /barcode exch def

    /dontdraw false def
    /columns 0 def
    /rows 0 def
    /rowmult 2 def
    /cca false def
    /ccb false def
    /raw false def
    /parse false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /columns columns cvi def
    /rows rows cvi def
    /rowmult rowmult cvr def

    cca {/raw true def} if

    % Parse ordinals of the form ^NNN to ASCII
    parse {
        /msg barcode length string def
        /j 0 def
        barcode
        { % loop
            (^) search {
                dup msg exch j exch putinterval
                length j add 1 add /j exch def
                pop
                dup 0 3 getinterval cvi msg exch j 1 sub exch put
                dup length 3 sub 3 exch getinterval
            } {
                dup msg exch j exch putinterval
                length j add /j exch def
                /barcode msg 0 j getinterval def
                exit
            } ifelse 
        } loop
    } if

    % Convert input into array of codewords
    raw {
        /datcws barcode length array def
        /i 0 def /j 0 def
        { % loop
            i barcode length eq {exit} if
            /cw barcode i 1 add 3 getinterval cvi def
            datcws j cw put
            /i i 4 add def
            /j j 1 add def
        } loop
        /datcws datcws 0 j getinterval def
    } {  % Simple autoencoder from input to codewords using byte mode
        /barlen barcode length def
        barlen 6 mod 0 eq {
            /datcws barlen 6 idiv 5 mul 1 add array def
            datcws 0 924 put
        } {
            /datcws barlen 6 idiv 5 mul barlen 6 mod add 1 add array def
            datcws 0 901 put 
        } ifelse

        % Rebase groups of 6 bytes splitting into 3 byte chunks
        0 1 barlen 6 idiv 1 sub {
            /i exch def
            /msbs [ barcode i 6 mul 3 getinterval {} forall ] def
            /mscs [
                msbs aload pop exch 256 mul add exch 65536 mul add 
                3 {dup 900 mod exch 900 idiv} repeat 
            ] def
            /lsbs [barcode i 6 mul 3 add 3 getinterval {} forall] def
            /lscs [
                lsbs aload pop exch 256 mul add exch 65536 mul add
                3 {dup 900 mod exch 900 idiv} repeat
            ] def
            /cws 5 array def
            lscs 0 get mscs 0 get 316 mul add
            cws 4 2 index 900 mod put
            900 idiv lscs 1 get add mscs 0 get 641 mul add mscs 1 get 316 mul add
            cws 3 2 index 900 mod put 
            900 idiv lscs 2 get add mscs 0 get 20 mul add mscs 1 get 641 mul add mscs 2 get 316 mul add 
            cws 2 2 index 900 mod put
            900 idiv lscs 3 get add mscs 1 get 20 mul add mscs 2 get 641 mul add
            cws 1 2 index 900 mod put
            900 idiv mscs 2 get 20 mul add
            cws 0 3 -1 roll 900 mod put
            datcws i 5 mul 1 add cws putinterval 
        } for

        % Add the remaining bytes to the end of the codewords
        /rem barlen 6 mod def
        rem 0 ne {
            datcws datcws length rem sub 
            [ barcode barlen rem sub rem getinterval {} forall ] 
            putinterval
        } if

        ccb {/datcws [920 datcws aload pop] def} if

    } ifelse

    % Basic metrics for the each symbol
    %     c  r ecw  rl rc rr
    /metrics [
        [ 1 11   7   1  0  9 ]
        [ 1 14   7   8  0  8 ]
        [ 1 17   7  36  0 36 ]
        [ 1 20   8  19  0 19 ]
        [ 1 24   8   9  0 17 ]
        [ 1 28   8  25  0 33 ]
        [ 2  8   8   1  0  1 ]
        [ 2 11   9   1  0  9 ]
        [ 2 14   9   8  0  8 ]
        [ 2 17  10  36  0 36 ]
        [ 2 20  11  19  0 19 ]
        [ 2 23  13   9  0 17 ]
        [ 2 26  15  27  0 35 ]
        [ 3  6  12   1  1  1 ]
        [ 3  8  14   7  7  7 ]
        [ 3 10  16  15 15 15 ]
        [ 3 12  18  25 25 25 ]
        [ 3 15  21  37 37 37 ]
        [ 3 20  26   1 17 33 ]
        [ 3 26  32   1  9 17 ]
        [ 3 32  38  21 29 37 ]
        [ 3 38  44  15 31 47 ]
        [ 3 44  50   1 25 49 ]
        [ 4  4   8  47 19 43 ]
        [ 4  6  12   1  1  1 ]
        [ 4  8  14   7  7  7 ]
        [ 4 10  16  15 15 15 ]
        [ 4 12  18  25 25 25 ]
        [ 4 15  21  37 37 37 ]
        [ 4 20  26   1 17 33 ]
        [ 4 26  32   1  9 17 ]
        [ 4 32  38  21 29 37 ]
        [ 4 38  44  15 31 47 ]
        [ 4 44  50   1 25 49 ]
    ] def

    % Basic metrics for the each symbol
    %     c  r ecw  rl rc rr
    /ccametrics [
        [ 2  5   4  39  0 19 ]
        [ 2  6   4   1  0 33 ]
        [ 2  7   5  32  0 12 ]
        [ 2  8   5   8  0 40 ]
        [ 2  9   6  14  0 46 ]
        [ 2 10   6  43  0 23 ]
        [ 2 12   7  20  0 52 ]
        [ 3  4   4  11 43 23 ]
        [ 3  5   5   1 33 13 ]
        [ 3  6   6   5 37 17 ]
        [ 3  7   7  15 47 27 ]
        [ 3  8   7  21  1 33 ]
        [ 4  3   4  40 20 52 ]
        [ 4  4   5  43 23  3 ]
        [ 4  5   6  46 26  6 ]
        [ 4  6   7  34 14 46 ]
        [ 4  7   8  29  9 41 ]
    ] def
    cca {/metrics ccametrics def} if

    % Select metrics of an appropriate symbol
    /urows rows def
    /ucols columns def
    /i 0 def
    { % loop
        /m metrics i get def
        /c    m 0 get def        % Columns in symbol
        /r    m 1 get def        % Rows in symbol
        /k    m 2 get def        % Error correction codewords
        /rapl m 3 get def        % Left row address pattern
        /rapc m 4 get def        % Centre row address pattern
        /rapr m 5 get def        % Right row address pattern
        /ncws r c mul k sub def  % Data codewords
        /okay true def
        datcws length ncws gt     {/okay false def} if
        urows 0 ne urows r ne and {/okay false def} if
        ucols 0 ne ucols c ne and {/okay false def} if
        okay {exit} if
        /i i 1 add def
    } loop
    /m datcws length def

    % Create codewords array with one extra working space element and add padding
    /n c r mul k sub def
    /cws c r mul 1 add array def
    cws 0 datcws putinterval
    cws m [ n m sub {900} repeat ] putinterval
    cws n [ k {0} repeat 0 ] putinterval

    % Calculate the log and anti-log tables
    /rsalog [ 1 928 {dup 3 mul 929 mod} repeat ] def
    /rslog 929 array def
    1 1 928 {dup rsalog exch get exch rslog 3 1 roll put} for

    % Function to calculate the product in the field
    /rsprod {
        2 copy 0 ne exch 0 ne and {
            rslog exch get exch rslog exch get add 928 mod rsalog exch get
        } {
            pop pop 0
        } ifelse
    } bind def

    % Generate the coefficients
    /coeffs [ 1 k {0} repeat ] def
    1 1 k {
        /i exch def 
        coeffs i coeffs i 1 sub get put
        i 1 sub -1 1 {
            /j exch def
            coeffs j coeffs j 1 sub get coeffs j get rsalog i get rsprod add 929 mod put
        } for 
        coeffs 0 coeffs 0 get rsalog i get rsprod put
    } for
    /coeffs coeffs 0 coeffs length 1 sub getinterval def
    coeffs length 1 sub -2 0 {coeffs exch 2 copy get 929 exch sub put} for

    % Derive the error codewords
    0 1 n 1 sub {
        /t exch cws exch get cws n get add 929 mod def
        0 1 k 1 sub {
            /j exch def
            cws n j add cws n j add 1 add get 929 t coeffs k j sub 1 sub get mul 929 mod sub add 929 mod put
        } for
    } for
    n 1 n k add { dup cws exch 929 cws 5 -1 roll get sub 929 mod put } for

    % Trim the working space from the end of the codewords
    /cws cws 0 cws length 1 sub getinterval def

    % Base 10 encoding of the bar space successions for the codewords in each cluster
    /clusters [
        [
            120256 125680 128380 120032 125560 128318 108736 119920 108640  86080 108592  86048
            110016 120560 125820 109792 120440 125758  88256 109680  88160  89536 110320 120700
             89312 110200 120638  89200 110140  89840 110460  89720 110398  89980 128506 119520
            125304 128190 107712 119408 125244 107616 119352  84032 107568 119324  84000 107544
             83984 108256 119672 125374  85184 108144 119612  85088 108088 119582  85040 108060
             85728 108408 119742  85616 108348  85560 108318  85880 108478  85820  85790 107200
            119152 125116 107104 119096 125086  83008 107056 119068  82976 107032  82960  82952
             83648 107376 119228  83552 107320 119198  83504 107292  83480  83468  83824 107452
             83768 107422  83740  83900 106848 118968 125022  82496 106800 118940  82464 106776
            118926  82448 106764  82440 106758  82784 106936 119006  82736 106908  82712 106894
             82700  82694 106974  82830  82240 106672 118876  82208 106648 118862  82192 106636
             82184 106630  82180  82352  82328  82316  82080 118830 106572 106566  82050 117472
            124280 127678 103616 117360 124220 103520 117304 124190  75840 103472  75808 104160
            117624 124350  76992 104048 117564  76896 103992  76848  76824  77536 104312 117694
             77424 104252  77368  77340  77688 104382  77628  77758 121536 126320 128700 121440
            126264 128670 111680 121392 126236 111648 121368 126222 111632 121356 103104 117104
            124092 112320 103008 117048 124062 112224 121656 126366  93248  74784 102936 117006
             93216 112152  93200  75456 103280 117180  93888  75360 103224 117150  93792 112440
            121758  93744  75288  93720  75632 103356  94064  75576 103326  94008 112542  93980
             75708  94140  75678  94110 121184 126136 128606 111168 121136 126108 111136 121112
            126094 111120 121100 111112 111108 102752 116920 123998 111456 102704 116892  91712
             74272 121244 116878  91680  74256 102668  91664 111372 102662  74244  74592 102840
            116958  92000  74544 102812  91952 111516 102798  91928  74508  74502  74680 102878
             92088  74652  92060  74638  92046  92126 110912 121008 126044 110880 120984 126030
            110864 120972 110856 120966 110852 110850  74048 102576 116828  90944  74016 102552
            116814  90912 111000 121038  90896  73992 102534  90888 110982  90884  74160 102620
             91056  74136 102606  91032 111054  91020  74118  91014  91100  91086 110752 120920
            125998 110736 120908 110728 120902 110724 110722  73888 102488 116782  90528  73872
            102476  90512 110796 102470  90504  73860  90500  73858  73944  90584  90572  90566
            120876 120870 110658 102444  73800  90312  90308  90306 101056 116080 123580 100960
            116024  70720 100912 115996  70688 100888  70672  70664  71360 101232 116156  71264
            101176 116126  71216 101148  71192  71180  71536 101308  71480 101278  71452  71612
             71582 118112 124600 127838 105024 118064 124572 104992 118040 124558 104976 118028
            104968 118022 100704 115896 123486 105312 100656 115868  79424  70176 118172 115854
             79392 105240 100620  79376  70152  79368  70496 100792 115934  79712  70448 118238
             79664 105372 100750  79640  70412  79628  70584 100830  79800  70556  79772  70542
             70622  79838 122176 126640 128860 122144 126616 128846 122128 126604 122120 126598
            122116 104768 117936 124508 113472 104736 126684 124494 113440 122264 126670 113424
            104712 117894 113416 122246 104706  69952 100528 115804  78656  69920 100504 115790
             96064  78624 104856 117966  96032 113560 122318 100486  96016  78600 104838  96008
             69890  70064 100572  78768  70040 100558  96176  78744 104910  96152 113614  70022
             78726  70108  78812  70094  96220  78798 122016 126552 128814 122000 126540 121992
            126534 121988 121986 104608 117848 124462 113056 104592 126574 113040 122060 117830
            113032 104580 113028 104578 113026  69792 100440 115758  78240  69776 100428  95136
             78224 104652 100422  95120 113100  69764  95112  78212  69762  78210  69848 100462
             78296  69836  95192  78284  69830  95180  78278  69870  95214 121936 126508 121928
            126502 121924 121922 104528 117804 112848 104520 117798 112840 121958 112836 104514
            112834  69712 100396  78032  69704 100390  94672  78024 104550  94664 112870  69698
             94660  78018  94658  78060  94700  94694 126486 121890 117782 104484 104482  69672
             77928  94440  69666  77922  99680  68160  99632  68128  99608 115342  68112  99596
             68104  99590  68448  99768 115422  68400  99740  68376  99726  68364  68358  68536
             99806  68508  68494  68574 101696 116400 123740 101664 116376 101648 116364 101640
            116358 101636  67904  99504 115292  72512  67872 116444 115278  72480 101784 116430
             72464  67848  99462  72456 101766  67842  68016  99548  72624  67992  99534  72600
            101838  72588  67974  68060  72668  68046  72654 118432 124760 127918 118416 124748
            118408 124742 118404 118402 101536 116312 105888 101520 116300 105872 118476 116294
            105864 101508 105860 101506 105858  67744  99416  72096  67728 116334  80800  72080
            101580  99398  80784 105932  67716  80776  72068  67714  72066  67800  99438  72152
             67788  80856  72140  67782  80844  72134  67822  72174  80878 126800 128940 126792
            128934 126788 126786 118352 124716 122576 126828 124710 122568 126822 122564 118338
            122562 101456 116268 105680 101448 116262 114128 105672 118374 114120 122598 101442
            114116 105666 114114  67664  99372  71888  67656  99366  80336  71880 101478  97232
             80328 105702  67650  97224 114150  71874  97220  67692  71916  67686  80364  71910
             97260  80358  97254 126760 128918 126756 126754 118312 124694 122472 126774 122468
            118306 122466 101416 116246 105576 101412 113896 105572 101410 113892 105570 113890
             67624  99350  71784 101430  80104  71780  67618  96744  80100  71778  96740  80098
             96738  71798  96758 126738 122420 122418 105524 113780 113778  71732  79988  96500
             96498  66880  66848  98968  66832  66824  66820  66992  66968  66956  66950  67036
             67022 100000  99984 115532  99976 115526  99972  99970  66720  98904  69024 100056
             98892  69008 100044  69000 100038  68996  66690  68994  66776  98926  69080 100078
             69068  66758  69062  66798  69102 116560 116552 116548 116546  99920 102096 116588
            115494 102088 116582 102084  99906 102082  66640  68816  66632  98854  73168  68808
             66628  73160  68804  66626  73156  68802  66668  68844  66662  73196  68838  73190
            124840 124836 124834 116520 118632 124854 118628 116514 118626  99880 115478 101992
            116534 106216 101988  99874 106212 101986 106210  66600  98838  68712  99894  72936
             68708  66594  81384  72932  68706  81380  72930  66614  68726  72950  81398 128980
            128978 124820 126900 124818 126898 116500 118580 116498 122740 118578 122738  99860
            101940  99858 106100 101938 114420
        ] [
            128352 129720 125504 128304 129692 125472 128280 129678 125456 128268 125448 128262
            125444 125792 128440 129758 120384 125744 128412 120352 125720 128398 120336 125708
            120328 125702 120324 120672 125880 128478 110144 120624 125852 110112 120600 125838
            110096 120588 110088 120582 110084 110432 120760 125918  89664 110384 120732  89632
            110360 120718  89616 110348  89608 110342  89952 110520 120798  89904 110492  89880
            110478  89868  90040 110558  90012  89998 125248 128176 129628 125216 128152 129614
            125200 128140 125192 128134 125188 125186 119616 125360 128220 119584 125336 128206
            119568 125324 119560 125318 119556 119554 108352 119728 125404 108320 119704 125390
            108304 119692 108296 119686 108292 108290  85824 108464 119772  85792 108440 119758
             85776 108428  85768 108422  85764  85936 108508  85912 108494  85900  85894  85980
             85966 125088 128088 129582 125072 128076 125064 128070 125060 125058 119200 125144
            128110 119184 125132 119176 125126 119172 119170 107424 119256 125166 107408 119244
            107400 119238 107396 107394  83872 107480 119278  83856 107468  83848 107462  83844
             83842  83928 107502  83916  83910  83950 125008 128044 125000 128038 124996 124994
            118992 125036 118984 125030 118980 118978 106960 119020 106952 119014 106948 106946
             82896 106988  82888 106982  82884  82882  82924  82918 124968 128022 124964 124962
            118888 124982 118884 118882 106728 118902 106724 106722  82408 106742  82404  82402
            124948 124946 118836 118834 106612 106610 124224 127664 129372 124192 127640 129358
            124176 127628 124168 127622 124164 124162 117568 124336 127708 117536 124312 127694
            117520 124300 117512 124294 117508 117506 104256 117680 124380 104224 117656 124366
            104208 117644 104200 117638 104196 104194  77632 104368 117724  77600 104344 117710
             77584 104332  77576 104326  77572  77744 104412  77720 104398  77708  77702  77788
             77774 128672 129880  93168 128656 129868  92664 128648 129862  92412 128644 128642
            124064 127576 129326 126368 124048 129902 126352 128716 127558 126344 124036 126340
            124034 126338 117152 124120 127598 121760 117136 124108 121744 126412 124102 121736
            117124 121732 117122 121730 103328 117208 124142 112544 103312 117196 112528 121804
            117190 112520 103300 112516 103298 112514  75680 103384 117230  94112  75664 103372
             94096 112588 103366  94088  75652  94084  75650  75736 103406  94168  75724  94156
             75718  94150  75758 128592 129836  91640 128584 129830  91388 128580  91262 128578
            123984 127532 126160 123976 127526 126152 128614 126148 123970 126146 116944 124012
            121296 116936 124006 121288 126182 121284 116930 121282 102864 116972 111568 102856
            116966 111560 121318 111556 102850 111554  74704 102892  92112  74696 102886  92104
            111590  92100  74690  92098  74732  92140  74726  92134 128552 129814  90876 128548
             90750 128546 123944 127510 126056 128566 126052 123938 126050 116840 123958 121064
            116836 121060 116834 121058 102632 116854 111080 121078 111076 102626 111074  74216
            102646  91112  74212  91108  74210  91106  74230  91126 128532  90494 128530 123924
            126004 123922 126002 116788 120948 116786 120946 102516 110836 102514 110834  73972
             90612  73970  90610 128522 123914 125978 116762 120890 102458 110714 123552 127320
            129198 123536 127308 123528 127302 123524 123522 116128 123608 127342 116112 123596
            116104 123590 116100 116098 101280 116184 123630 101264 116172 101256 116166 101252
            101250  71584 101336 116206  71568 101324  71560 101318  71556  71554  71640 101358
             71628  71622  71662 127824 129452  79352 127816 129446  79100 127812  78974 127810
            123472 127276 124624 123464 127270 124616 127846 124612 123458 124610 115920 123500
            118224 115912 123494 118216 124646 118212 115906 118210 100816 115948 105424 100808
            115942 105416 118246 105412 100802 105410  70608 100844  79824  70600 100838  79816
            105446  79812  70594  79810  70636  79852  70630  79846 129960  95728 113404 129956
             95480 113278 129954  95356  95294 127784 129430  78588 128872 129974  95996  78462
            128868 127778  95870 128866 123432 127254 124520 123428 126696 128886 123426 126692
            124514 126690 115816 123446 117992 115812 122344 117988 115810 122340 117986 122338
            100584 115830 104936 100580 113640 104932 100578 113636 104930 113634  70120 100598
             78824  70116  96232  78820  70114  96228  78818  96226  70134  78838 129940  94968
            113022 129938  94844  94782 127764  78206 128820 127762  95102 128818 123412 124468
            123410 126580 124466 126578 115764 117876 115762 122100 117874 122098 100468 104692
            100466 113140 104690 113138  69876  78324  69874  95220  78322  95218 129930  94588
             94526 127754 128794 123402 124442 126522 115738 117818 121978 100410 104570 112890
             69754  78074  94714  94398 123216 127148 123208 127142 123204 123202 115408 123244
            115400 123238 115396 115394  99792 115436  99784 115430  99780  99778  68560  99820
             68552  99814  68548  68546  68588  68582 127400 129238  72444 127396  72318 127394
            123176 127126 123752 123172 123748 123170 123746 115304 123190 116456 115300 116452
            115298 116450  99560 115318 101864  99556 101860  99554 101858  68072  99574  72680
             68068  72676  68066  72674  68086  72694 129492  80632 105854 129490  80508  80446
            127380  72062 127924 127378  80766 127922 123156 123700 123154 124788 123698 124786
            115252 116340 115250 118516 116338 118514  99444 101620  99442 105972 101618 105970
             67828  72180  67826  80884  72178  80882  97008 114044  96888 113982  96828  96798
            129482  80252 130010  97148  80190  97086 127370 127898 128954 123146 123674 124730
            126842 115226 116282 118394 122618  99386 101498 105722 114170  67706  71930  80378
             96632 113854  96572  96542  80062  96702  96444  96414  96350 123048 123044 123042
            115048 123062 115044 115042  99048 115062  99044  99042  67048  99062  67044  67042
             67062 127188  68990 127186 123028 123316 123026 123314 114996 115572 114994 115570
             98932 100084  98930 100082  66804  69108  66802  69106 129258  73084  73022 127178
            127450 123018 123290 123834 114970 115514 116602  98874  99962 102138  66682  68858
             73210  81272 106174  81212  81182  72894  81342  97648 114364  97592 114334  97564
             97550  81084  97724  81054  97694  97464 114270  97436  97422  80990  97502  97372
             97358  97326 114868 114866  98676  98674  66292  66290 123098 114842 115130  98618
             99194  66170  67322  69310  73404  73374  81592 106334  81564  81550  73310  81630
             97968 114524  97944 114510  97932  97926  81500  98012  81486  97998  97880 114478
             97868  97862  81454  97902  97836  97830  69470  73564  73550  81752 106414  81740
             81734  73518  81774  81708  81702
        ] [
            109536 120312  86976 109040 120060  86496 108792 119934  86256 108668  86136 129744
             89056 110072 129736  88560 109820 129732  88312 109694 129730  88188 128464 129772
             89592 128456 129766  89340 128452  89214 128450 125904 128492 125896 128486 125892
            125890 120784 125932 120776 125926 120772 120770 110544 120812 110536 120806 110532
             84928 108016 119548  84448 107768 119422  84208 107644  84088 107582  84028 129640
             85488 108284 129636  85240 108158 129634  85116  85054 128232 129654  85756 128228
             85630 128226 125416 128246 125412 125410 119784 125430 119780 119778 108520 119798
            108516 108514  83424 107256 119166  83184 107132  83064 107070  83004  82974 129588
             83704 107390 129586  83580  83518 128116  83838 128114 125172 125170 119284 119282
            107508 107506  82672 106876  82552 106814  82492  82462 129562  82812  82750 128058
            125050 119034  82296 106686  82236  82206  82366  82108  82078  76736 103920 117500
             76256 103672 117374  76016 103548  75896 103486  75836 129384  77296 104188 129380
             77048 104062 129378  76924  76862 127720 129398  77564 127716  77438 127714 124392
            127734 124388 124386 117736 124406 117732 117730 104424 117750 104420 104418 112096
            121592 126334  92608 111856 121468  92384 111736 121406  92272 111676  92216 111646
             92188  75232 103160 117118  93664  74992 103036  93424 112252 102974  93304  74812
             93244  74782  93214 129332  75512 103294 129908 129330  93944  75388 129906  93820
             75326  93758 127604  75646 128756 127602  94078 128754 124148 126452 124146 126450
            117236 121844 117234 121842 103412 103410  91584 111344 121212  91360 111224 121150
             91248 111164  91192 111134  91164  91150  74480 102780  91888  74360 102718  91768
            111422  91708  74270  91678 129306  74620 129850  92028  74558  91966 127546 128634
            124026 126202 116986 121338 102906  90848 110968 121022  90736 110908  90680 110878
             90652  90638  74104 102590  91000  74044  90940  74014  90910  74174  91070  90480
            110780  90424 110750  90396  90382  73916  90556  73886  90526  90296 110686  90268
             90254  73822  90334  90204  90190  71136 101112 116094  70896 100988  70776 100926
             70716  70686 129204  71416 101246 129202  71292  71230 127348  71550 127346 123636
            123634 116212 116210 101364 101362  79296 105200 118140  79072 105080 118078  78960
            105020  78904 104990  78876  78862  70384 100732  79600  70264 100670  79480 105278
             79420  70174  79390 129178  70524 129466  79740  70462  79678 127290 127866 123514
            124666 115962 118266 100858 113376 122232 126654  95424 113264 122172  95328 113208
            122142  95280 113180  95256 113166  95244  78560 104824 117950  95968  78448 104764
             95856 113468 104734  95800  78364  95772  78350  95758  70008 100542  78712  69948
             96120  78652  69918  96060  78622  96030  70078  78782  96190  94912 113008 122044
             94816 112952 122014  94768 112924  94744 112910  94732  94726  78192 104636  95088
             78136 104606  95032 113054  95004  78094  94990  69820  78268  69790  95164  78238
             95134  94560 112824 121950  94512 112796  94488 112782  94476  94470  78008 104542
             94648  77980  94620  77966  94606  69726  78046  94686  94384 112732  94360 112718
             94348  94342  77916  94428  77902  94414  94296 112686  94284  94278  77870  94318
             94252  94246  68336  99708  68216  99646  68156  68126  68476  68414 127162 123258
            115450  99834  72416 101752 116414  72304 101692  72248 101662  72220  72206  67960
             99518  72568  67900  72508  67870  72478  68030  72638  80576 105840 118460  80480
            105784 118430  80432 105756  80408 105742  80396  80390  72048 101564  80752  71992
            101534  80696  71964  80668  71950  80654  67772  72124  67742  80828  72094  80798
            114016 122552 126814  96832 113968 122524  96800 113944 122510  96784 113932  96776
            113926  96772  80224 105656 118366  97120  80176 105628  97072 114076 105614  97048
             80140  97036  80134  97030  71864 101470  80312  71836  97208  80284  71822  97180
             80270  97166  67678  71902  80350  97246  96576 113840 122460  96544 113816 122446
             96528 113804  96520 113798  96516  96514  80048 105564  96688  80024 105550  96664
            113870  96652  80006  96646  71772  80092  71758  96732  80078  96718  96416 113752
            122414  96400 113740  96392 113734  96388  96386  79960 105518  96472  79948  96460
             79942  96454  71726  79982  96494  96336 113708  96328 113702  96324  96322  79916
             96364  79910  96358  96296 113686  96292  96290  79894  96310  66936  99006  66876
             66846  67006  68976 100028  68920  99998  68892  68878  66748  69052  66718  69022
             73056 102072 116574  73008 102044  72984 102030  72972  72966  68792  99934  73144
             68764  73116  68750  73102  66654  68830  73182  81216 106160 118620  81184 106136
            118606  81168 106124  81160 106118  81156  81154  72880 101980  81328  72856 101966
             81304 106190  81292  72838  81286  68700  72924  68686  81372  72910  81358 114336
            122712 126894 114320 122700 114312 122694 114308 114306  81056 106072 118574  97696
             81040 106060  97680 114380 106054  97672  81028  97668  81026  97666  72792 101934
             81112  72780  97752  81100  72774  97740  81094  97734  68654  72814  81134  97774
            114256 122668 114248 122662 114244 114242  80976 106028  97488  80968 106022  97480
            114278  97476  80962  97474  72748  81004  72742  97516  80998  97510 114216 122646
            114212 114210  80936 106006  97384  80932  97380  80930  97378  72726  80950  97398
            114196 114194  80916  97332  80914  97330  66236  66206  67256  99166  67228  67214
             66142  67294  69296 100188  69272 100174  69260  69254  67164  69340  67150  69326
             73376 102232 116654  73360 102220  73352 102214  73348  73346  69208 100142  73432
            102254  73420  69190  73414  67118  69230  73454 106320 118700 106312 118694 106308
            106306  73296 102188  81616 106348 102182  81608  73284  81604  73282  81602  69164
             73324  69158  81644  73318  81638 122792 126934 122788 122786 106280 118678 114536
            106276 114532 106274 114530  73256 102166  81512  73252  98024  81508  73250  98020
             81506  98018  69142  73270  81526  98038 122772 122770 106260 114484 106258 114482
             73236  81460  73234  97908  81458  97906 122762 106250 114458  73226  81434  97850
             66396  66382  67416  99246  67404  67398  66350  67438  69456 100268  69448 100262
             69444  69442  67372  69484  67366  69478 102312 116694 102308 102306  69416 100246
             73576 102326  73572  69410  73570  67350  69430  73590 118740 118738 102292 106420
            102290 106418  69396  73524  69394  81780  73522  81778 118730 102282 106394  69386
             73498  81722  66476  66470  67496  99286  67492  67490  66454  67510 100308 100306
             67476  69556  67474  69554 116714
        ]
    ] def

    % Row address patterns
    /raps [
        [  % Left and right
            802 930 946 818 882 890 826 954 922 986 970 906 778
            794 786 914 978 982 980 916 948 932 934 942 940 936
            808 812 814 806 822 950 918 790 788 820 884 868 870
            878 876 872 840 856 860 862 846 844 836 838 834 866
        ] [  % Centre
            718 590 622 558 550 566 534 530 538 570 562 546 610
            626 634 762 754 758 630 628 612 614 582 578 706 738
            742 740 748 620 556 552 616 744 712 716 708 710 646
            654 652 668 664 696 688 656 720 592 600 604 732 734
        ]
    ] def

    % Return the 17 bits for a codeword in a given cluster
    /cwtobits {
        clusters exch get exch get /v exch def
        [ 17 {0} repeat v 2 17 string cvrs {48 sub} forall ]
        dup length 17 sub 17 getinterval
    } bind def

    % Return the 10 bits for a row address pattern
    /raptobits {
        raps exch get exch get /v exch def
        [ 10 {0} repeat v 2 10 string cvrs {48 sub} forall ]
        dup length 10 sub 10 getinterval
    } bind def

    % Populate bitmap for the image
    /rwid [38 55 82 99] c 1 sub get def
    c 3 eq cca and {/rwid 72 def} if
    /pixs rwid r mul array def

    0 1 r 1 sub {
        /i exch def
        /clst i rapl add 1 sub 3 mod def
        pixs rwid i mul [
            c 1 eq {
                i rapl add 1 sub 52 mod 0 raptobits aload pop
                cws i get clst cwtobits aload pop
                i rapr add 1 sub 52 mod 0 raptobits aload pop
            } if
            c 2 eq {
                i rapl add 1 sub 52 mod 0 raptobits aload pop
                cws i 2 mul get clst cwtobits aload pop
                cws i 2 mul 1 add get clst cwtobits aload pop
                i rapr add 1 sub 52 mod 0 raptobits aload pop
            } if
            c 3 eq {
                cca not {
                    i rapl add 1 sub 52 mod 0 raptobits aload pop
                } if
                cws i 3 mul get clst cwtobits aload pop
                i rapc add 1 sub 52 mod 1 raptobits aload pop
                cws i 3 mul 1 add get clst cwtobits aload pop
                cws i 3 mul 2 add get clst cwtobits aload pop
                i rapr add 1 sub 52 mod 0 raptobits aload pop
            } if
            c 4 eq {
                i rapl add 1 sub 52 mod 0 raptobits aload pop
                cws i 4 mul get clst cwtobits aload pop
                cws i 4 mul 1 add get clst cwtobits aload pop
                i rapc add 1 sub 52 mod 1 raptobits aload pop
                cws i 4 mul 2 add get clst cwtobits aload pop
                cws i 4 mul 3 add get clst cwtobits aload pop
                i rapr add 1 sub 52 mod 0 raptobits aload pop
            } if
            1
        ] putinterval
    } for

    % Return the arguments
    <<
    /ren //renmatrix
    /pixs pixs
    /pixx rwid
    /pixy r
    /height r 72 div rowmult mul
    /width rwid 72 div
    /opt options
    >>

    dontdraw not //renmatrix if

    end

} bind def
/micropdf417 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER micropdf417--

% --BEGIN ENCODER datamatrix--
% --DESC: Data Matrix
% --EXAM: This is Data Matrix!
% --EXOP: rows=32 columns=32
% --RNDR: renmatrix
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/datamatrix {

    20 dict begin

    /options exch def
    /barcode exch def

    /dontdraw false def
    /columns 0 def
    /rows 0 def
    /encoding (ascii) def
    /raw false def
    /parse false def
    /parsefnc false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /columns columns cvi def
    /rows rows cvi def

    % Parse ordinals of the form ^NNN to ASCII
    parse {
        /msg barcode length string def
        /j 0 def
        barcode
        { % loop
            (^) search {
                dup msg exch j exch putinterval
                length j add 1 add /j exch def
                pop
                dup 0 3 getinterval cvi msg exch j 1 sub exch put
                dup length 3 sub 3 exch getinterval
            } {
                dup msg exch j exch putinterval
                length j add /j exch def
                /barcode msg 0 j getinterval def
                exit
            } ifelse 
        } loop
    } if

    /barlen barcode length def

    raw {/encoding (raw) def} if

    encoding (raw) eq {
        /cws barlen array def
        /i 0 def /j 0 def
        { % loop
            i barlen eq {exit} if
            /cw barcode i 1 add 3 getinterval cvi def
            cws j cw put
            /i i 4 add def
            /j j 1 add def
        } loop
        /cws cws 0 j getinterval def
    } if

    % Special function characters
    /fn1 -1 def

    encoding (ascii) eq {
        /fncvals <<
            (FNC1) fn1
        >> def
        /msg barlen array def
        /i 0 def /j 0 def {
            i barlen eq {exit} if
            /char barcode i get def
            parsefnc char 94 eq and i barlen 4 sub lt and {
                barcode i 1 add get 94 ne {
                    /char fncvals barcode i 1 add 4 getinterval get def
                    /i i 4 add def
                } {
                    /i i 1 add def
                } ifelse
            } if
            msg j char put
            /i i 1 add def
            /j j 1 add def
        } loop
        /msg msg 0 j getinterval def
        /msglen msg length def

        /cws msglen 2 mul array def
        /i 0 def /j 0 def
        { % loop
            i msglen eq {exit} if
            /char msg i get def
            char fn1 eq {  % FNC1
                cws j 232 put
                /i i 1 add def
                /j j 1 add def
            } { char 48 ge char 57 le and i msglen 1 sub lt and {
                msg i 1 add get dup 48 ge exch 57 le and {  % Digit pair
                    cws j msg i get 48 sub 10 mul msg i 1 add get 48 sub add 130 add put
                    /i i 2 add def
                    /j j 1 add def
                } {  % Singular digit
                    cws j char 1 add put
                    /i i 1 add def
                    /j j 1 add def
                } ifelse
            } { char 127 le {  % ASCII
                cws j char 1 add put
                /i i 1 add def
                /j j 1 add def
            } {  % Extended ASCII
                cws j 235 put
                cws j 1 add char 127 sub put
                /i i 1 add def
                /j j 2 add def
            } ifelse } ifelse } ifelse
        } loop
        /cws cws 0 j getinterval def
    } if

    % Basic metrics for the each symbol
    %    rows  cols  regh  regv  rscw  rsbl
    /metrics [
        % Standard square symbols
        [  10    10     1     1     5     1 ]
        [  12    12     1     1     7     1 ]
        [  14    14     1     1    10     1 ]
        [  16    16     1     1    12     1 ]
        [  18    18     1     1    14     1 ]
        [  20    20     1     1    18     1 ] 
        [  22    22     1     1    20     1 ]
        [  24    24     1     1    24     1 ]
        [  26    26     1     1    28     1 ]
        [  32    32     2     2    36     1 ]
        [  36    36     2     2    42     1 ]
        [  40    40     2     2    48     1 ]
        [  44    44     2     2    56     1 ]
        [  48    48     2     2    68     1 ]
        [  52    52     2     2    84     2 ]
        [  64    64     4     4   112     2 ]
        [  72    72     4     4   144     4 ]
        [  80    80     4     4   192     4 ]
        [  88    88     4     4   224     4 ]
        [  96    96     4     4   272     4 ]
        [ 104   104     4     4   336     6 ]
        [ 120   120     6     6   408     6 ]
        [ 132   132     6     6   496     8 ]
        [ 144   144     6     6   620    10 ]
        % Optional rectangular symbols
        [   8    18     1     1     7     1 ]
        [   8    32     1     2    11     1 ]
        [  12    26     1     1    14     1 ]
        [  12    36     1     2    18     1 ]
        [  16    36     1     2    24     1 ]
        [  16    48     1     2    28     1 ]
    ] def

    % Select metrics of an appropriate symbol
    /urows rows def
    /ucols columns def
    /i 0 def
    { % loop
        /m metrics i get def
        /rows m 0 get def                          % Rows in symbol
        /cols m 1 get def                          % Columns in symbol
        /regh m 2 get def                          % Horizontal regions
        /regv m 3 get def                          % Vertical regions
        /rscw m 4 get def                          % Error correction codewords
        /rsbl m 5 get def                          % Error correction blocks
        /mrows rows 2 regh mul sub def             % Rows in the mapping matrix
        /mcols cols 2 regv mul sub def             % Columns in the mapping matrix
        /rrows mrows regh idiv def                 % Rows per region
        /rcols mcols regv idiv def                 % Columns per region
        /ncws mrows mcols mul 8 idiv rscw sub def  % Data codewords
        /okay true def
        cws length ncws gt           {/okay false def} if
        urows 0 ne urows rows ne and {/okay false def} if
        ucols 0 ne ucols cols ne and {/okay false def} if
        okay {exit} if
        /i i 1 add def
    } loop

    % Extend cws to ncws codewords by addition of pseudo-randomised pad characters
    cws length ncws lt {
        /datlen cws length def
        /cws [ cws {} forall ncws datlen sub {129} repeat ] def
        datlen 1 add 1 ncws 1 sub {
            /i exch def
            i 1 add 149 mul 253 mod 1 add 129 add
            dup 254 gt {254 sub} if
            cws exch i exch put
        } for
    } if

    % De-interleave the codewords into blocks
    /cwbs rsbl array def  % Array of data codeword blocks
    /ecbs rsbl array def  % Array of error correction blocks
    0 1 rsbl 1 sub {
        /i exch def
        cws length 1558 ne {
            /cwbsize cws length rsbl idiv def
        } {
            i 7 le {/cwbsize 156 def} {/cwbsize 155 def} ifelse
        } ifelse
        /cwb cwbsize array def 
        0 1 cwbsize 1 sub {
            /j exch def
            cwb j cws j rsbl mul i add get put
        } for 
        cwbs i cwb put
        ecbs i [ rscw rsbl idiv {0} repeat ] put
    } for

    % Calculate the log and anti-log tables
    /rsalog [ 1 255 { dup 2 mul dup 256 ge {301 xor} if } repeat ] def
    /rslog 256 array def
    1 1 255 {dup rsalog exch get exch rslog 3 1 roll put} for

    % Function to calculate the product in the field
    /rsprod {
        2 copy 0 ne exch 0 ne and { 
            rslog exch get exch rslog exch get add 255 mod rsalog exch get
        } {
            pop pop 0
        } ifelse
    } bind def

    % Generate the coefficients
    /coeffs [ 1 rscw rsbl idiv {0} repeat ] def
    1 1 rscw rsbl idiv {
        /i exch def 
        coeffs i coeffs i 1 sub get put
        i 1 sub -1 1 {
            /j exch def
            coeffs j coeffs j 1 sub get coeffs j get rsalog i get rsprod xor put
        } for 
        coeffs 0 coeffs 0 get rsalog i get rsprod put
    } for
    /coeffs coeffs 0 coeffs length 1 sub getinterval def

    % Calculate the error correction codewords for each block
    0 1 cwbs length 1 sub {
        /i exch def
        /cwb cwbs i get def
        /ecb ecbs i get def
        0 1 cwb length 1 sub {
            /t exch cwb exch get ecb 0 get xor def 
            ecb length 1 sub -1 0 {
                /j exch def
                /p ecb length j sub 1 sub def
                ecb p t coeffs j get rsprod put
                j 0 gt { ecb p ecb p 1 add get ecb p get xor put } if
            } for 
        } for
    } for

    % Strange fixup for 144x144 symbols
    ncws 1558 eq {
        /ecbs [ ecbs 8 2 getinterval {} forall ecbs 0 8 getinterval {} forall ] def
    } if

    % Extend codewords with the interleaved error correction codes
    /cws [ cws {} forall rscw {0} repeat ] def
    0 1 rscw 1 sub {
        /i exch def
        cws ncws i add ecbs i rsbl mod get i rsbl idiv get put
    } for

    % Place the codewords into the matrix
    /module {
        % cw row col shape
        4 -1 roll 
        (00000000) 8 string copy dup 3 -1 roll 2 8 string cvrs 
        dup length 8 exch sub exch putinterval 
        7 -1 0 {1 index exch get 48 sub exch} for pop
        11 -3 roll
        % 1 2 4 8 16 32 64 128 row col shape
        {  % Place each bit of the codeword in the shape, MSB first
            exec
            1 index 0 lt {
                exch mrows add exch
                4 mrows 4 add 8 mod sub add
            } if
            dup 0 lt {
                mcols add exch
                4 mcols 4 add 8 mod sub add exch
            } if
            exch mcols mul add
            mmat exch 5 -1 roll put
        } forall
    } bind def

    % Placement patterns
    /dmn [
        { 2 copy 2 sub exch 2 sub exch } bind  { 2 copy 1 sub exch 2 sub exch } bind
        { 2 copy 2 sub exch 1 sub exch } bind  { 2 copy 1 sub exch 1 sub exch } bind
        { 2 copy exch 1 sub exch } bind        { 2 copy 2 sub } bind
        { 2 copy 1 sub } bind                  { 2 copy } bind
    ] def
    
    /dmc1 [
        { mrows 1 sub 0 } bind  { mrows 1 sub 1 } bind
        { mrows 1 sub 2 } bind  { 0 mcols 2 sub } bind
        { 0 mcols 1 sub } bind  { 1 mcols 1 sub } bind
        { 2 mcols 1 sub } bind  { 3 mcols 1 sub } bind
    ] def
    
    /dmc2 [
        { mrows 3 sub 0 } bind  { mrows 2 sub 0 } bind
        { mrows 1 sub 0 } bind  { 0 mcols 4 sub } bind
        { 0 mcols 3 sub } bind  { 0 mcols 2 sub } bind
        { 0 mcols 1 sub } bind  { 1 mcols 1 sub } bind
    ] def
    
    /dmc3 [
        { mrows 3 sub 0 } bind  { mrows 2 sub 0 } bind
        { mrows 1 sub 0 } bind  { 0 mcols 2 sub } bind
        { 0 mcols 1 sub } bind  { 1 mcols 1 sub } bind
        { 2 mcols 1 sub } bind  { 3 mcols 1 sub } bind
    ] def
    
    /dmc4 [
        { mrows 1 sub 0 } bind  { mrows 1 sub mcols 1 sub } bind
        { 0 mcols 3 sub } bind  { 0 mcols 2 sub } bind
        { 0 mcols 1 sub } bind  { 1 mcols 3 sub } bind
        { 1 mcols 2 sub } bind  { 1 mcols 1 sub } bind
    ] def

    /mmat [ mrows mcols mul {-1} repeat ] def
    cws length 1 sub -1 0 {cws exch get} for  % Reverse cws onto stack
    4 0  % Starting row and column
    { % loop
        2 copy 0 eq exch mrows eq and {
            dmc1 module
        } if
        2 copy 0 eq exch mrows 2 sub eq and mcols 4 mod 0 ne and {
            dmc2 module
        } if
        2 copy 0 eq exch mrows 2 sub eq and mcols 8 mod 4 eq and {
            dmc3 module
        } if
        2 copy 2 eq exch mrows 4 add eq and mcols 8 mod 0 eq and {
            dmc4 module
        } if

        { % loop for sweeping upwards
            2 copy 0 ge exch mrows lt and {
                2 copy exch mcols mul add mmat exch get -1 eq {
                    dmn module
                } if
            } if
            2 add exch 2 sub exch
            2 copy mcols lt exch 0 ge and not {exit} if
        } loop
        3 add exch 1 add exch

        { % loop for sweeping downwards
            2 copy mcols lt exch 0 ge and {
                2 copy exch mcols mul add mmat exch get -1 eq {
                    dmn module
                } if
            } if
            2 sub exch 2 add exch
            2 copy 0 ge exch mrows lt and not {exit} if
        } loop
        1 add exch 3 add exch

        2 copy mcols lt exch mrows lt or not {pop pop exit} if

    } loop

    % Set checker pattern if required
    mmat mrows mcols mul 1 sub get -1 eq {
        mmat mrows mcols 1 sub mul 2 sub [1 0] putinterval
        mmat mrows mcols mul 2 sub [0 1] putinterval
    } if

    % Place the modules onto a pixel map between alignment patterns
    /pixs rows cols mul array def
    /cwpos 0 def
    0 1 rows 1 sub {
        /i exch def
        i rrows 2 add mod 0 eq { pixs i cols mul [ cols 2 idiv {1 0} repeat ] putinterval } if  
        i rrows 2 add mod rrows 1 add eq { pixs i cols mul [ cols {1} repeat ] putinterval } if 
        i rrows 2 add mod 0 ne i rrows 2 add mod rrows 1 add ne and {
            0 1 cols 1 sub {
                /j exch def
                j rcols 2 add mod 0 eq { pixs i cols mul j add 1 put } if
                j rcols 2 add mod rcols 1 add eq { pixs i cols mul j add i 2 mod put } if
                j rcols 2 add mod 0 ne j rcols 2 add mod rcols 1 add ne and {
                    pixs i cols mul j add mmat cwpos get put
                    /cwpos cwpos 1 add def
                } if
            } for
        } if 
    } for

    % Return the arguments
    <<
    /ren //renmatrix
    /pixs pixs
    /pixx cols
    /pixy rows
    /height rows 2 mul 72 div
    /width cols 2 mul 72 div
    /opt options
    >>

    dontdraw not //renmatrix if

    end

} bind def
/datamatrix dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER datamatrix--

% --BEGIN ENCODER qrcode--
% --DESC: QR Code
% --EXAM: http://www.terryburton.co.uk/barcodewriter/
% --EXOP: eclevel=M
% --RNDR: renmatrix
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/qrcode {

    20 dict begin

    /options exch def
    /barcode exch def

    /dontdraw false def
    /format (full) def     % full or micro
    /version (unset) def
    /eclevel (unset) def   % L, M, Q or H
    /encoding (unset) def
    /raw false def
    /parse false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    % Parse ordinals of the form ^NNN to ASCII
    parse {
        /msg barcode length string def
        /j 0 def
        barcode
        { % loop
            (^) search {
                dup msg exch j exch putinterval
                length j add 1 add /j exch def
                pop
                dup 0 3 getinterval cvi msg exch j 1 sub exch put
                dup length 3 sub 3 exch getinterval
            } {
                dup msg exch j exch putinterval
                length j add /j exch def
                /barcode msg 0 j getinterval def
                exit
            } ifelse 
        } loop
    } if

    /barlen barcode length def

    % Default error correction level
    eclevel (unset) eq {/eclevel format (full) eq {(M)} {(L)} ifelse def} if

    % Convert from input into message bitstream
    raw {/encoding (raw) def} if
    encoding (raw) eq {
        /msgbits barcode def 
    } {

        % Symbol capacities
        /fullcaps <<
            /numeric <<
                /L [   41    77   127   187   255   322   370   461   552   652    %  1-L - 10-L
                      772   883  1022  1101  1250  1408  1548  1725  1903  2061    % 11-L - 20-L
                     2232  2409  2620  2812  3057  3283  3517  3669  3909  4158    % 21-L - 30-L
                     4417  4686  4965  5253  5529  5836  6153  6479  6743  7089 ]  % 31-L - 40-L
                /M [   34    63   101   149   202   255   293   365   432   513    %  1-M - 10-M
                      604   691   796   871   991  1082  1212  1346  1500  1600    % 11-M - 20-M
                     1708  1872  2059  2188  2395  2544  2701  2857  3035  3289    % 21-M - 30-M
                     3486  3693  3909  4134  4343  4588  4775  5039  5313  5596 ]  % 31-M - 40-M
                /Q [   27    48    77   111   144   178   207   259   312   364    %  1-Q - 10-Q
                      427   489   580   621   703   775   876   948  1063  1159    % 11-Q - 20-Q
                     1224  1358  1468  1588  1718  1804  1933  2085  2181  2358    % 21-Q - 30-Q
                     2473  2670  2805  2949  3081  3244  3417  3599  3791  3993 ]  % 31-Q - 40-Q
                /H [   17    34    58    82   106   139   154   202   235   288    %  1-H - 10-H
                      331   374   427   468   530   602   674   746   813   919    % 11-H - 20-H
                      969  1056  1108  1228  1286  1425  1501  1581  1677  1782    % 21-H - 30-H
                     1897  2022  2157  2301  2361  2524  2625  2735  2927  3057 ]  % 31-H - 40-H
            >>
            /alphanumeric <<
                /L [   25    47    77   114   154   195   224   279   335   395    %  1-L - 10-L
                      468   535   619   667   758   854   938  1046  1153  1249    % 11-L - 20-L
                     1352  1460  1588  1704  1853  1990  2132  2223  2369  2520    % 21-L - 30-L
                     2677  2840  3009  3183  3351  3537  3729  3927  4087  4296 ]  % 31-L - 40-L
                /M [   20    38    61    90   122   154   178   221   262   311    %  1-M - 10-M
                      366   419   483   528   600   656   734   816   909   970    % 11-M - 20-M
                     1035  1134  1248  1326  1451  1542  1637  1732  1839  1994    % 21-M - 30-M
                     2113  2238  2369  2506  2632  2780  2894  3054  3220  3391 ]  % 31-M - 40-M
                /Q [   16    29    47    67    87   108   125   157   189   221    %  1-Q - 10-Q
                      259   296   352   376   426   470   531   574   644   702    % 11-Q - 20-Q
                      742   823   890   963  1041  1094  1172  1263  1322  1429    % 21-Q - 30-Q
                     1499  1618  1700  1787  1867  1966  2071  2181  2298  2420 ]  % 31-Q - 40-Q
                /H [   10    20    35    50    64    84    93   122   143   174    %  1-H - 10-H
                      200   227   259   283   321   365   408   452   493   557    % 11-H - 20-H
                      587   640   672   744   779   864   910   958  1016  1080    % 21-H - 30-H
                     1150  1226  1307  1394  1431  1530  1591  1658  1774  1852 ]  % 31-H - 40-H
            >>
            /byte <<
                /L [   17    32    53    78   106   134   154   192   230   271    %  1-L - 10-L
                      321   367   425   458   520   586   644   718   792   858    % 11-L - 20-L
                      929  1003  1091  1171  1273  1367  1465  1528  1628  1732    % 21-L - 30-L
                     1840  1952  2068  2188  2303  2431  2563  2699  2809  2953 ]  % 31-L - 40-L
                /M [   14    26    42    62    84   106   122   152   180   213    %  1-M - 10-M
                      251   287   331   362   412   450   504   560   624   666    % 11-M - 20-M
                      711   779   857   911   997  1059  1125  1190  1264  1370    % 21-M - 30-M
                     1452  1538  1628  1722  1809  1911  1989  2099  2213  2331 ]  % 31-M - 40-M
                /Q [   11    20    32    46    60    74    86   108   130   151    %  1-Q - 10-Q
                      177   203   241   258   292   322   364   394   442   482    % 11-Q - 20-Q
                      509   565   611   661   715   751   805   868   908   982    % 21-Q - 30-Q
                     1030  1112  1168  1228  1283  1351  1423  1499  1579  1663 ]  % 31-Q - 40-Q
                /H [    7    14    24    34    44    58    64    84    98   119    %  1-H - 10-H
                      137   155   177   194   220   250   280   310   338   382    % 11-H - 20-H
                      403   439   461   511   535   593   625   658   698   742    % 21-H - 30-H
                      790   842   898   958   983  1051  1093  1139  1219  1273 ]  % 31-H - 40-H
            >>
            /kanji <<
                /L [   10    20    32    48    65    82    95   118   141   167    %  1-L - 10-L
                      198   226   262   282   320   361   397   442   488   528    % 11-L - 20-L
                      572   618   672   721   784   842   902   940  1002  1066    % 21-L - 30-L
                     1132  1201  1273  1347  1417  1496  1577  1661  1729  1817 ]  % 31-L - 40-L
                /M [    8    16    26    38    52    65    75    93   111   131    %  1-M - 10-M
                      155   177   204   223   254   277   310   345   384   410    % 11-M - 20-M
                      438   480   528   561   614   652   692   732   778   843    % 21-M - 30-M
                      894   947  1002  1060  1113  1176  1224  1292  1362  1435 ]  % 31-M - 40-M
                /Q [    7    12    20    28    37    45    53    66    80    93    %  1-Q - 10-Q
                      109   125   149   159   180   198   224   243   272   297    % 11-Q - 20-Q
                      314   348   376   407   440   462   496   534   559   604    % 21-Q - 30-Q
                      634   684   719   756   790   832   876   923   972  1024 ]  % 31-Q - 40-Q
                /H [    4     8    15    21    27    36    39    52    60    74    %  1-H - 10-H
                       85    96   109   120   136   154   173   191   208   235    % 11-H - 20-H
                      248   270   284   315   330   365   385   405   430   457    % 21-H - 30-H
                      486   518   553   590   605   647   673   701   750   784 ]  % 31-H - 40-H 
            >> 
        >> def 

        %            M1 M2 M3 M4         M1 M2 M3 M4         M1 M2 M3 M4         M1 M2 M3 M4
        /microcaps <<
            /numeric <<
                /L [  5 10 23 35 ]  /M [ -1  8 18 30 ]  /Q [ -1 -1 -1 21 ]  /H [ -1 -1 -1 -1 ]
            >>
            /alphanumeric <<
                /L [ -1  6 14 21 ]  /M [ -1  5 11 18 ]  /Q [ -1 -1 -1 13 ]  /H [ -1 -1 -1 -1 ]
            >>
            /byte <<
                /L [ -1 -1  9 15 ]  /M [ -1 -1  7 13 ]  /Q [ -1 -1 -1  9 ]  /H [ -1 -1 -1 -1 ]
            >> 
            /kanji <<
                /L [ -1 -1  6  9 ]  /M [ -1 -1  4  8 ]  /Q [ -1 -1 -1  5 ]  /H [ -1 -1 -1 -1 ]
            >>
        >> def

        /encvals <<
            /numeric      0
            /alphanumeric 1
            /byte         2
            /kanji        3
        >> def

        /encs <<
            /numeric      /encnumeric
            /alphanumeric /encalphanumeric
            /byte         /encbyte
            /kanji        /enckanji
        >> def

        %           N      A      B      K
        /mids  [ (0001) (0010) (0100) (1000) ] def
        /mids <<
           /M1 [     ()     -1     -1     -1 ]
           /M2 [    (0)    (1)     -1     -1 ]
           /M3 [   (00)   (01)   (10)   (11) ]
           /M4 [  (000)  (001)  (010)  (011) ]
           1 1 40 {2 string 10 exch cvrs mids} for
        >> def

        %            N  A  B  K
        /cc1to9   [ 10  9  8  8 ] def
        /cc10to26 [ 12 11 16 10 ] def
        /cc27to40 [ 14 13 16 12 ] def
        /cclens <<
            /M1   [  3 -1 -1 -1 ]
            /M2   [  4  3 -1 -1 ]
            /M3   [  5  4  4  3 ]
            /M4   [  6  5  5  4 ]
             1 1  9 { 2 string 10 exch cvrs cc1to9 } for
            10 1 26 { 2 string 10 exch cvrs cc10to26 } for            
            27 1 40 { 2 string 10 exch cvrs cc27to40 } for
        >> def

        % Alphanumeric character to value map
        /charmap (0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:) def
        /charvals 44 dict def
        0 1 44 {dup charmap exch get exch charvals 3 1 roll put} for

        /encnumeric {
            /in exch def
            /out in length 10 mul 3 idiv 1 add string def
            /i 0 def /j 0 def {
                i in length eq {exit} if
                i in length 2 sub lt {
                    (0000000000) 10 string copy
                    dup in i 3 getinterval cvi
                    2 10 string cvrs dup length 10 exch sub exch putinterval
                    /i i 3 add def
                } {
                    i in length 2 sub eq {  % Two final digits
                        (0000000) 7 string copy
                        dup in i 2 getinterval cvi
                        2 7 string cvrs dup length 7 exch sub exch putinterval
                        /i i 2 add def
                    } {  % One final digit
                        (0000) 4 string copy
                        dup in i 1 getinterval cvi
                        2 4 string cvrs dup length 4 exch sub exch putinterval
                        /i i 1 add def
                    } ifelse
                } ifelse
                dup out exch j exch putinterval
                length j add /j exch def
            } loop
            out 0 j getinterval
        } bind def

        /encalphanumeric {
            /in exch def
            /out in length 11 mul 2 idiv 1 add string def
            /i 0 def /j 0 def {
                i in length eq {exit} if
                i in length 1 sub lt {
                    (00000000000) 11 string copy
                    dup charvals in i get get 45 mul charvals in i 1 add get get add
                    2 11 string cvrs dup length 11 exch sub exch putinterval
                    /i i 2 add def
                } {
                    (000000) 6 string copy
                    dup charvals in i get get
                    2 6 string cvrs dup length 6 exch sub exch putinterval
                    /i i 1 add def
                } ifelse
                dup out exch j exch putinterval
                length j add /j exch def
            } loop
            out 0 j getinterval
        } bind def

        /encbyte {
            /in exch def
            /out in length 8 mul string def
            0 1 in length 1 sub {
                /i exch def
                (00000000) 8 string copy
                dup in i get cvi
                2 8 string cvrs dup length 8 exch sub exch putinterval 
                out i 8 mul 3 -1 roll putinterval
            } for
            out
        } bind def

        /enckanji {
            /in exch def
            /out in length 2 idiv 13 mul string def
            /i 0 def /j 0 def {
                i in length eq {exit} if
                in i get 256 mul in i 1 add get add
                dup 16#E040 lt {16#8140} {16#C140} ifelse sub
                dup -8 bitshift 16#C0 mul exch 16#00FF and add
                (0000000000000) 13 string copy
                dup 3 -1 roll 2 13 string cvrs dup length 13 exch sub exch putinterval
                dup out exch j exch putinterval
                length j add /j exch def
                /i i 2 add def
            } loop
            out
        } bind def

        % Determine a compact encoding for the data
        encoding (unset) eq {
            /numericokay true def
            /alphanumericokay true def
            /kanjiokay true def
            /byteokay true def
            barlen 2 mod 0 ne {/kanjiokay false def} if
            0 1 barlen 1 sub {
                /i exch def
                /barchar barcode i get def
                barchar 48 lt barchar 57 gt or {/numericokay false def} if
                charvals barchar known not {/alphanumericokay false def} if
                i 2 mod 0 eq {
                    barchar 16#81 lt barchar 16#9F gt or
                    barchar 16#E0 lt barchar 16#EB gt or and {
                        /kanjiokay false def
                    } if
                } if
            } for
            byteokay         {/encoding (byte) def} if
            kanjiokay        {/encoding (kanji) def} if
            alphanumericokay {/encoding (alphanumeric) def} if
            numericokay      {/encoding (numeric) def} if
        } if

        % Determine smallest symbol version to hold given amount of data
        /numchars barlen encoding (kanji) eq {2 idiv} if def
        version (unset) eq {
            /caps format (full) eq {fullcaps} {microcaps} ifelse encoding get eclevel get def
            /i 1 def {
                numchars caps i 1 sub get le {exit} if
                /i i 1 add def
            } loop
            /version i 10 2 string cvrs def
            format (micro) eq {
                /version (M ) 2 string copy dup version 1 exch putinterval def
            } if
        } if

        % Opportunistically raise the error correction level for a fit to the same symbol
        /caps format (full) eq {fullcaps} {microcaps} ifelse encoding get def
        /verval format (full) eq {version cvi 1 sub} {version 1 get 49 sub} ifelse def
        eclevel (L) eq {numchars caps /M get verval get le {/eclevel (M) def} if} if
        eclevel (M) eq {numchars caps /Q get verval get le {/eclevel (Q) def} if} if
        eclevel (Q) eq {numchars caps /H get verval get le {/eclevel (H) def} if} if

        % Set the control character data for the version
        /mid mids version get encvals encoding get get def
        /cclen cclens version get encvals encoding get get def
 
        % Create the bitstream as mode_id character_count encoded_data
        /enc barcode encs encoding get load exec def
        (0000000000000000) 0 cclen getinterval cclen string copy 
        dup barlen encoding (kanji) eq {2 idiv} if cvi
        2 cclen string cvrs dup length cclen exch sub exch putinterval 
        /cc exch def
        /msgbits mid length cclen add enc length add string def
        msgbits 0 mid putinterval
        msgbits mid length cc putinterval
        msgbits mid length cclen add enc putinterval

    } ifelse

    % Lookup the most appropriate symbol specification
    /metrics [
        % format   vers  size align modules    error codewords        error correction blocks 
        %                                      L    M    Q    H       L1 L2 M1 M2 Q1 Q2 H1 H2
        [ (micro)  (M1)   11  98 99     36  [   2   99   99   99 ]  [  1  0 -1 -1 -1 -1 -1 -1 ] ]
        [ (micro)  (M2)   13  98 99     80  [   5    6   99   99 ]  [  1  0  1  0 -1 -1 -1 -1 ] ]
        [ (micro)  (M3)   15  98 99    132  [   6    8   99   99 ]  [  1  0  1  0 -1 -1 -1 -1 ] ]
        [ (micro)  (M4)   17  98 99    192  [   8   10   14   99 ]  [  1  0  1  0  1  0 -1 -1 ] ]
        [ (full)   (1)    21  98 99    208  [   7   10   13   17 ]  [  1  0  1  0  1  0  1  0 ] ]
        [ (full)   (2)    25  18 99    359  [  10   16   22   28 ]  [  1  0  1  0  1  0  1  0 ] ]
        [ (full)   (3)    29  22 99    567  [  15   26   36   44 ]  [  1  0  1  0  2  0  2  0 ] ]
        [ (full)   (4)    33  26 99    807  [  20   36   52   64 ]  [  1  0  2  0  2  0  4  0 ] ]
        [ (full)   (5)    37  30 99   1079  [  26   48   72   88 ]  [  1  0  2  0  2  2  2  2 ] ]
        [ (full)   (6)    41  34 99   1383  [  36   64   96  112 ]  [  2  0  4  0  4  0  4  0 ] ]
        [ (full)   (7)    45  22 38   1568  [  40   72  108  130 ]  [  2  0  4  0  2  4  4  1 ] ]
        [ (full)   (8)    49  24 42   1936  [  48   88  132  156 ]  [  2  0  2  2  4  2  4  2 ] ]
        [ (full)   (9)    53  26 46   2336  [  60  110  160  192 ]  [  2  0  3  2  4  4  4  4 ] ]
        [ (full)   (10)   57  28 50   2768  [  72  130  192  224 ]  [  2  2  4  1  6  2  6  2 ] ]
        [ (full)   (11)   61  30 54   3232  [  80  150  224  264 ]  [  4  0  1  4  4  4  3  8 ] ]
        [ (full)   (12)   65  32 58   3728  [  96  176  260  308 ]  [  2  2  6  2  4  6  7  4 ] ]
        [ (full)   (13)   69  34 62   4256  [ 104  198  288  352 ]  [  4  0  8  1  8  4 12  4 ] ]
        [ (full)   (14)   73  26 46   4651  [ 120  216  320  384 ]  [  3  1  4  5 11  5 11  5 ] ]
        [ (full)   (15)   77  26 48   5243  [ 132  240  360  432 ]  [  5  1  5  5  5  7 11  7 ] ]
        [ (full)   (16)   81  26 50   5867  [ 144  280  408  480 ]  [  5  1  7  3 15  2  3 13 ] ]
        [ (full)   (17)   85  30 54   6523  [ 168  308  448  532 ]  [  1  5 10  1  1 15  2 17 ] ]
        [ (full)   (18)   89  30 56   7211  [ 180  338  504  588 ]  [  5  1  9  4 17  1  2 19 ] ]
        [ (full)   (19)   93  30 58   7931  [ 196  364  546  650 ]  [  3  4  3 11 17  4  9 16 ] ]
        [ (full)   (20)   97  34 62   8683  [ 224  416  600  700 ]  [  3  5  3 13 15  5 15 10 ] ]
        [ (full)   (21)  101  28 50   9252  [ 224  442  644  750 ]  [  4  4 17  0 17  6 19  6 ] ]
        [ (full)   (22)  105  26 50  10068  [ 252  476  690  816 ]  [  2  7 17  0  7 16 34  0 ] ]
        [ (full)   (23)  109  30 54  10916  [ 270  504  750  900 ]  [  4  5  4 14 11 14 16 14 ] ]
        [ (full)   (24)  113  28 54  11796  [ 300  560  810  960 ]  [  6  4  6 14 11 16 30  2 ] ]
        [ (full)   (25)  117  32 58  12708  [ 312  588  870 1050 ]  [  8  4  8 13  7 22 22 13 ] ]
        [ (full)   (26)  121  30 58  13652  [ 336  644  952 1110 ]  [ 10  2 19  4 28  6 33  4 ] ]
        [ (full)   (27)  125  34 62  14628  [ 360  700 1020 1200 ]  [  8  4 22  3  8 26 12 28 ] ]
        [ (full)   (28)  129  26 50  15371  [ 390  728 1050 1260 ]  [  3 10  3 23  4 31 11 31 ] ]
        [ (full)   (29)  133  30 54  16411  [ 420  784 1140 1350 ]  [  7  7 21  7  1 37 19 26 ] ]
        [ (full)   (30)  137  26 52  17483  [ 450  812 1200 1440 ]  [  5 10 19 10 15 25 23 25 ] ]
        [ (full)   (31)  141  30 56  18587  [ 480  868 1290 1530 ]  [ 13  3  2 29 42  1 23 28 ] ]
        [ (full)   (32)  145  34 60  19723  [ 510  924 1350 1620 ]  [ 17  0 10 23 10 35 19 35 ] ]
        [ (full)   (33)  149  30 58  20891  [ 540  980 1440 1710 ]  [ 17  1 14 21 29 19 11 46 ] ]
        [ (full)   (34)  153  34 62  22091  [ 570 1036 1530 1800 ]  [ 13  6 14 23 44  7 59  1 ] ]
        [ (full)   (35)  157  30 54  23008  [ 570 1064 1590 1890 ]  [ 12  7 12 26 39 14 22 41 ] ]
        [ (full)   (36)  161  24 50  24272  [ 600 1120 1680 1980 ]  [  6 14  6 34 46 10  2 64 ] ]
        [ (full)   (37)  165  28 54  25568  [ 630 1204 1770 2100 ]  [ 17  4 29 14 49 10 24 46 ] ]
        [ (full)   (38)  169  32 58  26896  [ 660 1260 1860 2220 ]  [  4 18 13 32 48 14 42 32 ] ]
        [ (full)   (39)  173  26 54  28256  [ 720 1316 1950 2310 ]  [ 20  4 40  7 43 22 10 67 ] ]
        [ (full)   (40)  177  30 58  29648  [ 750 1372 2040 2430 ]  [ 19  6 18 31 34 34 20 61 ] ]
    ] def
    /eclval (LMQH) eclevel search pop length exch pop exch pop def
    /i 0 def
    { % loop
        /m metrics i get def
        /frmt m 0 get def                             % Format of the symbol
        /vers m 1 get def                             % Version of symbol
        /size m 2 get def                             % Length of side
        /asp2 m 3 get def                             % Position of second alignment symbol
        /asp3 m 4 get def                             % Position of third alignment symbol
        /nmod m 5 get def                             % Number of modules
        /ncws nmod 8 idiv def                         % Total number of codewords
        /rbit nmod 8 mod def                          % Number of remainder bits
        /lc4b false def                               % Last data codeword is 4 bits long
        size 11 eq size 15 eq or {                    % Adjustments for M1 and M3 symbols
            /ncws ncws 1 add def
            /rbit 0 def
            /lc4b true def
        } if
        /ecws m 6 get eclval get def                  % Number of error correction codewords
        /dcws ncws ecws sub def                       % Number of data codewords
        /dmod dcws 8 mul lc4b {4} {0} ifelse sub def  % Number of data modules
        /ecb1 m 7 get eclval 2 mul get def            % First error correction blocks
        /ecb2 m 7 get eclval 2 mul 1 add get def      % Second error correction blocks
        /okay true def
        format frmt ne {/okay false def} if           % The format must match that supplied
        version (unset) ne version vers ne and {/okay false def} if  % The version must match that supplied
        msgbits length dmod gt {/okay false def} if   % Bitstream must fit into data modules
        ecb1 -1 eq ecb2 -1 eq or {/okay false def} if % Error correction level must be valid
        okay {exit} if
        /i i 1 add def
    } loop

    /format frmt def
    /version vers def
    /dcpb dcws ecb1 ecb2 add idiv def                 % Base data codewords per block
    /ecpb ncws ecb1 ecb2 add idiv dcpb sub def        % Error correction codewords per block

    % Complete the message bits by adding the terminator, truncated if neccessary
    /terms <<
        /M1 (000)
        /M2 (00000)
        /M3 (0000000)
        /M4 (000000000)
    >> def
    /term terms version known {terms version get} {(0000)} ifelse def
    /term term 0 dmod msgbits length sub term length 2 copy gt {exch} if pop getinterval def
    msgbits length term length add string
    dup 0 msgbits putinterval
    dup msgbits length term putinterval
    /msgbits exch def
    
    % Expand the message bits by adding padding as necessary
    /pad dmod string def
    0 1 pad length 1 sub {pad exch 48 put} for
    pad 0 msgbits putinterval
    /padstrs [ (11101100) (00010001) ] def
    /padnum 0 def
    msgbits length 8 div ceiling 8 mul cvi 8 dmod lc4b {5} {1} ifelse sub {
        pad exch padstrs padnum get putinterval 
        /padnum padnum 1 add 2 mod def
    } for

    % Evaluate the padded message into codewords
    /cws dcws array def 
    0 1 cws length 1 sub {
        /c exch def
        /bpcw 8 def
        lc4b c cws length 1 sub eq and {/bpcw 4 def} if
        /cwb pad c 8 mul bpcw getinterval def
        /cw 0 def
        0 1 bpcw 1 sub {
            /i exch def
            /cw cw 2 bpcw i sub 1 sub exp cvi cwb i get 48 sub mul add def
        } for 
        cws c cw put
    } for 

    % Calculate the log and anti-log tables
    /rsalog [ 1 255 { dup 2 mul dup 256 ge {285 xor} if } repeat ] def
    /rslog 256 array def
    1 1 255 {dup rsalog exch get exch rslog 3 1 roll put} for

    % Function to calculate the product in the field
    /rsprod {
        2 copy 0 ne exch 0 ne and { 
            rslog exch get exch rslog exch get add 255 mod rsalog exch get
        } {
            pop pop 0
        } ifelse
    } bind def

    % Generate the coefficients for the Reed-Solomon algorithm
    /coeffs [ 1 ecpb {0} repeat ] def
    0 1 ecpb 1 sub {
        /i exch def 
        coeffs i 1 add coeffs i get put
        i -1 1 {
            /j exch def
            coeffs j coeffs j 1 sub get coeffs j get rsalog i get rsprod xor put
        } for 
        coeffs 0 coeffs 0 get rsalog i get rsprod put
    } for
    /coeffs coeffs 0 coeffs length 1 sub getinterval def

    % Reed-Solomon algorithm to derive the error correction codewords
    /rscodes {
        /rscws exch def
        /rsnd rscws length def
        /rscws [ rscws {} forall ecpb {0} repeat ] def
        0 1 rsnd 1 sub {
            /m exch def
            /k rscws m get def
            0 1 ecpb 1 sub {
                /j exch def
                rscws m j add 1 add coeffs ecpb j sub 1 sub get k rsprod rscws m j add 1 add get xor put
            } for
        } for
        rscws rsnd ecpb getinterval
    } bind def

    % Divide codewords into two groups of blocks and calculate the error correction codewords
    /dcwsb ecb1 ecb2 add array def
    /ecwsb ecb1 ecb2 add array def
    0 1 ecb1 1 sub {  % First group of blocks has smaller number of data codewords
        /i exch def
        dcwsb i cws i dcpb mul dcpb getinterval put
        ecwsb i dcwsb i get rscodes put
    } for
    0 1 ecb2 1 sub {  % Second group of blocks has larger number of data codewords
        /i exch def
        dcwsb ecb1 i add cws ecb1 dcpb mul i dcpb 1 add mul add dcpb 1 add getinterval put
        ecwsb ecb1 i add dcwsb ecb1 i add get rscodes put
    } for
    
    % Reassemble the codewords
    /cws ncws array def
    /cw 0 def
    0 1 dcpb {  % Interleave the data codeword blocks
        /i exch def
        0 1 ecb1 ecb2 add 1 sub {
            /j exch def
            i dcwsb j get length lt {  % Ignore the end of short blocks
                cws cw dcwsb j get i get put
                /cw cw 1 add def
            } if
        } for
    } for
    0 1 ecpb 1 sub {  % Interleave the error codeword blocks
        /i exch def
        0 1 ecb1 ecb2 add 1 sub {
            /j exch def
            cws cw ecwsb j get i get put
            /cw cw 1 add def
        } for
    } for
    
    % Extend codewords by one if there are remainder bits
    rbit 0 gt {
        /pad cws length 1 add array def
        pad 0 cws putinterval
        pad pad length 1 sub 0 put
        /cws pad def
    } if
 
    % Fixups for the short final data byte in M1 and M3 symbols
    lc4b {
        dcws 1 sub 1 ncws 2 sub {
            /i exch def
            cws i cws i get 15 and 4 bitshift put
            cws i cws i 1 add get -4 bitshift 15 and cws i get or put
        } for
        cws ncws 1 sub cws ncws 1 sub get 15 and 4 bitshift put
    } if

    % Create the bitmap
    /pixs [ size size mul {-1} repeat ] def
    /qmv {size mul add} bind def
    
    % Finder patterns
    /fpat [
        [ 1 1 1 1 1 1 1 0 ]
        [ 1 0 0 0 0 0 1 0 ]
        [ 1 0 1 1 1 0 1 0 ]
        [ 1 0 1 1 1 0 1 0 ]
        [ 1 0 1 1 1 0 1 0 ]
        [ 1 0 0 0 0 0 1 0 ]
        [ 1 1 1 1 1 1 1 0 ]
        [ 0 0 0 0 0 0 0 0 ]
    ] def
    0 1 fpat length 1 sub {
      /y exch def
      0 1 fpat 0 get length 1 sub {
        /x exch def
        /fpb fpat y get x get def
        pixs x y qmv fpb put
        format (full) eq {
            pixs size x sub 1 sub y qmv fpb put
            pixs x size y sub 1 sub qmv fpb put
        } if
      } for
    } for
    
    % Alignment patterns
    /algnpat [
        [ 1 1 1 1 1 ]
        [ 1 0 0 0 1 ]
        [ 1 0 1 0 1 ]
        [ 1 0 0 0 1 ]
        [ 1 1 1 1 1 ]
    ] def
    /putalgnpat {
        /py exch def
        /px exch def
        0 1 4 {
            /pb exch def
            0 1 4 {
                /pa exch def
                pixs px pa add py pb add qmv algnpat pb get pa get put
            } for
        } for
    } bind def
    asp2 2 sub asp3 asp2 sub size 13 sub {
        /i exch def
        i 4 putalgnpat
        4 i putalgnpat
    } for
    asp2 2 sub asp3 asp2 sub size 9 sub { 
        /x exch def
        asp2 2 sub asp3 asp2 sub size 9 sub {
            /y exch def
            x y putalgnpat
        } for
    } for
    
    % Timing patterns
    format (full) eq {
        8 1 size 9 sub {
            /i exch def
            pixs i 6 qmv i 1 add 2 mod put
            pixs 6 i qmv i 1 add 2 mod put
        } for
    } {
        8 1 size 1 sub {
            /i exch def
            pixs i 0 qmv i 1 add 2 mod put
            pixs 0 i qmv i 1 add 2 mod put
        } for
    } ifelse
    
    % Format information modules
    format (full) eq {
        /formatmap [
            [ [ 0 8 ] [ 8 size 1 sub ] ]  [ [ 1 8 ] [ 8 size 2 sub ] ]  [ [ 2 8 ] [ 8 size 3 sub ] ]
            [ [ 3 8 ] [ 8 size 4 sub ] ]  [ [ 4 8 ] [ 8 size 5 sub ] ]  [ [ 5 8 ] [ 8 size 6 sub ] ]
            [ [ 7 8 ] [ 8 size 7 sub ] ]  [ [ 8 8 ] [ size 8 sub 8 ] ]  [ [ 8 7 ] [ size 7 sub 8 ] ]
            [ [ 8 5 ] [ size 6 sub 8 ] ]  [ [ 8 4 ] [ size 5 sub 8 ] ]  [ [ 8 3 ] [ size 4 sub 8 ] ]
            [ [ 8 2 ] [ size 3 sub 8 ] ]  [ [ 8 1 ] [ size 2 sub 8 ] ]  [ [ 8 0 ] [ size 1 sub 8 ] ]
        ] def
    } {
        /formatmap [
            [ [ 1 8 ] ]  [ [ 2 8 ] ]  [ [ 3 8 ] ]  [ [ 4 8 ] ]  [ [ 5 8 ] ]
            [ [ 6 8 ] ]  [ [ 7 8 ] ]  [ [ 8 8 ] ]  [ [ 8 7 ] ]  [ [ 8 6 ] ]
            [ [ 8 5 ] ]  [ [ 8 4 ] ]  [ [ 8 3 ] ]  [ [ 8 2 ] ]  [ [ 8 1 ] ]
        ] def
    } ifelse
    formatmap {
        { {} forall qmv pixs exch 0 put } forall
    } forall
    
    % Version information modules
    size 45 ge {
        /versionmap [
            [ [ size  9 sub 5 ] [ 5 size  9 sub ] ]  [ [ size 10 sub 5 ] [ 5 size 10 sub ] ]
            [ [ size 11 sub 5 ] [ 5 size 11 sub ] ]  [ [ size  9 sub 4 ] [ 4 size  9 sub ] ]
            [ [ size 10 sub 4 ] [ 4 size 10 sub ] ]  [ [ size 11 sub 4 ] [ 4 size 11 sub ] ]
            [ [ size  9 sub 3 ] [ 3 size  9 sub ] ]  [ [ size 10 sub 3 ] [ 3 size 10 sub ] ]
            [ [ size 11 sub 3 ] [ 3 size 11 sub ] ]  [ [ size  9 sub 2 ] [ 2 size  9 sub ] ]
            [ [ size 10 sub 2 ] [ 2 size 10 sub ] ]  [ [ size 11 sub 2 ] [ 2 size 11 sub ] ]
            [ [ size  9 sub 1 ] [ 1 size  9 sub ] ]  [ [ size 10 sub 1 ] [ 1 size 10 sub ] ]
            [ [ size 11 sub 1 ] [ 1 size 11 sub ] ]  [ [ size  9 sub 0 ] [ 0 size  9 sub ] ]
            [ [ size 10 sub 0 ] [ 0 size 10 sub ] ]  [ [ size 11 sub 0 ] [ 0 size 11 sub ] ]
        ] def
    } {
        /versionmap [] def
    } ifelse
    versionmap {
        { {} forall qmv pixs exch 0 put } forall
    } forall
    
    % Solitary dark module in full symbols
    format (full) eq {
        pixs 8 size 8 sub qmv 1 put
    } if
    
    % Calculate the mask patterns
    format (full) eq {
        /maskfuncs [ 
            {add 2 mod} bind
            {exch pop 2 mod} bind
            {pop 3 mod} bind
            {add 3 mod} bind
            {2 idiv exch 3 idiv add 2 mod} bind
            {mul dup 2 mod exch 3 mod add} bind
            {mul dup 2 mod exch 3 mod add 2 mod} bind
            {2 copy mul 3 mod 3 1 roll add 2 mod add 2 mod} bind
        ] def
    } {
        /maskfuncs [ 
            {exch pop 2 mod} bind
            {2 idiv exch 3 idiv add 2 mod} bind
            {mul dup 2 mod exch 3 mod add 2 mod} bind
            {2 copy mul 3 mod 3 1 roll add 2 mod add 2 mod} bind
        ] def
    } ifelse
    /masks maskfuncs length array def
    0 1 masks length 1 sub {
        /m exch def
        /mask size size mul array def
        0 1 size 1 sub {
            /j exch def
            0 1 size 1 sub {
                /i exch def
                i j maskfuncs m get exec 0 eq 
                pixs i j qmv get -1 eq and {1} {0} ifelse
                mask i j qmv 3 -1 roll put
            } for
        } for
        masks m mask put
    } for
    
    % Walk the symbol placing the bitstream
    /posx size 1 sub def
    /posy size 1 sub def
    /dir -1 def  % -1 is upwards, 1 is downwards
    /col 1 def   % 0 is left bit, 1 is right bit
    /num 0 def
    { % loop
        posx 0 lt {exit} if
        pixs posx posy qmv get -1 eq {
            cws num 8 idiv get 7 num 8 mod sub neg bitshift 1 and
            pixs posx posy qmv 3 -1 roll put
            /num num 1 add def
        } if
        col 1 eq {
            /col 0 def
            /posx posx 1 sub def
        } {
            /col 1 def
            /posx posx 1 add def 
            /posy posy dir add def
            posy 0 lt posy size ge or {  % Turn around at top and bottom
                /dir dir -1 mul def
                /posy posy dir add def
                /posx posx 2 sub def
                % Hop over the timing pattern in full size symbols
                format (full) eq posx 6 eq and {/posx posx 1 sub def} if
            } if
        } ifelse
    } loop

    % Evaluate runlength encoded rows or columns in full symbols
    /evalfulln1n3 {
        /scrle exch def
        % Detect runs of 5 or more like modules
        /scr1 0 scrle { dup 5 ge {add 2 sub dup} if pop } forall def
        % Detect 1:1:3:1:1 ratio next to 4 modules of whitespace
        /scr3 0 def
        3 2 scrle length 3 sub {  % Scan odd (dark) runs within bounds
            /j exch def
            scrle j get 3 mod 0 eq {  % Multiple of 3 black modules
                /fact scrle j get 3 idiv def
                scrle j 2 sub 5 getinterval {fact eq} forall and exch pop and and {
                    j 3 eq j 4 add scrle length ge or {  % At either extent of run
                        /scr3 scr3 40 add def
                    } {  % Bounded by dark modules
                        scrle j 3 sub get 4 ge scrle j 3 add get 4 ge or {
                            /scr3 scr3 40 add def
                        } if
                    } ifelse
                } if
            } if
        } for
        scr1 scr3
    } bind def
    
    % Evaluation algorithm for full symbols
    /evalfull {
        /sym exch def

        /n1 0 def /n2 0 def /n3 0 def
        /rle size 1 add array def
        /lastpairs size array def
        /thispairs size array def
        /sizeadd1 size 1 add def
        0 1 size 1 sub {  
            /i exch def

            % Runlength encode (light, dark, light, ...) and evaluate each column
            mark 0 0
            i size dup dup mul 1 sub {
                sym exch get exch 1 index eq {exch 1 add exch} {1 exch} ifelse
            } for
            pop
            rle 0 counttomark 2 sub getinterval astore
            evalfulln1n3 n3 add /n3 exch def n1 add /n1 exch def
            pop

            % Runlength encode (light, dark, light, ...) and evaluate each row
            /symrow sym i size mul size getinterval def
            mark 0 0 
            symrow { 
                exch 1 index eq {exch 1 add exch} {1 exch} ifelse
            } forall 
            pop
            rle 0 counttomark 2 sub getinterval astore
            evalfulln1n3 n3 add /n3 exch def n1 add /n1 exch def
            pop

            % Count and score same coloured blocks
            /lastpairs thispairs /thispairs lastpairs def def
            symrow 0 get 1 eq {0} {1} ifelse
            symrow {exch 1 index add exch} forall
            pop
            thispairs astore pop
            i 0 gt {
                mark
                lastpairs aload pop thispairs aload pop
                n2 size { exch sizeadd1 index add 3 and 0 eq {3 add} if } repeat
                /n2 exch def
                cleartomark
            } if

        } for
 
        % Score dark/light imbalance 
        /dark 0 sym {add} forall def
        /n4 dark 100 mul size dup mul div 50 sub abs 5 div cvi 10 mul def

        n1 n2 add n3 add n4 add
    } bind def
 
    % Evaluation algorithm for micro symbols
    /evalmicro {
        /sym exch def
        /dkrhs 0 def /dkbot 0 def
        1 1 size 1 sub {
            /i exch def
            /dkrhs dkrhs sym size 1 sub i qmv get add def
            /dkbot dkbot sym i size 1 sub qmv get add def
        } for
        dkrhs dkbot le {
            dkrhs 16 mul dkbot add neg
        } {
            dkbot 16 mul dkrhs add neg
        } ifelse
    } bind def
    
    % Evaluate the masked symbols to find the most suitable
    /bestscore 999999999 def
    0 1 masks length 1 sub {
        /m exch def
        /masksym size size mul array def
        0 1 size size mul 1 sub {
            /i exch def
            masksym i pixs i get masks m get i get xor put
        } for
        format (full) eq {
            masksym evalfull /score exch def
        } {
            masksym evalmicro /score exch def
        } ifelse
        score bestscore lt { 
            /bestsym masksym def
            /bestmaskval m def
            /bestscore score def
        } if    
    } for
    /pixs bestsym def
    
    % Add the format information
    format (full) eq {
        /fmtvals [
            16#5412 16#5125 16#5e7c 16#5b4b 16#45f9 16#40ce 16#4f97 16#4aa0 
            16#77c4 16#72f3 16#7daa 16#789d 16#662f 16#6318 16#6c41 16#6976
            16#1689 16#13be 16#1ce7 16#19d0 16#0762 16#0255 16#0d0c 16#083b 
            16#355f 16#3068 16#3f31 16#3a06 16#24b4 16#2183 16#2eda 16#2bed
        ] def
        /ecid (MLHQ) eclevel search pop length exch pop exch pop def
        /fmtval fmtvals ecid 3 bitshift bestmaskval add get def
    } {
        /fmtvals [
            16#4445 16#4172 16#4e2b 16#4b1c 16#55ae 16#5099 16#5fc0 16#5af7
            16#6793 16#62a4 16#6dfd 16#68ca 16#7678 16#734f 16#7c16 16#7921
            16#06de 16#03e9 16#0cb0 16#0987 16#1735 16#1202 16#1d5b 16#186c
            16#2508 16#203f 16#2f66 16#2a51 16#34e3 16#31d4 16#3e8d 16#3bba
        ] def
        /symid [ [0] [1 2] [3 4] [5 6 7] ] size 11 sub 2 idiv get eclval get def
        /fmtval fmtvals symid 2 bitshift bestmaskval add get def
    } ifelse
    0 1 formatmap length 1 sub {
        /i exch def
        formatmap i get {
            pixs exch {} forall qmv fmtval 14 i sub neg bitshift 1 and put
        } forall
    } for
    
    % Add the version information
    size 45 ge {
        /vervals [
            16#07c94 16#085bc 16#09a99 16#0a4d3 16#0bbf6 16#0c762 16#0d847 
            16#0e60d 16#0f928 16#10b78 16#1145d 16#12a17 16#13532 16#149a6 
            16#15683 16#168c9 16#177ec 16#18ec4 16#191e1 16#1afab 16#1b08e 
            16#1cc1a 16#1d33f 16#1ed75 16#1f250 16#209d5 16#216fd 16#228ba 
            16#2379f 16#24b0b 16#2542e 16#26a64 16#27541 16#28c69
        ] def
        /verval vervals size 17 sub 4 idiv 7 sub get def
        0 1 versionmap length 1 sub {
            /i exch def
            versionmap i get {
                pixs exch {} forall qmv verval 17 i sub neg bitshift 1 and put
            } forall
        } for
    } if

    % Return the arguments
    <<
    /ren //renmatrix
    /pixs pixs
    /pixx size
    /pixy size
    /height size 2 mul 72 div
    /width size 2 mul 72 div
    /opt options
    >>

    dontdraw not //renmatrix if

    end

} bind def
/qrcode dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER qrcode--

% --BEGIN ENCODER maxicode--
% --DESC: MaxiCode
% --EXAM: [)>^03001^02996152382802^029840^029001^0291Z00004951^029UPSN^02906X610^029159^0291234567^0291/1^029^029Y^029634 ALPHA DR^029PITTSBURGH^029PA^029^004
% --EXOP: mode=2 parse
% --RNDR: renmaximatrix
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renmaximatrix dup /uk.co.terryburton.bwipp findresource put
begin
/maxicode {

    20 dict begin

    /options exch def        % We are given an option string
    /barcode exch def        % We are given a barcode string

    /dontdraw false def
    /mode -1 def
    /sam -1 def
    /parse false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /mode mode cvi def
    /sam sam cvi def

    % Parse ordinals of the form ^NNN to ASCII
    parse {
        /msg barcode length string def
        /j 0 def
        barcode
        { % loop
            (^) search {
                dup msg exch j exch putinterval
                length j add 1 add /j exch def
                pop
                dup 0 3 getinterval cvi msg exch j 1 sub exch put
                dup length 3 sub 3 exch getinterval
            } {
                dup msg exch j exch putinterval
                length j add /j exch def
                /barcode msg 0 j getinterval def
                exit
            } ifelse 
        } loop
    } if
    
    /msg barcode def
    /msglen msg length def

    % Special message handling for modes 2 and 3
    mode 2 eq mode 3 eq or {

        % Normalise messages that begin with a field identifier [)>RS01GSyy
        msg 0 7 getinterval <5b293e1e30311d> eq {
            /fid msg 0 9 getinterval def
            /msg msg 9 msglen 9 sub getinterval def 
        } {
            /fid () def
        } ifelse

        % Read the postcode, country code and service code fields seperated by GS
        msg <1d> search pop /pcode exch def
        pop <1d> search pop /ccode exch def
        pop <1d> search pop /scode exch def
        pop /msg exch def

        % Prepend the field identifier
        msg length fid length add string dup
        0 fid putinterval dup 
        fid length msg putinterval
        /msg exch def
        /msglen msg length def

    } if

    % Special function characters
    /eci -1 def  /pad -2 def  /ns -3 def
    /la  -4 def  /lb  -5 def
    /sa  -6 def  /sb  -7 def  /sc -8 def  /sd -9 def  /se -10 def
    /sa2 -11 def /sa3 -12 def  
    /lkc -13 def /lkd -14 def /lke -15 def
    /pd2 -16 def /pd3 -17 def 
    
    % Character maps for each state
    /charmaps [
        %  A    B    C    D    E
        [  13  (`)  192  224    0 ]  % 0
        [ (A)  (a)  193  225    1 ]  % 1
        [ (B)  (b)  194  226    2 ]  % 2
        [ (C)  (c)  195  227    3 ]  % 3
        [ (D)  (d)  196  228    4 ]  % 4
        [ (E)  (e)  197  229    5 ]  % 5
        [ (F)  (f)  198  230    6 ]  % 6
        [ (G)  (g)  199  231    7 ]  % 7
        [ (H)  (h)  200  232    8 ]  % 8
        [ (I)  (i)  201  233    9 ]  % 9 
        [ (J)  (j)  202  234   10 ]  % 10
        [ (K)  (k)  203  235   11 ]  % 11
        [ (L)  (l)  204  236   12 ]  % 12
        [ (M)  (m)  205  237   13 ]  % 13
        [ (N)  (n)  206  238   14 ]  % 14
        [ (O)  (o)  207  239   15 ]  % 15
        [ (P)  (p)  208  240   16 ]  % 16
        [ (Q)  (q)  209  241   17 ]  % 17
        [ (R)  (r)  210  242   18 ]  % 18
        [ (S)  (s)  211  243   19 ]  % 19
        [ (T)  (t)  212  244   20 ]  % 20
        [ (U)  (u)  213  245   21 ]  % 21
        [ (V)  (v)  214  246   22 ]  % 22
        [ (W)  (w)  215  247   23 ]  % 23
        [ (X)  (x)  216  248   24 ]  % 24
        [ (Y)  (y)  217  249   25 ]  % 25
        [ (Z)  (z)  218  250   26 ]  % 26
        [ eci  eci  eci  eci  eci ]  % 27
        [  28   28   28   28  pad ]  % 28
        [  29   29   29   29  pad ]  % 29
        [  30   30   30   30   27 ]  % 30
        [  ns   ns   ns   ns   ns ]  % 31
        [ ( )  ({)  219  251   28 ]  % 32
        [ pad  pad  220  252   29 ]  % 33
        [ (")  (})  221  253   30 ]  % 34
        [ (#)  (~)  222  254   31 ]  % 35
        [ ($)  127  223  255  159 ]  % 36
        [ (%)  (;)  170  161  160 ]  % 37
        [ (&)  (<)  172  168  162 ]  % 38
        [ (')  (=)  177  171  163 ]  % 39
        [  40  (>)  178  175  164 ]  % 40
        [  41  (?)  179  176  165 ]  % 41
        [ (*)  ([)  181  180  166 ]  % 42
        [ (+)   92  185  183  167 ]  % 43
        [ (,)  (])  186  184  169 ]  % 44
        [ (-)  (^)  188  187  173 ]  % 45
        [ (.)  (_)  189  191  174 ]  % 46
        [ (/)  ( )  190  138  182 ]  % 47
        [ (0)  (,)  128  139  149 ]  % 48
        [ (1)  (.)  129  140  150 ]  % 49
        [ (2)  (/)  130  141  151 ]  % 50
        [ (3)  (:)  131  142  152 ]  % 51
        [ (4)  (@)  132  143  153 ]  % 52
        [ (5)  (!)  133  144  154 ]  % 53
        [ (6)  (|)  134  145  155 ]  % 54
        [ (7)  pd2  135  146  156 ]  % 55
        [ (8)  sa2  136  147  157 ]  % 56
        [ (9)  sa3  137  148  158 ]  % 57
        [ (:)  pd3   la   la   la ]  % 58
        [  sb   sa  ( )  ( )  ( ) ]  % 59
        [  sc   sc  lkc   sc   sc ]  % 60
        [  sd   sd   sd  lkd   sd ]  % 61
        [  se   se   se   se  lke ]  % 62
        [  lb   la   lb   lb   lb ]  % 63
    ] def 
    
    % Invert charmaps to give character to value maps for each state
    /charvals [ 64 dict 64 dict 64 dict 64 dict 64 dict ] def
    0 1 charmaps length 1 sub {
        /i exch def
        /encs charmaps i get def
        0 1 4 {
            /j exch def
            encs j get dup type /stringtype eq {0 get} if  % convert string to ASCII if required
            charvals j get exch i put 
        } for
    } for
    /seta charvals 0 get def
    /setb charvals 1 get def
    /setc charvals 2 get def
    /setd charvals 3 get def
    /sete charvals 4 get def

    % Compute numeric runlengths
    /nseq [ msglen 1 add {0} repeat ] def
    msglen 1 sub -1 0 {
        /i exch def
        msg i get dup 48 ge exch 57 le and {
            nseq i nseq i 1 add get 1 add put
        } {
            nseq i 0 put
        } ifelse
    } for
    /nseq nseq 0 msglen getinterval def

    % Encode the message from ASCII to codewords 
    /prefixinset {
        0 {
            2 copy exch length ge {exit} if 
            2 copy get 3 index exch known {1 add} {exit} ifelse
        } loop
        exch pop exch pop
    } bind def
    
    /enc {
        exch get out exch j exch put
        /j j 1 add def
    } bind def

    /out 144 array def
    /i 0 def /j 0 def /cset (seta) def
    { % loop
        % Exit when no characters remain latching back to A if necessary
        i msglen eq {
            cset (seta) ne cset (setb) ne and {
                la cset load enc
                /cset (seta) def
            } if
            exit
        } if
        { % not a loop but common exit point
    
            % If 9 numerals available then use NS
            nseq i get 9 ge {
                msg i 9 getinterval cvi 4 { dup 63 and exch -6 bitshift } repeat cset load ns get
                0 2 10 {index} for 6 array astore 7 1 roll 6 {pop} repeat
                out exch j exch putinterval
                /i i 9 add def
                /j j 6 add def
                exit
            } if
    
            % Read next three characters
            /char1 msg i get def
            /char2 i 1 add msglen lt {msg i 1 add get} {-99} ifelse def
            /char3 i 2 add msglen lt {msg i 2 add get} {-99} ifelse def
    
            % If current mode is sufficient then directly encode
            cset load char1 known { 
                char1 cset load enc
                /i i 1 add def
                exit
            } if
    
            % For switching from A to B
            cset (seta) eq setb char1 known and {
                setb char2 known {
                    lb seta enc
                    /cset (setb) def
                } {
                    sb seta enc
                    char1 setb enc
                    /i i 1 add def
                } ifelse
                exit
            } if
    
            % For switching from B to A encode according to length of prefix
            cset (setb) eq seta char1 known and {
                /p seta msg i 4 msglen i sub 2 copy gt {exch} if pop getinterval prefixinset def
                p 1 eq {
                    sa setb enc
                    char1 seta enc
                    /i i 1 add def
                } if
                p 2 eq {
                    sa2 setb enc
                    char1 seta enc
                    char2 seta enc
                    /i i 2 add def 
                } if
                p 3 eq {
                    sa3 setb enc
                    char1 seta enc
                    char2 seta enc
                    char3 seta enc
                    /i i 3 add def 
                } if
                p 4 ge {
                    la setb enc
                    /cset (seta) def
                } if
                exit
            } if
    
            % If character is in A or B then directly latch
            seta char1 known {
                la cset load enc
                /cset (seta) def
                exit
            } if      
            setb char1 known {
                lb cset load enc
                /cset (setb) def
                exit
            } if      
     
            % Determine which one of sets C, D or E the character is in
            setc char1 known {/setx (setc) def /sx sc def /lkx lkc def} if
            setd char1 known {/setx (setd) def /sx sd def /lkx lkd def} if
            sete char1 known {/setx (sete) def /sx se def /lkx lke def} if
    
            % Encode according to the length of the prefix
            /p setx load msg i 4 msglen i sub 2 copy gt {exch} if pop getinterval prefixinset def
            p 1 eq {
                sx cset load enc
                char1 setx load enc
                /i i 1 add def
            } if
            p 2 eq {
                sx cset load enc
                char1 setx load enc
                sx cset load enc
                char2 setx load enc
                /i i 2 add def
            } if
            p 3 eq {
                sx cset load enc
                char1 setx load enc
                sx cset load enc
                char2 setx load enc
                sx cset load enc
                char3 setx load enc
                /i i 3 add def
            } if
            p 4 ge {
                sx cset load enc
                lkx setx load enc
                /cset setx def 
            } if
    
            exit
        } loop  % out
    } loop
    /encmsg out 0 j getinterval def
    /padval cset load pad get def 

    % Prefix the encoded message with the structured append insert
    /sami [] def
    sam -1 ne {
        /sami 2 array def
        sami 0 seta pad get put 
        sami 1 sam 10 idiv 1 sub 8 mul sam 10 mod 1 sub add put
    } if
    /encmsg [ sami aload pop encmsg aload pop ] def

    % Derive the primary and secondary codewords for modes 2 and 3
    mode 2 eq mode 3 eq or {

        % Calculate the fixed-width binary values for the mode, postcode, country code and service
        /mdb (0000) 4 string copy dup mode cvi 2 4 string cvrs dup length 4 exch sub exch putinterval def
        /ccb (0000000000) 10 string copy dup ccode cvi 2 10 string cvrs dup length 10 exch sub exch putinterval def
        /scb (0000000000) 10 string copy dup scode cvi 2 10 string cvrs dup length 10 exch sub exch putinterval def
        /pcb (000000000000000000000000000000000000) 36 string copy def
        mode 2 eq {
            % For numeric postcode, first six bits represent length and remaining 30 bits the value
            pcb pcode length 2 6 string cvrs dup length 6 exch sub exch putinterval
            pcb pcode cvi 2 30 string cvrs dup length 36 exch sub exch putinterval
        } {  % mode=3
            % For alphanumeric postcode, trim or pad with spaces to 6 chars and encode to binary
            /pccw [ 
                (      ) 6 string copy dup 0 pcode length 6 gt {pcode 0 6 getinterval} {pcode} ifelse putinterval 
                {seta exch get} forall
            ] def
            0 1 5 {
                /i exch def
                pcb pccw i get 2 6 string cvrs dup length 6 i mul 6 add exch sub exch putinterval
            } for
        } ifelse

        % Convolute the binary values into the structured carrier message
        /scm 60 string def
        scm 2  mdb putinterval
        scm 38 pcb 0  4 getinterval putinterval
        scm 30 pcb 4  6 getinterval putinterval
        scm 24 pcb 10 6 getinterval putinterval
        scm 18 pcb 16 6 getinterval putinterval
        scm 12 pcb 22 6 getinterval putinterval
        scm 6  pcb 28 6 getinterval putinterval
        scm 0  pcb 34 2 getinterval putinterval
        scm 52 ccb 0  2 getinterval putinterval
        scm 42 ccb 2  6 getinterval putinterval
        scm 36 ccb 8  2 getinterval putinterval
        scm 54 scb 0  6 getinterval putinterval
        scm 48 scb 6  4 getinterval putinterval

        % Evaluate the structured carrier message as codewords
        /pri [ 0 0 0 0 0 0 0 0 0 0 ] def
        0 1 59 { 
            /i exch def
            /ps i 6 idiv def
            /ep 2 5 i 6 mod sub exp cvi scm i get 48 sub mul def
            pri ps pri ps get ep add put
        } for

        % Pad the encoded message into the secondary component
        /sec [ 84 {padval} repeat ] def
        sec 0 encmsg putinterval

    } if

    % Derive the primary and secondary codewords for modes 4, 5 and 6
    mode 4 eq mode 5 eq or mode 6 eq or mode -1 eq or {

        % If mode isn't specified then use EEC if message fits, otherwise SEC
        mode -1 eq {
            /mode encmsg length 77 le {5} {4} ifelse def
        } if

        % First symbol is the mode and the remainder are the padded message
        /cws [ mode 5 eq {78} {94} ifelse {padval} repeat ] def
        cws 0 mode put
        cws 1 encmsg putinterval

        % Fit the message into the primary and secondary components
        /pri cws 0 10 getinterval def
        /sec cws 10 cws length 10 sub getinterval def

    } if

    % Calculate the log and anti-log tables
    /rsalog [ 1 63 { dup 2 mul dup 64 ge {67 xor} if } repeat ] def
    /rslog 64 array def
    1 1 63 {dup rsalog exch get exch rslog 3 1 roll put} for

    % Function to calculate the product in the field
    /rsprod {
        2 copy 0 ne exch 0 ne and {
            rslog exch get exch rslog exch get add 63 mod rsalog exch get
        } {
            pop pop 0
        } ifelse
    } bind def

    % Generate error correction codewords
    /rscodes {

        /rsnum exch def
        /cwb exch def

        % Generate the coefficients
        /coeffs [ 1 rsnum {0} repeat ] def
        1 1 rsnum {
            /i exch def
            coeffs i coeffs i 1 sub get put
            i 1 sub -1 1 {
                /j exch def
                coeffs j coeffs j 1 sub get coeffs j get rsalog i get rsprod xor put
            } for
            coeffs 0 coeffs 0 get rsalog i get rsprod put
        } for
        /coeffs coeffs 0 coeffs length 1 sub getinterval def

        % Calculate the error correction codewords
        /ecb [ rsnum {0} repeat ] def
        0 1 cwb length 1 sub {
            /t exch cwb exch get ecb 0 get xor def
            ecb length 1 sub -1 0 {
                /i exch def
                /p ecb length i sub 1 sub def
                ecb p t coeffs i get rsprod put
                i 0 gt { ecb p ecb p 1 add get ecb p get xor put } if
            } for
        } for

        ecb

    } bind def

    % Split secondary codeword into odd and even elements
    /seco [ 0 2 sec length 1 sub { sec exch get } for ] def
    /sece [ 1 2 sec length 1 sub { sec exch get } for ] def

    % Calculate the parity codewords for secondary codeword parts based on mode
    /scodes sec length 84 eq {20} {28} ifelse def  % SEC/EEC mode
    /secochk seco scodes rscodes def
    /secechk sece scodes rscodes def

    % Recompose the secondary parity codewords
    /secchk [ 0 1 scodes 1 sub { dup secochk exch get exch secechk exch get } for ] def

    % Concatinate the data into final codewords
    /codewords [
        pri aload pop 
        pri 10 rscodes aload pop
        sec aload pop 
        secchk aload pop
    ] def

    % Convert the codewords into module bits
    /mods [ 864 {0} repeat ] def
    0 1 143 {
        /i exch def
        /cw [ codewords i get 2 6 string cvrs {48 sub} forall ] def
        mods 6 i mul 6 cw length sub add cw putinterval
    } for

    % Maps modules to pixels in the grid
    /modmap [
        469 529 286 316 347 346 673 672 703 702 647 676 283 282 313 312 370 610 618 379 
        378 409 408 439 705 704 559 589 588 619 458 518 640 701 675 674 285 284 315 314 
        310 340 531 289 288 319 349 348 456 486 517 516 471 470 369 368 399 398 429 428 
        549 548 579 578 609 608 649 648 679 678 709 708 639 638 669 668 699 698 279 278 
        309 308 339 338 381 380 411 410 441 440 561 560 591 590 621 620 547 546 577 576 
        607 606 367 366 397 396 427 426 291 290 321 320 351 350 651 650 681 680 711 710 
        1   0   31  30  61  60  3   2   33  32  63  62  5   4   35  34  65  64  7   6   
        37  36  67  66  9   8   39  38  69  68  11  10  41  40  71  70  13  12  43  42  
        73  72  15  14  45  44  75  74  17  16  47  46  77  76  19  18  49  48  79  78  
        21  20  51  50  81  80  23  22  53  52  83  82  25  24  55  54  85  84  27  26  
        57  56  87  86  117 116 147 146 177 176 115 114 145 144 175 174 113 112 143 142 
        173 172 111 110 141 140 171 170 109 108 139 138 169 168 107 106 137 136 167 166 
        105 104 135 134 165 164 103 102 133 132 163 162 101 100 131 130 161 160 99  98  
        129 128 159 158 97  96  127 126 157 156 95  94  125 124 155 154 93  92  123 122 
        153 152 91  90  121 120 151 150 181 180 211 210 241 240 183 182 213 212 243 242 
        185 184 215 214 245 244 187 186 217 216 247 246 189 188 219 218 249 248 191 190 
        221 220 251 250 193 192 223 222 253 252 195 194 225 224 255 254 197 196 227 226 
        257 256 199 198 229 228 259 258 201 200 231 230 261 260 203 202 233 232 263 262 
        205 204 235 234 265 264 207 206 237 236 267 266 297 296 327 326 357 356 295 294 
        325 324 355 354 293 292 323 322 353 352 277 276 307 306 337 336 275 274 305 304 
        335 334 273 272 303 302 333 332 271 270 301 300 331 330 361 360 391 390 421 420 
        363 362 393 392 423 422 365 364 395 394 425 424 383 382 413 412 443 442 385 384 
        415 414 445 444 387 386 417 416 447 446 477 476 507 506 537 536 475 474 505 504 
        535 534 473 472 503 502 533 532 455 454 485 484 515 514 453 452 483 482 513 512 
        451 450 481 480 511 510 541 540 571 570 601 600 543 542 573 572 603 602 545 544 
        575 574 605 604 563 562 593 592 623 622 565 564 595 594 625 624 567 566 597 596 
        627 626 657 656 687 686 717 716 655 654 685 684 715 714 653 652 683 682 713 712 
        637 636 667 666 697 696 635 634 665 664 695 694 633 632 663 662 693 692 631 630 
        661 660 691 690 721 720 751 750 781 780 723 722 753 752 783 782 725 724 755 754 
        785 784 727 726 757 756 787 786 729 728 759 758 789 788 731 730 761 760 791 790 
        733 732 763 762 793 792 735 734 765 764 795 794 737 736 767 766 797 796 739 738 
        769 768 799 798 741 740 771 770 801 800 743 742 773 772 803 802 745 744 775 774 
        805 804 747 746 777 776 807 806 837 836 867 866 897 896 835 834 865 864 895 894 
        833 832 863 862 893 892 831 830 861 860 891 890 829 828 859 858 889 888 827 826 
        857 856 887 886 825 824 855 854 885 884 823 822 853 852 883 882 821 820 851 850 
        881 880 819 818 849 848 879 878 817 816 847 846 877 876 815 814 845 844 875 874 
        813 812 843 842 873 872 811 810 841 840 871 870 901 900 931 930 961 960 903 902 
        933 932 963 962 905 904 935 934 965 964 907 906 937 936 967 966 909 908 939 938 
        969 968 911 910 941 940 971 970 913 912 943 942 973 972 915 914 945 944 975 974 
        917 916 947 946 977 976 919 918 949 948 979 978 921 920 951 950 981 980 923 922 
        953 952 983 982 925 924 955 954 985 984 927 926 957 956 987 986 58  89  88  118 
        149 148 178 209 208 238 269 268 298 329 328 358 389 388 418 449 448 478 509 508 
        538 569 568 598 629 628 658 689 688 718 749 748 778 809 808 838 869 868 898 929 
        928 958 989 988
    ] def

    % Lookup pixels for enabled modules from modmap
    /pixs 864 array def
    /j 0 def
    0 1 mods length 1 sub {
        /i exch def
        mods i get 1 eq {
            pixs j modmap i get put
            /j j 1 add def
        } if
    } for
    /pixs [ pixs 0 j getinterval {} forall 28 29 280 281 311 457 488 500 530 670 700 677 707 ] def

    % Return the arguments
    <<
    /ren //renmaximatrix
    /pixs pixs
    /opt options
    >>

    dontdraw not //renmaximatrix if

    end

} bind def
/maxicode dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER maxicode--

% --BEGIN ENCODER azteccode--
% --DESC: Aztec Code
% --EXAM: This is Aztec Code
% --EXOP: format=full
% --RNDR: renmatrix
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/azteccode {

    20 dict begin

    /options exch def
    /barcode exch def

    /dontdraw false def
    /format (unset) def    % full, compact or rune
    /readerinit false def
    /layers -1 def
    /eclevel 23 def
    /ecaddchars 3 def
    /raw false def
    /parse false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
 
    /layers layers cvi def
    /eclevel eclevel cvr def
    /ecaddchars ecaddchars cvi def

    % Parse ordinals of the form ^NNN to ASCII
    parse {
        /msg barcode length string def
        /j 0 def
        barcode
        { % loop
            (^) search {
                dup msg exch j exch putinterval
                length j add 1 add /j exch def
                pop
                dup 0 3 getinterval cvi msg exch j 1 sub exch put
                dup length 3 sub 3 exch getinterval
            } {
                dup msg exch j exch putinterval
                length j add /j exch def
                /barcode msg 0 j getinterval def
                exit
            } ifelse 
        } loop
    } if

    % Convert from input into message bitstream
    /msgbits () def 
    format (rune) ne raw and {/msgbits barcode def} if 
    format (rune) ne raw not and {  % Simple autoencoder from input to bitstream using byte mode only

        % Determine the character count
        /barlen barcode length def
        barlen 31 le {
            (00000) 5 string copy dup barlen 2 5 string cvrs
            dup length 5 exch sub exch putinterval
            /cc exch def
        } {
            (0000000000000000) 16 string copy dup barlen 31 sub 2 16 string cvrs
            dup length 16 exch sub exch putinterval
            /cc exch def
        } ifelse
        /cclen cc length def

        % Create the bitstream as byte_mode_id character_count data_bytes
        /msgbits 5 cclen add barlen 8 mul add string def
        msgbits 0 (11111) putinterval
        msgbits 5 cc putinterval
        0 1 barlen 1 sub {
            /i exch def
            (00000000) 8 string copy dup barcode i get cvi 2 8 string cvrs dup length 8 exch sub exch putinterval 
            msgbits 5 cclen add i 8 mul add 3 -1 roll putinterval
        } for

    } if

    % Lookup the most appropriate symbol specification 
    /metrics [
        [ (rune)     0 0    0  6 ]  % Special metric for rune symbols
        [ (compact)  1 1   17  6 ] [ (full)     1 1   21  6 ] [ (compact)  2 0   40  6 ]
        [ (full)     2 1   48  6 ] [ (compact)  3 0   51  8 ] [ (full)     3 1   60  8 ]
        [ (compact)  4 0   76  8 ] [ (full)     4 1   88  8 ] [ (full)     5 1  120  8 ]
        [ (full)     6 1  156  8 ] [ (full)     7 1  196  8 ] [ (full)     8 1  240  8 ]
        [ (full)     9 1  230 10 ] [ (full)    10 1  272 10 ] [ (full)    11 1  316 10 ]
        [ (full)    12 1  364 10 ] [ (full)    13 1  416 10 ] [ (full)    14 1  470 10 ]
        [ (full)    15 1  528 10 ] [ (full)    16 1  588 10 ] [ (full)    17 1  652 10 ]
        [ (full)    18 1  720 10 ] [ (full)    19 1  790 10 ] [ (full)    20 1  864 10 ]
        [ (full)    21 1  940 10 ] [ (full)    22 1 1020 10 ] [ (full)    23 0  920 12 ]
        [ (full)    24 0  992 12 ] [ (full)    25 0 1066 12 ] [ (full)    26 0 1144 12 ]
        [ (full)    27 0 1224 12 ] [ (full)    28 0 1306 12 ] [ (full)    29 0 1392 12 ]
        [ (full)    30 0 1480 12 ] [ (full)    31 0 1570 12 ] [ (full)    32 0 1664 12 ]
    ] def

    /i 0 def
    { % loop
        /m metrics i get def
        /frmt m 0 get def                          % Format of the symbol
        /mlyr m 1 get def                          % Data layers
        /icap m 2 get def                          % Reader initialisation capable
        /ncws m 3 get def                          % Total of codewords
        /bpcw m 4 get def                          % Bits per codeword
        /numecw ncws eclevel mul 100 div ecaddchars add ceiling cvi def
        msgbits length 0 eq {/numecw 0 def} if     % Error correction codewords 
        /numdcw ncws numecw sub def                % Data codewords
        /okay true def
        format (unset) ne format frmt ne and {/okay false def} if
        readerinit icap 1 ne and {/okay false def} if
        layers -1 ne layers mlyr ne and {/okay false def} if 
        msgbits length bpcw div ceiling cvi numdcw gt {/okay false def} if
        okay {exit} if
        /i i 1 add def
    } loop
    /layers mlyr def
    /format frmt def

    % Expand message bits into codewords avoiding codewords with all zeros or all ones
    /allzero {dup length (000000000000) 0 3 -1 roll getinterval eq} bind def
    /allones {dup length (111111111111) 0 3 -1 roll getinterval eq} bind def
    /cws ncws array def
    /m 0 def /c 0 def
    {
        msgbits length m le {exit} if
        msgbits length m sub bpcw ge {
            /cwb msgbits m bpcw 1 sub getinterval def        % All but last bit
            /cwf msgbits m bpcw add 1 sub 1 getinterval def  % Last bit
            cwb allzero {/cwf (1) def /m m 1 sub def} if     % Flip last bit to avoid zeros
            cwb allones {/cwf (0) def /m m 1 sub def} if     % Flip last bit to avoid ones
            % Concatinate the bits 
            12 string dup 0 cwb putinterval 
            dup bpcw 1 sub cwf putinterval
            0 bpcw getinterval
            /cwb exch def
        } {  %  Final codeword
            /cwb msgbits m msgbits length m sub getinterval def
            /cwb (111111111111) 12 string copy dup 0 cwb putinterval 0 bpcw getinterval def
            cwb allones {cwb cwb length 1 sub (0) putinterval} if  % Prevent all ones
        } ifelse
        % Conversion of binary data into byte array
        /cw 0 def
        0 1 bpcw 1 sub {
            /i exch def
            /cw cw 2 bpcw i sub 1 sub exp cvi cwb i get 48 sub mul add def
        } for
        cws c cw put
        /m m bpcw add def 
        /c c 1 add def
    } loop    
    /cws cws 0 c getinterval def

    % Reed-Solomon algorithm
    /rscodes {

        /rspm exch def
        /rsgf exch def
        /rsnc exch def
        /rscws exch def

        % Calculate the log and anti-log tables
        /rsalog [ 1 rsgf 1 sub { dup 2 mul dup rsgf ge {rspm xor} if } repeat ] def
        /rslog rsgf array def
        1 1 rsgf 1 sub {dup rsalog exch get exch rslog 3 1 roll put} for

        % Function to calculate the product in the field
        /rsprod {
            2 copy 0 ne exch 0 ne and {
                rslog exch get exch rslog exch get add rsgf 1 sub mod rsalog exch get
            } {
                pop pop 0
            } ifelse
        } bind def

        % Generate the coefficients
        /coeffs [ 1 rsnc {0} repeat ] def
        1 1 rsnc {
            /i exch def 
            coeffs i coeffs i 1 sub get put
            i 1 sub -1 1 {
                /j exch def
                coeffs j coeffs j 1 sub get coeffs j get rsalog i get rsprod xor put
            } for 
            coeffs 0 coeffs 0 get rsalog i get rsprod put
        } for

        % Extend the input with the error correction values
        /nd rscws length def
        /rscws [ rscws {} forall rsnc {0} repeat 0 ] def
        0 1 nd 1 sub {
            /k exch rscws exch get rscws nd get xor def 
            0 1 rsnc 1 sub {
                /j exch def 
                rscws nd j add rscws nd j add 1 add get k coeffs rsnc j sub 1 sub get rsprod xor put
            } for 
        } for

        % Return all but the last codeword
        rscws 0 rscws length 1 sub getinterval

    } bind def

    % Create the codewords and bit string for the mode
    format (full) eq {
        /mode layers 1 sub 11 bitshift cws length 1 sub add def
        readerinit {/mode mode 2#1000000000000000 or def} if
        /mode [
            mode 2#1111000000000000 and -12 bitshift
            mode 2#0000111100000000 and -8 bitshift
            mode 2#0000000011110000 and -4 bitshift
            mode 2#0000000000001111 and
        ] def
        /mode mode 6 16 19 rscodes def 
    } if
    format (compact) eq {
        /mode layers 1 sub 6 bitshift cws length 1 sub add def
        readerinit {/mode mode 2#10000000 or def} if 
        /mode [
            mode 2#11110000 and -4 bitshift
            mode 2#00001111 and
        ] def
        /mode mode 5 16 19 rscodes def
    } if
    format (rune) eq {
        /mode barcode cvi def
        /mode [
            mode 2#11110000 and -4 bitshift
            mode 2#00001111 and
        ] def
        /mode mode 5 16 19 rscodes def
        /mode [mode {2#1010 xor} forall] def  % Invert alternate bits
    } if
    /modebits mode length 4 mul string def
    0 1 modebits length 1 sub {modebits exch (0) putinterval} for
    0 1 mode length 1 sub {
        /i exch def
        modebits mode i get 2 4 string cvrs dup length 4 exch sub 4 i mul add exch putinterval 
    } for

    % Extend the data codewords with error correction codewords to create the bit string for the data
    /rsparams [
        [] [] [] [] [] [] 
        [ 64 67 ]      % 6-bit codewords 
        []
        [ 256 301 ]    % 8-bit codewords
        [] 
        [ 1024 1033 ]  % 10-bit codewords
        []
        [ 4096 4201 ]  % 12-bit codewords
    ] def
    /cws cws ncws cws length sub rsparams bpcw get {} forall rscodes def
    format (full) eq {
        /databits layers layers mul 16 mul layers 112 mul add string def 
    } {
        /databits layers layers mul 16 mul layers 88 mul add string def 
    } ifelse
    0 1 databits length 1 sub {databits exch (0) putinterval} for
    0 1 ncws 1 sub { 
        /i exch def
        databits cws i get 2 bpcw string cvrs 
        dup length bpcw exch sub bpcw i mul add databits length ncws bpcw mul sub add 
        exch putinterval 
    } for

    % Move to a point in the cartesian plane centered on the bullseye
    /cmv {size mul sub mid add} bind def

    % Move to a bit position within a layer
    /lmv {
        /lbit exch def
        /llyr exch def
        /lwid fw llyr 4 mul add def
        /ldir lbit 2 idiv lwid idiv def
        ldir 0 eq {  % Top
            lwid 1 sub 2 idiv neg 1 add lbit 2 idiv lwid mod add 
            fw 1 sub 2 idiv llyr 2 mul add lbit 2 mod add
            cmv
        } if
        ldir 1 eq {  % Right
            fw 2 idiv llyr 2 mul add lbit 2 mod add
            lwid 1 sub 2 idiv 1 sub lbit 2 idiv lwid mod sub
            cmv
        } if
        ldir 2 eq {  % Bottom
            lwid 2 idiv neg 1 add lbit 2 idiv lwid mod add neg
            fw 2 idiv llyr 2 mul add lbit 2 mod add neg
            cmv
        } if
        ldir 3 eq {  % Left
            fw 1 sub 2 idiv llyr 2 mul add lbit 2 mod add neg
            lwid 2 idiv 1 sub lbit 2 idiv lwid mod sub neg
            cmv
        } if
    } bind def

    % Create the pixel map
    % For full symbols we disregard the reference grid at this stage
    format (full) eq {/fw 12 def} {/fw 9 def} ifelse
    /size fw layers 4 mul add 2 add def 
    /pixs [size size mul {-1} repeat] def
    /mid size 1 sub 2 idiv size mul size 1 sub 2 idiv add def

    % Data layers
    /i 0 def
    1 1 layers {
        /layer exch def
        0 1 fw layer 4 mul add 8 mul 1 sub {
            /pos exch def
            pixs layer pos lmv databits databits length i sub 1 sub get 48 sub put
            /i i 1 add def
        } for
    } for

    % For full symbols expand the pixel map by inserting the reference grid
    format (full) eq {
        /fw 13 def
        /size fw layers 4 mul add 2 add layers 10.5 add 7.5 div 1 sub cvi 2 mul add def
        /mid size size mul 2 idiv def
        /npixs [size size mul {-2} repeat] def
        0 16 size 2 idiv {
            /i exch def
            0 1 size 1 sub {
                /j exch def
                npixs size 2 idiv neg j add i cmv     [size 2 idiv j add i add 1 add 2 mod] putinterval
                npixs size 2 idiv neg j add i neg cmv [size 2 idiv j add i add 1 add 2 mod] putinterval
                npixs i size 2 idiv neg j add cmv     [size 2 idiv j add i add 1 add 2 mod] putinterval
                npixs i neg size 2 idiv neg j add cmv [size 2 idiv j add i add 1 add 2 mod] putinterval
            } for
        } for 
        /j 0 def
        0 1 npixs length 1 sub {
            /i exch def
            npixs i get -2 eq {
                npixs i pixs j get put
                /j j 1 add def
            } if
        } for
        /pixs npixs def
    } if

    % Finder pattern
    /fw fw 2 idiv def
    fw neg 1 fw {
        /i exch def
        fw neg 1 fw {
            /j exch def
            pixs i j cmv
            i abs j abs gt {i abs} {j abs} ifelse 1 add 2 mod
            put
        } for
    } for

    % Orientation bits
    [ [ fw 1 add neg   fw             1 ] [ fw 1 add neg   fw 1 add       1 ]
      [ fw neg         fw 1 add       1 ] [ fw 1 add       fw 1 add       1 ]
      [ fw 1 add       fw             1 ] [ fw 1 add       fw neg         1 ]
      [ fw             fw 1 add       0 ] [ fw 1 add       fw 1 add neg   0 ]
      [ fw             fw 1 add neg   0 ] [ fw neg         fw 1 add neg   0 ]
      [ fw 1 add neg   fw 1 add neg   0 ] [ fw 1 add neg   fw neg         0 ]
    ] {pixs exch {} forall 3 1 roll cmv exch put} forall

    % Mode ring
    format (full) eq {
        /modemap [ 
            [-5  7] [-4  7] [-3  7] [-2  7] [-1  7] [ 1  7] [ 2  7] [ 3  7] [ 4  7] [ 5  7]
            [ 7  5] [ 7  4] [ 7  3] [ 7  2] [ 7  1] [ 7 -1] [ 7 -2] [ 7 -3] [ 7 -4] [ 7 -5]
            [ 5 -7] [ 4 -7] [ 3 -7] [ 2 -7] [ 1 -7] [-1 -7] [-2 -7] [-3 -7] [-4 -7] [-5 -7]
            [-7 -5] [-7 -4] [-7 -3] [-7 -2] [-7 -1] [-7  1] [-7  2] [-7  3] [-7  4] [-7  5]
        ] def
    } {
        /modemap [
            [-3  5] [-2  5] [-1  5] [ 0  5] [ 1  5] [ 2  5] [ 3  5]
            [ 5  3] [ 5  2] [ 5  1] [ 5  0] [ 5 -1] [ 5 -2] [ 5 -3]
            [ 3 -5] [ 2 -5] [ 1 -5] [ 0 -5] [-1 -5] [-2 -5] [-3 -5]
            [-5 -3] [-5 -2] [-5 -1] [-5  0] [-5  1] [-5  2] [-5  3]
        ] def
    } ifelse
    0 1 modemap length 1 sub {
        /i exch def
        pixs modemap i get {} forall cmv modebits i get 48 sub put
    } for

    <<
    /ren //renmatrix
    /pixs pixs
    /pixx size
    /pixy size
    /height size 2 mul 72 div
    /width size 2 mul 72 div
    /opt options
    >>

    dontdraw not //renmatrix if

    end

} bind def
/azteccode dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER azteccode--

% --BEGIN ENCODER codeone--
% --DESC: Code One
% --EXAM: Code One
% --EXOP: version=B
% --RNDR: renmatrix
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/codeone {

    20 dict begin

    /options exch def
    /barcode exch def

    /dontdraw false def
    /version (unset) def
    /encoding (ascii) def
    /raw false def
    /parse false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /stype version 0 1 getinterval (S) eq def
    stype {/raw true def} if

    % Parse ordinals of the form ^NNN to ASCII
    parse {
        /msg barcode length string def
        /j 0 def
        barcode
        { % loop
            (^) search {
                dup msg exch j exch putinterval
                length j add 1 add /j exch def
                pop
                dup 0 3 getinterval cvi msg exch j 1 sub exch put
                dup length 3 sub 3 exch getinterval
            } {
                dup msg exch j exch putinterval
                length j add /j exch def
                /barcode msg 0 j getinterval def
                exit
            } ifelse 
        } loop
    } if

    /barlen barcode length def

    raw {/encoding (raw) def} if

    encoding (raw) eq {
        /cws barlen array def
        /i 0 def /j 0 def
        { % loop
            i barlen eq {exit} if
            /cw barcode i 1 add 3 getinterval cvi def
            cws j cw put
            /i i 4 add def
            /j j 1 add def
        } loop
        /cws cws 0 j getinterval def
    } if

    encoding (ascii) eq {
        /cws barlen 2 mul array def
        /i 0 def /j 0 def
        { % loop
            i barlen eq {exit} if
            /char barcode i get def
            char 48 ge char 57 le and i barlen 1 sub lt and {
                barcode i 1 add get dup 48 ge exch 57 le and {  % Digit pair
                    cws j barcode i 2 getinterval cvi 130 add put
                    /i i 2 add def
                    /j j 1 add def
                } {  % Singular digit
                    cws j char 1 add put
                    /i i 1 add def
                    /j j 1 add def
                } ifelse
            } { char 127 le {  % ASCII
                cws j char 1 add put
                /i i 1 add def
                /j j 1 add def
            } {  % Extended ASCII
                cws j 235 put
                cws j 1 add char 127 sub put
                /i i 1 add def
                /j j 2 add def
            } ifelse } ifelse
        } loop
        /cws cws 0 j getinterval def
    } if

    % Basic metrics for the each symbol
    %     ver    row col dcol dcws rscw rsbl  ro ri rl
    /metrics [
        [ (A)     16  18   16   10   10    1   4 99  6 ]
        [ (B)     22  22   20   19   16    1   4 99  8 ]
        [ (C)     28  32   28   44   26    1   4 22 11 ]
        [ (D)     40  42   36   91   44    1   4 16 16 ]
        [ (E)     52  54   48  182   70    1   4 22 22 ]
        [ (F)     70  76   68  370  140    2   4 22 31 ]
        [ (G)    104  98   88  732  280    4   6 21 47 ]
        [ (H)    148 134  120 1480  560    8   6 20 69 ]
        [ (S-10)   8  11   10    4    4    1  99 99 99 ]
        [ (S-20)   8  21   20    8    8    1  99 99 99 ]
        [ (S-30)   8  31   30   12   12    1  99 99 99 ]
        [ (T-16)  16  17   16   10   10    1  99 99 99 ]
        [ (T-32)  16  33   32   24   16    1  99 99 99 ]
        [ (T-48)  16  49   48   38   22    1  99 99 99 ]
    ] def

    % Select metrics of an appropriate symbol
    /i 0 def
    { % loop
        /m metrics i get def
        /vers m 0 get def           % Version of symbol
        /rows m 1 get def           % Rows in symbol
        /cols m 2 get def           % Columns in symbol
        /dcol m 3 get def           % Data columns in symbol
        /dcws m 4 get def           % Data codewords in symbol
        /rscw m 5 get def           % Error correction codewords 
        /rsbl m 6 get def           % Error correction blocks
        /riso m 7 get def           % Riser offset
        /risi m 8 get def           % Riser interval
        /risl m 9 get def           % Riser length
        /dcpb dcws rsbl idiv def    % Data codewords per block
        /ecpb rscw rsbl idiv def    % Error codewords per block
        /okay true def
        version (unset) ne version vers ne and {/okay false def} if  % The version must match that supplied
        cws length dcws gt {/okay false def} if
        okay {exit} if
        /i i 1 add def
    } loop

    % Extend cws to ncws codewords by addition of pad characters
    stype not {
        /cws [ cws aload pop dcws cws length sub {129} repeat ] def
    } if

    % De-interleave the codewords into blocks
    /cwbs rsbl array def  % Array of data codeword blocks
    /ecbs rsbl array def  % Array of error correction blocks
    0 1 rsbl 1 sub {
        /i exch def
        /cwb dcpb array def 
        0 1 dcpb 1 sub {
            /j exch def
            cwb j cws j rsbl mul i add get put
        } for 
        cwbs i cwb put
    } for

    % Log and anti-log tables and function to calculate product in the field
    /gf stype {32} {256} ifelse def
    /gf-1 gf 1 sub def
    /pm stype {37} {301} ifelse def
    /rsalog [ 1 gf-1 { dup 2 mul dup gf ge {pm xor} if } repeat ] def
    /rslog gf array def
    1 1 gf-1 {dup rsalog exch get exch rslog 3 1 roll put} for
    /rsprod {
        2 copy 0 ne exch 0 ne and { 
            rslog exch get exch rslog exch get add gf-1 mod rsalog exch get
        } {
            pop pop 0
        } ifelse
    } bind def

    % Generate the coefficients for the Reed-Solomon algorithm
    /coeffs [ 1 ecpb {0} repeat ] def
    0 1 ecpb 1 sub {
        /i exch def 
        coeffs i 1 add coeffs i get put
        i -1 1 {
            /j exch def
            coeffs j coeffs j 1 sub get coeffs j get rsalog i get rsprod xor put
        } for 
        coeffs 0 coeffs 0 get rsalog i get rsprod put
    } for
    /coeffs coeffs 0 coeffs length 1 sub getinterval def

    % Reed-Solomon algorithm to derive the error correction codewords
    0 1 cwbs length 1 sub {
        /i exch def
        /rscws [ cwbs i get aload pop ecpb {0} repeat ] def
        0 1 dcpb 1 sub {
            /m exch def
            /k rscws m get def
            0 1 ecpb 1 sub {
                /j exch def
                rscws m j add 1 add coeffs ecpb j sub 1 sub get k rsprod rscws m j add 1 add get xor put
            } for
        } for
        ecbs i rscws dcpb ecpb getinterval put
    } for

    % Extend codewords with the interleaved error correction codes
    /cws [ cws aload pop rscw {0} repeat ] def
    0 1 rscw 1 sub {
        /i exch def
        cws dcws i add ecbs i rsbl mod get i rsbl idiv get put
    } for

    % Module matrix for layout of the codewords
    /mmat dcws rscw add stype {5} {8} ifelse mul array def
    /r 0 def /c 0 def
    0 stype {2} {1} ifelse cws length 1 sub {
        /i exch def
        stype not {
            (00000000) 8 string copy dup cws i get 2 8 string cvrs
            dup length 8 exch sub exch putinterval [ exch {48 sub} forall ]
            dup 0 4 getinterval /top exch def
            4 4 getinterval /bot exch def
        } {
            (00000) 5 string copy dup cws i get 2 5 string cvrs
            dup length 5 exch sub exch putinterval [ exch {48 sub} forall ]
            /c1 exch def
            (00000) 5 string copy dup cws i 1 add get 2 5 string cvrs
            dup length 5 exch sub exch putinterval [ exch {48 sub} forall ]
            /c2 exch def
            /top [ c1 0 3 getinterval aload pop c2 0 2 getinterval aload pop ] def
            /bot [ c1 3 2 getinterval aload pop c2 2 3 getinterval aload pop ] def
        } ifelse
        mmat r dcol mul c add top putinterval
        mmat r 1 add dcol mul c add bot putinterval
        /c c top length add def
        c dcol eq {/c 0 def /r r 2 add def} if
    } for

    % Create bitmap and add finder patterns
    /mmv {cols mul add} bind def
    /pixs [ rows cols mul {-1} repeat ] def

    % Centre pattern
    /artifact [
        {cols {0} repeat} bind 
        {cols {1} repeat} bind 
        {0   cols 2 sub {1} repeat   0} bind 
        {0 1 cols 4 sub {0} repeat 1 0} bind 
        {cols 1 sub 2 idiv {-1} repeat 1 cols 1 sub 2 idiv {-1} repeat} bind 
        {cols 1 sub 2 idiv {-1} repeat 0 cols 1 sub 2 idiv {-1} repeat} bind 
        {1   cols 2 sub {0} repeat   1} bind 
        {1 0 cols 4 sub {1} repeat 0 1} bind 
    ] def
    /cpat <<
        /A (121343)
        /B (12134343)
        /C (12121343)
        /D (1213434343)
        /E (1212134343)
        /F (1212121343)
        /G (121213434343)
        /H (121212134343)
        /S (56661278)
        /T (5666666666127878)
    >> vers 0 1 getinterval get def
    pixs 0 rows cpat length sub 2 idiv mmv 
    [ cpat {artifact exch 49 sub get exec} forall ] putinterval

    % Risers
    0 1 risl 1 sub {
        /i exch def
        riso risi cols 1 sub {
            /j exch def
            [ 1 i 12 mod 0 eq {1} {0} ifelse ] dup
            pixs j i mmv
            3 -1 roll putinterval
            i risl 1 sub ne {
                pixs cols j sub 2 sub rows i sub 1 sub mmv 
                3 -1 roll putinterval
            } {pop} ifelse
        } for
    } for

    % Black dots
    <<
        /A [ [12 5] ]
        /B [ [16 7] ]
        /C [ [26 12] ]
        /D []
        /E [ [26 23] ]
        /F [ [26 32] [70 32] [26 34] [70 34] ]
        /G [ [27 48] [69 48] ]
        /H [ [26 70] [66 70] [106 70] [26 72] [66 72] [106 72] ]
        /S-10 []
        /S-20 [ [10 4] ]
        /S-30 [ [15 4] [15 6] ]
        /T-16 [ [8 10] ]
        /T-32 [ [16 10] [16 12] ]
        /T-48 [ [24 10] [24 12] [24 14] ]
    >> vers get {pixs exch aload pop mmv 1 put} forall

    % Place the modules onto a pixel map between alignment patterns
    /j 0 def
    0 1 pixs length 1 sub {
        /i exch def
        pixs i get -1 eq {
            pixs i mmat j get put
            /j j 1 add def
        } if
    } for

    % Return the arguments
    <<
    /ren //renmatrix
    /pixs pixs
    /pixx cols
    /pixy rows
    /height rows 72 div 2 mul
    /width cols 72 div 2 mul
    /opt options
    >>

    dontdraw not //renmatrix if

    end

} bind def
/codeone dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER codeone--

% --BEGIN ENCODER gs1-cc--
% --REQUIRES micropdf417 pdf417--
% --DESC: GS1 Composite 2D Component
% --EXAM: (01)95012345678903(3103)000123
% --EXOP: ccversion=b cccolumns=4
% --RNDR: renmatrix
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
dup /pdf417 dup /uk.co.terryburton.bwipp findresource put
dup /micropdf417 dup /uk.co.terryburton.bwipp findresource put
begin
/gs1-cc {
    
    20 dict begin            % Confine variables to local scope

    /options exch def  % We are given an option string
    /barcode exch def  % We are given a barcode string

    /dontdraw false def
    /ccversion (a) def
    /cccolumns -1 def
    /lintype () def
    /linwidth -1 def
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall
 
    /cccolumns cccolumns cvi def
    /linwidth linwidth cvi def

    % Select columns based on linear type
    cccolumns -1 eq {
        <<
            /ean13                  4
            /upca                   4
            /ean8                   3
            /upce                   2
            /gs1-128
                ccversion (c) ne {4} {linwidth 52 sub 17 idiv} ifelse
            /databaromni            4
            /databarstacked         2
            /databarstackedomni     2
            /databartruncated       4
            /databarlimited         3
            /databarexpanded        4
            /databarexpandedstacked 4
        >> lintype get /cccolumns exch def 
    } if

    % Expand ordinals of the form ^NNN to ASCII
    /expand {
        /in exch def
        /out in length string def
        /j 0 def
        in
        { % loop
            (^) search {
                dup out exch j exch putinterval
                length j add 1 add /j exch def
                pop
                dup 0 3 getinterval cvi out exch j 1 sub exch put
                dup length 3 sub 3 exch getinterval
            } {
                dup out exch j exch putinterval
                length j add /j exch def
                out 0 j getinterval exit
            } ifelse 
        } loop
    } bind def
 
    % Parse out AIs
    /ais [] def
    /aival 2 dict def
    barcode dup length 1 sub 1 exch getinterval
    {  % loop
        dup () eq {exit} if
        (\)) search pop
        exch pop
        exch (\() search {
            exch pop exch 3 1 roll 
        } { 
            () 3 1 roll
        }  ifelse
        [ ais aload pop counttomark 2 add index ] /ais exch def
        aival 3 1 roll expand put
    } loop
    pop
    
    % Method selection
    /isupper {dup 65 ge exch 90 le and} bind def  % A-Z
    /isnum0  {dup 48 ge exch 57 le and} bind def  % 0-9
    /isnum1  {dup 49 ge exch 57 le and} bind def  % 1-9
    {  % common exit
    
        % (10/11/17)...
        ais length 1 ge {
            ais 0 get (10) eq ais 0 get (11) eq or ais 0 get (17) eq or {
                -1 (10) exit
            } if
        } if

        % (90){0-3 digits not starting 0}{upper alpha}...
        ais length 1 ge {
            ais 0 get (90) eq {
                /v aival (90) get def
                v length 1 ge {
                   v 0 get isupper {
                       0 (11) exit
                   } if
                } if
                v length 2 ge {
                   v 0 get isnum1
                   v 1 get isupper and {
                       1 (11) exit
                   } if
                } if
                v length 3 ge {
                    v 0 get isnum1
                    v 1 get isnum0 and
                    v 2 get isupper and {
                        2 (11) exit
                    } if
                } if
                v length 4 ge {
                    v 0 get isnum1
                    v 1 get isnum0 and
                    v 2 get isnum0 and
                    v 3 get isupper and {
                        3 (11) exit
                    } if
                } if
            } if
        } if

        % Freeform
        -1 (0) exit
    
    } loop
    /method exch def
    /npre exch def

    /fnc1 -1 def /lnumeric -2 def /lalphanumeric -3 def /liso646 -4 def

    /tobin {
        string dup length 1 sub 0 exch 1 exch {1 index exch 48 put} for
        dup 3 -1 roll 2 2 index length string cvrs dup length 2 index length exch sub exch putinterval 
    } bind def
 
    /alpha <<
        65 1 90 {dup 65 sub 5 tobin} for
        48 1 57 {dup 4 add 6 tobin} for
        fnc1 (11111)
    >> def

    /numeric <<
        0 1 119 {
            dup (00) 2 string copy dup 3 -1 roll 11 2 string cvrs
            dup length 2 exch sub exch putinterval 
            dup 0 get 65 eq {dup 0 94 put} if 
            dup 1 get 65 eq {dup 1 94 put} if 
            exch 8 add
            (0000000) 7 string copy dup 3 -1 roll 2 7 string cvrs 
            dup length 7 exch sub exch putinterval
        } for
        lalphanumeric (0000)
    >> def
 
    /alphanumeric <<
        48 1 57 {dup 43 sub 5 tobin} for
        fnc1 (01111)
        65 1 90 {dup 33 sub 6 tobin} for
        42 (111010)
        44 1 47 {dup 15 add 6 tobin} for
        lnumeric (000)
        liso646 (00100)
    >> def
    
    /iso646 <<
        48 1 57 {dup 43 sub 5 tobin} for
        fnc1 (01111)
        65 1 90 {dup 1 sub 7 tobin} for
        97 1 122 {dup 7 sub 7 tobin} for
        33 (11101000)
        34 (11101001)
        37 1 47 {dup 197 add 8 tobin} for
        58 1 63 {dup 187 add 8 tobin} for
        95 (11111011)
        32 (11111100)
        lnumeric (000)
        lalphanumeric (00100)
    >> def

    method (10) eq {  % TODO: fixme
        ais 0 get (11) eq ais 0 get (17) eq or {
            aival ais 0 get get
            dup 0 2 getinterval cvi 384 mul exch
            dup 2 2 getinterval cvi 1 sub 32 mul exch
            4 2 getinterval cvi add add 
            (0000000000000000) 16 string copy dup 3 -1 roll 2 16 string cvrs
            dup length 16 exch sub exch putinterval
            [ 1 0
              4 -1 roll {48 sub} forall
              ais 0 get (11) eq {0} {1} ifelse
            ] /cdf exch def
            /ais ais 1 ais length 1 sub getinterval def
        } {
            /cdf [ 1 0  1 1 ] def
        } ifelse
        ais length 0 ne {
            ais 0 get (10) eq {
                /gpf [ aival (10) get {} forall ] def
                ais length 1 gt {/gpf [ gpf aload pop fnc1 ] def} if  % TODO: check
                /ais ais 1 ais length 1 sub getinterval def
            } {
                /gpf [fnc1] def  % TODO: check
            } ifelse
        } {
            /cdf [ cdf aload pop 0 0 0 0 0 1 1 1 1 ] def
            /gpf [] def
        } ifelse
        /mode (numeric) def
    } if

    method (11) eq {
        /cdf [ 1 1 ] def
        /ai90 aival (90) get def
        npre 1 add ai90 length ne {
            ai90 npre 1 add ai90 length npre sub 1 sub getinterval
        } {
            ()
        } ifelse
        /ai90rem exch def
        /nalpha 0 ai90rem {dup 65 ge exch 90 le and {1 add} if} forall def
        /nnums  0 ai90rem {dup 48 ge exch 57 le and {1 add} if} forall def
        /mode nalpha nnums gt {(alpha)} {(numeric)} ifelse def
        nalpha nnums add ai90rem length ne {/mode (alphanumeric) def} if
        /cdf [
            cdf aload pop
            mode (alphanumeric) eq {0} if   
            mode (numeric) eq {1 0} if   
            mode (alpha) eq {1 1} if   
        ] def
        /ais1 ais length 1 gt {ais 1 get} {-1} ifelse def
        ais1 (21) eq ais1 (8004) eq or { 
            /cdf [ cdf aload pop ais1 (21) eq {1 0} {1 1} ifelse ] def
        } {
            /cdf [ cdf aload pop 0 ] def
        } ifelse
        /nval npre 0 ne {ai90 0 npre getinterval cvi} {0} ifelse def
        (BDHIJKLNPQRSTVXZ) ai90 npre 1 getinterval search {
            length exch pop exch pop
            /aval exch def
        } {
            pop /aval -1 def
        } ifelse 
        nval 31 lt aval -1 ne and {
            (00000) 5 string copy dup nval 2 5 string cvrs
            dup length 5 exch sub exch putinterval
            [ exch {48 sub} forall ] /nbits exch def
            (0000) 4 string copy dup aval 2 4 string cvrs
            dup length 4 exch sub exch putinterval
            [ exch {48 sub} forall ] /abits exch def
            /cdf [
                cdf aload pop 
                nbits aload pop
                abits aload pop
            ] def
        } {
            (0000000000) 10 string copy dup nval 2 10 string cvrs
            dup length 10 exch sub exch putinterval
            [ exch {48 sub} forall ] /nbits exch def
            (00000) 5 string copy dup ai90 npre get 65 sub 2 5 string cvrs
            dup length 5 exch sub exch putinterval
            [ exch {48 sub} forall ] /abits exch def
            /cdf [
                cdf aload pop
                1 1 1 1 1
                nbits aload pop
                abits aload pop
            ] def
        } ifelse
        mode (numeric) eq {
            /gpf [ ai90rem {} forall ais length 1 gt {fnc1} if ] def
        } {
            /encs mode (alpha) eq {alpha} {alphanumeric} ifelse def
            /in [ ai90rem {} forall ais length 1 gt {fnc1} if ] def
            /out in length 6 mul array def
            /j 0 def
            0 1 in length 1 sub {
                in exch get encs exch get 
                dup [ exch {48 sub} forall ] out exch j exch putinterval
                length j add /j exch def
            } for
            /cdf [
                cdf aload pop 
                out 0 j getinterval aload pop
            ] def
            /gpf [] def
            ais length 1 gt mode (alpha) ne or {/mode (numeric) def} if
        } ifelse
        /ais ais 1 ais length 1 sub getinterval def
        ais length 0 ne {
            ais1 (21) eq ais1 (8004) eq or {
                /gpf [
                    gpf aload pop
                    aival ais1 get {} forall
                ] def
                /ais ais 1 ais length 1 sub getinterval def
                ais length 0 ne {/gpf [gpf aload pop fnc1] def} if
            } if
        } if
    } if

    method (0) eq {
        /cdf [ 0 ] def
        /gpf [] def
        /mode (numeric) def
    } if

    % Pre-defined fixed length data field AIs
    % any AI whose prefix is not included in this table must be
    % terminated with "FNC1", even if it's fixed length
    /aifixed 23 dict def
    [
        0 1 4 {} for
    ] {
        (00) 2 string copy dup dup 1 5 -1 roll 48 add put aifixed 3 1 roll put
    } forall
    [
        11 1 20 {} for
        23
        31 1 36 {} for
        41
    ] {
        10 2 string cvrs dup aifixed 3 1 roll put
    } forall

    % Append the remaining AI data
    0 1 ais length 1 sub {
        /i exch def
        /ai ais i get def
        /val aival ai get def
        gpf length ai length add val length add array
        dup 0 gpf putinterval
        dup gpf length ai [ exch {} forall ] putinterval
        dup gpf length ai length add val [ exch {} forall ] putinterval
        /gpf exch def
        i ais length 1 sub ne aifixed ai 0 2 getinterval known not and {  % Append FNC1
            gpf length 1 add array
            dup 0 gpf putinterval
            dup gpf length fnc1 put
            /gpf exch def
        } if
    } for

    % Calculate the number of bits remaining to the next valid symbol size
    /rembits {
        /used exch def
        ccversion (c) ne {  % cc-a or cc-b
            <<
            /a [
                [167 138 118 108 88 78 59]
                [167 138 118  98 78]
                [197 167 138 108 78]
            ]
            /b [
                [ 336  296 256 208 160 104  56]
                [ 768  648 536 416 304 208 152 112  72 32]
                [1184 1016 840 672 496 352 264 208 152 96 56]
            ]
            >> ccversion get cccolumns 2 sub get /bitcaps exch def
            -1 bitcaps {dup used ge {exch} if pop} forall
            dup -1 ne {used sub} if
        } {
            << /c -1 >> ccversion get pop  % Assert cc-c
            /m used 8 div ceiling cvi dup 6 idiv 5 mul exch 6 mod add def
            m   40 le               {8 } if
            m   41 ge m  160 le and {16} if
            m  161 ge m  320 le and {32} if
            m  321 ge               {64} if
            /eccws exch def
            /m m eccws add 3 add def
            /c linwidth 52 sub 17 idiv def
            m c idiv 90 gt {/c c 1 add def} if
            /r m c div ceiling cvi def
            /tgt c r mul eccws sub 3 sub dup 5 idiv 6 mul exch 5 mod add 8 mul def
            used 8296 le {tgt used sub} {-1} ifelse
        } ifelse
        dup -1 eq {  % Upgrade CC-A to CC-B or CC-B to CC-C to fit
            pop
            ccversion (a) eq {
                /ccversion (b) def
            } {
                ccversion (b) eq lintype (gs1-128) eq and {
                    /ccversion (c) def
                    /cccolumns linwidth 52 sub 17 idiv def
                } {
                    /ccversion -1 def
                } ifelse
            } ifelse 
            used rembits
        } if
    } bind def

    /encode {
        dup /raw ne {exch get} {pop} ifelse
        [ exch {48 sub} forall ]
        dup length exch
        gpfenc exch j exch putinterval
        /j exch j add def
    } bind def

    % Pre-compute alphanumeric and numeric runlengths and position of next ISO646-only characters
    /numericruns [ gpf length {0} repeat 0 -1 ] def
    /alphanumericruns [ gpf length {0} repeat 0 ] def
    /nextiso646only [ gpf length {0} repeat 9999 ] def
    gpf length 1 sub -1 0 {
        /i exch def
        gpf i get
        (00) 2 string copy
        dup 0 gpf i get dup fnc1 eq {pop 94} if put 
        i gpf length 1 sub lt {dup 1 gpf i 1 add get dup fnc1 eq {pop 94} if put} if
        numeric exch known {
            numericruns i numericruns i 2 add get 2 add put
        } {
            numericruns i 0 put
        } ifelse
        dup alphanumeric exch known {
            alphanumericruns i alphanumericruns i 1 add get 1 add put
        } {
            alphanumericruns i 0 put
        } ifelse
        dup iso646 exch known exch alphanumeric exch known not and {
            nextiso646only i 0 put
        } {
            nextiso646only i nextiso646only i 1 add get 1 add put
        } ifelse
    } for
   
    % Encode the general purpose field
    /gpfenc 8296 array def
    /i 0 def /j 0 def
    {  % loop
        i gpf length eq {exit} if
        {  % not a loop but common exit point
    
            mode (numeric) eq {
                i gpf length 2 sub le {
                    2 string 
                    dup 0 gpf i get dup fnc1 eq {pop 94} if put
                    dup 1 gpf i 1 add get dup fnc1 eq {pop 94} if put
                    dup numeric exch known {
                        numeric encode
                        /i i 2 add def
                        exit
                    } if
                    pop
                    lalphanumeric numeric encode 
                    /mode (alphanumeric) def
                    exit
                } {
                    gpf i get dup 48 lt exch 57 gt or {
                        lalphanumeric numeric encode
                        /mode (alphanumeric) def
                        exit
                    } if
                    /rem cdf length j add rembits def
                    rem 4 ge rem 6 le and {  % C1 + 1 into 4 to 6 bits
                        (000000) 6 string copy 0 rem getinterval
                        dup gpf i get 47 sub 2 4 string cvrs
                        dup length 4 exch sub exch putinterval /raw encode
                        /i i 1 add def
                        exit
                    } {  % C1.FNC1
                        2 string dup 0 gpf i get put dup 1 94 put numeric encode 
                        /i i 1 add def
                        exit
                    } ifelse
                } ifelse
            } if
    
            mode (alphanumeric) eq {
                gpf i get fnc1 eq {
                    fnc1 alphanumeric encode
                    /i i 1 add def
                    exit
                } if
                gpf i get dup iso646 exch known exch alphanumeric exch known not and {
                     liso646 alphanumeric encode
                     /mode (iso646) def
                     exit
                } if
                numericruns i get 6 ge {
                    lnumeric alphanumeric encode
                    /mode (numeric) def
                    exit
                } if
                numericruns i get dup 4 ge exch i add gpf length eq and {
                    lnumeric alphanumeric encode
                    /mode (numeric) def
                    exit
                } if
                gpf i get alphanumeric encode
                /i i 1 add def
                exit
            } if
    
            mode (iso646) eq {
                gpf i get fnc1 eq {
                    fnc1 iso646 encode
                    /i i 1 add def
                    exit
                } if
                numericruns i get 4 ge nextiso646only i get 10 ge and {
                    lnumeric iso646 encode
                    /mode (numeric) def
                    exit
                } if
                alphanumericruns i get 5 ge nextiso646only i get 10 ge and {
                    lalphanumeric iso646 encode
                    /mode (alphanumeric) def
                    exit
                } if
                gpf i get iso646 encode
                /i i 1 add def
                exit
            } if
    
        } loop
    } loop
    /gpf gpfenc 0 j getinterval def

    % Create pad
    /pad cdf length gpf length add rembits array def
    pad length 0 gt {
        0 5 pad length 1 sub {  % Fill with 00100
            /i exch def
            pad i [ 0 0 1 0 0 ] 0 pad length i sub 5 2 copy gt {exch} if pop getinterval putinterval 
        } for 
        mode (numeric) eq {  % Prefix shift from numeric to ASCII
            /pad [ 0 0 0 0 pad aload pop ] 0 pad length getinterval def
        } if
        mode (alpha) eq {  % Prefix FNC1
            /pad [ 1 1 1 1 1 pad aload pop ] 0 pad length getinterval def
        } if
    } if

    % Concatinate fields
    /bits [
        cdf aload pop
        gpf aload pop
        pad aload pop
    ] def

    ccversion (a) eq {
        /pwr928 [
            [ 0 0 0 0 0 0 1 ]
            68 {7 array} repeat
        ] def
        1 1 68 {
            /j exch def
            /v 0 def
            6 -1 1 {
                /i exch def
                /v pwr928 j 1 sub get i get 2 mul v 928 idiv add def
                pwr928 j get i v 928 mod put 
            } for   
            pwr928 j get 0 pwr928 j 1 sub get 0 get 2 mul v 928 idiv add put
        } for
        /cws [ 28 {0} repeat ] def
        /b 0 def /c 0 def
        {  % loop
            b bits length eq {exit} if
            /bs bits b 69 bits length b sub 2 copy gt {exch} if pop getinterval def
            /bsl bs length def
            /cs cws c bsl 10 idiv 1 add getinterval def
            /csl cs length def
            0 1 bsl 1 sub {
                /i exch def
                0 1 csl 1 sub {
                    /j exch def
                    cs j 2 copy get
                    pwr928 i get j 7 add csl sub get
                    bs bsl i sub 1 sub get
                    mul add put
                } for
            } for
            csl 1 sub -1 1 {
                /i exch def
                cs i 1 sub 2 copy get cs i get 928 idiv add put
                cs i 2 copy get 928 mod put
            } for 
            /b b bsl add def
            /c c csl add def
        } loop
        /cws cws 0 c getinterval def
        /barcode cws length 4 mul string def
        0 1 cws length 1 sub {
            /i exch def
            (^   ) 4 string copy dup cws i get 10 4 string cvrs
            dup length 4 exch sub exch putinterval
            barcode i 4 mul 3 -1 roll putinterval
        } for
        options (dontdraw) true put
        options (cca) true put
        options (columns) cccolumns put
        /args barcode options //micropdf417 exec def
    } if

    ccversion (b) eq {
        /barcode bits length 8 idiv string def
        0 1 barcode length 1 sub {
            /i exch def
            bits i 8 mul 8 getinterval 0 exch {add 2 mul} forall 2 idiv
            barcode exch i exch put
        } for
        options (dontdraw) true put
        options (ccb) true put
        options (columns) cccolumns put
        /args barcode options //micropdf417 exec def
    } if

    ccversion (c) eq {
        /barcode bits length 8 idiv string def
        0 1 barcode length 1 sub {
            /i exch def
            bits i 8 mul 8 getinterval 0 exch {add 2 mul} forall 2 idiv
            barcode exch i exch put
        } for
        options (dontdraw) true put
        options (ccc) true put
        options (columns) cccolumns put
        /args barcode options //pdf417 exec def
    } if

    args
    dontdraw not //renmatrix if

    end

} bind def
/gs1-cc dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER gs1-cc--

% --BEGIN ENCODER ean13composite--
% --REQUIRES ean13 micropdf417 pdf417 gs1-cc--
% --SUGGESTS ean5 ean2--
% --DESC: EAN-13 Composite
% --EXAM: 2112345678900|(99)1234-abcd
% --EXOP: includetext
% --RNDR: renlinear renmatrix
/setpacking where {pop currentpacking true setpacking} if
2 dict
dup /ean13 dup /uk.co.terryburton.bwipp findresource put
dup /gs1-cc dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/ean13composite {

    20 dict begin            % Confine variables to local scope

    /options exch def
    /barcode exch def

    /dontdraw false def
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    % Split the linear and composite parts
    barcode (|) search {
        /linear exch def
        pop
        /comp exch def
    } {
        pop
    } ifelse

    gsave

    options (lintype) (ean13) put
    options (inkspread) (0) put
    options (dontdraw) true put

    % Plot the linear part
    linear options //ean13 exec //renlinear exec

    % Plot the separator
    -1 72 rmoveto <<
        /ren //renmatrix
        /pixs [
            0 1  93 {0} repeat  1 0
            1 0  93 {0} repeat  0 1
            0 1  93 {0} repeat  1 0
        ]
        /pixx 97
        /pixy 3
        /height 6 72 div
        /width 97 72 div
        /opt options
    >> //renmatrix exec

    % Plot the 2D part
    -2 6 rmoveto comp options //gs1-cc exec //renmatrix exec

    grestore

    end

} bind def
/ean13composite dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER ean13composite--

% --BEGIN ENCODER ean8composite--
% --REQUIRES ean8 micropdf417 pdf417 gs1-cc--
% --SUGGESTS ean5 ean2--
% --DESC: EAN-8 Composite
% --EXAM: 02345673|(21)A12345678
% --EXOP: includetext
% --RNDR: renlinear renmatrix
/setpacking where {pop currentpacking true setpacking} if
2 dict
dup /ean8 dup /uk.co.terryburton.bwipp findresource put
dup /gs1-cc dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/ean8composite {

    20 dict begin            % Confine variables to local scope

    /options exch def
    /barcode exch def

    /dontdraw false def
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    % Split the linear and composite parts
    barcode (|) search {
        /linear exch def
        pop
        /comp exch def
    } {
        pop
    } ifelse

    gsave

    % Get the result of encoding with ean8 and gs1-cc
    options (lintype) (ean8) put
    options (inkspread) (0) put
    options (dontdraw) true put

    % Plot the linear part
    linear options //ean8 exec //renlinear exec

    % Plot the separator
    -1 72 rmoveto <<
        /ren //renmatrix
        /pixs [
            0 1  65 {0} repeat  1 0
            1 0  65 {0} repeat  0 1
            0 1  65 {0} repeat  1 0
        ]
        /pixx 69
        /pixy 3
        /height 6 72 div
        /width 69 72 div
        /opt options
    >> //renmatrix exec

    % Plot the 2D part
    comp options //gs1-cc exec
    dup (pixx) get 69 exch sub 6 rmoveto
    //renmatrix exec

    grestore

    end

} bind def
/ean8composite dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER ean8composite--

% --BEGIN ENCODER upcacomposite--
% --REQUIRES upca micropdf417 pdf417 gs1-cc--
% --SUGGESTS ean5 ean2--
% --DESC: UPC-A Composite
% --EXAM: 416000336108|(99)1234-abcd
% --EXOP: includetext
% --RNDR: renlinear renmatrix
/setpacking where {pop currentpacking true setpacking} if
2 dict
dup /upca dup /uk.co.terryburton.bwipp findresource put
dup /gs1-cc dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/upcacomposite {

    20 dict begin            % Confine variables to local scope

    /options exch def
    /barcode exch def

    /dontdraw false def
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    % Split the linear and composite parts
    barcode (|) search {
        /linear exch def
        pop
        /comp exch def
    } {
        pop
    } ifelse

    gsave

    options (lintype) (ean13) put
    options (inkspread) (0) put
    options (dontdraw) true put

    % Plot the linear part
    linear options //upca exec //renlinear exec

    % Plot the separator
    -1 72 rmoveto <<
        /ren //renmatrix
        /pixs [
            0 1  93 {0} repeat  1 0
            1 0  93 {0} repeat  0 1
            0 1  93 {0} repeat  1 0
        ]
        /pixx 97
        /pixy 3
        /height 6 72 div
        /width 97 72 div
        /opt options
    >> //renmatrix exec

    % Plot the 2D part
    -2 6 rmoveto comp options //gs1-cc exec //renmatrix exec

    grestore

    end

} bind def
/upcacomposite dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER upcacomposite--

% --BEGIN ENCODER upcecomposite--
% --REQUIRES upce micropdf417 pdf417 gs1-cc--
% --SUGGESTS ean5 ean2--
% --DESC: UPC-E Composite
% --EXAM: 00123457|(15)021231
% --EXOP: includetext
% --RNDR: renlinear renmatrix
/setpacking where {pop currentpacking true setpacking} if
2 dict
dup /upce dup /uk.co.terryburton.bwipp findresource put
dup /gs1-cc dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/upcecomposite {

    20 dict begin            % Confine variables to local scope

    /options exch def
    /barcode exch def

    /dontdraw false def
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    % Split the linear and composite parts
    barcode (|) search {
        /linear exch def
        pop
        /comp exch def
    } {
        pop
    } ifelse

    % Define the separator
    /sep <<
        /ren //renmatrix
        /pixs [
            0 1  49 {0} repeat  1 0
            1 0  49 {0} repeat  0 1
            0 1  49 {0} repeat  1 0
        ] 
        /pixx 53
        /pixy 3
        /height 6 72 div
        /width 53 72 div
        /opt options
    >> def

    gsave

    options (lintype) (upce) put
    options (inkspread) (0) put
    options (dontdraw) true put

    % Plot the linear part
    linear options //upce exec //renlinear exec

    % Plot the separator
    -1 72 rmoveto <<
        /ren //renmatrix
        /pixs [
            0 1  49 {0} repeat  1 0
            1 0  49 {0} repeat  0 1
            0 1  49 {0} repeat  1 0
        ]
        /pixx 53
        /pixy 3
        /height 6 72 div
        /width 53 72 div
        /opt options
    >> //renmatrix exec

    % Plot the 2D part
    -2 6 rmoveto comp options //gs1-cc exec //renmatrix exec

    grestore

    end

} bind def
/upcecomposite dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER upcecomposite--

% --BEGIN ENCODER databaromnicomposite--
% --REQUIRES databaromni micropdf417 pdf417 gs1-cc--
% --DESC: GS1 DataBar Omnidirectional Composite
% --EXAM: (01)03612345678904|(11)990102
% --EXOP:
% --RNDR: renlinear renmatrix
/setpacking where {pop currentpacking true setpacking} if
2 dict
dup /databaromni dup /uk.co.terryburton.bwipp findresource put
dup /gs1-cc dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/databaromnicomposite {

    20 dict begin            % Confine variables to local scope

    /options exch def
    /barcode exch def

    /dontdraw false def
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    % Split the linear and composite parts
    barcode (|) search {
        /linear exch def
        pop
        /comp exch def
    } {
        pop
    } ifelse

    gsave

    options (lintype) (databaromni) put
    options (linkage) true put
    options (inkspread) (0) put
    options (dontdraw) true put

    % Plot the linear part
    linear options //databaromni exec
    dup (sbs) get /linsbs exch def
    dup (bhs) get 0 get 72 mul /linheight exch def
    //renlinear exec

    % Plot the separator
    /sepfinder {
        /fp exch def
        fp 1 fp 12 add {
            /i exch def
            bot i get 0 eq {
                bot i 1 sub get 1 eq {
                    1
                } {
                    sep i 1 sub get 0 eq {1} {0} ifelse
                } ifelse
            } {
                0
            } ifelse
            sep exch i exch put
        } for
        /f3 [1 1 1 1 1 1 1 1 1 0 1 1 1] def
        true 0 1 12 {dup bot exch fp add get exch f3 exch get eq and} for {
            % Right shifted module for value 3 finder
            sep fp [ 0 0 0 0 0 0 0 0 0 0 1 0 0 ] putinterval
        } if
    } bind def
    mark
    0 linsbs {1 index 1 eq {{0}} {{1}} ifelse repeat} forall
    counttomark 1 sub array astore /bot exch def pop pop
    /sep [ bot {1 exch sub} forall ] def
    sep 0 [0 0 0] putinterval
    sep sep length 4 sub [0 0 0 0] putinterval
    18 sepfinder 64 sepfinder
    0 linheight rmoveto <<
        /ren //renmatrix
        /pixs sep
        /pixx sep length
        /pixy 1
        /height 1 72 div
        /width sep length 72 div
        /opt options
    >> //renmatrix exec

    % Plot the 2D part
    -5 1 rmoveto comp options //gs1-cc exec //renmatrix exec

    grestore

    end

} bind def
/databaromnicomposite dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER databaromnicomposite--

% --BEGIN ENCODER databarstackedcomposite--
% --REQUIRES databaromni databarstacked micropdf417 pdf417 gs1-cc--
% --DESC: GS1 DataBar Stacked Composite
% --EXAM: (01)03412345678900|(17)010200
% --EXOP:
% --RNDR: renlinear renmatrix
/setpacking where {pop currentpacking true setpacking} if
2 dict
dup /databarstacked dup /uk.co.terryburton.bwipp findresource put
dup /gs1-cc dup /uk.co.terryburton.bwipp findresource put
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/databarstackedcomposite {

    20 dict begin            % Confine variables to local scope

    /options exch def
    /barcode exch def

    /dontdraw false def
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    % Split the linear and composite parts
    barcode (|) search {
        /linear exch def
        pop
        /comp exch def
    } {
        pop
    } ifelse

    gsave

    options (lintype) (databarstacked) put
    options (linkage) true put
    options (inkspread) (0) put
    options (dontdraw) true put

    % Plot the linear part
    linear options //databarstacked exec
    dup (pixs) get 0 2 index (pixx) get getinterval /bot exch def
    dup (pixy) get /linheight exch def
    //renmatrix exec

    % Plot the separator
    /sepfinder {
        /fp exch def
        fp 1 fp 12 add {
            /i exch def
            bot i get 0 eq {
                bot i 1 sub get 1 eq {
                    1
                } {
                    sep i 1 sub get 0 eq {1} {0} ifelse
                } ifelse
            } {
                0
            } ifelse
            sep exch i exch put
        } for
        /f3 [1 1 1 1 1 1 1 1 1 0 1 1 1] def
        true 0 1 12 {dup bot exch fp add get exch f3 exch get eq and} for {
            % Right shifted module for value 3 finder
            sep fp [ 0 0 0 0 0 0 0 0 0 0 1 0 0 ] putinterval
        } if
    } bind def
    /sep [ bot {1 exch sub} forall ] def
    sep 0 [ 0 0 0 0 ] putinterval
    sep sep length 4 sub [ 0 0 0 0 ] putinterval
    18 sepfinder
    0 linheight rmoveto <<
        /ren //renmatrix
        /pixs sep
        /pixx sep length
        /pixy 1
        /height 1 72 div
        /width sep length 72 div
        /opt options
    >> //renmatrix exec

    % Plot the 2D part
    1 1 rmoveto comp options //gs1-cc exec //renmatrix exec

    grestore

    end

} bind def
/databarstackedcomposite dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER databarstackedcomposite--

% --BEGIN ENCODER databarstackedomnicomposite--
% --REQUIRES databaromni databarstackedomni micropdf417 pdf417 gs1-cc--
% --DESC: GS1 DataBar Stacked Omnidirectional Composite
% --EXAM: (01)03612345678904|(11)990102
% --EXOP:
% --RNDR: renlinear renmatrix
/setpacking where {pop currentpacking true setpacking} if
2 dict
dup /databarstackedomni dup /uk.co.terryburton.bwipp findresource put
dup /gs1-cc dup /uk.co.terryburton.bwipp findresource put
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/databarstackedomnicomposite {

    20 dict begin            % Confine variables to local scope

    /options exch def
    /barcode exch def

    /dontdraw false def
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    % Split the linear and composite parts
    barcode (|) search {
        /linear exch def
        pop
        /comp exch def
    } {
        pop
    } ifelse

    gsave

    options (lintype) (databarstackedomni) put
    options (linkage) true put
    options (inkspread) (0) put
    options (dontdraw) true put

    % Plot the linear part
    linear options //databarstackedomni exec
    dup (pixs) get 0 2 index (pixx) get getinterval /bot exch def
    dup (pixy) get /linheight exch def
    //renmatrix exec

    % Plot the separator
    /sepfinder {
        /fp exch def
        fp 1 fp 12 add {
            /i exch def
            bot i get 0 eq {
                bot i 1 sub get 1 eq {
                    1
                } {
                    sep i 1 sub get 0 eq {1} {0} ifelse
                } ifelse
            } {
                0
            } ifelse
            sep exch i exch put
        } for
        /f3 [1 1 1 1 1 1 1 1 1 0 1 1 1] def
        true 0 1 12 {dup bot exch fp add get exch f3 exch get eq and} for {
            % Right shifted module for value 3 finder
            sep fp [ 0 0 0 0 0 0 0 0 0 0 1 0 0 ] putinterval
        } if
    } bind def
    /sep [ bot {1 exch sub} forall ] def
    sep 0 [ 0 0 0 ] putinterval
    sep sep length 4 sub [ 0 0 0 0 ] putinterval
    18 sepfinder
    0 linheight rmoveto <<
        /ren //renmatrix
        /pixs sep
        /pixx sep length
        /pixy 1
        /height 1 72 div
        /width sep length 72 div
        /opt options
    >> //renmatrix exec

    % Plot the 2D part
    1 1 rmoveto comp options //gs1-cc exec //renmatrix exec

    grestore

    end

} bind def
/databarstackedomnicomposite dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER databarstackedomnicomposite--

% --BEGIN ENCODER databartruncatedcomposite--
% --REQUIRES databaromni databartruncated micropdf417 pdf417 gs1-cc--
% --DESC: GS1 DataBar Truncated Composite
% --EXAM: (01)03612345678904|(11)990102
% --EXOP:
% --RNDR: renlinear renmatrix
/setpacking where {pop currentpacking true setpacking} if
2 dict
dup /databartruncated dup /uk.co.terryburton.bwipp findresource put
dup /gs1-cc dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/databartruncatedcomposite {

    20 dict begin            % Confine variables to local scope

    /options exch def
    /barcode exch def

    /dontdraw false def
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    % Split the linear and composite parts
    barcode (|) search {
        /linear exch def
        pop
        /comp exch def
    } {
        pop
    } ifelse

    gsave

    options (lintype) (databartruncated) put
    options (linkage) true put
    options (inkspread) (0) put
    options (dontdraw) true put

    % Plot the linear part
    linear options //databartruncated exec
    dup (sbs) get /linsbs exch def
    dup (bhs) get 0 get 72 mul /linheight exch def
    //renlinear exec

    % Plot the separator
    /sepfinder {
        /fp exch def
        fp 1 fp 12 add {
            /i exch def
            bot i get 0 eq {
                bot i 1 sub get 1 eq {
                    1
                } {
                    sep i 1 sub get 0 eq {1} {0} ifelse
                } ifelse
            } {
                0
            } ifelse
            sep exch i exch put
        } for
        /f3 [1 1 1 1 1 1 1 1 1 0 1 1 1] def
        true 0 1 12 {dup bot exch fp add get exch f3 exch get eq and} for {
            % Right shifted module for value 3 finder
            sep fp [ 0 0 0 0 0 0 0 0 0 0 1 0 0 ] putinterval
        } if
    } bind def
    mark
    0 linsbs {1 index 1 eq {{0}} {{1}} ifelse repeat} forall
    counttomark 1 sub array astore /bot exch def pop pop
    /sep [ bot {1 exch sub} forall ] def
    sep 0 [0 0 0] putinterval
    sep sep length 4 sub [0 0 0 0] putinterval
    18 sepfinder 64 sepfinder
    0 linheight rmoveto <<
        /ren //renmatrix
        /pixs sep
        /pixx sep length
        /pixy 1
        /height 1 72 div
        /width sep length 72 div
        /opt options
    >> //renmatrix exec

    % Plot the 2D part
    -5 1 rmoveto comp options //gs1-cc exec //renmatrix exec

    grestore

    end

} bind def
/databartruncatedcomposite dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER databartruncatedcomposite--

% --BEGIN ENCODER databarlimitedcomposite--
% --REQUIRES databarlimited micropdf417 pdf417 gs1-cc--
% --DESC: GS1 DataBar Limited Composite
% --EXAM: (01)03512345678907|(21)abcdefghijklmnopqrstuv
% --EXOP:
% --RNDR: renlinear renmatrix
/setpacking where {pop currentpacking true setpacking} if
2 dict
dup /databarlimited dup /uk.co.terryburton.bwipp findresource put
dup /gs1-cc dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/databarlimitedcomposite {

    20 dict begin            % Confine variables to local scope

    /options exch def
    /barcode exch def

    /dontdraw false def
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    % Split the linear and composite parts
    barcode (|) search {
        /linear exch def
        pop
        /comp exch def
    } {
        pop
    } ifelse

    gsave

    options (lintype) (databarlimited) put
    options (linkage) true put
    options (inkspread) (0) put
    options (dontdraw) true put

    % Plot the linear part
    linear options //databarlimited exec
    dup (sbs) get /linsbs exch def
    dup (bhs) get 0 get 72 mul /linheight exch def
    //renlinear exec

    % Plot the separator
    mark
    1 linsbs {1 index 0 eq {{1}} {{0}} ifelse repeat} forall
    counttomark 1 sub array astore /sep exch def pop pop
    sep 0 [0 0 0] putinterval
    sep sep length 4 sub [0 0 0 0] putinterval
    0 linheight rmoveto <<
        /ren //renmatrix
        /pixs sep
        /pixx sep length
        /pixy 1
        /height 1 72 div
        /width sep length 72 div
        /opt options
    >> //renmatrix exec

    % Plot the 2D part
    comp options //gs1-cc exec 
    dup (pixx) get 72 exch sub 1 rmoveto 
    //renmatrix exec

    grestore

    end

} bind def
/databarlimitedcomposite dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER databarlimitedcomposite--

% --BEGIN ENCODER databarexpandedcomposite--
% --REQUIRES databarexpanded micropdf417 pdf417 gs1-cc--
% --DESC: GS1 DataBar Expanded Composite
% --EXAM: (01)93712345678904(3103)001234|(91)1A2B3C4D5E
% --EXOP:
% --RNDR: renlinear renmatrix
/setpacking where {pop currentpacking true setpacking} if
2 dict
dup /databarexpanded dup /uk.co.terryburton.bwipp findresource put
dup /gs1-cc dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/databarexpandedcomposite {

    20 dict begin            % Confine variables to local scope

    /options exch def
    /barcode exch def

    /dontdraw false def
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    % Split the linear and composite parts
    barcode (|) search {
        /linear exch def
        pop
        /comp exch def
    } {
        pop
    } ifelse

    gsave

    options (lintype) (databarexpanded) put
    options (linkage) true put
    options (inkspread) (0) put
    options (dontdraw) true put

    % Plot the linear part
    linear options //databarexpanded exec
    dup (sbs) get /linsbs exch def
    dup (bhs) get 0 get 72 mul /linheight exch def
    //renlinear exec

    % Plot the separator
    /sepfinder {
        /fp exch def
        fp 1 fp 12 add {
            /i exch def
            bot i get 0 eq {
                bot i 1 sub get 1 eq {
                    1
                } {
                    sep i 1 sub get 0 eq {1} {0} ifelse
                } ifelse
            } {
                0
            } ifelse
            sep exch i exch put
        } for
    } bind def
    mark
    0 linsbs {1 index 1 eq {{0}} {{1}} ifelse repeat} forall
    counttomark 1 sub array astore /bot exch def pop pop
    /sep [ bot {1 exch sub} forall ] def
    sep 0 [0 0 0] putinterval
    sep sep length 4 sub [0 0 0 0] putinterval
    [  % Finder pattern module positions
        18 98 bot length 13 sub {} for
        69 98 bot length 13 sub {} for
    ] {sepfinder} forall 
    0 linheight rmoveto <<
        /ren //renmatrix
        /pixs sep
        /pixx sep length
        /pixy 1
        /height 1 72 div
        /width sep length 72 div
        /opt options
    >> //renmatrix exec

    % Plot the 2D part
    1 1 rmoveto comp options //gs1-cc exec //renmatrix exec

    grestore

    end

} bind def
/databarexpandedcomposite dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER databarexpandedcomposite--

% --BEGIN ENCODER databarexpandedstackedcomposite--
% --REQUIRES databarexpanded databarexpandedstacked micropdf417 pdf417 gs1-cc--
% --DESC: GS1 DataBar Expanded Stacked Composite
% --EXAM: (01)00012345678905(10)ABCDEF|(21)12345678
% --EXOP: segments=4 
% --RNDR: renmatrix renlinear
/setpacking where {pop currentpacking true setpacking} if
2 dict
dup /databarexpandedstacked dup /uk.co.terryburton.bwipp findresource put
dup /gs1-cc dup /uk.co.terryburton.bwipp findresource put
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/databarexpandedstackedcomposite {

    20 dict begin            % Confine variables to local scope

    /options exch def
    /barcode exch def

    /dontdraw false def
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    % Split the linear and composite parts
    barcode (|) search {
        /linear exch def
        pop
        /comp exch def
    } {
        pop
    } ifelse

    gsave

    options (lintype) (databarexpandedstacked) put
    options (linkage) true put
    options (inkspread) (0) put
    options (dontdraw) true put

    % Plot the linear part
    linear options //databarexpandedstacked exec
    dup (pixs) get 0 2 index (pixx) get getinterval /bot exch def
    dup (pixy) get /linheight exch def
    //renmatrix exec

    % Plot the separator
    /sepfinder {
        /fp exch def
        fp 1 fp 12 add {
            /i exch def
            bot i get 0 eq {
                bot i 1 sub get 1 eq {
                    1
                } {
                    sep i 1 sub get 0 eq {1} {0} ifelse
                } ifelse
            } {
                0
            } ifelse
            sep exch i exch put
        } for
    } bind def
    /sep [ bot {1 exch sub} forall ] def
    sep 0 [ 0 0 0 ] putinterval
    sep sep length 4 sub [ 0 0 0 0 ] putinterval
    [  % Finder pattern module positions
        19 98 bot length 13 sub {} for
        70 98 bot length 13 sub {} for
    ] {sepfinder} forall 
    0 linheight rmoveto <<
        /ren //renmatrix
        /pixs sep
        /pixx sep length
        /pixy 1
        /height 1 72 div
        /width sep length 72 div
        /opt options
    >> //renmatrix exec

    % Plot the 2D part
    bot 0 get 0 eq {2} {0} ifelse 1 rmoveto
    comp options //gs1-cc exec //renmatrix exec

    grestore

    end

} bind def
/databarexpandedstackedcomposite dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER databarexpandedstackedcomposite--

% --BEGIN ENCODER gs1-128composite--
% --REQUIRES code128 gs1-128 micropdf417 pdf417 gs1-cc--
% --DESC: GS1-128 Composite
% --EXAM: (00)030123456789012340|(02)13012345678909(37)24(10)1234567ABCDEFG
% --EXOP: ccversion=c
% --RNDR: renlinear renmatrix
/setpacking where {pop currentpacking true setpacking} if
2 dict
dup /gs1-128 dup /uk.co.terryburton.bwipp findresource put
dup /gs1-cc dup /uk.co.terryburton.bwipp findresource put
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/gs1-128composite {

    20 dict begin            % Confine variables to local scope

    /options exch def
    /barcode exch def

    /dontdraw false def
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    % Split the linear and composite parts
    barcode (|) search {
        /linear exch def
        pop
        /comp exch def
    } {
        pop
    } ifelse

    gsave

    options (inkspread) (0) put
    options (dontdraw) true put

    % Dummy plot of linear part with CC-A to get width
    options (linkagea) true put
    linear << options {} forall >> //gs1-128 exec
    (sbs) get 0 exch {add} forall /linwidth exch def

    % Create 2D part and determine type
    options (lintype) (gs1-128) put
    options (linwidth) linwidth put
    comp options //gs1-cc exec /compsym exch def
    compsym (pixx) get 99 eq {(a)} {(c)} ifelse /linktype exch def 

    % Plot linear part
    linktype (a) eq {
        options (linkagea) true put
        options (linkagec) false put
    } {
        options (linkagea) false put
        options (linkagec) true put
    } ifelse
    linear << options {} forall >> //gs1-128 exec
    dup (sbs) get /linsbs exch def
    dup (bhs) get 0 get 72 mul /linheight exch def
    //renlinear exec

    % Plot the separator
    mark
    1 linsbs {1 index 0 eq {{1}} {{0}} ifelse repeat} forall
    counttomark 1 sub array astore /sep exch def pop pop
    0 linheight rmoveto <<
        /ren //renmatrix
        /pixs sep
        /pixx sep length
        /pixy 1
        /height 1 72 div
        /width sep length 72 div
        /opt options
    >> //renmatrix exec

    % Plot the 2D part
    linktype (a) eq {
        /s linwidth 2 sub 11 idiv def
        /p s 9 sub 2 idiv def
        /x s p sub 1 sub 11 mul 10 add p 0 eq {2 add} if 99 sub def
        x 1 rmoveto
    } {
        -7 1 rmoveto 
    } ifelse

    compsym //renmatrix exec

    grestore

    end

} bind def
/gs1-128composite dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER gs1-128composite--

% --BEGIN ENCODER gs1datamatrix--
% --REQUIRES datamatrix--
% --DESC: GS1 Data Matrix
% --EXAM: (01)03453120000011(17)120508(10)ABCD1234(410)9501101020917
% --EXOP:
% --RNDR: renmatrix
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
dup /datamatrix dup /uk.co.terryburton.bwipp findresource put
begin
/gs1datamatrix {

    20 dict begin            % Confine variables to local scope

    /options exch def  % We are given an option string
    /barcode exch def  % We are given a barcode string

    /dontdraw false def
 
    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    % Expand ordinals of the form ^NNN to ASCII
    /expand {
        /in exch def
        /out in length string def
        /j 0 def
        in
        { % loop
            (^) search {
                dup out exch j exch putinterval
                length j add 1 add /j exch def
                pop
                dup 0 3 getinterval cvi out exch j 1 sub exch put
                dup length 3 sub 3 exch getinterval
            } {
                dup out exch j exch putinterval
                length j add /j exch def
                out 0 j getinterval exit
            } ifelse 
        } loop
    } bind def
    
    % Parse out AIs
    /ais [] def
    /aival 2 dict def
    barcode dup length 1 sub 1 exch getinterval
    {  % loop
        dup () eq {exit} if
        (\)) search pop
        exch pop
        exch (\() search {
            exch pop exch 3 1 roll 
        } { 
            () 3 1 roll
        } ifelse
        [ ais aload pop counttomark 2 add index ] /ais exch def
        aival 3 1 roll expand put
    } loop
    pop

    % Pre-defined fixed length data field AIs
    % any AI whose prefix is not included in this table must be
    % terminated with "FNC1", even if it's fixed length
    /aifixed 23 dict def
    [
        0 1 4 {} for
    ] {
        (00) 2 string copy dup dup 1 5 -1 roll 48 add put aifixed 3 1 roll put
    } forall
    [
        11 1 20 {} for
        23
        31 1 36 {} for
        41
    ] {
        10 2 string cvrs dup aifixed 3 1 roll put
    } forall

    % Create the datamatrix data 
    /fnc1 -1 def
    /dmtx [ fnc1 ] def
    0 1 ais length 1 sub {
        /i exch def
        /ai ais i get def
        /val aival ai get def
        dmtx length ai length add val length add array
        dup 0 dmtx putinterval
        dup dmtx length ai [ exch {} forall ] putinterval
        dup dmtx length ai length add val [ exch {} forall ] putinterval
        /dmtx exch def
        i ais length 1 sub ne aifixed ai 0 2 getinterval known not and {  % Append FNC1
            dmtx length 1 add array
            dup 0 dmtx putinterval
            dup dmtx length fnc1 put
            /dmtx exch def
        } if
    } for

    % Compose input to datamatrix
    /barcode dmtx length 1 add 5 mul string def
    /i 0 def /j 0 def {
        i dmtx length eq {exit} if
        dmtx i get dup fnc1 eq {
            pop barcode j (^FNC1) putinterval
            /j j 4 add def
        } {
            barcode exch j exch put
        } ifelse
        /i i 1 add def
        /j j 1 add def
    } loop
    /barcode barcode 0 j getinterval def

    % Get the result of encoding with code128
    options (dontdraw) true put
    options (parsefnc) true put
    /args barcode options //datamatrix exec def

    args (opt) options put
    args
 
    dontdraw not //renmatrix if
 
    end

} bind def
/gs1datamatrix dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER gs1datamatrix--

% --BEGIN ENCODER hibccode39--
% --REQUIRES code39--
% --DESC: HIBC Code 39
% --EXAM: A123BJC5D6E71
% --EXOP: includetext
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /code39 dup /uk.co.terryburton.bwipp findresource put
begin
/hibccode39 {

    20 dict begin                 % Confine variables to local scope

    /options exch def       % We are given an option string
    /barcode exch def       % We are given a barcode string

    /dontdraw false def
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /textxoffset 0 def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /textxoffset textxoffset cvr def

    /barlen barcode length def

    /barchars (0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%) def

    /barcode barlen 2 add string dup 1 barcode putinterval def
    barcode 0 43 put

    /checksum 0 def
    0 1 barlen {
        /i exch def
        % Lookup the encoding for the each barcode character
        barcode i 1 getinterval barchars exch search
        pop                                  % Discard true leaving pre
        length /indx exch def                % indx is the length of pre
        pop pop                              % Discard seek and post
        /checksum checksum indx add def
    } for
    barcode barlen 1 add barchars checksum 43 mod get put

    /text barlen 4 add string def
    text 0 42 put
    text 1 barcode putinterval
    text barlen 2 add barcode barlen 1 add get dup 32 eq {pop 95} if put
    text barlen 3 add 42 put

    % Get the result of encoding with code39
    options (dontdraw) true put
    options (includecheck) false put
    /args barcode options //code39 exec def

    args (txt) [ [text textxoffset textyoffset textfont textsize] ] put
    args (textxalign) (center) put
    args (opt) options put
    args
 
    dontdraw not //renlinear if

    end

} bind def
/hibccode39 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER hibccode39--

% --BEGIN ENCODER hibccode128--
% --REQUIRES code128--
% --DESC: HIBC Code 128
% --EXAM: A123BJC5D6E71
% --EXOP: includetext
% --RNDR: renlinear
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renlinear dup /uk.co.terryburton.bwipp findresource put
dup /code128 dup /uk.co.terryburton.bwipp findresource put
begin
/hibccode128 {

    20 dict begin                 % Confine variables to local scope

    /options exch def       % We are given an option string
    /barcode exch def       % We are given a barcode string

    /dontdraw false def
    /textfont /Courier def
    /textsize 10 def
    /textyoffset -7 def
    /textxoffset 0 def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /textfont textfont cvlit def
    /textsize textsize cvr def
    /textyoffset textyoffset cvr def
    /textxoffset textxoffset cvr def

    /barlen barcode length def

    /barchars (0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%) def

    /barcode barlen 2 add string dup 1 barcode putinterval def
    barcode 0 43 put

    /checksum 0 def
    0 1 barlen {
        /i exch def
        % Lookup the encoding for the each barcode character
        barcode i 1 getinterval barchars exch search
        pop                                  % Discard true leaving pre
        length /indx exch def                % indx is the length of pre
        pop pop                              % Discard seek and post
        /checksum checksum indx add def
    } for
    barcode barlen 1 add barchars checksum 43 mod get put

    /text barlen 4 add string def
    text 0 42 put
    text 1 barcode putinterval
    text barlen 2 add barcode barlen 1 add get dup 32 eq {pop 95} if put
    text barlen 3 add 42 put

    % Get the result of encoding with code128
    options (dontdraw) true put
    /args barcode options //code128 exec def

    args (txt) [ [text textxoffset textyoffset textfont textsize] ] put
    args (textxalign) (center) put
    args (opt) options put
    args
 
    dontdraw not //renlinear if

    end

} bind def
/hibccode128 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER hibccode128--

% --BEGIN ENCODER hibcdatamatrix--
% --REQUIRES datamatrix--
% --DESC: HIBC Data Matrix
% --EXAM: A123BJC5D6E71
% --EXOP:
% --RNDR: renmatrix
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
dup /datamatrix dup /uk.co.terryburton.bwipp findresource put
begin
/hibcdatamatrix {

    20 dict begin                 % Confine variables to local scope

    /options exch def       % We are given an option string
    /barcode exch def       % We are given a barcode string

    /dontdraw false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /barlen barcode length def

    /barchars (0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%) def

    /barcode barlen 2 add string dup 1 barcode putinterval def
    barcode 0 43 put

    /checksum 0 def
    0 1 barlen {
        /i exch def
        % Lookup the encoding for the each barcode character
        barcode i 1 getinterval barchars exch search
        pop                                  % Discard true leaving pre
        length /indx exch def                % indx is the length of pre
        pop pop                              % Discard seek and post
        /checksum checksum indx add def
    } for
    barcode barlen 1 add barchars checksum 43 mod get put

    % Get the result of encoding with datamatrix
    options (dontdraw) true put
    /args barcode options //datamatrix exec def

    args (opt) options put
    args
 
    dontdraw not //renmatrix if

    end

} bind def
/hibcdatamatrix dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER hibcdatamatrix--

% --BEGIN ENCODER hibcpdf417--
% --REQUIRES pdf417--
% --DESC: HIBC PDF417
% --EXAM: A123BJC5D6E71
% --EXOP:
% --RNDR: renmatrix
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
dup /pdf417 dup /uk.co.terryburton.bwipp findresource put
begin
/hibcpdf417 {

    20 dict begin                 % Confine variables to local scope

    /options exch def       % We are given an option string
    /barcode exch def       % We are given a barcode string

    /dontdraw false def
    /columns 2 def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /columns columns cvi def

    /barlen barcode length def

    /barchars (0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%) def

    /barcode barlen 2 add string dup 1 barcode putinterval def
    barcode 0 43 put

    /checksum 0 def
    0 1 barlen {
        /i exch def
        % Lookup the encoding for the each barcode character
        barcode i 1 getinterval barchars exch search
        pop                                  % Discard true leaving pre
        length /indx exch def                % indx is the length of pre
        pop pop                              % Discard seek and post
        /checksum checksum indx add def
    } for
    barcode barlen 1 add barchars checksum 43 mod get put

    % Get the result of encoding with pdf417
    options (dontdraw) true put
    options (columns) columns put
    /args barcode options //pdf417 exec def

    args (opt) options put
    args
 
    dontdraw not //renmatrix if

    end

} bind def
/hibcpdf417 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER hibcpdf417--

% --BEGIN ENCODER hibcmicropdf417--
% --REQUIRES micropdf417--
% --DESC: HIBC MicroPDF417
% --EXAM: A123BJC5D6E71
% --EXOP:
% --RNDR: renmatrix
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
dup /micropdf417 dup /uk.co.terryburton.bwipp findresource put
begin
/hibcmicropdf417 {

    20 dict begin                 % Confine variables to local scope

    /options exch def       % We are given an option string
    /barcode exch def       % We are given a barcode string

    /dontdraw false def
    /columns 2 def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /columns columns cvi def

    /barlen barcode length def

    /barchars (0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%) def

    /barcode barlen 2 add string dup 1 barcode putinterval def
    barcode 0 43 put

    /checksum 0 def
    0 1 barlen {
        /i exch def
        % Lookup the encoding for the each barcode character
        barcode i 1 getinterval barchars exch search
        pop                                  % Discard true leaving pre
        length /indx exch def                % indx is the length of pre
        pop pop                              % Discard seek and post
        /checksum checksum indx add def
    } for
    barcode barlen 1 add barchars checksum 43 mod get put

    % Get the result of encoding with micropdf417
    options (dontdraw) true put
    options (columns) columns put
    /args barcode options //micropdf417 exec def

    args (opt) options put
    args
 
    dontdraw not //renmatrix if

    end

} bind def
/hibcmicropdf417 dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER hibcmicropdf417--

% --BEGIN ENCODER hibcqrcode--
% --REQUIRES qrcode--
% --DESC: HIBC QR Code
% --EXAM: A123BJC5D6E71
% --EXOP:
% --RNDR: renmatrix
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
dup /qrcode dup /uk.co.terryburton.bwipp findresource put
begin
/hibcqrcode {

    20 dict begin                 % Confine variables to local scope

    /options exch def       % We are given an option string
    /barcode exch def       % We are given a barcode string

    /dontdraw false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /barlen barcode length def

    /barchars (0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%) def

    /barcode barlen 2 add string dup 1 barcode putinterval def
    barcode 0 43 put

    /checksum 0 def
    0 1 barlen {
        /i exch def
        % Lookup the encoding for the each barcode character
        barcode i 1 getinterval barchars exch search
        pop                                  % Discard true leaving pre
        length /indx exch def                % indx is the length of pre
        pop pop                              % Discard seek and post
        /checksum checksum indx add def
    } for
    barcode barlen 1 add barchars checksum 43 mod get put

    % Get the result of encoding with qrcode
    options (dontdraw) true put
    /args barcode options //qrcode exec def

    args (opt) options put
    args
 
    dontdraw not //renmatrix if

    end

} bind def
/hibcqrcode dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER hibcqrcode--

% --BEGIN ENCODER hibccodablockf--
% --REQUIRES codablockf--
% --DESC: HIBC Codablock F
% --EXAM: A123BJC5D6E71
% --EXOP:
% --RNDR: renmatrix
/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
dup /codablockf dup /uk.co.terryburton.bwipp findresource put
begin
/hibccodablockf {

    20 dict begin                 % Confine variables to local scope

    /options exch def       % We are given an option string
    /barcode exch def       % We are given a barcode string

    /dontdraw false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    /barlen barcode length def

    /barchars (0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%) def

    /barcode barlen 2 add string dup 1 barcode putinterval def
    barcode 0 43 put

    /checksum 0 def
    0 1 barlen {
        /i exch def
        % Lookup the encoding for the each barcode character
        barcode i 1 getinterval barchars exch search
        pop                                  % Discard true leaving pre
        length /indx exch def                % indx is the length of pre
        pop pop                              % Discard seek and post
        /checksum checksum indx add def
    } for
    barcode barlen 1 add barchars checksum 43 mod get put

    % Get the result of encoding with codablockf
    options (dontdraw) true put
    /args barcode options //codablockf exec def

    args (opt) options put
    args
 
    dontdraw not //renmatrix if

    end

} bind def
/hibccodablockf dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
% --END ENCODER hibccodablockf--

% --END TEMPLATE--

%%EndProcSet
%%BeginProcSet: 8r.enc 0 0
% File 8r.enc  TeX Base 1 Encoding  Revision 2.0  2002-10-30
%
% @@psencodingfile@{
%   author    = "S. Rahtz, P. MacKay, Alan Jeffrey, B. Horn, K. Berry,
%                W. Schmidt, P. Lehman",
%   version   = "2.0",
%   date      = "27nov06",
%   filename  = "8r.enc",
%   email     = "tex-fonts@@tug.org",
%   docstring = "This is the encoding vector for Type1 and TrueType
%                fonts to be used with TeX.  This file is part of the
%                PSNFSS bundle, version 9"
% @}
% 
% The idea is to have all the characters normally included in Type 1 fonts
% available for typesetting. This is effectively the characters in Adobe
% Standard encoding, ISO Latin 1, Windows ANSI including the euro symbol,
% MacRoman, and some extra characters from Lucida.
% 
% Character code assignments were made as follows:
% 
% (1) the Windows ANSI characters are almost all in their Windows ANSI
% positions, because some Windows users cannot easily reencode the
% fonts, and it makes no difference on other systems. The only Windows
% ANSI characters not available are those that make no sense for
% typesetting -- rubout (127 decimal), nobreakspace (160), softhyphen
% (173). quotesingle and grave are moved just because it's such an
% irritation not having them in TeX positions.
% 
% (2) Remaining characters are assigned arbitrarily to the lower part
% of the range, avoiding 0, 10 and 13 in case we meet dumb software.
% 
% (3) Y&Y Lucida Bright includes some extra text characters; in the
% hopes that other PostScript fonts, perhaps created for public
% consumption, will include them, they are included starting at 0x12.
% These are /dotlessj /ff /ffi /ffl.
% 
% (4) hyphen appears twice for compatibility with both ASCII and Windows.
%
% (5) /Euro was assigned to 128, as in Windows ANSI
%
% (6) Missing characters from MacRoman encoding incorporated as follows:
%
%     PostScript      MacRoman        TeXBase1
%     --------------  --------------  --------------
%     /notequal       173             0x16
%     /infinity       176             0x17
%     /lessequal      178             0x18
%     /greaterequal   179             0x19
%     /partialdiff    182             0x1A
%     /summation      183             0x1B
%     /product        184             0x1C
%     /pi             185             0x1D
%     /integral       186             0x81
%     /Omega          189             0x8D
%     /radical        195             0x8E
%     /approxequal    197             0x8F
%     /Delta          198             0x9D
%     /lozenge        215             0x9E
%
/TeXBase1Encoding [
% 0x00
 /.notdef /dotaccent /fi /fl
 /fraction /hungarumlaut /Lslash /lslash
 /ogonek /ring /.notdef /breve
 /minus /.notdef /Zcaron /zcaron
% 0x10
 /caron /dotlessi /dotlessj /ff
 /ffi /ffl /notequal /infinity
 /lessequal /greaterequal /partialdiff /summation
 /product /pi /grave /quotesingle
% 0x20
 /space /exclam /quotedbl /numbersign
 /dollar /percent /ampersand /quoteright
 /parenleft /parenright /asterisk /plus
 /comma /hyphen /period /slash
% 0x30
 /zero /one /two /three
 /four /five /six /seven
 /eight /nine /colon /semicolon
 /less /equal /greater /question
% 0x40
 /at /A /B /C
 /D /E /F /G
 /H /I /J /K
 /L /M /N /O
% 0x50
 /P /Q /R /S
 /T /U /V /W
 /X /Y /Z /bracketleft
 /backslash /bracketright /asciicircum /underscore
% 0x60
 /quoteleft /a /b /c
 /d /e /f /g
 /h /i /j /k
 /l /m /n /o
% 0x70
 /p /q /r /s
 /t /u /v /w
 /x /y /z /braceleft
 /bar /braceright /asciitilde /.notdef
% 0x80
 /Euro /integral /quotesinglbase /florin
 /quotedblbase /ellipsis /dagger /daggerdbl
 /circumflex /perthousand /Scaron /guilsinglleft
 /OE /Omega /radical /approxequal
% 0x90
 /.notdef /.notdef /.notdef /quotedblleft
 /quotedblright /bullet /endash /emdash
 /tilde /trademark /scaron /guilsinglright
 /oe /Delta /lozenge /Ydieresis
% 0xA0
 /.notdef /exclamdown /cent /sterling
 /currency /yen /brokenbar /section
 /dieresis /copyright /ordfeminine /guillemotleft
 /logicalnot /hyphen /registered /macron
% 0xB0
 /degree /plusminus /twosuperior /threesuperior
 /acute /mu /paragraph /periodcentered
 /cedilla /onesuperior /ordmasculine /guillemotright
 /onequarter /onehalf /threequarters /questiondown
% 0xC0
 /Agrave /Aacute /Acircumflex /Atilde
 /Adieresis /Aring /AE /Ccedilla
 /Egrave /Eacute /Ecircumflex /Edieresis
 /Igrave /Iacute /Icircumflex /Idieresis
% 0xD0
 /Eth /Ntilde /Ograve /Oacute
 /Ocircumflex /Otilde /Odieresis /multiply
 /Oslash /Ugrave /Uacute /Ucircumflex
 /Udieresis /Yacute /Thorn /germandbls
% 0xE0
 /agrave /aacute /acircumflex /atilde
 /adieresis /aring /ae /ccedilla
 /egrave /eacute /ecircumflex /edieresis
 /igrave /iacute /icircumflex /idieresis
% 0xF0
 /eth /ntilde /ograve /oacute
 /ocircumflex /otilde /odieresis /divide
 /oslash /ugrave /uacute /ucircumflex
 /udieresis /yacute /thorn /ydieresis
] def


%%EndProcSet
%%BeginProcSet: texps.pro 0 0
%!
TeXDict begin/rf{findfont dup length 1 add dict begin{1 index/FID ne 2
index/UniqueID ne and{def}{pop pop}ifelse}forall[1 index 0 6 -1 roll
exec 0 exch 5 -1 roll VResolution Resolution div mul neg 0 0]FontType 0
ne{/Metrics exch def dict begin Encoding{exch dup type/integertype ne{
pop pop 1 sub dup 0 le{pop}{[}ifelse}{FontMatrix 0 get div Metrics 0 get
div def}ifelse}forall Metrics/Metrics currentdict end def}{{1 index type
/nametype eq{exit}if exch pop}loop}ifelse[2 index currentdict end
definefont 3 -1 roll makefont/setfont cvx]cvx def}def/ObliqueSlant{dup
sin S cos div neg}B/SlantFont{4 index mul add}def/ExtendFont{3 -1 roll
mul exch}def/ReEncodeFont{CharStrings rcheck{/Encoding false def dup[
exch{dup CharStrings exch known not{pop/.notdef/Encoding true def}if}
forall Encoding{]exch pop}{cleartomark}ifelse}if/Encoding exch def}def
end

%%EndProcSet
%%BeginProcSet: special.pro 0 0
%!
TeXDict begin/SDict 200 dict N SDict begin/@SpecialDefaults{/hs 612 N
/vs 792 N/ho 0 N/vo 0 N/hsc 1 N/vsc 1 N/ang 0 N/CLIP 0 N/rwiSeen false N
/rhiSeen false N/letter{}N/note{}N/a4{}N/legal{}N}B/@scaleunit 100 N
/@hscale{@scaleunit div/hsc X}B/@vscale{@scaleunit div/vsc X}B/@hsize{
/hs X/CLIP 1 N}B/@vsize{/vs X/CLIP 1 N}B/@clip{/CLIP 2 N}B/@hoffset{/ho
X}B/@voffset{/vo X}B/@angle{/ang X}B/@rwi{10 div/rwi X/rwiSeen true N}B
/@rhi{10 div/rhi X/rhiSeen true N}B/@llx{/llx X}B/@lly{/lly X}B/@urx{
/urx X}B/@ury{/ury X}B/magscale true def end/@MacSetUp{userdict/md known
{userdict/md get type/dicttype eq{userdict begin md length 10 add md
maxlength ge{/md md dup length 20 add dict copy def}if end md begin
/letter{}N/note{}N/legal{}N/od{txpose 1 0 mtx defaultmatrix dtransform S
atan/pa X newpath clippath mark{transform{itransform moveto}}{transform{
itransform lineto}}{6 -2 roll transform 6 -2 roll transform 6 -2 roll
transform{itransform 6 2 roll itransform 6 2 roll itransform 6 2 roll
curveto}}{{closepath}}pathforall newpath counttomark array astore/gc xdf
pop ct 39 0 put 10 fz 0 fs 2 F/|______Courier fnt invertflag{PaintBlack}
if}N/txpose{pxs pys scale ppr aload pop por{noflips{pop S neg S TR pop 1
-1 scale}if xflip yflip and{pop S neg S TR 180 rotate 1 -1 scale ppr 3
get ppr 1 get neg sub neg ppr 2 get ppr 0 get neg sub neg TR}if xflip
yflip not and{pop S neg S TR pop 180 rotate ppr 3 get ppr 1 get neg sub
neg 0 TR}if yflip xflip not and{ppr 1 get neg ppr 0 get neg TR}if}{
noflips{TR pop pop 270 rotate 1 -1 scale}if xflip yflip and{TR pop pop
90 rotate 1 -1 scale ppr 3 get ppr 1 get neg sub neg ppr 2 get ppr 0 get
neg sub neg TR}if xflip yflip not and{TR pop pop 90 rotate ppr 3 get ppr
1 get neg sub neg 0 TR}if yflip xflip not and{TR pop pop 270 rotate ppr
2 get ppr 0 get neg sub neg 0 S TR}if}ifelse scaleby96{ppr aload pop 4
-1 roll add 2 div 3 1 roll add 2 div 2 copy TR .96 dup scale neg S neg S
TR}if}N/cp{pop pop showpage pm restore}N end}if}if}N/normalscale{
Resolution 72 div VResolution 72 div neg scale magscale{DVImag dup scale
}if 0 setgray}N/psfts{S 65781.76 div N}N/startTexFig{/psf$SavedState
save N userdict maxlength dict begin/magscale true def normalscale
currentpoint TR/psf$ury psfts/psf$urx psfts/psf$lly psfts/psf$llx psfts
/psf$y psfts/psf$x psfts currentpoint/psf$cy X/psf$cx X/psf$sx psf$x
psf$urx psf$llx sub div N/psf$sy psf$y psf$ury psf$lly sub div N psf$sx
psf$sy scale psf$cx psf$sx div psf$llx sub psf$cy psf$sy div psf$ury sub
TR/showpage{}N/erasepage{}N/setpagedevice{pop}N/copypage{}N/p 3 def
@MacSetUp}N/doclip{psf$llx psf$lly psf$urx psf$ury currentpoint 6 2 roll
newpath 4 copy 4 2 roll moveto 6 -1 roll S lineto S lineto S lineto
closepath clip newpath moveto}N/endTexFig{end psf$SavedState restore}N
/@beginspecial{SDict begin/SpecialSave save N gsave normalscale
currentpoint TR @SpecialDefaults count/ocount X/dcount countdictstack N}
N/@setspecial{CLIP 1 eq{newpath 0 0 moveto hs 0 rlineto 0 vs rlineto hs
neg 0 rlineto closepath clip}if ho vo TR hsc vsc scale ang rotate
rwiSeen{rwi urx llx sub div rhiSeen{rhi ury lly sub div}{dup}ifelse
scale llx neg lly neg TR}{rhiSeen{rhi ury lly sub div dup scale llx neg
lly neg TR}if}ifelse CLIP 2 eq{newpath llx lly moveto urx lly lineto urx
ury lineto llx ury lineto closepath clip}if/showpage{}N/erasepage{}N
/setpagedevice{pop}N/copypage{}N newpath}N/@endspecial{count ocount sub{
pop}repeat countdictstack dcount sub{end}repeat grestore SpecialSave
restore end}N/@defspecial{SDict begin}N/@fedspecial{end}B/li{lineto}B
/rl{rlineto}B/rc{rcurveto}B/np{/SaveX currentpoint/SaveY X N 1
setlinecap newpath}N/st{stroke SaveX SaveY moveto}N/fil{fill SaveX SaveY
moveto}N/ellipse{/endangle X/startangle X/yrad X/xrad X/savematrix
matrix currentmatrix N TR xrad yrad scale 0 0 1 startangle endangle arc
savematrix setmatrix}N end

%%EndProcSet
%%BeginProcSet: color.pro 0 0
%!
TeXDict begin/setcmykcolor where{pop}{/setcmykcolor{dup 10 eq{pop
setrgbcolor}{1 sub 4 1 roll 3{3 index add neg dup 0 lt{pop 0}if 3 1 roll
}repeat setrgbcolor pop}ifelse}B}ifelse/TeXcolorcmyk{setcmykcolor}def
/TeXcolorrgb{setrgbcolor}def/TeXcolorgrey{setgray}def/TeXcolorgray{
setgray}def/TeXcolorhsb{sethsbcolor}def/currentcmykcolor where{pop}{
/currentcmykcolor{currentrgbcolor 10}B}ifelse/DC{exch dup userdict exch
known{pop pop}{X}ifelse}B/GreenYellow{0.15 0 0.69 0 setcmykcolor}DC
/Yellow{0 0 1 0 setcmykcolor}DC/Goldenrod{0 0.10 0.84 0 setcmykcolor}DC
/Dandelion{0 0.29 0.84 0 setcmykcolor}DC/Apricot{0 0.32 0.52 0
setcmykcolor}DC/Peach{0 0.50 0.70 0 setcmykcolor}DC/Melon{0 0.46 0.50 0
setcmykcolor}DC/YellowOrange{0 0.42 1 0 setcmykcolor}DC/Orange{0 0.61
0.87 0 setcmykcolor}DC/BurntOrange{0 0.51 1 0 setcmykcolor}DC
/Bittersweet{0 0.75 1 0.24 setcmykcolor}DC/RedOrange{0 0.77 0.87 0
setcmykcolor}DC/Mahogany{0 0.85 0.87 0.35 setcmykcolor}DC/Maroon{0 0.87
0.68 0.32 setcmykcolor}DC/BrickRed{0 0.89 0.94 0.28 setcmykcolor}DC/Red{
0 1 1 0 setcmykcolor}DC/OrangeRed{0 1 0.50 0 setcmykcolor}DC/RubineRed{
0 1 0.13 0 setcmykcolor}DC/WildStrawberry{0 0.96 0.39 0 setcmykcolor}DC
/Salmon{0 0.53 0.38 0 setcmykcolor}DC/CarnationPink{0 0.63 0 0
setcmykcolor}DC/Magenta{0 1 0 0 setcmykcolor}DC/VioletRed{0 0.81 0 0
setcmykcolor}DC/Rhodamine{0 0.82 0 0 setcmykcolor}DC/Mulberry{0.34 0.90
0 0.02 setcmykcolor}DC/RedViolet{0.07 0.90 0 0.34 setcmykcolor}DC
/Fuchsia{0.47 0.91 0 0.08 setcmykcolor}DC/Lavender{0 0.48 0 0
setcmykcolor}DC/Thistle{0.12 0.59 0 0 setcmykcolor}DC/Orchid{0.32 0.64 0
0 setcmykcolor}DC/DarkOrchid{0.40 0.80 0.20 0 setcmykcolor}DC/Purple{
0.45 0.86 0 0 setcmykcolor}DC/Plum{0.50 1 0 0 setcmykcolor}DC/Violet{
0.79 0.88 0 0 setcmykcolor}DC/RoyalPurple{0.75 0.90 0 0 setcmykcolor}DC
/BlueViolet{0.86 0.91 0 0.04 setcmykcolor}DC/Periwinkle{0.57 0.55 0 0
setcmykcolor}DC/CadetBlue{0.62 0.57 0.23 0 setcmykcolor}DC
/CornflowerBlue{0.65 0.13 0 0 setcmykcolor}DC/MidnightBlue{0.98 0.13 0
0.43 setcmykcolor}DC/NavyBlue{0.94 0.54 0 0 setcmykcolor}DC/RoyalBlue{1
0.50 0 0 setcmykcolor}DC/Blue{1 1 0 0 setcmykcolor}DC/Cerulean{0.94 0.11
0 0 setcmykcolor}DC/Cyan{1 0 0 0 setcmykcolor}DC/ProcessBlue{0.96 0 0 0
setcmykcolor}DC/SkyBlue{0.62 0 0.12 0 setcmykcolor}DC/Turquoise{0.85 0
0.20 0 setcmykcolor}DC/TealBlue{0.86 0 0.34 0.02 setcmykcolor}DC
/Aquamarine{0.82 0 0.30 0 setcmykcolor}DC/BlueGreen{0.85 0 0.33 0
setcmykcolor}DC/Emerald{1 0 0.50 0 setcmykcolor}DC/JungleGreen{0.99 0
0.52 0 setcmykcolor}DC/SeaGreen{0.69 0 0.50 0 setcmykcolor}DC/Green{1 0
1 0 setcmykcolor}DC/ForestGreen{0.91 0 0.88 0.12 setcmykcolor}DC
/PineGreen{0.92 0 0.59 0.25 setcmykcolor}DC/LimeGreen{0.50 0 1 0
setcmykcolor}DC/YellowGreen{0.44 0 0.74 0 setcmykcolor}DC/SpringGreen{
0.26 0 0.76 0 setcmykcolor}DC/OliveGreen{0.64 0 0.95 0.40 setcmykcolor}
DC/RawSienna{0 0.72 1 0.45 setcmykcolor}DC/Sepia{0 0.83 1 0.70
setcmykcolor}DC/Brown{0 0.81 1 0.60 setcmykcolor}DC/Tan{0.14 0.42 0.56 0
setcmykcolor}DC/Gray{0 0 0 0.50 setcmykcolor}DC/Black{0 0 0 1
setcmykcolor}DC/White{0 0 0 0 setcmykcolor}DC end

%%EndProcSet
TeXDict begin @defspecial

 /pgfH{/pgfheight exch def 0.75 setlinewidth [] 0 setdash /pgfshade
{pgfA} def /pgfdir { dup 0 moveto dup 5 index lineto } bind def} bind
def

 /pgfV{/pgfheight exch def 0.75 setlinewidth [] 0 setdash /pgfshade
{pgfA} def /pgfdir { dup 0 exch moveto dup 5 index exch lineto } bind
def} bind def

 /pgfA{ /pgfdiff 8 index round cvi 8 index round cvi sub 2 mul 1 add
def 2 index 6 index sub pgfdiff div 2 index 6 index sub pgfdiff div
2 index 6 index sub pgfdiff div pgfheight 9 index 9 index 9 index 14
index pgfdiff { 3 index 3 index 3 index setrgbcolor pgfdir stroke 4
-1 roll 7 index add 4 -1 roll 6 index add 4 -1 roll 5 index add 4 -1
roll .5 sub } repeat mark 15 1 roll cleartomark exch pop }bind def

 /pgfR1{ newpath dup dup dup 0 360 arc clip newpath dup /pgfendx exch
def /pgfendy exch def 0.875 setlinewidth [] 0 setdash /pgfshade {pgfR}
def /pgfstartx exch def /pgfstarty exch def /pgfdiffx pgfendx pgfstartx
sub def /pgfdiffy pgfendy pgfstarty sub def dup /pgfdomb exch def }bind
def

 /pgfR2{ newpath 0.5 add pgfcircx pgfcircy 3 2 roll 0 360 arc setrgbcolor
fill pop}bind def

 /pgfR{ /pgfdiff 8 index round cvi 8 index round cvi sub 4 mul 1 add
def /pgfcircx pgfstartx 9 index pgfdiffx pgfdomb div mul add def /pgfcircy
pgfstarty 9 index pgfdiffy pgfdomb div mul add def /pgfcircxe pgfstartx
8 index pgfdiffx pgfdomb div mul add def /pgfcircye pgfstarty 8 index
pgfdiffy pgfdomb div mul add def /pgfxstep pgfcircxe pgfcircx sub pgfdiff
div def /pgfystep pgfcircye pgfcircy sub pgfdiff div def 2 index 6
index sub pgfdiff div 2 index 6 index sub pgfdiff div 2 index 6 index
sub pgfdiff div 8 index 8 index 8 index 13 index pgfdiff { 3 index
3 index 3 index setrgbcolor pgfcircx pgfcircy 2 index 0 360 arc closepath
stroke 4 -1 roll 6 index add 4 -1 roll 5 index add 4 -1 roll 4 index
add 4 -1 roll .25 sub /pgfcircx pgfcircx pgfxstep add def /pgfcircy
pgfcircy pgfystep add def } repeat mark 14 1 roll cleartomark exch
pop }bind def

  /pgfsc{}bind def/pgffc{}bind def/pgfstr{stroke}bind def/pgffill{fill}bind
def/pgfeofill{eofill}bind def/pgfe{a dup 0 rlineto exch 0 exch rlineto
neg 0 rlineto closepath}bind def/pgfw{setlinewidth}bind def/pgfs{save
pgfpd 72 Resolution div 72 VResolution div neg scale magscale{1 DVImag
div dup scale}if pgfx neg pgfy neg translate pgffoa .setopacityalpha}bind
def/pgfr{pgfsd restore}bind def userdict begin/pgfo{pgfsd /pgfx currentpoint
/pgfy exch def def @beginspecial}bind def /pgfc{newpath @endspecial
pgfpd}bind def /pgfsd{globaldict /pgfdelta /delta where {pop delta}
{0} ifelse put}bind def/pgfpd{/delta globaldict /pgfdelta get def}bind
def /.setopacityalpha where {pop} {/.setopacityalpha{pop}def} ifelse
/.pgfsetfillopacityalpha{/pgffoa exch def /pgffill{gsave pgffoa .setopacityalpha
fill 1 .setopacityalpha newpath fill grestore}bind def /pgfeofill{gsave
pgffoa .setopacityalpha eofill 1 .setopacityalpha newpath eofill grestore}bind
def}bind def /.pgfsetstrokeopacityalpha{/pgfsoa exch def /pgfstr{gsave
pgfsoa .setopacityalpha stroke grestore}bind def}bind def /pgffoa 1
def /pgfsoa 1 def end

 systemdict /pdfmark known{userdict /?pdfmark systemdict /exec get
put}{userdict /?pdfmark systemdict /pop get put userdict /pdfmark systemdict
/cleartomark get put}ifelse

 /DvipsToPDF{72.27 mul Resolution div} def/PDFToDvips{72.27 div Resolution
mul} def/BPToDvips{72 div Resolution mul}def/BorderArrayPatch{[exch{dup
dup type/integertype eq exch type/realtype eq or{BPToDvips}if}forall]}def/HyperBorder
{1 PDFToDvips} def/H.V {pdf@hoff pdf@voff null} def/H.B {/Rect[pdf@llx
pdf@lly pdf@urx pdf@ury]} def/H.S {currentpoint HyperBorder add /pdf@lly
exch def dup DvipsToPDF 72 add /pdf@hoff exch def HyperBorder sub /pdf@llx
exch def} def/H.L {2 sub dup/HyperBasePt exch def PDFToDvips /HyperBaseDvips
exch def currentpoint HyperBaseDvips sub /pdf@ury exch def/pdf@urx
exch def} def/H.A {H.L currentpoint exch pop vsize 72 sub exch DvipsToPDF
HyperBasePt sub sub /pdf@voff exch def} def/H.R {currentpoint HyperBorder
sub /pdf@ury exch def HyperBorder add /pdf@urx exch def currentpoint
exch pop vsize 72 sub exch DvipsToPDF sub /pdf@voff exch def} def

 /pgf1{gsave exec 1.0 pgfw 2.00002 0.0 moveto -6.00006 4.00005 lineto
-3.00003 0.0 lineto -6.00006 -4.00005 lineto pgffill  grestore} bind
def

 /pgf2{gsave exec 1.0 pgfw 0.8 pgfw [ ] 0.0 setdash 1 setlinecap 1
setlinejoin -3.00003 4.00005 moveto -2.75002 2.50002 0.0 0.24998 0.75
0.0 curveto 0.0 -0.24998 -2.75002 -2.50002 -3.00003 -4.00005 curveto
pgfstr  grestore} bind def

 /pgf3{gsave exec 1.0 pgfw [ ] 0.0 setdash 0.0 -5.00005 moveto 0.0
5.00005 lineto pgfstr  grestore} bind def

 /pgf4{gsave exec 1.0 pgfw [ ] 0.0 setdash -3.00003 -5.00005 moveto
0.0 -5.00005 lineto 0.0 5.00005 lineto -3.00003 5.00005 lineto pgfstr
 grestore} bind def

 /pgf5{gsave exec 1.0 pgfw [ ] 0.0 setdash -2.00002 -5.00005 moveto
1.0 -3.00003 1.0 3.00003 -2.00002 5.00005 curveto pgfstr  grestore}
bind def

 /pgf6{gsave exec 1.0 pgfw [ ] 0.0 setdash -4.50003 -5.00005 moveto
0.49998 0.0 lineto -4.50003 5.00005 lineto pgfstr  grestore} bind def

 /pgf7{gsave exec 1.0 pgfw -2.50002 0.0 translate [ ] 0.0 setdash 3.00003
0.0 moveto 3.00003 1.65689 1.65689 3.00003 0.0 3.00003 curveto -1.65689
3.00003 -3.00003 1.65689 -3.00003 0.0 curveto -3.00003 -1.65689 -1.65689
-3.00003 0.0 -3.00003 curveto 1.65689 -3.00003 3.00003 -1.65689 3.00003
0.0 curveto closepath gsave pgffc pgffill grestore gsave pgfsc pgfstr
grestore newpath  grestore} bind def

 /pgf8{gsave exec 1.0 pgfw [ ] 0.0 setdash 1.0 0.0 moveto -5.00005
3.00003 lineto -11.00012 0.0 lineto -5.00005 -3.00003 lineto closepath
gsave pgffc pgffill grestore gsave pgfsc pgfstr grestore newpath  grestore}
bind def
 
@fedspecial end
%%BeginFont: Fourier-Math-Symbols
%!PS-AdobeFont-1.0: Fourier-Math-Symbols 001.004
%%CreationDate: Fri Jan 7 18:46:05 2005
%%VMusage: 120000 150000
11 dict begin
/FontInfo 14 dict dup begin
/version (001.004) readonly def
/Notice (Copyright 2003-2004, GUTenberg) readonly def
/FullName (Fourier-Math-Symbols) readonly def
/FamilyName (Fourier-Math-Symbols) readonly def
/ItalicAngle -15 def
/isFixedPitch false def
/UnderlinePosition -17 def
/UnderlineThickness 3 def
/Weight (Regular) readonly def
end readonly def
/FontName /Fourier-Math-Symbols def
/Encoding 256 array
0 1 255 {1 index exch /.notdef put} for
dup 49 /infinity put
dup 91 /union put
dup 161 /minus put
dup 183 /lessequal put
dup 184 /greaterequal put
dup 197 /plus put
readonly def
/PaintType 0 def
/FontType 1 def
/FontMatrix [ 0.0010000 0 0 0.0010000 0 0 ] readonly def
/FontBBox {-34 -960 1001 847} readonly def
currentdict end
currentfile eexec
D9D66F633B846A989B9974B0179FC6CC445BCF7C3C3333173232E3FDBFF43949
1DB866C39088C203DC22FDC758584860EC7BB67FDA28CC6208249060E18FAB32
204779B5C03C0493BBBBC95CF02692CC4DEAA8D2EA90B5C2E64374E92BCB8501
429B8FAE4A76C0C6B76D6FF7CF9A7D5EDFBCA0E959541C59BD05B7DE43D25D53
FC3DDA6EF0C2743978A6D03E19CCED4A11F2EA4BCC3110BE8B8D9E2772361969
C19258EFAFDC276CB1ADE9208A941A36D18F9FB1C33DEF76AA315DDB07D441AB
0467A1BF50AD0DE4F98225ADD1F93634005664EC4D3A79AAE931F7496D4AD122
EAEBCBFB4D4AC1B8D85E9CBE4ABB2225405A9DA5AB44E12A710451885D4FADD8
C3F48A838573A733544D6AD3B5C7B3E16F8F777F1DD842F33638F7D57C0C9212
0C6560A06445FFE43730EC1895E85874440C56BF079DCF6C249978AEC565369E
E2DE0A62595334A70543753553A4D58895F84C9627524042C4B480C4654D6578
67B2C0CC4A43523BABBF2E8BB693003339A7DD77148E4C146BF5A7AA602A3908
5300B7C1798206E16AAEC1262E3B1DD7325659679A19229F75B0A7BF816E1594
68BE15C3F762C51595E7902AAB117057F4EB1316DC1C507B857AC1B1BE38123E
4AB0CC69F0C42D92081FEAC1259E24E696131A9170053DED6CE28A4D407AE241
675620191E5953CB96967BF04CE1DCB7B9089849FE477F73ADDA94B72632B5C3
E4B12701C044D3B666DB24E45DF8FB89C5DA53188D7C588C1F9DCE353F3D357C
212D5E0CE43B242313912CB809EA23E8158049754D5A9129419949A7C79BB1C5
17FD49A1E5FC3A4095D91E472B31D7A788DB3D0D0778C6D96F68C849FD58496A
9F820DA8C2E98BA0DB5D0EDD60D0A5EF062D122D5B440DEEF97172CA0DA38AC6
D8AE16E16E62C3A99D3B1DF9F1BEA90163879CEA5BA341CB947DFB0C41B08B06
946F9C8A754B9FD193F9EB60CF81B8343A759E5D9641BCE58C2D8C0BF5CBB461
88E32829BBBEEF6E1C8A713A3A614565A4A9AFDD566D081CE2954D486E275D41
3BB9DCEF1E66E7EC178E370757EC626E6E82D294BF3E83ECC0782DC63E319DD4
CF867F340449A0A245430C101F3E5DB92CD828ECD21A2B602F26E72FEB38368F
DC03123FA421EEA747607B26A3030C048BD160A39735F731DA07EF3D6E818628
AF05166460DA5B83052A083336C23DE3F4916E3E60E10509910166E063832CE3
29E5DF2FDFD0AA1DC9F1C99A95FC477BF7F113B2CF4626600B1B5DFF712EB302
AFCB86EEF4DD29EA456833CF29BC0C5CC42C0BB09735A0A83143A0560B03DF25
B27B0B383BD641B85E8F6790F6ACFA6A03C77D60425F8B515C48893EE05FFD60
CB40D1B9185FCF7D27FAE0616B15007FBA17D23DBE9347515CC3A932A96246E1
85C477A9D6665D4F5D8F374CF4C0F4CDE76C57C8F7BD4A66071AF94604FBA047
80C65D0357949E03600E099BFE0ECAEBC6E6A636BCFEFC0A9035532476354B49
DFC61218068C10E8103BFF464394C6A73A86807D46452EFE438C9A865EBF1012
EBFFBCDF91BD6D42C70CF917948F1614FF711A7B3CF5C0EDA38090F1EE7E8036
FBDE8308D2A3CF08B83350E4004B771F8A5E10059DD473B96E62C2CDB9A88D06
7CA60CA5D379936002719364D03787F47ECBDB456A774EBEC7708BAB088BA165
90976D361066DDFD3929345B04391DFDDDCCE8349B9522DC0263C457BC9A97C6
686221F2ECD7582E2EC82979AF1B077912BE9AD663AD70D0E4F0A0B093DC80EA
0B7759F20A1495B921F4895E30C0AF855A6447A40469E517370C0A543502C5E5
0257AD29ADD61816748F3670E90DE43BC78EF37068FB974D59361AC7C0BA1381
03CD41FB9EFD31055CB627062710B3C4B93CC45764046C4FDEBA45AFD72C82A1
BCBBF9859334313D7E8058E911780E57D7D2B47000A2824A1F28B759D2F6DED5
BEE6620B8F35DE353D9ACF0E886BF4101CB8E3B5CB6C046D2B8D215F44ECD507
5BC9B37977C903F6B4CA745B266C52493E2561F59678C97A12FFB9290CAB892D
D52159B160FCE42A5EC3B7AB8F393F52C20956125BF622DEE20417893C1E0FAF
62F8196AF8A9924F3786D3469E6181C85D0768A4E35EFBD4BC3672578E6F74F1
DE58F91F0C4A0776781469DBE6069B04B1D87A88ECFA2330EAA97AF1A0BBAE96
B82B6E87DB45307E3BD4A6C6C51EAC0FE5EF32D58749B938650044A653F7CD41
26E81783E381A7B37509D6E5F06B350AA79A7E769CBA2D94B35DA0E7BDE618A3
ECBB2D5E366AAFAA6EAEDD6BB5922DCEE55E7B8238414602BFD40362B0C14DF0
55B824E7D7FE7E08BFC70A7807C0974D6DC20E407F1FA882FC09CFA62389275E
6D719CD40D175F6842BB1639E7BFBBA94D2488FDEE0144AE76C2699000946ADC
40DC07A20FD68F446819939C9F775614648794F2E23DB4E2582754BC28ECA1F4
5E9E7DF5104E744C9938BEA37553D0075C4D6AF25E4EFE057838192992E563CA
971F9266D69B6B2DC9
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
%%EndFont 
%%BeginFont: Utopia-Italic
%!PS-AdobeFont-1.0: Utopia-Italic 001.001
%%CreationDate: Wed Oct 2 18:58:18 1991
%%VMusage: 34122 41014
% License clarified 17 November 2006; pfb update 19 November 2006.
11 dict begin
/FontInfo 10 dict dup begin
/version (001.001) readonly def
/Notice (Copyright (c) 1989, 1991 Adobe Systems Incorporated. All Rights Reserved. Utopia is either a registered trademark or trademark of Adobe Systems Incorporated in the United States and/or other countries. Used under license. The Utopia fonts are freely available; see http://tug.org/fonts/utopia.) readonly def
/FullName (Utopia Italic) readonly def
/FamilyName (Utopia) readonly def
/Weight (Regular) readonly def
/ItalicAngle -13 def
/isFixedPitch false def
/UnderlinePosition -100 def
/UnderlineThickness 50 def
end readonly def
/FontName /Utopia-Italic def
/Encoding StandardEncoding def
/PaintType 0 def
/FontType 1 def
/FontMatrix [0.001 0 0 0.001 0 0] readonly def
/FontBBox{-166 -250 1205 890}readonly def
currentdict end
currentfile eexec
D9D66F633B846A989B9974B0179FC6CC445BC06347FF71900AC8FEAE3B716D52
C1AC4E5DCF4EFC3B9121F09CAB0C4BE35FD0740E08C853EF201BBFF011DE2163
790FADCD67A15500D3F87E2616B7DEEBFB3934B09CF7B8BE9B945D2638887F73
1C3214D790EBA3065BF944D77DD51978CB663398285895D774586FDDD6A7467E
B1BAC83EC766EDE0FF34D07C6E315D7B79B205EDE798A08FD0D9CD4A1307FDE8
7F57AE7A32759AAE66C77C6127F65D92BCCE74ED784372E34CC835BC789BDEA2
9E27574D388B2CEB1DB127C190624246F4991BA418137BEC72C8CF7830DCEA26
E13BC7F0CDDAE283F10C1FDCD1B46ED2C4BF3526E9DA8165ADF55799A329EB45
40E811F9140E5296B391A61903BC09B76E7BCF96FA1EA22ACBA9ED962E9BC596
BB22E4A514A5C551107BC74BACBFE55ABADEB1741C20BD80A186E49DD89CE033
CA0ACA0D0D4188B8A6FB40C265A88804443A7E912005A6BFD10EBB43315F7A9E
E8C24321131DDDAE6572BE67DE42C5969688AC1D7EB97887D783F63658AABEB1
FA4C2F625E6B6205D3EEC1C5E2FE8C29BD88FDF52802F3F5BACE6AA2007FC0FA
B6CE66673C1D698F51457AB1343CCCEC0D2FD0383BE98493902021E1A27B71A9
0BD0DC94B4C46825738C15B5E101C68813E1F8C8B19311648DF09363FCEF679C
E691E13CE96DDD1455A75181706F41EA2E0A6A4C870F7D3726547BAD35E0EE54
7F91EFEB803E93D1A9BA74A332EE4E56CDB48AC36A47B9B555997C7A58C3A16C
8D71BE01432D88B842B5D9ACAD19FFF7EC88B4E66036D2735311AA323BDD69D6
8CF32F9AA7781A2146E04D71C54044218DE26A4EFEAF67EFD04E4ADE1D7FE2DB
61A465957450E623CA58FC49FA2236C0BA3E81E9A9FA8909261A4A092AC9640C
08CB2AF3BC1E92E578086556ABF6A1F739582230AF46D4C184714197545BE932
1FE1F05FA46478BEB38010C2FAE84145D367FA53B10F42B7B7BA76B427210475
71E67A52D8EADC847639F0BE7F280F35EDBE34C7FFD9907E796F373015965E1C
FF36F43C653EA3F23B76FC2ECEF9EC19D5BC245369A690C280DAF9F3D8401A08
95D0FC1C3F0C033AE23062A80A3B8A944F642986A878A0284CEFB15CEDEA1347
51EF2555BA5CF5BC0C292C152AEDE39A3D435EC8891AD6FE99838F6BD7A8B858
00644760DFD22A7E42C5EE6EFF9FD93D01AF5826ACFEF73F55578040BD4EA591
94239AAD1358C37B5E6FEDF1B0D46734A5386B24F8EB5CC90E350D37688B8A07
A6ED37D9086A43938D17831150BF051470A956F16FABE095880A857ACC741540
10F2FA61EA1F01DE02D67D45D8FC7F464A0B2D3EC59C447C35DFD7FB3A9F9FB5
BB885C46C57184AA3EB8690830EBA8573F88A65B69070B528273945B10B76445
6D839EABDC0CC33171533EAC3890D6563EB1AD0B2950A81B08B5F05769588A51
854C1982EEDF6471D75907CC1DF0C1BB1C6B69272E3A2EA97D0B49E46A492E8F
8C8A246E064AEFAE6FE219F06892F302CD569E23539BBD92FA2077578FE386BB
D02544004ED88F23FA8A08103957BBFD144D01E56DC8033DA5165F621E4B4F00
754562828431A9821624AD6DB724A0D429DF2C7F74C30A4674AA7B006877B2FA
414BBCB6531F9B82DB524A8D65F27FD72C7ECD079301653B69A0B9BD4F15890A
02B8E25C29B3644B255768E4CE7B0FFD5674E4850CC1A175AB6409567DD90366
DA8886E9CC715784F50DC8A2CBBEBC017D4A3D0B78CBDAC3A4FBE58E7878898C
64529661B3C02C659BDD28BAFAEF400F13A38EAC51CFBE9FCB3284D37626BD2C
0F0881E7E94D1CE78A7042A1AE092A004A159ACAF89678837179D221F7D5621D
5F7E53E0737A397FDD41932F18C80A39605C90BEB634D95519987288ADF8329E
8DC9F0322EC8554B1465BD0B83E3E4C9F3FB3FA4114147CFC02B7A4C444B9D6F
DCD02B83352A92D61E394C8019407826A13E2C523AEFABBB7D77A88286BA4514
B17221420CEE8E6B3A01181604BF43CC7746FB953DA34CAA4FC9027AB6829DAF
F653300EE8B70EC38521DE8556AA79171ECAD56F00595123245A7F4181558001
321969CD052FE4843E9A3001BFE87EE260E1B226E11D7A9E290BC0155F3C47F0
5DD7AF5E31B757645DBD3A8034F427C6A79A2DB1FDF0385399C9D7CD9912D5F7
6AF87B4CC50C328415B220602A7B918F378C99CE73615AB2003F25E713240FE5
7ED993DF24CA8DF4E7DB9CE9F13F34C7DEF297143CF696309092EB2C15B16B4B
4C402212E2ECCAC815A7C1F786DCCB673E01FB893B49E2428CAFD2D201480CA8
6F29174566D6607ABFC8401D2545E9FACD322693F94BD5B2A2936388E2DEC934
A2155DC2E7A4A16012044DC4F503AC7A839D700A7FA1CB7AE5C75D7DAEC7FF5C
3518FE16FA4A5032D284011B7B4DE933EAF370C2B8A5CFB7C0C43C6C5837DE85
B01546EBEB064374451C96626F328476187101E35067CB41F763FC0F6950B277
2F4BCE6AF00228DD0F4151A3CF5FD03710257E69F6A4973D52B28D6CA91F4E34
AF897017BAF00719BB3BD4D84D1B7B4499D78177DF56958B251816487C4B9693
4E724F616B55F212F19C2A516FAD51C00E0300CED68405A82F27DC0F0D90E750
2C3D8DF47D448DB15485BE5285DA16AE15C8F2FE27E99F5194F7B6155DF7C080
72FDBA5D33B1FDBAA976C475B734BA463409FA7694087A0AF3051EED31D9B6B4
0DCD96BDC1BC902B99CA436114846D140FE6880478B42E7C08210E5CA3B7CA25
08355C51B30D1D5ECE203D62872AA2923DB2C4ED830D15932767D3F917F8F451
BC1C6C550731C5A8780B27722E5FC5CCF79A35907DCBBC764CA6B772EF73E44C
84A64173C0E001EFAB50C26895A7F87DC9CA5CEB07EF3004B2F80D65C7970953
036483B6AA639EBD37F92CE9F217B95BA0ADB8AD0B9C68984123641A24A2E0D0
5FE889218A14FE02654808DD9A3A4323DD30226A092BA8E3635AD263B3D82689
E4BE8D1DF6F62978CD616F14F2EFAC60FFF8D86AB3A059CD5C24BE83FE9515EB
931BF2C437793E05D7C710015A547477FDDCF3EB345034DD3F66EFC7137D118D
4F24365E852F4BF6E4498B7C2A2C0B9BB8A5BFB7A119CF900933F528E1BE0EA3
A268C57A36BBF2307F7D1E8C956E40335385D053FFE120C493EDF90D8C4E3669
C6BF825FE30E93B08E585F25B794B6339B610667E54A5802247D2610690CACE5
558DB97A103553E70F0F7F0D46E901409F30894D707BAB5F1B0A2DBFCF3738D8
EB2673234DC803CFAF4ECA0423E5B046E2379AFBC123EAEB1D7FEB771F1150B7
B5637A7830D98F754A5C08618C6D25A98AAEDF937B5BFFBB3A221FF845044DE2
8EFA5B1421C8FA2D938FAF8F31B1B1D9FF183C03836FC164951E514EFAE5F948
B249B593BBE6C93C5E54941AFD0B102A8AF2F6194D5AD4ED8D7C0A15E05FD9B1
4B1B3BDA8175C4EE34ADCE5C5D725C1EC2AAB44C23B85DCAD93FD38FAE1FD869
04E36279CAB177D97322B6A76E3CE02E9DC08B590DD9B1E85677D733FF07B558
F4AC48D9528D6BA66E14F3C046A1F0BBAC9CDD5095F0B5B16B62E91720E908BE
2CE1ACE89576B93A1CDB9D1A0F91603425C520242AE427A8E7AC3C0663A12B85
EDC78DD18F4406A3901EFA133710451F4871497CCA34766751BE87122015976E
E95050D07A72D3CDBFCEC7ACFAD24F481665CDC62F431F20170A45E8287A3C31
3E1F43C21C24530AD384823CFB8C9B7A761EB700766D976CF20A782776B03496
43BCC31126916FB309B314061C405E1F866BBF22FE084020D074858D2BB30FDF
7FC059FDF175D6A94E163D900F6E7A468EFFDD9250F14FFF445B77FD5F7B2B53
7B588B417B20D39C5ACF3D4695220221DD48BEA1204AA6AD1309BC648883144C
DD97E5AF4598557AC95444525EE89CBFE4DF60BA321EC8C7562F9BA6A96FEA19
D808A4CDDD997DB4E2BEFB657327AB3BC64D0E5E8BFFDF5AB948F478C09667C4
B72B9DD6E2DD064CE34460B9DC5E665EDC0E3CF03FBAC5933ED0612296632D42
C8DFC16E97AFF5590C15A496B666A158A5D83B4C04C9D4A73790E00188B8B7CE
69E93B30BCC7B4CBBB060A0F1F994162D094B7557F9D97ED44FF01A1813B6D78
69F7B3511731371D9A963DEEE6E7F80094BE329198F99C37A8CDE74D19EAD638
4E1D6DAB56BC912FDE178403A9972B36CD2015F9FDA7C6B9C781EC691ADFF56F
86D78237EF948BB4D84BAC4D649EDCD0DB3D25698D746A0AEA09644DC1AB99CC
889C386B4A45B572384FC1EC7D7DBA7B930E0A5D8E3FC92DE5F64B6F91B2FC07
702E1AA1E6A9FB59BA4E9C699B9CDEFE93AC05C15DE2FD0116DDA52EF5A073CD
BD82DCA8B2F67B7FA14894599070C07E19F7322BC9491954D1A850A783BEBA01
BC0F1420DFE5F0B07D180C519916C2A54E6B18E1CC6E4CF4BEDED451546112F2
F308EB32AAF02601FC4F93A16EE152DDC6C133699B566E964B52FEC5E85739E3
F647FDA7D9183CCBFA54EDDE178B40939D2ED8069FB5663A378B852DB592EACF
FC826FC3AF7E29501C77CAFA9C16475AA0E0DE2B1AD0B30D5A19F3FF0B01F65C
184DFF9EDAF67396C1F5D03FB3F14CFEF80336C980D193EA7F2D049018D41E5A
4168FC1F037B3072C48C2712B24EC3E1274BA087E7E54F46302A9DAC0C40AD4F
75431B2BC1C91DCB71C93034BC184C2882FDE2F6F40943B40D065B1047678177
7382E28743825823F4CA7DC669D8A300BB910C11D2A8027E200A1F3193BE1440
DD5882B554850C04A0FAA9BA7813F98DBDD94538DF93F98571CF8A6975BE0CBE
FC804BBAC5FA27934D85817163172F88C11F7B013E737DD88AF0E5CF883777F8
0902D519012FAAAB5E2837D1CBC12AD7B5C18E215A5E99C9D7CD9C2EBA72B51F
3F3C91C1AC68C2C432ED38FFF22CB3E55EDA5E61D193C1FB1353D8E1DADE4358
54B0A0B1E55CD8D87D04EA286BDE84468B0A846B18690EE00F79734FD400376D
3D64D6510F71C50238DD526FD10381E3A526388749FCF325A4DDEF7DA2E241E2
EDB160309A86FF740C129A348707645705AB3833A66DFD76FA95412E2A7FEE43
FBFB8DD3A2FF257C6A0996D4179B307096031A8F27FBA3E1DBDEC350943A7BBF
CF97D7A457513939AAA4C254E91D1219F436A69CC5D822C2C2F06C24299196A7
A874B7A87E528724FB0C36D468AA3A8CF8AA308DAA5F5DCA23F697EC4B4A64F6
8FFC9D1AEB97BAC7FC7A6812DBECABE66F9437B625F6748D48720A0F51301680
CB83FBCC249ABDBB01976035431A4605A7819206027739C0532F1E22AB922329
D5154B44B923B2CD707A6A4F3171F878B3EF455C242395E6C807B7E2E8D867F7
A988D444D93719150C6CF155930698C2D5BDDB2548C63009DCADA08CD544CA60
4ED82233D2145BFF862ACED0EF97061A3BF78536E50551CFD47DFC4A2F2603D8
D4770F8B592F4E7C32F7D29BB595582637C975F5D8C09E3760EBA129D7849BB0
2EADCA01531FB810A9FF2CA708960055D7CCC875173CC3CDE4F6D347B263664D
7E44BCDBE8F0BF84846A929A2ECCAE0FACA78A9D1230ECC079086858B740F2B4
D53A86642450562384272CB10CF5306E76031390BC67BD981841EE4F938CF048
59DD3BD66C029C813547B1174FE3908AB3F675FA8039AD7CB8331726C049117D
B040F0C3E4136F2A45503DC3370FA4404632B1E1826CFE3682EE830C395CA1FC
7428F5A637FE21FF47D8FE253AAFD66EA16F95F9AFEB3D39DC889BFF9FEF74B0
20547C39B0EA131789F93DC4B71251B5681BE101627FF95F6B18117AC17833E5
A3514D103A3DB09C271C7708F7D78C26C1D302687794E55EA927AB5D9DB4B728
7D0D419E477E787844C89367E717AEC76664ACDD2614541891B78E0EC88A3B69
99A4BD8792C68064F27BE973B40D709C87C685D988C6F5CFF3276BCE10471606
1F918A31C57453CBAF13D503987649CB0BC7A85AF6CAB1311AAA2CFA40F34E6F
00E35CC7C08ACE7CDA0A05554A46271AA0B32DD7F364DBE5328D3F8111613F3F
A299289B211B7CD3984436EF69E57608B34E659153D0606C83DCC106717D7DA5
B326B327685CD7B6EF780BD59AF906D11F3BEE243A5B052FAC7E5753BBEF658C
E24F7DEA00478FD741A430A8F0348CD1ED0717B9F2BF304D1FC73C94AF65182D
5487DC65939F04EDB44F4260042A4FAA2211CCC791B8BCE22870B2A89CC59A00
DF44289851B5B0A56669AE03A0F69BA3A59693416B6758A4ED9BE60C6C0C6A67
8658F1CA8091B6B280F49EFE8EA8F914656FE6EBE9929056DCE30D70207FC70D
3705A95D14B43B8D6A4EF72D4C5EE0DF03B3835475F09A84921AE8ECA6E2A4FB
E78E6612D789D9C8BDB55143C9DAB9FCF3A234CEC5C81D68C4D383E1EE624DDF
02A6BC1AED267D35CADA74E5E10262CB329E8B023894BB4475164E69BD1EB3E9
9946DCD9961EC07C6CD7373E0CF4EDC6BCFC2113C538E707C15C259AEC31E561
7E4E0F3767109DF26C726618551EE4E713340C110922778E5CB154AF85489E1F
A9D96C65DCD60CB7B237DD84467A942A0D2930A75193E883F2611929FDC28C20
219ECDF1472AB987A9BFB8FFCFF8B18526D4B875E7EF188F32E1124C35E1F29A
B9CA61F6B0E2446527C33BE36ADAE9A892B5E968035E7DD76C20433C4F215CA6
9A5710EA9A9B837D378BCF35E9579EC5E00C5A8FDDF18BA887D70F022DD19B9B
36B97E947E1BC623FFE28640A8BC72A22256DAACF1B9FDC1B6B67463B1868AB2
691395E393A34C60583DA3FED671F7C74A363CE77112987273AD59DF4558D2D6
3AF1865D70D49C7784CB31CD63D325C1ACB394183F0365B9817B90D057517E6F
40CB1178060E65DCF7E70B634D49F59425038B51F3D9EB2518826FEC47F867F6
F7D86C88CFEB0F108E9A5FFE7400A2E8B33E4404291E17DE65574A9B81DC88C5
420AABF3634C8ABE96A2DB3CA0CF7B4C18E41911DA2B27FC461601672BE6DC0F
DC0A854E00E01B23F1D52116B1697DCE7759EF0C24CE0D3D63D6AD7D12C6F9C9
1DA0D1A489EB0BB1315A1D7873601FA9C8CB28989EE680642BCE84D2C70EB1B0
0C5F181E962A13C841A26404D8BBB173F3A11AC9EC5AFA0F3E86BC37A7CF248D
C56EE1B48F328BE115536F59F383B702416543A0EFE506C19B6F8D5DA32412E7
8CA8282C79F1D5FF5396CBD2ED27213AC1CCD5B823CD6A422120F6CDFA9D30CC
5EE51D63E066566E456099191E5815BB8C5A85B678981B480F688674077DB66E
40182F307F909BF46181A56FA092FFD7D279F58F29A11D9DED24FC830A700E09
5019A62874073FB6E71E7B84552A90B9188CE7417E0B742524E7C867C443CE8F
C9404E36FEA1860073F84BEFD3F9B6FCBB312C627ED120255A2BD3642178AB48
76871FBF70AD9543A3ADBEE9EAC15DF4A534AD17058B8E88AA642D69A32FE003
3A83A3ECBE6B7526714D3D3D8C7C0321D77803AFDC09C0A0C44AE863A0468954
5224983A842398C0FE630BA51F62D9D7FABE6F136D0439FF69B57A6554BD70ED
BB69DDA2E145D1DB2BF35B1BD20DF4F38BEE8DF2FB33A79EA59C2FF420C72F0B
98FFD85FA1A1CF89880601BA7BD6D67BFC809A040B9287C2755D41C6192D8E38
BB31F8096A654E81648CE01C9CB28917D4D32C08BB06FEAE650DE3CD65E1419D
96EA5F0D6EC848B00C506ACA81D02FCBF0E1965C0E6E910CD5578D06CB91AF1A
B7A2D6F721BF71A9FF2F8DFC0209EFB60C1EFE3B69152DEBCF5980BBF08129FC
AC799DEA617DFA1C69DB1814EFB356E6F9CEAE61FB8AE2A1CC08CED4D4D24BD0
A7DE8B7A3093F8BC87EC661D783BF1258C5796FE67E2266902564EE586F97C2D
D22D88A00E6F04E4B172BE3EBC326BA0D4D95BC269B4D125FC3B7E921E5FCFBB
848296D4C42B0063B3728A590966A1F61790E826E8BC07846A887BD1B3B8AC03
FA7386312D692FFBF92804417F71D921C758A612095314744F9A69C44AF36B11
6F0169FBE88604B95E9380BEF8AAE69489CF5E141D4C4667964722B69DE646FB
F887214F2A303A6E5572D85CC460DA5FF8BA92E6B7E141D48C8CC9211E00348E
7CB88DD20DD1973E4CF31305A8A3D7E625D684BAE83A805F7D11083B10F7613C
59139B880E843A2047CA133D7549162402A8DDD65E8228EE766558654C0D32CF
8FBB2C8A2EDB25F39494094E3ABAA597F6B8651749975BAAECAC0E4FB09B4CD6
34C5E6F20E34AF0981589EF18E1A4A35C2F5AD4A686AD5F2E6206A96CA1F9687
71EDC9EF951844B94A006DCFF355D4FA33127578E6FE090066EE747BDF985BD7
50759FBA4DAE18177D2C8DF98D48309B3476024F876F5280FAA71354D347A9A4
3B5CE1EFE7CB2F5EA46AF82D934D3802E588656B17B48DB2589DBACB37C22652
2556F6E9E347A42A7C2630C49B29963474DC7F83EA4A36F191DB211D8ED0A88E
03FF6001723DCC15034A872F0D8CB1E70CF88C406D4E372233AFA863894C2D37
2D1A888CAA0EDD21B53BFCA42B69D8742120F58B5FE8DFEEC838CD6BDF087300
E1D7CEBA399B3FDFC6A6C652186D62ACB094F10C57C59B22184E00403D98F1A4
DBD8E6B8ED2A336DE30F3BE60BB7BE9A8622111BB81D4C8B5A6F6B08DA38E116
0363F0B5A7A6941E81C9BCE17060D3E3E5B7D94FB3E430CA1493EF74B4F4AB37
4D2AD12A85ECEC336507D8862431E526ED5AC4E4C928537B5F7FCED75B2B068B
E063365F68458822F60CAC405187207AD7AB1F03C22DA4FF5CCFFFB0BEE355EF
E6056EA4A0E3A8B901287375C6EE67329BF4898A09FB5A0BF3C85664DA9E58A0
ADE9F2CF96F2C1720EC7CBB691860B26248081FF6E74A032D629A86D70752E36
B7DC679E91C1C99ABEFFC5699F077A0E961E77117D8558ACD6BA3213D2AAAE0E
8BEBC086EDF3C74E1462FE9F1C24F11FA1EE28195617B983E0C04CD43662909C
ED0EB18D8025F37A4E4D1D945015D8D199E1ECC1EB5EA612AA3E385D1EC21D19
E1480BCC3E410319705A33842506EC5E35EB78B9B32A5E0D12ADE4841EFF60CE
6B33ECF064D02F5908A52988D7BB7BDFFB387717A2F07EE0DECD0B332DE32AC2
33162A46B819E57D5FFECB83EA168D4CAB520B2E91EF6F1C783A5B6B0779A13D
11C1A62C1509D69F41060FB35E65D3988ED7A2D5BED7E82B6C4F5A880C6E9268
085D7B47D10CC35D9C5A9AF7F40DA6280A5C9A63E3118EEB9CB0BCE1EE6149F6
4F24054E48EB63914F20644E80E57DC95D08BAB830E6BE1ABA8C6D53D817F43C
7A30BDCC16D1CFD1B577CDA4DD9FB982AB141270A4A723CB17E4E7AFB193B442
5172075A460559599915EB6937CF9AE9496CE93F95253DD01B34D9982046DD5F
716EB61095E2270179A2BBDE989B4E61F573485CFB3176ADD7AD3838725685EA
BC8AF6622C7667AFEDF6E1B1FFE838743589C9BF4BEBCE68E94096E8F1DED4DB
01215641CB8A46E0D30AF6D556F9BB8BAE95CF223F7D31FF65035692128AAFEF
6BD878951652752910280C6DFF936CC2580196DE9ED27F8DC4A5D8254A3EEAD7
443988CB4FB13CC31F7949ADAF9523E06AC9A1AD5E03DF02333DF9ACB7973922
7B0AF71E5706DDC16A7EEFC6A38ECE2F1B2573DB0C925CC15FCC21FCD995A6E2
8F81E4523F50EFFE5E445036F4E1A0C75D6A46D575341E68A6054AC346850300
E9FBD91BFCEA5EC4DEB6C5C3357E48CB3D99A87A5D81E013A7BD4241EE3DC358
A5ED693CEFE54E3C4020D0536214AFE171C7AA1F8F205149CA1BB0131D8172EB
1BF9E7D35B27CC76B681601DCA6C947284344CF76BE6CC54604CF3FEE85B2C57
28C12387213B1867E8C6B76F7765A80DB34E4849AB67639EBC8E9AD781A2C5F1
549A3CFB4A270518E7C1EE81028E13024D2FAEB523A38505A452FF077F4ABB08
EC68B2FD292D186121ED29015878D4F3F0DD27F19BD0B3277A85EC2404518AA4
99FB755925DCAD60E4928D006C5017422F43524E56F03F62BFBF3AC9B22F9470
30413B8C700E0FFE02BBE72BF955E92B08D9FA278AD38D40740E836E6DE06A52
F58FB7B59D87C6C801B144AF82BBFEEFEBB92545F3FBAA5B882D88FD55012DD0
1A91B7102DE1498876561F1F3E4A9087738504FB88BA15B7EDE7186CFC7CBA3B
D9F6D3EC1DA09C5F200606E5DDC750B54AA9B1139B380A91520A1CF28A012FFE
D7ACB0C8F56E0532554B50ED5A3C3B8A67F462172E79874B014861B585CD2D7F
F29BF3CAE83477489BD8F0929DD07DDB7DB77E6CC38C7CD5D784BC9804319F1E
3121D76D44A8130B73EF2B65F961E31500D23186C912C261AEB2342E49C46A8A
3AF1C31B704A2596BA3B6ABEF4C28472B839065284ABED85A3BC3BA6985A72F5
759C0EB7BEF99742137438D7F632F92F8721607B4F2674CA3E77F6D29A348BD9
7D57AD16CCAB792E7CF2786AD83151579DAE636CB4515067DE39B78778444E6F
9B234C91A0EB8BAE82C9C30CFA7DD1FF23F4F7F77A5EB950D131C7F302A2F9C9
E94ABF52DD9AA944F01E2F84B4F264E9795059F79B75F889B9CE9F349AF0BF0A
156915C55F586AC878DB2A09204AED28F36BCFA9E6F234236C604749911847FD
050AF0DAF4A3C202EADB2B70E64D445AD62EA3F2BFDF7C552A1174E9051F28B1
3EAC2DE0A960BFAFF1FD4C23F90B66CAF5284FB2C2F147140AC48B22EF9CE0DC
02BBBC802C4E752A2C813A101E1B30A0D5CC35C3715CFF2AC068A83A0B339314
63B1708B7866DDAC234B3A29D8ECDE00A5B7B410503BCC95B5B10EDFAD751797
FC472318C00CFB53CCA5083E10F49278F6D1546E333C0431857D808107F53BA5
D6D7B96A82A197C0BCF86AA5E5CDF0DB7CC5092BAAB0834B013E6F81043815C6
9968F9A2642DB9AA8EE9BEB5553A80B6B89214EFB182637890E1117923E627E8
B6A26E6EAD15D1C8DB91E197AE33DA178A96E2FF8F7CB7A8592B7CFA4F481B0B
C8F791FDE1F309530E83DC352DDD6E3A3ED05966952482A390CDBB928EA41F64
1D2C9EC25EE9575C184328F41E96FC6D5CC4315D96AE3AFC526A7E5957B9CE0A
74F2955F7C9907D707F6773DF04046103A0D259331FD5A368B0E322F6E7650D0
1B09E2C1C31D8B7BCB9D118663469202DCC83B2AC8A1BB77DD482C10F29C0C9B
F08F509D95A865182D5453292C5B86160A7221F299F32FD989E393DA2ACAFB26
B1315989AC464447C416FC35F82ADCF0A5F91E6547B72F90A7667FBC53EF8568
004444AD72A716B1CCF0DAD130D55BCC7E05BB7A0111ACE50CDE21152593F5DB
E72D2B96F2CF38B5F6874499BEE22C2CD05E99DA05CFABBCE8DC0923125D86D4
5469CA46C1B7669A29BBCF83E95F3E8D45BC7C96130CC4F033DF711D49EAB8EA
D749CA67DB8A71FB8E81E87E09DA5BCFA4959132D9C34B7D5865DD6AFC732939
F38689CA7E25747FAEC8233441FAB734278171ED498D4443F631DE208D655541
6F71171C1FA05637425F3B2EE1E2CF3B2C1FE6C3F48610B0FAA477132F852D87
C161E5C20ABACA37338A465CE3E97DC1C1AA8F618B5C03918FC62C682BBE147E
2CE733A0C04015D0CB4772B4556FE4D6B3F63F8006EEA335B5BDE2EFD8E8ECBB
20B92DB7A7C408F7670BB6491C1031ECD4F0F1991BCFAAD268CFBCF08277419D
50610BA45F203117169AE6FABD5F2DC06F18BC3B6444FD4729538B9B15340059
B49F7B229881A573FC1F41FE9A5F6D3BD0A976E2D25DC22F69A3877CA045248B
E5685F426B7BB7146525800C750AF05DBFB69CD67D25A8F3747C52BE6C100254
8ECD3E5A72D4B9797925B3EB8FC14062F5B1FB68AC9F1A7CDD50F59FBC81AC81
9FCD5879179D161DA81DD15CCEC63C2901CE4AFAEFD6148A1C850AC8E858EDE1
5A5D5BF2A7957D95FF33E1FB1F743CA0A605B3C4E4323730D846DE839E6B64B1
77C97BD1586EE32F04CFB4C2F578518E37E431FFC2D3463B8203374DB1E62791
FAC33A1025FD82F5CC88725F37CD5FAC75B7320CB5D2226F3F70FBAE2C17A7CD
431BB67C50845E254BBD2BE7A2721A826689593BA660B24B76111739AEF52C03
1CB0D5CD360BCBC08D0169FFB416C92401CBEA57004F17C90B1F902E44CF31BE
8502FA95962E9438FC09E5A519BBD1CD797418B33935B87760012E1331E9E820
C676AD59739E37763ACA20F660A5112A8F05E7179A352EE9699788E671E9E7F8
E963EEEA9F6795D92828563E662AF4DC64AF36F41E21996995B102B3C07408CC
2DE33E2A2416E972393DC2622E9B5F146BD0A1F0EACAA52EC07301F3C0772DBD
328D01F8064574B50627F2FBF797616404C07814F63C9EC3C51A4291857ECB89
DC076D1580BC0DFE56DEF2EC4DE28A8B124472729B9270289703956BA1A8B0EF
A86BB142CED3BF9E92C6315278144506502E0821D136A73C67CA8E9172CBC30F
0BA674CBF94829A6AFC525BA13984E0E177E9C41D5762189E8BB9CCE6C560F86
CABFEADBC517962A4087DC26306136334B79E8A3A7C5369886C066023804D29F
838A52AFF677A2718CA9EA710665925A9A0915CDE64A706F3148A06B47323028
E5102DF1816D46A9FFAF8C077A7B727E6E7B9E427C94FF1AA148E2945BC5F623
465E8147CD866CDB153668D76ED69ECA2271BCFDDA20BCD6328693DA446E9AC6
3297BF9676B273DA38B66DF161764F237180CA0D29B03468B177C20698BBA65C
C0FF846CA5E7CE474F62E7377CCDCF829F93EE741C8E82ABDB485A3997A170E8
F502E4EB6023949A2517FA3E005265F0B26F3B72945832766395808D3538ED70
97A781590719B9A9287CE1B3A86090EDA95E9C0288353ADE67E775663B858197
5D4C14CBDEC918BA648076C24821791D5EAB7F17CAB589A88643118D3DA314BC
EB9D11670BA89B29BF0F08F586A85A748E1DED23D009D2B3347F514E970B04A3
85C8736494F39D25DDE13231F446191A9667C979149565C8C37FACB874BA7215
5125DC89972CF2EEF71576D75F283A15911D1F3D1A66717F9C1BC14A4900169B
BA8D40165ECCD95F3081BBD02DE3C315315BA6A4CF5CED7E3A4F10625717C603
1F37AC62AB0B93ECD2D99BADE54B68CC95C00C3F953633D5929A23E4FB817A02
B7E42FA134B2DF61A10F5F27641D83D4ACA43635543419DB3327FA2717494136
9F5A72D33EC961643A2E58B72CF405FAAB055F7B9ED698B201318C4E86694686
6DA4B00C2065537BAC365DB2BDD9172B082BFF5BB4845ECD67BC5A3D9CDD9714
91709C65D887F88540B8A1A27D12EF07CDB0573A14E8FE9C7C1E7B2D10700CB4
DE1E7C11F7955A9B2320AB0604B591AD99B6C585DB6006FA3CD43F80E4F2C3D0
01D2A7388A9999B99DA3ABCA037EAF601B2982B3CA55C5D6C78295FD3B92DB2E
CF0B82749E49C45C234F65F52123785D91282F278A482A4B293900919129FE53
0C8019DBFCC4A61796A597F01208BE7C4469627935C88AE6CB37C07CCA156AC1
5D92152FE2551057EE42248AB4F9BC15161D2626D8FEE4F70BA32CC8B99A2789
3098AAABB6E2D00F8181343054546CD5D8C9162FA3878966EE7C308031426450
0C3DECFEF997777BDE40290BDFCBB05A9FDBBEAB03C1E53EEE88679147ED0EEC
8F97B684F176DE6648FC2095712CD2E8C5DA365A90B1C264AE8395F3F7A2A482
6BE37D3BB65F1054A63B431EBACDF0091554832159153A9004DF194A4B48CCE3
8E856BC73F1E34798E4AA3FCA3D060F2AD84643AFC33C35DF309B970A58655FE
D52E91776DED669789638868096A3BA1DA526D297E8B17BDCD93507017A04D43
955672A301FC7E2170F7F6B9C061EB16759F16AA9B0ABB8441475ED0051D2DAE
DB0A4277E52F40396EA0AB70994D741D35D800CDE55B4B03B2DD18E8AD40369C
324646857318CC8E663B7E50C219089B5FE98C1CDE20358384BFA8742C018C4E
AD4C8713D33EA339F861FDCCB562B9EDB6B1C3F14CFFBA7CD24E2E8A62BA176F
556781E76610F534E10CEC5A5E2FF4ACC06C07F7C58A428D378C99CE41BEF938
E9DD013C6C5F59ACF2E24EB6135EC709B583E614533270713242ED6016B56307
553930EC2C4A522BF4CCBE060FB9C5F3DF2C1134FAF730F2C9CF5E40B944D972
F1EB77C6728CDFD04C81F0B742E4B630B0A05AC8869B9B37EA0D1427AB6ECF84
27004C69E47E01F16009F0803C716A49DBF8F49E325B9160A74A49C628ABC58B
D892225CF5675DC5AC313C59759CB629E39C1C777BDBD7A9C3667383ADAA6A7E
6CDEA5C7C80532C7840849DC0325D3D93109917D9AA3B9441147CF27D18AF070
037936895D30DB4392C24E7E8E504B897465CCBE384BC2E4104B2B0CC746EC7F
4D6ACF91BDE250107D5CEBE37793641D7DD83A9AE2768593D938F7CCA5C07C62
E8DC3B888E06000913EFE5C8426F88BF5F4778C54A9FF20E8D8FB2842AD1092F
350F39A9E15A667C2ACC8A524BF961A1614F7139B037A5B79AC08DCF4959588B
E91ACD26AA8A3FF83AB93C1E1A1652E50D14B4F311B151FD6AEE6EF288E35CE1
E7C684ACD00CD37303BDE672F91583E7F33A2F9786B564FAFDB8B2F6BB8257A2
15687B5076C149B5D80570
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
%%EndFont 
%%BeginFont: Utopia-Regular
%!PS-AdobeFont-1.0: Utopia-Regular 001.001
%%CreationDate: Wed Oct 2 19:10:38 1991
%%VMusage: 32987 39879
% License clarified 17 November 2006; pfb update 19 November 2006.
11 dict begin
/FontInfo 10 dict dup begin
/version (001.001) readonly def
/Notice (Copyright (c) 1989, 1991 Adobe Systems Incorporated. All Rights Reserved. Utopia is either a registered trademark or trademark of Adobe Systems Incorporated in the United States and/or other countries. Used under license. The Utopia fonts are freely available; see http://tug.org/fonts/utopia.) readonly def
/FullName (Utopia Regular) readonly def
/FamilyName (Utopia) readonly def
/Weight (Regular) readonly def
/ItalicAngle 0 def
/isFixedPitch false def
/UnderlinePosition -100 def
/UnderlineThickness 50 def
end readonly def
/FontName /Utopia-Regular def
/Encoding StandardEncoding def
/PaintType 0 def
/FontType 1 def
/FontMatrix [0.001 0 0 0.001 0 0] readonly def
/FontBBox{-158 -250 1158 890}readonly def
currentdict end
currentfile eexec
D9D66F633B846A989B9974B0179FC6CC445BC06347FF71900AC8FEAE3B716D52
C1AC4E5DCF4EFC3B9121F09CAB0C4BE35FD0740E08C853EF201BBFF011DE2163
790FADCD67A15500D3F87E2616B7DEEBFB3934B09CF7B8BE9B945D2638887F73
1C3214D790EBA3065BF944D77DD51978CB663398285895D774586FDDD6A7467E
B1BAC83EC766EDE0FF34D07C6E315D7B79B205EDE798A08FD0D9CD4A1307FDE8
7F57AE7A32759AAE66C77C6127F65D92BCCE74ED784372E34CC835BC789BDEA2
9E27574D388B2CEB1DB127C190624246F4991BA418137BEC72C8CF7830DCEA26
E13BC7F0CDDAE283F10C1FDCD1B46ED2C4BF3526E9DD2FD5DD021D1116D3D9B4
44188211B1332E1BE656BCD0DC7C6D7F23ED03F9A42FD10B79980768710365EB
A8E211AC8936893AA9318E20D297C730A6A626FECA9E5F91E1E0B5992698A7F3
F8BEB86C9BD1B318CB141ACCA92730554DB8F57A8A21370C885A2F6612188DF1
0200D203FB6B33556F21DADE387C352EB80799C9BFA76FC4192381FF39AD0FDD
883D39690055E6A12477D408452D16B726E759BFE286CF62450D5683C4EB0845
EE3B21D7D64E100CCE7A2B86926828DDDDCFAFBF3861F98324538A0799F67E49
72B96013BF16E190839B9D1DF92A8B6A610468110B7CBF1C24CD2CB1E994CCC2
4BA3DF5753B81CBCB3B71C63FFB17B3B47E949C570D03A4B162E12ACB36EA11A
22733406532DB9FF39B2B2DE58B270277E7B1C3E1A460CF4B6FF063F5CF37F5E
AC709027E0FCEC1B27227D8A49D0664C6FB0178976D6EB5B09B4F47B5E94D782
25FC9D56FD8EFD97D514EB2ECC5630ADD87D6ABA98B19DC1AB262AB9A8C979C0
59A76953EC55333F7800EE9330B7FCCD8C3BC325658816EA542654337DA7D3C0
407058CC4601BA7B6C6B2DA0E376F7D94DED19271029E32844351B475FA30E37
2D98E7D5E6340A878CEA0811FFF598E5E1617F2D13066E7640416BBA886DDF0A
E9B8A56119CE61E57FA8A6309245DF8BC6CCA7CEA55FDE2D7B6CD06E8C118928
1EE6CB47A4B7D7E38CEBED3A0D1F2639BFF76FAFACC17476D13F4CB31FBEBF15
89252E409F16ED56EC1DEAB4F330B7659E93AD217785061D581BC8FAA0851486
654C51CA8472E0FF71158D1D3285ED72ED927B7F750F99BEE45F5C77300D0411
A3D81B0A9C8F5865B057F75E8D97E77958D3502994B90340EF5362A99D9750D7
14286B362186F0715DA5C6039DE18044B8E67EB1152D6C0DC98D0E36E6D3C331
C817257F4D3CAF8AE438EB03B04E8597046197D67105121CD8F5DCBBABCA9FC6
55EC17EBF96D17329B7C8BE8F7D3062E20E83FA6AF45A0C932B5E6EFB4DBB928
E4511768F708A03FA8BEA26BEBE94936A426DB77A8E800BF093CF53914B71382
019AC58ACA79B9DF64946EA241C84569F2A13CE8AEC335F6B5DE8C00317AC6EE
983987246EB7659537AD0F945CEB9EAC541E02AE257377258E81CFE33CB66A9B
EB514F04CA9AB516CCAFE56EB0324AB192EBDDA61E0792EC1857BCC062666338
0089C3A9FDEB405DCF235A497AC316B132B3476551DCEBA0560C18F1BF84F1E0
1467DE59252B169861541BD6774161EA8F9035787CA842050E2089AAEED6F37B
2D12BCF5E67293A1F71DF87589FD22D5F72B9C91CCF4019F97356DEBC9B82C93
BD0040BBCEB10CF8F607E0F7863C43D7F6A91917EBD66730DBD642DAB8769849
47384FFFB4994ECF216FFA8140397695EE5AD63F1156720A01BBFB15AA24FDB8
2F2A8F541C7FC860E03F5E4DE80BCF6891263C142159D5879CA0A1883A9B6C50
CBDA9CF0C97E761E354C39527F070E680B42E6732896B10E6A7600184B156ACF
57BD9A98F613FC166F47C3D1C4E5E02BAB648D74B078EE3F0D8598C8572FE7FD
3294F166AC491EB93BA365B2C535890A74C6B35EE6EEB142BFCDD1896E3E2D83
55E7A2EE6A02827AE1A95760158E090398D309E96DFBBB7A792B8AAEDA2BCAC9
4D6D01F341CFE1B53E9E3D8A22E7E602AB4A3172F035216756F13E7E122DB663
5F470062A836D1071EBC6837AFBF91C914487F931A56F8A2352A77669796D331
03F167AE4F4781C6C7E518F3F5C5D544E6887D1A3A499616E47D23C39AD52B22
BD4A16B3F8D818EA9EFE95AF85060208BAA87E0BBE78BA695C17BCA32CD3CE2B
EC52CBB4619CE8FE1EEE3BADF6D86FC17A36F01E9755EA7E49A72A043685E094
152B9043D36787A8CBB0A3D7569F0772BED499557D1C23EE03062D8546E54D4C
5791F2A7410DDA89DBCA388B710EC4205009441D76912814545EB4FB90578EC5
32FC5F44CB0A9E18BC8498014FC6AFA38D290BD895D7C09B95390DFB4C3D373A
B6530B24E56DBB752A5EEEDC41EDFA194B4CD39727CE28845139790DAC9E25B2
48D589D009C17938DFB01C8E1AF248A1245F3D33983B993201F9BFDC190E2988
1BD4C7DE97FEF3189FF87328B65D0A40A8645CE6AF98703CC253592A21F290B8
544DE18CB57B816F2A7171D21E746437BD06AD9D7CDC09FFDF015EA36C0C29B9
54BDD925E0DB62F952D4FF02B658FA63B39D0DBD611B661400E4F79E35637257
BFB4DF2B2BA52DBFE1378D8E898275EE809D91A3260DFEC52508222F0EE3CD32
3B86F7C022A92E7F1118B96F05615D030900ECB4AA52452051600D0389B13125
5B96FBB30E865A06F5D726D6CCC7E143A639ABA3F38342D9AA0C8EBA6ED4607F
194FDB420ECD24646BE94E1EAE70CEF7F4BB351CE2B183F20378325106ED3FA7
C30A41CAC75C21261D2C811736BDB9A3C4DFE2757C518BA05082E160E4FE5B1C
7A279668A795621B9536A5D2A333972193DFE75E5B507E8735314EB0255F7D27
E7F98191BFD06CB7508B7336AC7C54B86C51CC685C14740128F422BD9667260B
528F4873A5322666A000D54970850AAC2837DE22C40AD2D349F09B8EF0F4A8EA
3FAAA4DED6A13A5900986B6A71578B3B5B9E4E99E40698885BEC4D957B66B969
354B52183462F00AB955ED4844275964414F82622BE93C6229B206E64E92316D
32874D8CC813E0EDC810CAC92B0797073F2925C6E678DF07FDD5EC67F5310A6C
E0F84E6820396252EBDBA14F543BFDBC8567C969358F9DCE259C27621A3A49E2
15FB6C52D696FB97DB3C7DD9D71C46F3BA5069BE128255220DDDE95E2AFF9E1D
DE94E8F6D294CCE99A1944B2F2B4DBD7804181BAA5447152071C2EB29BBDF7C3
E0F5F27108D85BAA99C92BEE89EC3896F0216A62A4CCD4F08C6EAF9956F24A57
4893514F1C65D278FBCD3342AFA8C2997B56DAF1C88D1E224AEDF3EF1FE39F85
E5476658AE0483EAEAA88923E8BBF9D57D33CC7BAC5F8734307E05DC315C15B5
9D65718E5616237D3C6E944EF71E3BB0ACD149D92ADA45F5DEEF210D0BF5CB62
555217151CD211EF7B0DED6980F1FCF0A2F67213DEC1E2254093629D080AE74D
6EB41B2EF4EAC5C5EEA2FC4E93B5A2590886191C73FB1F34CCBFE23B91DF9E95
F76E814C6C0693D041FFFB50AEF0F528194EDCC438A5E10DD2BE38BA003FEE4C
33361282002E8F1BEEEF87FA24E2ADD9B01997CDEEFDFEB63CF93A9147538B3A
A1749C75FC4E301A710BFA0B0C991794DE240FE569B191E2A6954A797E82E221
D39BBCABA86891397538A8415F82A7CFF5E2626B07C884E53AB019EC076FF729
E0E32C5B73349DE530D65C26E3FD8D0F8CF222ADDCD179102FB71DE8C8D9DD33
76DFA62521E4F9E3D89D6BD18DE9EA2AB4D75108CDD5C40A5DB870C2E63B9C2C
BE879960E6EE483B14BA4369DBCF00E9AD7B02A9388D055E3A518871BFDEFAD8
651A9FC027B2BFECEB444057C6422C1820A1FA033582658120D60C6A422036F7
0351F9DA69C83C5279EC0E919686D4ABBE5B21FC3610391252AD02E9A78A8783
F49CF037DD0D7478943B7AE3FE5E51C0ADA5AA42458F8E8E9DEB735B7608F4F1
B2E0162222756148A9779420106DEDFCBABFD692D6E6863925AFFDCEE42C1981
EB8E13499DCD6D18CFBE173B17147074567D41F4E29CF9C27F1BB92F84B31B7A
279D43F1DCC5DBED629929A22A6C72F625C919B5CB8268966EC9EBD62DA546AF
637E04D9385901D8C6B1F1825E30E3EDC991CCC4B5D0A21DD901786D0DE5513B
CBA645B07E11EA8AA0B892E2B4BF530F1F1AA68FA4E174E180BBFE38C28CDCBB
AA0643E39EA70AB1333396FD5450320EB2BFDCA8680A5F9EF84C759FA64FE24E
480FBE450EFD0039FA9EE079E64E01A4EC2756EA6B3A6BCC0772AF7C655108CE
506C33FB13D8A9B18AB5FAFCA8A307DBFB17CCB68BB8A343111CC60DEEB89537
C14CB4C1AD6DE20DF083E4075E1690E46D145FACD876C061C1BFDFA12A49EC46
AFE6907376B12DB730FC9EC0D4971180CA1A00FCA0BB7DDC6C96C142D484DD2F
8756D5937DAACEA34457991A2E610253CF9AB210C20CFB511645251EFAF5697B
4F4B5CF4BB6A1F73CB98D75ED414D78B61D57D9A124239D252DACA31A76F106E
667F9606EEBC5317CFD5A199877F048183DD701FF0D0F3957CD544071431FA7F
4F89D337128E0D0F16FBDCC73691F54DF701B405A8733C6F3AB7550D5216A2D6
7BBBD8B3170C16900F279E3E45B2D48512BA6F61F5B2320F156D1ABE01BCEA8D
862C825E88046F4ECAD128B7525CF75CDC8A222C25D7E5E46F213B789F466BC2
CEA834BE658937E811DEC01A3E3AB6F8FC59DBE287A5CDAB3CDED821AE4C939B
608B677ACF46C891DC09BBC8829FA6C9DD70F59D5B837859558C7985AB6C3650
1267FFA79444E197B321898A51705171C1902976FC49D5B16C436A069AF3592F
1FF418499B3D70F523932144CC94669C01310FF99FE3E3709779983175D111B1
705929175C7293F523C30599B2DEE1539461B76B46FA3B8D5BF2E7D04AF5C051
C58D0E6FEF271259690B6CF032A8843144EFFFF0A9387FCAB26A85A8739568A9
00CFA2F9D3270AD47FEFD2A56C190EB37790ABFEDACA9768E6F31E94A1FB849B
502507E68B8606EB5A2070543D3C75088DD2D8A4F18A6EEFA9BF9417EBF49818
6EABF5E61E8EB685F31B1198C6DDD257B33747AD97259E6D1B252E4E06DEBC16
68DD78EC5459FC3D12C9235800DC8E790D502A92B3447869C266DE168ADA8897
23AC952E6D0DF94F448085BB9D6D4CEF3BC3D28ABC0429162BE040514119D363
B0A8AEB4028AEF0A1089E553C9881260A4DDCB10080AEF83AF37A958461C1AD4
1FAE4BB693971EC714A2F30D6DEF51F2E5F5818DF4129F9E0B78916FAAB7F7E1
8182160E17AA2F3BE2BD640FE21E6B4392AAF11143D962FF2D34FA7043D2F313
4C9817F46DC6CD4FEA8E1DEA0AAB11E05E5A0FFF220994304DC8F021F638EAE7
FA90AAECB943A3001061FCCF54A0A49B5EDFA8FF2F7EA87201F69C6631C34A63
AF3F818EE9F94DC84E443111F4E54EE6E04C286D85B6CDF0C1CDDD5995A6E618
A1FCF66BA605509D3B02172583FC515522C449DFC07262F878AB208A1309F391
57CEDA3CAC91E253D6C0D93F194A187943654B5371340E22B004DDC927339AEA
6D2D4003CFB7C2DEF626285BB003C54706B5EECE431419541C15FB878BB725B0
E82C80E034A90CB4C3CD6B7D8E48920B64A692241F316EA956F9884A42FD38B1
32107989D8ADB5563588D3BE983B25B8B8C901F22ACB965B3F63FDCE90E2ACA2
E6854382AA5CA5697CF63DE45BE3B5E47AC0EA6DC9BB9D8225ED784498958573
588AFBD4245559383AA1373B617E06110DE1D592556B47B2C5D90D8ABF8C14A0
C8FD4F4FCBB68968AF0C1F15636AF2EBF80DD907B4F1DD4E042B64AB88832F2E
1EB205DA37D8F2B76FB0ADE032280F7C9D6FDA2481279DE3B9A0C63FADBAC807
C55AE387134F06616EFAFC383126983D7EA0A15332434667F089B7CB57F78D0A
C4FA53893D1A325A7E9550D55D4473090B35C0C503F5AD63A0DB6D50165E7253
A9C41F50205B449BBA58F8B073442BE7A1A8F78F5959CDBAE077A6C89B514407
604A39107E9AB6DD0521AE6964C585A4DF9F124B024E15C16191CB73FEC1B5D2
27166DCE5EE34A1C2D85E9B4FB0A5406108FC48BD6B7D4DFF0F7DDD758AB6F1A
BECE0563ED84D4EA0E7C610D9C69DCAF2DEBCD13C0DE6516B649A4EEF62A61BB
5B2C410769E448A77C56170E9ADEF02456A1A82CFCE9E67D01FCC7B6FB5433A4
C1B9D5384F42EE6EF9377B60CD6254A20957C760D639DE068E646B6E717CE9A1
D932C7659FBBBE9026B9354EC870F35E5CABF73E2B931974DFD6D5EEEFA6D4D5
4B096463D3532265F8D32951858C85FF403F693E837663D92A0F8130FFECDA4E
03595C2163F6550C5D457582E9A085A8A5208EBEC8555EC341E54D9F9E25470F
E7F25F39BE5C52E83D1FE99A2CB750C1A912D8DE2BC6C8A5FA29B477018D5154
607AA0CACFD7CEE5EA93351862CC5A28234C71C624C113DF900682AF35ADF8B5
DAD7C875E95DF937A380D96BDA5FA037FD0685C575449D1B91FCCC1431DD7376
05713AE42EE1FF70E1F51F02480F8E39492566431F4A0343FE3205B4082DC1A0
2E92625E32FDAAE15F5615AB477234FD0800ED2EAA1DC6621C8FEF38348F355C
73E7A9DF1903E55F76FA4EF185AEFAAE39BFF0A429E1E5AE6E4EF9A8E2D3ACFD
BE82D2DE0F808A43C65D51A5BB22AAAFCAE6A03034D0FEA111740085EB5B3E09
AC6CD2AC1AE5F0C5AA20FB63E0F9026E29EE5CFA4D679A1948AD363D40FC75D9
E1072D4D4BC928CDE39AA947408F34E0A1E81473199F1EE65BA362D6E0D83D5A
5D74DF352FDFD48E76F77F2A35EA7D7FF56CC5C86A008C105AE85529A9AA69F1
B5CCA625074A2B1E21F5F359C1C1E17AF3203ECA63F2C7D77B451CCACBF8C25A
AAF3FC362C6D402A2950D061EDBC632A422521373AFDD25EE9D241443FB7E47F
3630C69E402AF97DC4F57EE34F8BF633F656CC1B2283621D7F3BEEFACF7C78A8
C6F1759DCB70F1E295777759EA2EF7699F2B7C270BF4F4AEA1BF99F8357B434A
FA1C9AB803A5B00AA57199638C65F45B0F65DB71A2FBA74E81D272A8932C8D17
B593AE025E7D85E7FEC21B4E9DC48A938E28E2B978C88BC016AC0198F3111D1B
869361D5A22E04542F355D4F877256020837031D7FC78B2815BB383C6DCEA8EF
8D69FEF91E21A654779148D4280017F760EC08ED9BCD7DE51AAE7F1E3B5CD8D1
7B00EA3E5238D4F9A3D7B320B1368BE707FD277A2651EF8D720FA9C29C80CD99
FA259F81B3CA5B558C2CC6CEFB7B190675EC4472C1F01883D067EDDF122A4AA4
47483567EF74E4D49E7B623D69373D444D40AAC901BAECF24AB8F294F6885263
94295FF55EC7BB9535B0E4CA71BEA276C52472B10CEB31F4D7986CFBBDFDDF54
3E6587640F5CC8203C7331FB8CB9AE143572154DC945D66A29E8801741FA70BC
0E0A790ED8BD50E7E336ED1E9E4CB9AEB03D84F85809FE7761C2C2B9F217753F
E412A217722C415BEA7B5EAC73E4E2ECB891EE8EAFD7D4E3841E0C49AE6827D9
55DE7FC1322BEF379CC49865F8162C27F5826F5D00BD522896098DC751EB8938
27326F41472D45D88F12CD3A9186702A682A14889D3C1B470F8ED83686DF36BE
9B7EC2113DCBD6DAA1981BA21BBA6675A5F7CC5523E07319733165F3F8818BA3
4A29DED7CBDB0C2F268B8ADD033D6A0D689AD8A4372BFA5DCB925BDA5C98E9BE
77FAF74DEED41F5AED197575DE9D70D010C705400919B09B49B3ADF23CCB4FF9
94D418B7DC9ED0B774DF22648F56EA13A501600AD6B2979C4ED4EB6497E5CD48
C3C8CBC466BACFD9E38160EE1D64CD73965546DCE8DE3B2E3D42FF7251AC0244
CE1843769AC64AFF17924B6F0B4439735A4ECBF6DDC0422F3E911F2A28A4127B
9B74855BF802F576E007A671C527867BB83EFA5850FC5E5655740EB2B5E0CBEC
C782B78A35CE8D8C0331BB6CA78117D381C2CD89829A237BD00A733E92C96B4F
CA84D42B0CC1EC2FCF22822C24636E6FD8305E833A817403BB20A45398E186F5
C74BB515E62004DA0EDB9463FBBFCA510431F0A13ABAF34BB243BC2B1BB5652A
867A87F07CA0BBA47550D17F2A2913B60B014CDA35ABE00500CA8A2F05107BA7
86324829D7937042F6E114D0A3C30B162BA061AA153AEFA72AF8B90F0FFE55C2
DFE105A99576C32E07C9807ABD8B5F18870D52D97A652C349AE906BD12901228
7D8BA8C4F92105FAB1898B67A1198BE8E1BC3D775C5B9715656ABAAC2D58FD50
6C2403B22D9673631431454717F725E372B24142AAD2331D0FE082302765BCC5
0BC9128B6079FE15A29DFA5802978FF0D204A6304856B3925234C2CAA73DD45A
31302C762DDFDE361432BBB4CB393120CE83C0723713CB06DD5E01F4D014BD32
3A2ADBB52362404DB52FF7F1CF98616023B21D19A35722FE6EC054D595842032
E7A25AC5B9277963A07A8D8BCEB7F151C45C89906FDA19D83869EFEE35656AE3
E00834E303244237C980DFDE42F5ED8508E2FBF6AC21BE2E6200AB8705257A86
D775840E61D844E4ACD59FF3A7B2BB573A78C2718627B3E553438CE4945BB75B
5A524A15C9CE848DFECF360A41F5560293B32806F327E109881E62E6E2DA5B7A
13011E787205BFE53CFD9DD47FC383CEC5178FFCB88757A7A2B114FF2AA1BFEB
B01B5153C27EE228E400A94DB3D601165ED763215DF11554D326EFA70BA01F72
289D2F09A7EF3511CD1E82250F57DD118FE44EA585F997BA4E072D34400C2FA2
E865D9EB6ADB8FB50D9F5293B8FF5C5898977A87E49BD49CEA28D209048DB4D6
5B4B225D3805461BA8328797C688ADDF82CCE22870D0710A18B27083DF9A53E5
21AE70528E771A6B5A94E01D440D49FC987A2A80844290677BE6AB631ACE06A9
A9FE79D77EB1F219569E89C7C5E11B30F646444802936DC2C7E0E4811235EFB5
DAF155F649AF2A7BE27788AB1BC8DCE622DC0DA0AFC48D883F2D223E439A8103
D37B2B6300A083D5F71089C3F94ABC2A8DDE7977AB169243AC5901010E730CC6
63CD98B3189D067F9895AF0BF7CCD4D9AB62FE26D2A5AFF023F3F604C2B5E839
6565316179A6C4F7B43A98AE32FBBF0F68B1E3B1BCA1DBEA94AF6F050BFCF9BA
AB9A271979F63B1773175314CBF38BCB50DE03786B379DDC1377220E0D3FD02C
C0E7A43E723B86D6958784B0A97C73C8F9B48568A1F1B1474517DDBB7C85B005
DE0C8BF12327386A20230FC257C7F14AE02CB5A46C577EF7D1740E0BE25678B0
CF62951B0523D9F4BA8301AA84D8BB29FFE878CCC3783A63D4FBC9841CF2E76D
CB77221D2291C90D5864484950D09D89BEEA1EE3D01CC969EB01E2837642F832
8E297D2571FD1A066ACADD6C57F08762F686355197A3C276A6D42DAF1097A4A4
7FFD744E3DDEEA0790E35365970F990BBFBE287AD3CB6C0CC288DF4BD6E38AE2
AA3BB7DB64305FA7EF605075EE157846CB7AEBD6AE0D123F9823E249AE163948
B2B72982CCF5189FF2823D5CAF762E865145BDDCCBC5FF6EB74EE3792D8DDA2B
2BBD1BA87019CD3A71DF3548E85F589A8128F978D931B5A817AF66B2BFDDD903
9D577BD4B255CD612674D4F563FE4054F4189FF7A4C0D062786B8A26D1E6DDBC
505AEE69DF7D93229D070597073759A48F6AC9B19F926EE4BDAE0CBF85858BA8
A08F81174FF8B12DCA3CBC0D230C4B29733DCFFC93CAC3915932AAF3C1F1295F
8D4B5FB7745CBB094C81D5C2470207BD1496518A5AC7521FC56C94F0B0F08E16
656B001290498CB0CA5E368079F3B1E8BCAB177CC722D1578B9AEBE37D698EBC
497D3C243300659DC0416547BC75C3CC55BBF9B288898C6899A53E14DD882127
AD677FF348E8ED0228A585627BA1FD2CCAD6B16DE5757CF5E7AA3C194B3F5641
CC84EA8BB281FCC602CCD47F79CFB22972CD624E4DF703109E6FBA852F889293
D9289C2B6471263274ABE492317A8F138B0C1611C7E611A85863D9936D62983F
5AAEF808054793B82E744940BA79ED097434F696224A8A478E03EA8489EF99E7
42AC82D9A687BF9A45D4E3D187078CE1918548FE1948043980C187E853D105E2
B4D691578CBE634C6AE7BCFAE09158349AAA724F3BF280247D5AA1985A86339D
18BC23ACAF0E9AD963807E572D94BEA92E0097492F9AFD9A9B66978DA878D538
6ED73EE1C363276F38240A07F5A0B87062F186FD7FC66E06ACCD4E4E09F57F1A
A1FB010E66C054048641097090DDB8AE491D2A24191B35B62CA1D8384D7A815D
95644A1EBC0622639E9C6D4547263F60381EDFDB8CCDDE45B16D4356B38C05EC
1185AE4C486388ACEBC77A4C7BFF3E524441EA361E21CBF2CF273CD7A77156EC
FCF3CEAB8B092F7C094A8C64D2771F67F83B1100ACFB20CB21235A62F8C1D93B
C3E089384A2AEA848F76893409F62DC4A7E06E78259B631418FE91AF5CACA456
C42B3D1293D5B52E4AED8CC805E832F016A7FE7D85D56A2ACCD598260DB84337
8918FAC6E77F6A0800034C5D7AB3F1800758D65160326AE185C477A9D23B6784
25A2A4A1B5164F49A11699674632ACC83C69AB203A24FD424C2ED9B928EC2E33
70F06CC128CF018928D2C3D9803B2150E5275AB6A17A4D321C906BD5AFCFA056
810D61041DE429251F2CF33D661D8C76DBCC172993E0068A1B46868F4967109D
F47DD6CDF1B4A1AB674C62E4E25D7110D7E772B30C0CAA7630EA57CD8DE46B41
6CD10B6EDC3C2F11CEF0A752A1EA491C0825FEBD0212AE3DBF209E6426BBE013
EFA26E9E4AD10A9C1B1730CBE72D83A5F9C0875B20E2B15AB23A25485048580A
32EB30BDE3AFE1A4EB3AD7014ADE39469AC60715A60A766457C5AFE7CC05D528
0D79AC9E0BE69C944F3AA44DD6E5BC2521E803CDBF468D27DEE08668716BDEE0
9D265A4B316901E62FD42B5EA2E6926E88A4709DC35F594B1216C2D9C7685BB1
B0B552E9882E31E7D1F7295D6C8FC1F7B6D2C0841CDD416473D86F4927CB406C
1B3FF9E9E82EACA9C88F882E29F4CFFE91BF9022AEB329D43C31437F4C9BCBB0
3A2ADFDC5AB8795C0024001CB17CAF8D1ECD58525D76CF0513AE5C18DAD1EB47
232F3CE2B321C744F175BC9D2A62F0236688C6B2D4E66115C99A99C0B4986A78
43846D96D02A8D5BE98763C3BA9B849EDD6D76FDA492539D15CB4A17D91746FA
7854C7045849E80D332113F6223B22EEB4DBCC306AE65B56E34A58080BFF595E
24EF8940A1010653EEC61D4F3B6165F2BCD2EF81F730A69402C4B82E5959F5B5
27015A386918F75DE0A356017E799D399783692E6961A5EC47315893DF72F761
1368608E6AA9578CDBA6E4C935FAFC4AEAE92C7D6E4994563C2F66397F332EFC
D9DDCAB7C11F483C0CDAFEB14F5EE6CEF4CDAA6BC4B06E5DDA2EA79D2C8F5786
BC98772CD7C7AE18BB255E1E01BAC7430A3AA992388AAFF908C79C7CFE8C7D37
96998C0F4ECEAE6CFEA6EB3F76F7B65AC4DC54F26B1EF29B282035350E971EFA
A0F2A5C317A74CD7D291208F7EB23755D7847312BBE666407E975A6D4B238A64
F346E5512922D30039FA5BF4B3650B7EBDD15971D70C6A5F172225EE93EE408E
29B07DEBDFEAE5D82C74EFC80E03C14593FB1045C7C825DD3832BF7DA148D9F2
B7BCF553F70268296FE8CF8F5F69BF26656CF55B9F5AEA351EAC5BB67EF9AAB9
95BACB625355ED1D99EC4B79E0E516A901673B7932EE12C1AE65B57DE6557A99
B5F44820F7BAFF46E9BD9EF238138E5F3392710B9555DFA061627129CFFF3678
CA2CE534576ECCD61776101158140A930453867D1BE8ADA1EF4B7220F5E74630
54FF89DD9933432DE7FB7DDF25A82D4F85515E357D67CD48364F5CCCBA1DA2B1
D8484D4B114D180C83C15F1264B723C4672A1685707DE356B07DC2131421EAA0
349A23F5726CF2A49D431EE10B8B42BA4B3278C8E29E4AD74C97E2BABD37CCA2
4342CAA6550A7324AA50EABE80B07AAEB02AE97AA40DFE3D3B3B0BEA23BF3862
5B87376AD0FF4EDAE728A40F1A19000F19A5987FA54B40D1F2465DEC61747D6E
7E74B43BFD047F9F8F0C86CED66952471C92F44D44F9E5F0A0DE4A3FC8D2CF16
9414CA0AB2D01B9EBAECC552439FC2EC1BC93CD7F12D7D8BEDF6D6B614AB4C90
30576DD830CCCA8E6028D95BA201DF0F9AF320E04C21C3AC3B3B1625C1C451C6
77132FD4C5CB875B3BFC7233A0B20D187FFB0F04C8F80BAD374B48B2EB2C5D9C
1EECF0324D036BFE6A23FC8529F41F1763D4E655FA8C988F48BEE08EDEF455FF
25F5E0A5212F7989F9FA6DE9EA795D3FE4506583F1390445F6889392A07FFB67
B2DC8090F2CD465BE4EB59F3F56EC230B882F2E17D6ACEC1AFCA3D967AAEB8EF
35139CC37AEEA2B5E12F7A9CF347FA11E4D9F6A1869CF48B144B14C174234DDE
B48184C603C7C9429B1EA42F4BABA02AA69170D8C568BC8BA8CAA4F60EAE33E0
5B89ABD3331AFDA08CC184B4844EDD5EB071DB3EB59B3FE4A32E914601F84AAC
A379EB0E8BEE456AB6C91FE0CFA23DA5395EE4BB5DE1694CC49F2ADC4FB4DA46
D479F1361AF8C67D5A9ACA4D59DA9E699D9E44B7A6DB8A0F7496601B0BDAAB3A
D8E828F55B41EA62CF3F3822EB425F3966D757449C295EA87552D140F5DABB7C
740DD20E4CFD08A5E06E4F7ADDACF26F9076BC9BFDBDE24018A1E05F8BD485E3
509CDE12D34693372BF29438A2AAB1EF78C940FA8D40567023C8C3EE435C892C
E4C485B5A450E93EC6C6403F58F8A83DDCA89F51676B5DDCEEF684F758FCABEA
3BF881B1A739E9F762FB85A143D7B2ABFF27B773081FDF05F7FEE6DC51EB284A
42234038C36CF97A9DD83C507BF2CAC1307ED79AFBFED528BBE3E93205B7C193
FED261579C2C592910B922FB12416EAD408463BBA555973EE8F64A24A78F46D4
FBBACDCF7E70BCC4BBE8F5F6F785A8F318F0227B144DC4CD991A73C55C9B1336
AE17A7B6FAB037FB590ED23107E5AC2232F4D0D39612CAFE167D14265FAE0EE9
64CFD7B3D0170E9E847D24F59CCF307F6D76D8E67BB151297F61DDA2A11D1041
A70A272DC3150922CDE10DA9244223982F9C113ED8CB9797A6DF077449CCC7EA
47AE04E8BB0781C9D5B5AE42F47DF2767A6BF81E658D8ED286090655625DD29D
FB59EC2EE0228F389607CE0BA0F33D58507B7A6A93EE1CFBEF5EB1B36F7335FD
FC5678A4E85DEC3CE70D22CDBB0F12E76D6491068203C9AC20619791F9E1D30D
A92165C8DF5492D068BAA1D1BBFB4AC5CD4DFFE623DC9865A41E5B26492400C2
6EF0ECDD2C00999804C302A12792B99CBE797D29C0D14179BBF1FA13E6848ED2
5817D9F829AA4F521AC6E5FB490F8D44A7B98EA928830B25D9A307D3F9B274D9
97A8DA1E5E7B68E1C9DBA89EB8D38652FC0414F1B60356F7FBDC156C391D5B20
862DEC64CCA3EDEB18CEE6EB3B4F4C827690C071F8C02A0F597E6E136AAB5B04
40DDC66157DE379BA904CA9F019094249A818FFF0ECAA9B96151B903C4FCD1A6
A64A79624B80FBDB9A9A55DBAE33483B68ABB326275B776E56EDDC40F93B0604
A2F2C6DE71F944F9885E3E2B1EC3E95A693F7F9B0D7A5E03B4F6FF0B5AFB3DC3
E8B0620B72A14AC650BDF391F1168D7256ED49C52E45926816D58D4E2334609D
8770C7229F14E934C6FE90DD54C8592A609B857AB699F95180650A622545025C
9154DDD78F966DA550A0D4BCA014BD19184B2C0F0908AD48902A8A9E7DF2786A
D83151579DAE636CB4515067DE39B7864581BEEB859B76CCF17955A83CCDE8D4
099FA355EB11131EF68E3533E8CF2D552987F044483EBE90296D5EB8828074DD
B86D34368DE5A86500886C93F399DEAA46225CED342A9DE577CFA98D7764CEBE
F680AB0A34D37D10DAEC1B0CB907BF7AD67E4AF25CA89D49ABFACB386CB5C121
BA8A02D6C36B417D37E268BAC2914C81BA322E6CB3382E3EEEA41B198A7252C1
5BD2D565335DCCBF6A12D0A7E89BC2FB514A21D740FD15A7036CDDE7368EC171
CFDF7692FF7185BA8FB0BCD7F1EF39495C5B839AE346A386ABB260E83643E162
EFBF491FF8CDEBD5743F78C0A6659364E633711ACC927D50FD01B4BCBDFADE7F
C86DBB58544CE9839E0BB70500080996F22920C0D767514CCBC5DC718479AD9A
E07AD788C5FAE37AB2F0B722806E22D85E99FBB48CE324AF772A39499B32E644
3262B84ED5A81BB4006C35808108407C09ABF0755B00F5BCCAE09E815003B9CB
BAC69C96E7FA7FD1B19C06F8200E9E3AAEFF7506DF1CFA27E53558C462051802
C7641A24CD7AF03C6C408BB29D7B9E7D509F525EA605D88BCBCC89A2FDD6B941
F2C735FD051B4193D233788F7AFDFC9F0A549CAA87F4B1B5BCBE0C0C45C86770
51B2B5D3513FAB3A012788DA3C774F3099C0D873DC554E74C3AC5BEF9CE3C8B0
9123A91AD78BDC80DFD356DA491D85FF479C5AA97D8A8E15D302CAE5839B80D7
C73CA163AB92F9B8970A2F8BC81E8069D9E27EF0663D6F466CFC081BA6620F82
D1AFEA88A69D58BE6B475F6E40A345FD53BEBA3B9953FDF4D00AFC1D4D8935D8
47E5A13D76922DD9478C6F456C4894AE640A60E9907D6FA252C4A9E322EBF92C
B50FBE5CEA15DB0164534EB8BAFFE2D8C5516C110277CA120AAD96BB63C36A20
CD280CDD03B8BE40C11615F1AB1A0252D90F997E0BA1302CC30A26751CA118A1
CCA2242D11098E8641C2283091BD3D498EE01A11A8E5BC594253933857951399
7711F7512982D5081C392FB83BD25479C37388685172159B600C4B2F89A9FC9F
318B92D6A61B21D5F4320A4F4C9CA64B117CA122F3C12CFEB66F6B9AB228AC15
B10251201882F2785C25C4724A32EE407BF3DA448FF2267F0C7BE74478A7AD6D
D18BD4ACB8C06A5A5A61F7527488B26163BEA4C238DF9E35041F93B5BB807DC4
FDFBAB9D73B0FF2F5CD0E2642C81F96A594CFC7151DCCDD885A7D44FA0B44028
CB4AF9AF0671DDF01F9C0FAB255DD8376D4AB95E9E278A1724FF33234BBFD044
371E159EF0569097A76A2935285E23AE6657712565E223AF39D9196164CA0DFB
137AE40CA962404A2F8460755D9F283E4AE113C93F6A63B84E17D95657576626
641B3C161447B61938FD64AF1F96F8E6DD1D0B35E3563128737CC204874C5DD8
A8B98803F66DA1BD3E192D8F2936C460821DEE0223CFDF953BDDE68F39A1361C
53F5C54105A6D8B25C55A3DC8B55F2CABC7CE7F9C7B6B057B14579BAE7E6C851
7ED6ACE5AD526D08512BC11BAF6D6D78DDBF662D9F921C147EF3EC3798C15CFB
471402ABC82E83794B30F7E73F6F59A9DC57AB1718817DD3178DB14838332411
43291341449F4B60D4AA8781F298496367BAF713F82B0A4949590B5CA92D33AF
CC12A813BEF933FA1FDD9371EB15B6D38A29E40B2C9BB379AFF8D2A40C25CAB5
DF600431DE440C793B4D0B3757BDEA22AFE432F2253F72FDED0675B7803523DE
32148306B7A2B2C374CD2327C663E7FB7F31096462A9E25987359A4CA9449A83
DD855D970CCD67A505EDE83D11C86B3E2139A6C8046C39AEC7675D6012159CA7
B8C05A9C96A6D7A83824DED4301C16A14DFDAEA2A4E0D2AA4F5D6F47D6C1B759
3F7F92F090CCF5FD9CE10F960FA65C768E6C949A496F7C7C0E9D6716D2A98A37
B1BBFD16C0B2C71D9AEDB770A1AE04476F97412920498BB92FE7FF6269EEB0E2
29F85BAEA6BAB963D23A946D7D00B816256199C117325EFFFDA7E3BC90D359D0
C5AC352C303EEB4645456CD110669C62653ECFE7281BEC18F273436ED3E715FB
85384EA92F8F0B1725670C781E6CCA1C5BAD534E7E7149D1839F9A58E411038F
FA1E109035C849BB95800FE8BF4E44956A5FF0D8AD773D9AC77E64E8DA78EE67
FDD16550030D1C43F79161513AA0A3391F371DCFCDDDE3325B2773393735012F
E12D8A804784E19337B92B3A0346CB353E061EEC2182B4254A571E8C85425041
4B4746CD33CBE9BC0E047C9E7CDD14C78ADFB08DCAF01A606600E9E4326D7FB6
90F99955940742DC556447AF1A932257094DC394332C2788ABF6E6826E5E3158
0613759253947BF1A2A77BE530F90D7B376D8120F0D7ECC61B8F120F8309FBCC
0DB206B354674BA2599F1ED4B800EB4D95760CCFDCE15A68DD52749615228FEC
8EC6933AE56BFA30ABE30999A9C372CF6960B2889272B62D699DEB41B184B72C
F77F90BF7C333D06D13B26C982DC298578D567936ED2435F5635546743406E2C
02748B9835072566306E240C26F5CBF42C47692E4E15452ADB523EF934316068
72C37D5B0C0D9F1557B2E0325F7006EC1FEF06B824B5E2E14944A951FA045736
A618E898FD92A64092450CD9FE4933905DC3F11226C6B6D76ADCED9B2A4C71E2
FC8D34D2A5DECE42D621ED278F4AB913A2055430B478818121D965743681864E
E727EC63492747EA12EF376B40B8CE354CC7E01A77D704E57D9AD1C58E686736
135D90BB9EF6B86961FE742B9A5012E0F6B42F14D3EB00B34198BABFAB090A53
E3B495D36B5BC2155914172F4A9D40FAD6711556426A1E3A6F5DB74619703432
F9D666509C7DF6DFCF9DB9C4F01CF75307E7000FC10315D8FBD0F7F9AFE28EB5
B8963D44D8A60C16D3124F964C3CD013279E120CE9F50160266F6093D898F7D7
7B8B5149E79CE420FFCDA58C17428CC2EB4D73CC48A708BA54F1C9D17927A770
B454EB47C64FABD60EF02FA62D139F440894E6BD824184F57CB88423DE1380EB
861F076BC37B166581CA55377782129C9278FC74E1CE93AA1B6EAA726B0CE70A
DA8A826E7175A87043B5D4EBD6417C26AAF82D93FE65A425CE9F837A2973146B
BF712F16584EA396206D663BEA74B260B5E3A01B716BEC1AAABD9620CF667D18
2600731A9EA6320DBF1C0EBF215DD4F9AA6371F029EBC3BFE211D1E0ED2CF0F7
9EF4325A0605F832A025E38FC964816C63F22201A2C021DD89B921755BE53C26
2767D6066B0FA9A0691569E6BA523D40FBDA70847615CF0493DDAA0A385F94D1
4BA3DB18A5F9A2546F07A684939B654B017A23CEBFC3E11B6000861C9407B192
97A74378C47198E11BCF04EE8EC46A8AF1BDBC461EA25AAC6993AEA81BDE0C6D
7DAE04A445A552E1EDDB37F37B219D704732A927037635457E1E2122E7E27D16
F87A972A5B9A49FCEB70BCBCD897CDA4369F3B7C5E3A6088D5FE9D1A2AE8FA82
C2BF45D550BB9E3964428454ABD5A86EA354DCF179C909EB82103326C1010DDF
B733FF60018E570FBCF06A2946512DCF18D1D5CFBB485DD1A32088B56BFFBCC1
D7B23D0626AA8A9E97DB1C954869223B12C05015D683C6FC3871F72E46D41FC4
1D4BEB4DC3D6F4F6FFF0DE3ECE70FDA9D2767F64356DE270BF0186F6F2AC7BBA
82724B22134048E4C45B6847E24AA63BD48E763E448A028F4F1127762EFAFF1F
BAB76F3658591E2E4222EB1637B630ABF1665C5A7EC6CEAAACCBB334FEDE5FCE
A2E80E8B579893193ED3F03549B5253DB7456CC150710B1D78950661CA2ED189
37C10815EA965B47BADC9CA14F8C6D566692F22DAE5D89F1C414604205062A2E
98DB960847A0A9A4F0CA50DE5EB9C2720DEB5830262C266126FC192A1A95F531
E41B5EDF8A8EEDF844F6B7CF497EA1BD5BA5E96D8A08C43C9F2399CAEE8338A4
E7BA2B18D6375C36ADBFAD17FAFE12155189D8989066D4FE5B2A3722228293D4
5C2E8AE7CC6B36B61D2A22D7E69F2B58BF7D49422195853CF561C629269FC8FC
1226B331D26F467FD22EE20488BE73CDF05F962108B35CE75B9A14D8FC87CD5B
E4A8A68B29A9E18CB2D6E71717E9B433C00E8A0863DCAE4C36E80EE33762AE18
5427D806D5AD5FF5FA56EB26DB03CEFD6B2238F687540EBF2F3D3FD9E34C193D
D340AC1D88BA4072B2EA35A0EE6838F18B2EB1164D061DF27E7ABC05FA98BD09
B116395CD065A8F02A34CAE27130F09E2FE314DD4DFBEE84353D1B470F979CE9
8430822E240058A1EA1874B29932BDF2AADA50FFD263A133E0B3A327980F9168
9CFA6DB38B44E4B122A5C26971462D350EFA7ADDBB1AC66E54C923B1F9DB9F34
F11E4CCE1C1DB154C4520A6B77B9876DF3EAC1D84B00E2E216F35E8F995C65F5
6C8FB1E823FE878DEEE840B5F3D879F5B0822B205B654CF5A29FFF2398DF5A9C
DD095E8AEED5C8193C21AB219639033BAEB0952EE50A23C961F667CBAECFB3E0
D71E9D82B0DC7E0E156E75AA40B8913B08AEF3514D75F8A8A90C0D03FE8B87BB
11D6FEE9D410CE0BB403008AE9B037B341E33C6712EB5F30019A89085254D112
62D9D0738DC237F78AB46F38DD57DC4846A2EC28098F86D8B7A64AB3473A5CDD
2A6E953804E874D9F08E7CEB2D01A3F898072E9949F282EB664093C738EEDEF2
5D0474A756E985B6A0F0C03F437B6638D77367296D6A36D08653F15F01A28991
B1D8658C75356DD1F971A85095FFFFD66E2E9EE73590AD2007F69F8B95CCB709
8BA0CD6D1C59312D9BB9B2CF64A874FCE6C6A2A364291113C7958A0C8488249A
2EB9FB7E4E0D0C7960612AF739E31358DBDF05D3246A7B7C7D3FD5E4FE5663E6
44595D38D9C269AD04C003D7567E17EEFCCED79D879832C36988BA0677EEA65A
E2FD14F9722F7C9D40F0E396DF7E108437FFA4070257DA12C6E3183192DF49F5
16BD96E9399DBF8988539E2D209E4171B296C425C73309C5875F7FB1DCF027E5
A976C113E296780078DB9CC0B9018BEE9217627BDDA0D798C2BC7CA3A9E70664
6D3CBFB2DFE066FDF34784648291902063EC219D7F6D677152907F7590D57103
CB509332C25963D04114AE83060B0B4B28D545B5D5395F1E49824FF5D0A326A7
AD64045FCF940FBF455855E4DB6643FB7C915B006C4A1572DDD963DF45155133
B63DBC12CBE3331885B19001F502EB74F97CB90778293449DA864D208446CA24
2ACCB7D0F44565580E9DE5A08E57F18CBE6C94A3BA34DC38342C03AF1543BD8C
E48FC18DD77F6688963E0F90435F50390C646B2AF67592804C5E50B8A288935C
A35473D5C61C4C10417BF98119150907E6667D01E27FE48DDF37204279017B51
F503689CB888C16904E5002A08B3A54384BE732FE30243564EA0D5EF5596F20E
262501CE498DAA98E3B773C4F96924183939D01ED8575C7883DEE887F258D0D8
D519BA83BB32266CD37FDD026C0A2175C5457000C00CC9625C82D6481F502ED8
FC5DE72705425A758D38ADB009B86C6C8F0B5E4BB923CB225C502FF7EEA76ECE
68C23B9EAB2E681914BCB4A5667C2AE5633E6CF0AFDFC2D943EF5EECFFF0DA85
8ABEA058927A7113801D9E19D5BAE140CDEA3D674A8D93F984526B8F6094D42C
C2F65E48FAD23F4725A20CE486F7A6E4DBD7A1FC69E451D6B163A6E2A6B724AE
D451C8293913962BF750D18585A6F8B3FF495022EC6BAE80CF5B80D4FB1E70FA
E37006D10306AFA8C1E2B6AC64FEA43BB7CD45B289AAC6DFD9B6104C7A09831C
C0BE6A6D7ED5D1C2C87FB66B82929AFE406232F645B31B88186829C062
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
%%EndFont 
%%BeginFont: rsfs10
%!PS-AdobeFont-1.0: rsfs10 001.000
%%CreationDate: Sat Mar 21 18:47:14 1998
%%VMusage: 120000 150000
11 dict begin
/FontInfo 14 dict dup begin
/version (001.001) readonly def
/Copyright (Conversion from mf curves by Metafog (c) 1995 Richard Kinch) readonly def
/Notice (Copyright (c) Taco Hoekwater, 1998. All rights reserved.) readonly def
/FullName (rsfs10) readonly def
/FamilyName (rsfs10) readonly def
/ItalicAngle -12 def
/isFixedPitch false def
/UnderlinePosition -100 def
/UnderlineThickness 50 def
/Weight (Roman) readonly def
end readonly def
/FontName /rsfs10 def
/Encoding 256 array
0 1 255 {1 index exch /.notdef put} for
dup 67 /C put
readonly def
/PaintType 0 def
/FontType 1 def
/FontMatrix [0.001 0 0 0.001 0 0] readonly def
/FontBBox {-2 -300 1240 728} readonly def
currentdict end
currentfile eexec
D9D66F633B846A989B9974B0179FC6CC445BCF7C3C3333173232E3FDBFF43949
1DB866C39088C203DC22FDC758584860EC7BB67FDA28CC6208249060E18FAB32
204779B5C03C0493BBBBC95CF02692CC4DEAA8D2EA90B5C2E64374E92BCB8501
429B8FAE4A76C0C6B76D6FF7CF9A7D5EDFBCA0E959541C59BD05B7DE43D25D53
FC3DDA6EF0C2743978A6D03E19CCED4A11F2EA4BCC3110BE8B8D9E2772361969
C19258EFAFDC276CB1ADE9208A941A36D18F9FB1C33DEF76AA315DD8F41F8A25
4AF1DC3456B9DA8108CE7F2380A151DBB59CBB616BB498185CD0D0DE28290A9C
1DB96124F5F796C7A2FC57B079E292DD1A2E5EBB88585421F81BBDC63FE33ABC
2DF705A2BE4F6BE21BED49C3E2FC3D528A348CBEF34339397282607E56471B4E
B78EA8C9F24AC14AB83068335F7974D7262C18BEC4AC5FB4CB5E0D7C410A3F08
57FAC1C117ED77399C1E264A853EDDA05A6117D3DFD28F96E44B1B8D3995E42A
E0B030F113EC027670E66FF845D9F93808284DC73F51F44B4C210997E261644C
59B3455D7C3D3AFBD65E28D1AA774273FB1B6E9AB4F56464B0D56911EE6CB802
F1C90982836A63EAACD2B2E9D07850C716F7D1291C59433A10F31CB9FB2F2512
1CE1F7F343CC06008D111D235C75DBEB8CE22E88E207F0ADDD18772276176BFC
F43EEE4F51613C545A2A49B34E4237BE57CEDEF63179B73879C2674AF40B79AE
024EF39D4D01AA6E8E83BC1D5F393AC1F78D133A004DE64C4AE52897C279CFA1
C87E605E5C1CFC2F4C72A0D0F9ED40A8B4F8E9EFEBDC1D60E353DE792A091B4C
39738379EBB7BDCE4D06844931D77A2BA45D857EC30ECCCB37F85274F283C27B
4C9BDB119847F4422B1FBB4059A5ADEAC44D234520322E2259CFDA894D6148CC
1E0EFAEF5666358F343AA0C6ACCEFCE6F3BFE30C43C85ED1FC565196555E51C1
0395BAF253393AAE179F635A2DC0AF3A9BD67D385A9A96A5009D09BE5AA164FE
8A48F5DFBC3C2C7244F57C91356ADF25AE852673C48C9C3D4A2D1F06BED56256
869E52850D83D2A78DA51010268631BCF5562B70ECF818A741398D63ECA44D23
567F5932BDFDA9520FEC5F94C434FC369F0BE91DFC66ADCCD21A6AD1434BDCDF
CAE93B9934C7E24FC7238B6D3A663ED5950C932E0D18A0604526630522F6FCA9
A6998225F6C71FD55A5490C891C2B4F6A8F9B9E454670D51D7F883D0E26253DD
07517660B58ED8E1FE64AC617DBF2FB8C7A3E4B0E9313749E436516518542AB9
2BC049832DCAA3F92F1F53388FFB0B20D278D82A20C029ADD4D9F0C023DA1D3F
876CECD064AAC79B20865677C0F6C6F123E97A46278E51F67A14B5B2C678FF58
35A253D3521F0D6769427993399D380FA3A3EB3BB7E6BABE9D8EE8F4CD2AABE5
3CF57BB6B2CD38516ACE47C604E6C51D6DDBC16F7F4F93CEB861517BD485E6CB
37CD4A245ADAD29370E6E4F79970C021D30B9739D646538ED6283BD390EEA9E1
9B9AF9ECBA8A9DD9DF83672C72D9D4813948668D07A824392AEA77B49B73EB7D
5518CE71D48E3C6057732D80B52C6282E6C964F1A79624A2606174B60BD7C683
CF9EC1A3BC4DB33CD5A34A130031327F3812684E5F262E9C3B7566FF2229E216
B8861601FBADA5010B7EDEE6A3FDCD624C4331DB1E16BFF655FB19CE5E1A2DDA
8B7ECD28388A8915A5D352C6EE5802EADBF694C79942BEE4CBC4DDD12449B7F9
1CF404C1A347BF09F7F859A6242E430D6AE665B45B6542967F3998888469DDDC
E0966B6468394DC125D7CEEB7B6AB57459BA6238E72D5622AB74F1BF440716EA
4D2BF7A175CECD4DADFF779CF22FDD3645A10F21359472A96709519E26B67E45
AC47236F9528DC21E7536CC33D8C61DA792DDE69FE2C929FEF7402E0BDD6807A
0B9EB6E89BF89B8795C694A081F3BD46D21B6D0B2ECD3EE5AD5C9DEBBE07877E
6E14ECFD284E2722F7DE17158A17E1FABF85E4FE7A88944795F9BFA7393CE77D
A9380C321BB9E395ABFA3A82410E23B2A0C5AE2F269CD89B83FC112D76BBA05C
520069DB1ED50309A2562F7EAF7EFC44206FAC9341D43AC601DF80A80EEC9007
AD0862186139B9F94BFEAD5B0A0457BB8D7B606DBC419225743817957AB44B56
91CD6EA83EBF879D237516
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
%%EndFont 
%%BeginFont: dsrom10
%!PS-AdobeFont-1.0: dsrom10 001.001
13 dict begin
/FontInfo 16 dict dup begin
/version (001.001) readonly def
/Notice (Generated from MetaFont bitmap by pktrace, http://www.cs.uu.nl/~hanwen/pktrace/ ) readonly def
/FullName (dsrom10) readonly def
/FamilyName (dsrom10) readonly def
/Weight (Regular) readonly def
/ItalicAngle 0 def
/isFixedPitch false def
/UnderlinePosition -100 def
/UnderlineThickness 50 def
end readonly def
/FontName /dsrom10 def
/UniqueID 0 def
/FontType 1 def
/PaintType 0 def
/FontMatrix [0.001000 0 0 0.001000 0 0] readonly def
/FontBBox {-31 -13 1046 902} readonly def
/Encoding 256 array
0 1 255 {1 index exch /.notdef put} for
dup 82 /R put
readonly def
currentdict end
currentfile eexec
D9D66F633B846A989B9974B0179FC6CC4458BB4CB99E3608702C78822367AAF8
905981B7439CB3B707DDA0C0F799F4C51DE03E578CF7047BCBA4F6C526A7CE29
D8B98A4753185D35E1B8FD3EEE0E8A199654F240D55A36739E25B940DF313DF8
0E774DC232EC79CB46F57322041F2FAD125F7745CF281DC8E567DD931FE48C5D
7C16065D14F16EC9D2F4BF98201772D9398879A7B52801FE9EC53B39FA7E7C2E
BE21BC8C9684D614CD6E7A4A56D867DBD4E6CC3719D87181164C7DFFFAE03990
4DF78023E04898DE3236DCE6DF36527AEBEF601F06ED4AA9B69945FC843DC9DD
464F17B4029C85296243EE2BF77F0903FA743A3C89357249D230772CA410B8E9
D0E5997E6956637CB480F0D7F8666B7AC4E281D8C9B7B2FDEC5ADB378271657F
9C33C51921115B8FB18FDA5770AC0E74B9AEA8500D14910DA2676436B4D6BBD3
4935A0B20D18F8522B9D5C22AE57151112C1EA782554F680AC52537A30592855
77D34AAF8628E8F460A3484ACDDB2B5F5DA05144A60494C65AA078D8FD1592E0
2E488196064FEA8439C3C15B19BDE680C18937240EFD033BF951F24D5894FA50
46D2B8AF48961B2C2951B9AFFCB9717C1C483BC131450171020EC402FAB1C165
12874F9A710B87C22223A1BFD592C408987C1424865051C1D881D8A37224C8D4
A08A93B5D1D7D5E8B3E5BAF1A862AFF6B995315545E9CBF5B9EB5C7AD3BF4392
A92E51FB9EB94A47EF99B79EF4B2A1ADEFF70CF35CFABDB2D57F5ED7D683D9FC
5BA7D551031FAA6F6217DD137AF278C00C216D46AA0B2EE544E68D58C578B641
452CCFBA661689F4280C24FEE073571285A3260E50C3E571099369788E1241FA
4D02D0B0237A9BD371780C8CDB8EE4B92D4F5E1A7A79424FEC752CE50DF651C2
839BD0567ED3605D48DB05672F0A96F18B37E674000A620A848C550F5F527840
7ECDF45B778C24D49C3BFA5F9BFEDC780FB1292AB2DE941DD59AE974E93CF8E4
7BCE3E4B44EDF88D621AD217FF64372BA6E63A0171A066EF435E7C0F70345A2A
3977DB0644B46143F4361298EC32ACDEA13E99BD1D04AB11FCE1759FBD366D69
3BE2AE46529327CEDE42A86B321676C310BD390D2D81E8A00735C092D3A2A429
177E606B65FBF5FEBDB009F41D091BD9958704661DECC56BAF0D615BC8DAC81D
5D2DE41EEC77ED9308D0CAE9DC3A265829CE447C248961D28B1AB392398FF9E2
B2E6FEDAD6C698D27D8E7E8CF697AC5393DA4A3EB3D845C875E1F91FAB78084E
02C549FD10AC07123A6F2B4222CAFA5ABDC3C83F6D40F0A18123E3EFF48F9449
5BE84A
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
%%EndFont 
%%BeginFont: Utopia-Bold
%!PS-AdobeFont-1.0: Utopia-Bold 001.001
%%CreationDate: Wed Oct 2 18:24:56 1991
%%VMusage: 33079 39971
% License clarified 17 November 2006; pfb update 19 November 2006.
11 dict begin
/FontInfo 10 dict dup begin
/version (001.001) readonly def
/Notice (Copyright (c) 1989, 1991 Adobe Systems Incorporated. All Rights Reserved. Utopia is either a registered trademark or trademark of Adobe Systems Incorporated in the United States and/or other countries. Used under license. The Utopia fonts are freely available; see http://tug.org/fonts/utopia.) readonly def
/FullName (Utopia Bold) readonly def
/FamilyName (Utopia) readonly def
/Weight (Bold) readonly def
/ItalicAngle 0 def
/isFixedPitch false def
/UnderlinePosition -100 def
/UnderlineThickness 50 def
end readonly def
/FontName /Utopia-Bold def
/Encoding StandardEncoding def
/PaintType 0 def
/FontType 1 def
/FontMatrix [0.001 0 0 0.001 0 0] readonly def
/FontBBox{-155 -250 1249 916}readonly def
currentdict end
currentfile eexec
D9D66F633B846A989B9974B0179FC6CC445BC06347FF71900AC8FEAE3B716D52
C1AC4E5DCF4EFC3B9121F09CAB0C4BE35FD0740E08C853EF201BBFF011DE2163
790FADCD67A15500D3F87E2616B7DEEBFB3934B09CF7B8BE9B945D2638887F73
1C3214D790EBA3065BF944D77DD51978CB663398285895D774586FDDD6A7467E
B1BAC83EC766EDE0FF34D07C6E315D7B79B205EDE798A08FD0D9CD4A1307FDE8
7F57AE7A32759AAE66C77C6127F65D92BCCE74ED784372E34CC835BC789BDEA2
9E27574D388B2CEB1DB127C190624246F4991BA418137BEC72C8CF7830DCEA26
E13BC7F0CDDAE283F10C1FDCD1B46ED2C4BF3526E9DD2FD5DD021D1116D3D9B4
44188211B1332E1BE656BCD0DC7C6D7F23ED03F9A42FD10B79980768710365EB
A8E211AC8936893AA9318E20D297C730A6A626FECD20651E6159D498F85DEA98
038CD78953484C2AB6579DE0F8455DBC490B5E1656B45A31736E5E2BF50B8F31
267E916812FA4661B391CCF31C1CEF974E371009854CCC04B88163FDD69DFF46
307B783974C408286274E78CEFDD99FB253F6040F96E4DFB000EF00A93CC110A
AFEDBCB7E9DAFDB19E29736CA84017FBA4C48D67F617A0937229695652772391
0B47379ADCE97C1A2272E8ECE87A1E0B35CFC9400B90A330FDDC52494432E48A
07A5427237AE7DCEBA59F06395833B628C8BF425A38348523AB24EE529E70F6D
E36B4FCA848B48F5D18F20D88818239EA04A1D52164110F10A861C7B7AA87786
3787FA2BB85BEF178696D7433F83886F07FE61A11DF621C607226F24F7EDBCE7
EF8B9A9C547562D02F4CD5A7C1C4E9CF749B6E8484911EB05DC8C54A020A5376
9746976D0F3E7C6D7D6D03D38DAE94B64AE7BCB30EA45A64C8A37114EA85F851
5E5F96B454764A111B571111C7198992EA306160E302F1BC74EBD30F86678687
F7FC00E9E3CDE46A18A27D24305A3C595197D22DF748F133F070C630ABB6DC81
263ECD7E72539CE014BDF4B6F329B383570C09CE92278ECC0B38FA0BF876EBEF
458119485A6A70B3C82D9CF63A2EA37E776AF51DD37736854F8CFF11413C0061
18E2A555443444908D6E49D23F564B971C26A335C7A93634622FDC1D98982CE1
CF21854B959F0E1C248D4355FD3C3479B6FD320669A68F8B4E14BE7C83F37CD3
2978597FA3D1316AFBBC16678C2C59B38A74E29B9E7D4BEF828A51B13E71DF2C
C78DC0518AD29137C8DC053AD6D86747DC82DFD3366CBFCD581044AE5B23B88A
25842ED0050BE19E7F538EDAF1128614873F52B8FE20E16DEF21E3D2FB51713F
DB39D6C3E8B60AC7B4A83F38D6C3283AA890E5C5D4462D0CDA1D49DEB5221D7D
759291FD43C594074033868359A9CB523210CF1A2479FCCC7401AC1BBBA29A0C
F8449C165FECC03856CB08DA710B6DE98A17CA615483CEDBDBD9C2F47D84B562
1745DBAEB9560610DAA89F9D6EE68F8DFD8D0E136CF2B9B44D86E9064DDBA73D
4AD2AECB1F576EE1254970C70643BAACDEE7682FACB396AF64E102AD05E9141A
2A2B04760E9C6C61639B9E43B6D719F2431580556CCDFEF253C0B613B9BCFAD5
ACE01883440C3C61D2BF098A3823E734AAC86926CEEBD235D1F3E05CA0A67A4F
22C2D72A793CE08FC5937B4D7FC5E77105598B3AB259EEE0DA4D7517CF10172A
9CF549FC86FE3C79A1FE96E5ECBD1897E78765DAB8AF93587203554CB8008AB9
1561F7B489D2FA6D444F54CAFFB3F32607B0397165B14A92BE18683BC31EF660
5F4FF9BA5338BFD5864400194937B828D9D86E7EE72A083EDF44B4052C7AEAE5
A717188A7D376D56E0B4B1D432021A9EFA4307A08F209486B3CFFA939A4665B5
D627D9F3CB0E7863E79A95347529021C91088B5CB39D4D7BEA45FA317109628C
36BFA67F70119F8B0F33E0121A2675BFB153B298D913AB360F36F5B0D2D35C14
07D8477DF59218976FF8B593578363822DDBEBFD3DEDD4C85EE513D30E78D7EE
3049FBDB14785F6BBF58F94228342617ABB13A9B5471010ED8F4F0D421F534BA
4ED43A400DC83E5BC791CEC297C9D191C81636CF41463721C0668DEA8C652EAA
A1BA512AC17DF0F573E959DD1D97765E4884A28F9AD3533F8369A3630B3672A7
7AF8F756CA61CB1B474FFEE994993CB8C9E5D3F9B8D38940FEF2FD25B9C0E74A
2FDD1CFD6DAAD9545D878C08C8ADF66FE2C8C9A828221E4591E0428E74B2679F
4365C2F4C41F753EC8C25DF130E5394BBBFE6B2B02713C607593C05C07B8689F
F62377FC5BF6628B8FCE58F1538BAEB01F0F81E2C117943DD010B17815A19801
8D6C17F1DB0C4292E2E22BAD05261C34FBF02FFAAE8DC08B75C0AD9C52D39AA1
BCFDDC78CAF3515CA570AA5F53D932C72C4BC7009F6F9B4B5ECE48C0DA16619B
CE067CC1886AC1485D64CCA9BBECD3F2203FE722021FAD70EB58EB39B567FA0F
A140F52CDAAFA021A6B5EB84D5F63C4253C69E6A9D74867E5CFC6BD6409C0861
10066C9F9195F19922353E5270D5FCCB0D9C2A676384F09AC00BB4C78CC1E839
7872ED1E0815EC90A87894700557576242C345F153C67290B526404A3C902098
30EE8D14F60C39E4F076F03E7460534C881B04FD663916700C95D202A94198A7
90E7B4DC3914FA2BBEE1A7A909E855156D95730D37D428B51BBB3AF89F660AD3
8ABBA808890ECB590974B2EDC5C5F180616D3548A853EA132B5E01298C8C3252
27A4C4A6C1D4963D45A7BAED4C65B3C54CD77EE547D710724A82CF6917C50EB9
74A5B6C86E44D3A19A83BF83245B5B35C4DDE49E544CE27E43DFB02C61DFF5E6
4E2E5899D21F6CFD57C6739F462905CE9BFEB4F5A49F5F6AA384565A9A3495FD
2568D78FAD7CB4D5811750C6D43D43344933AA7FBF4B3C05663EB8B063C2E8F6
82D34C37E65E1CE04E7FC259019D93808EDE04A485F8A8F736C91557691A232F
B288D50E05208B6D2C5A547482A1BB734AE776431D3E9F64F4DF4A05172E4B31
F85CCFDF70FB1A2275A16427EDA0CAE0F1AEF462110093940100F24D52EF4052
ADB96389A98963B1203E5D38462F137434166537429CC89B09AAD89CC7F08DBF
F3DD2C978561D8A49F03FA46B320A0D51077ACDEAF71EC60CA1EC1F0BA1EBAFD
F841BA0E8C2CC7FFC3C12F3C2316B72740C5B51372012C73C28B8115CAE7801C
20EA47406B5ABF859C923333D118040564D377E3DD0CFA0EDA1D7A26B9FF52B0
C348B36DCA0B89C56BB44AA5D7006A9FD5D1ED3DEB4D8F74F67602E398CCFCD3
5FCF68F5E93A0D8A5D79E5CCFAF91F8808757F59FFAE59A86945925BE4728CE6
02F6D55A0DEF4C5AD39161413417ACAA955C55A1D8E4FBEFA67B04D4382D57CF
623021C42DF8F2762BBE07F271264154B238DCB99CF1D4718D04ED952720D712
47EA158DD7B4E8E9A11D95DD198C51BE09B116B603E4A410EA9AE7ACECFFFB08
2B1D8E6D23504B4094520A343E25D648B2423B226BF4F054EA46CF9E7412BBE5
5EBD003CCD1AD25F2326C35A3B1D3B02D2854E4C555ACDD144A6061BB3BA5CBF
6261BFA26DAFCA8204D117B1E1CEE5D8442D0D5BE935B8B633400FA677D8AC13
393AA1820F4E426160BCB849BEABC36F78B2FD0FC05CB4F49A32CB8A923C43DB
00FE0571B7E9F1BFF74B6EAD018CB12244C32DBDD0B7B8CF48C3D465E12CD353
0B1BB0722BBD7D7002FA46FEF452D3AE5CB0443B3B63FAEA058B5079B6259079
17A1FA558FEFF07A543EABD0412976332C010505705AB25634F1974241B33B67
AA61CF96FCF9AC48082D321C9FCC92B48AB0C9ED06EDF549CE302C6B8DFC9B18
6642C1C87CF745E42FFE87BFCFBF3A74AB067E6F73AC20FA47D45435289A1236
6FD9D4FC3F4CEB73912C9B4471CC7FF4A8D41CDA870C0C6E6CAC0B6A193DCF65
69167E33E7BE19A81F08F39756EC87DF91F6744A461B5F14AF7DD1763ECF1973
0B67068836AA145BD76F8CBCB046909FA09CCA234DF5E4EBC8057F89AEE64DC2
0E60789A7221680EC06FA7B26238CF67E24E0A032DB58637666D69771EACB4D6
A50538572A939790B6F17D2659A392CE8F401CDFC0241B7550F9106F2BA97787
3F178008E1B4296A1545423C40DF4E03CF6B67E0B13BB35CE373B5C24B3EB35E
97C43DFA17BFF51AD645696F3CFFFCE5CCF0419224B691FB11AA9C35F5274E2F
9EA32176F2464A14743EE1C9DC85185A1146E148602F732DCCDAB72C2692041C
4FFFC1BC2058BB7E7858898AD528630DCCE324DBD53DCC266753575D594D5BB7
30A820AA53CF8009E77E3B08EC58F4CFF20C718260B7F3644B8020160950369C
27CC6FAB0DFF22B41D6C755B992A8DC821FB550C8D10A6C3C2DDCF5DA974B234
E6232BC798A22127A09DF3F459128023A737F14752680446F888A04E29173F4C
28AE2E09541FBB7A00A7CBDC61EB37DDC45FBA8965B001333C47A03616E412B4
135A0D6069DA692E95C0BFF6E81A76A3EF02BF6B81F045E3D3F22A3D5CC1A483
3F2185DDE6069646986907F061765DE2F8FAAE095A438D401B8BD61490551D1C
46AFE2BF605BF3291081863F977509340FF806A967B12AAFA8909ED2875E9891
F7A19EC131C5AB5916C1A6B49357335FF9558FA7668CDE74E37C9AB7C1B18967
E8E6D3011AD420CD846EF29D1917487D86D7386E206881894050F718EEA62CEF
4B9B99042164F47114A9B084D3F882406EFEA142BB03C350A0B6C5DE4B78C4B4
DEAE6EFF23649DB55252BB620D29153A2846E0A67EBAA9FC656C1228C60E4CC6
04446A7797684AAF97BCA6FEB1768E5CB154AF85489E1FA9D96C65DCD60CB7B2
37DB20AE5435DABF8BFF7A7084B085ADC53165413E1ADDC98E7EF266A26F5D12
FA5ADF74434F603DDB68D36776DEFD077E7E1AB0B92B85B73970D8FEC4EF92A6
2C4172FB9928957734553C6E803EEFF3CAC487959CD34F8A883FE6A833FF2942
402FAA969C5561B6774140A3E49872BDFEA794F7FD7FFEF6E139AD747A1FE949
75EA1344B9588D86B95CF89CD763D73991B3D28831A2D4D4321D07A2100DF8D2
74A585940FCC74C45FBEE6D2F33F55A4B60CE0D32F928102266DFE7348AA4125
BB87284256E76E1878171F4B498DA00E281EE23A6E491E1E5FFEEF7A7BDCDDF2
A9A15E0D698D57439FD5405964940447EA1A45344A43D248CD123E24A21A06B4
380150E2FA9928106AEE7667B37010E988DC95D8C8438C6CCEA7F4454579ABD9
3757863F0A872BE053230464D09D4671AA3376CC291E45230A08110BA975EED4
7FC03ABBD0B9E135B8FC328FE6F40F1E063B7BAF08A8A814A557911A3715E1AC
665A358233C593BA092B0CC212018FAA8C57D30B4D8FAD6185729B3FB1B9CD4B
A20B8AAC667E1ACC0A0F485DB3EECE7BB47561827CC64BC589DA6156B9863CBE
ED9B500C9198838C9B945574DA5D574307928A6DBDF48E56E934C2921DFAC0DC
492F4606601ACD7D0080FC2A395F302F50E944D4066778405FA20565E86BE450
1C0E3AB6FEA0BB0CCBA62A6E4E5478A19B2EE72543A191750E08E0F76D747D6E
7EF3C4E04F37759A354B2CDD077D496A2F3C22DE5DD1D2BE3644E84A0735040B
728226D1A14E243D7766BB4F6F2AC454F5BCA90F1C4EC2C43A48C9F585D375CB
693C6A287E40860D133C8309DD7A08A1427901FCC2709D6B1A18874534BDEE62
E99D88E4B7BF4CF375C71B56B74D876A7ADCC2A73404ED4A9F7A3C4864A5BFBF
14DE594709502825EA5C6915BA5CFA4F5EDB688D2B610CA7BD6C03DA7C9EFCDC
6AB7E5AEC4A79CB4D221C62B37F52DD2294F9882DAF4EDA2E7250CAD26B99C0D
D525CFCE43EC607E69394C97F0613EDEB93DEC1D16AF3ED6C5B3D58F61685DC6
FE4041206F8F2F0EC97B0F16896410BEAD7E583F9BF3D7BFC5FC1ED0C4EBC9D6
BEDFFE88F32BFA5256F907B4B1304696B208184B95713A424E5B5FD274BFC4A5
C7614DF9530B30B1CAE36589BD8E80ADA63052020ACB81E231E7B98ADA8E9125
0BD38213E9FA165AD7F23B4654B265A8B28F07C25677A16210F99DE85EE2B3C9
339C7F2D5A35482F5A133F0E3E875234D5138DA5CAFAEAEE1C86AC0970B8B452
E2F930B97062AC899762EDA276008390B8A57A4B285CC22D9C4397DE487D200B
F30403E3FA67CC6FB6D86B6EE103CAEC815A4000F8F4F6193C02B89EF42FF49F
C9803DD7A0DD88C275884EF4B9C61AB607D282EFE744D0F88C47B267D82C4CC3
53E0457DCB73F658E2ED8CEB6263F983859FD0A3946680DAF443FDFC1D195986
2A7869CF79520E4B6F6FB74E2FF96F0B77984B7AAF31B68D3AF4808DC253D156
26567EB68A52BB5B407A9A653A4F75C606F5C9317680A1327E42F6014E2613AA
97507A9841CC0D753AD1672B990649FCE2A9DA46E17A70D63B06F5D54EA413DE
4C996B17F22773253A3164888AFBB1264F6F62668E644C04646F790B08CDDDA4
53154EF42D0EE379908BC4792AAE25741B1A8BDB94B480014364CEA3FF695D5A
496FB971B6B038702C37561E007703243705101C78AFBDBE18E288141B9E60FE
85CC8E7009ACA1CE60F5DDA0A344AB19923A421603ECC1620F40AE06FF50A7D1
311E388AC06D016AE0659513470BF3CC4754257C70A23582DAAB96B8BD7964F3
C11A1C23D5A21A294010290BB0974AAF6BF76149CEE298C8CF6B4CC4929380D6
D3B8018EB404A3CF831C233B69770125B5D86FF4BE5C299A1A2D05B3F1266FB8
56BC380549E139F50F5579B52232C643BAA7D48BCB8783D93CA182B259BD914C
007C3EDE735DE2C4F5B27DF9A9CA98BE49C4DB605F9A00C26DF29E7EE697BFFE
FE459946C4221C529A7E211E4410E7FA1826E5DAC5F2DC1E3E583636780B7BC0
6DFFBA04127AADED89C96FA23F67673A849416B603571C66CBC414640C733DF9
E020790534D6BA12366031BD1F1F8A4AA5F5D0C37991122AE51D148843803A23
902807C869E8594D410A24C23DF65B82AF69EAD5C3C12D2DC870F653E379C50F
A42E1529455DEAC09723100BB6EA08A261F936DF67226E73CA9E10E3A3BEFF2B
2FB989F2DDC463DD5D5A7340F0C175D0940CF178F48063C256F65A8F40DCEC12
0210CA10149C7C0B5E176DCB6414033D22B6B1211F59083D49414A9A9F353DFF
E84BCA86276BDB937DDD11D60912EB70CB0228D5D7659F1892A8C81ACED3B045
3ED727124985A11635011D0DB8F09F9FEEEA579DE0654DFD4CDDB6429135DAB9
4EBC03B25993CE582C78D45CE54297C4787769CBC96C68D4FF66F2BF4FBFF484
233241879A5CCEA7FB1B810E4C95B75056CC0F680A66AA877A7648186803F482
1182D7A3486C3ABAD61C11EC60EDA7AD8D3FE1D0C0217C057987B5FAA6F2C971
2DF78950CCA7D32EA28C5BC327B71BFA01E70786FFE45810293F7973638F0E20
A4FD59845093F431708ECC21013CC6EFC581282A896F0E97B5987E90268D1731
89D3CC4ABF16396A586610F633944D5267D9FFC19250DDF90DF9632AC0696754
8E00ABC7471590989ED6E63439778B3B4879D1096790EB7DBB19297616419FE6
C2E74557C37407D03436CB49F906A88362C0605ABD924A9B69D123E5182B4F95
B498B8EC4E0AB0128FA85E82DF5CC2FF321BF3AC819375B9240A6E17F35FD36F
9480738BDEA630FEAA7E2208B4F0FA2804E0BBCABDF7BB00AAB2CBACFAF313AC
5188E8E41BE6221BFD68CDF30250E19FF719D6C5FFC32D55B8458C47B69E64E6
F11883A2516ACA5FB0217CDD5B3D625DFE48BB1EAE29345F6328FF8772D7252F
9D7930F75515025BDC4AFED95B1D9471945843331B818B9B0E66A123965703F0
579FD30504A2F8002B1B21F6246BA012F90335D5F26EF1B00BAFED29A5A35AF8
4A2DBB0299A170D4E392325F12D8F83F6F3A654555F5FCF839B2EC27ED4A8AC9
04F9B5FD88F7055210525F287393BDE47B0947A724D00985F7ED4D85897E29D8
D0351C31A8219D03A4B5B480F71D794844779E0CD9476D3BBCB9EDB273A3D4BD
22AE6BF711A37AEE334E93E0147DBCF7AFF55167817FEBC5AF87C86FF82B8B17
590D62EF2C1C2AFA3E242D32ECA79ABC3EE63EAB225F2857D7E54B43D9F2F7A3
80CEFD9F6FDD519F13FD8B3F70D542F79105DE403BB1D4A9906F3EAC6F3CF2D7
A37A8813B1E0A2335E0713DABAFB6BB70DB459821447FABB24EAAFE8DA4B048A
A724C76B36AD46FE25C9C82FF70B9F9FE28408B85ED9ECA71799DA92494DA46A
0752960757C7976F7FF4EBA17E94950CA493F7B95FF8DB70332E44D06BD8F129
D9ECFBF6243EF4C0E8A7E2D2B441CDB72082A6B4DC95F45BDE9157AAA9D2E5B2
9214B0A78A69FAF101A3D9981562CCB60DC290117DEF0EDFD98B324DB90D2D2B
F3A1ED1C09A1B0BE08BBAE969C8E66B14D97E5D8590759D39BDA9DF6DDC3EE17
F2E7C130DD130B2DCCC27DDEFEC111C739B4B8E54463BB62E091A49BAC502C6A
21DC7EF006B0A61D11B6E37BD4A4991C3D9207937DC75BFFCC3A7AB552E4DA1A
EDD1F2D16EC6C8555DB97023A54A754690D24870F1256E6DDD5283CF4C308C9E
0F0CA6277BF01F91390200AF82233EBD2EB830E2785207709D596985C6CF2F23
310723FCEEDCD1D937A61FF9BD77EFFFAFF859AD8275E324C73BDA448EBB59B7
D8914BE66361F7572FB9A4D467AAFC82E13D39634BF3448E3873FBC7A720D0FD
73C9D30FC06F75BAB024B6B0C85A767AD0624A97ECF80B930DCF4310F498F163
0194278A2835CF32D51E6C85CD766F7298116E7FF6B8E09A092BB033D16427D5
16758614C91108C9E4AB87EC68A45D79A03B8491511835465DB7CFEBCF2FD3EC
159313FB2E9EC427D1243B062CCDDB63C03094D838E3DD3B46DB56C91020C47F
CB83408D70D88C53A83CEFBAE9F2913A745245F95B37A237066DE0542553B156
2B7CD87CA21F8E685D6301301AF68C327345812CF1D24C817D6576B092AFBB7F
F25E58AD8817622FCCDD68DEA499563C86520E4B6F6FB74E2C57D917C2F1300D
40E044AF938675AC946C9E0ED107E398E3DD8C9335490F20A43054799043A230
FDAC3A752E3E116D4C363C0FE184BA2813BBE7520E983E45E53C4CD6464264FF
C6B30F00DDB4038216101CF9BCF166175A79DABE52DCBE6C154895805D10E202
7A98BF9148C6C0104FAAB95C3C10958EB96A1C674C00B3684F0EB36A34CE5688
44F39951C608D3119D3089120946B7FA44016E9F492BA7B63A93A21F68B23952
6E5D71F6E93B513562C8EDFD18C3A403881FC525048010D7A17CF1FFEA360349
7EB15A0CB17DE2879C7FE60968A4563EE1F62F0041C4052543A54EEC7CADBE9C
2736CB89EA35BF5E1CBB576FA71515AF67C755A5FC4949AC830F81D359DCC825
4B3E605D8CA6944DC9728B291A09F2F70FA32570CCD74CFE6974B29E709860D6
84C3BA27985802CE917AE98C50A0FB49A991D5ADB4ADEAAC808FBAEB6C9B5D8F
1B5AE0D750387DCC0E9663AE50E6FB4B02801116523CAA7883E46F6BCB2F1AE6
A5473DDCFE2C5E8D3D05C3DB0B218F68417FD014B5774B07CABCC16B24EA3BF0
379DC55B03B9411A3353217B94F60D6CBDD8404154915C8ACB57FFB76D6D1E97
D08B6E584BE03A29ECC9E733953D61BFD9975131FFCB89C6A304ADA49CAFD61C
39B295045A0C545A374D7E0226259F41005187115316F9F6D5AE7F28784B4815
B8CF73033BA32D6008BB2CA82D0890DC58F28A981D2007E67D911D534980609A
38FA3DE2DF940F915A89AB253EC8EEE0C0AD432396D4DE62AD4E54B80CAEACF1
E3EABE76E79A8034228A43DC6017D08BFC792E5FF5030ACF7C6FBE491EA5CD1C
9AB4D08D29036F3112955691999CE6AEF7E915A9E43541A8BFBBF4BCA5D04EF4
626D93EE7169D5E2332650F91ABF827FE32409951CAD9B101D384B1B492D4A5B
9D04D057466A763E9D0192700ACAD8E573901EF74696E845BA5BDE6592C7DF96
C6DA99138FEAF06EA83264201C49B4CFCD30352BF499DA89CF6F9FBFAC917E30
F41CE95C2F326D4AE241C2E3E467BEA9BBE6179AFBDC82C3CB0378A447B027FA
D949F1CF7C81D9CC3C107CCD13E801A59CDF16A3443A7B477AC27F75B7A77C43
47E35E5BB9EDD5C14A49A95070A9FE43ADF89336567AD43EFB3297BAC93519F8
56681561CDC8F45FDB5AE790578E3D87A98C8B6B1864C90F027CC305EF54B502
7CFD6688F77651B6B1FA8B4FFCBCD6D247848CEE1E283721C7F9A5DC74D03116
CA0E4E86E82290B458CB4272E2DED186DE680F692FC6772041BB412398C6351B
152E263116233BD5E7486983FCC401A7CAF81DBFDDD3C61B9F59484679500078
C425314CE563B9333E6FFEBBE9597436225F0F2EE9B93192C91856AA60531147
37FC78BF915C397787E23EA108C7C94A3EACEF4390B4B7BC7E59927A243C2344
13756C945C76F5F25E64817D4520990CEA05AE370E3BF8730D2B1FF522DA5437
5B51CFF56A5C5BB9205596C7073B37BEB1F4CA17A6077AF01144957CE058C904
5F91D2981591AC39A18D0B21FCC7F4272D921E93F0F2109322FCDBB9FB7B8D2E
F006B9A58C6E2D5D246D94B52AC5ADD34A63467EBB504EF5B77EEE93489B9954
1E145B5E6F9288C86CC4C7CD041656538C70795623604823E29A7EC66B59A5EE
2E274C292A4B72B5749EBBA9639E040D0976CB49DBA0FFB2CB5665AFDBAAB8C8
5BE76B84E998AEEBA74F7AFB623C76BD320EF9E1C229AC91DA7068F475601E1F
FC06D303B135944875E8BC20A56D09A1B5D36962D6C676541440F5A2A67958AC
3AE0921D45575AFCAA0C28ABDDDA69D06D580EE5CE54F19EC5974B7C45CDFA38
3B7D43D4BC320843A48D05696E341E48C3B9709171AFA088BB08C99C0503FE81
6C80989BDA85FE56A2190E1DCC900C16CA6C646710BCF518C1B878F1D5FF5396
CBD2ED27213AC1CCD5B823CD6A4172F94FDDC778254D2625E646CE726A5298B0
5A57E1CF41808AD7B92B3792FA609E86209486B3CFFA939A4FBE92BB9BFDBDE2
C725823EE5D252EC9D6E9C1B570794D2802E4D36409B4D5E17600E2C57F585DA
96CC86D0EA3117D2C7357B4376D774157D11F8A9A4147F2893AEAD7C19A0E280
A2C3B8DF12F300700FD18931D15E00E4726E092EB7BE3084D2BA2D4C24426A00
39E0F1FFF09FB422A9465BBB3A56AAFAD875F8B1D7A0AA2A59994DD1BAA72C2B
7167D4F31E4B99A2F2D4B77784A6FDDBD135F734AFFD732DD2BB4E0BFBEE0F5A
0AE264B8826119AA49F3E062059F245ADD46BBA563FD5C77D7DCDD24DE122BA6
37CB0B56226A18326745E2671BB52F23D804C49181CA97AB79D00D61E46A1EE1
8BFA4AEBBCFD53C30FDFACF1DD5D3FA85857B11B9A9D5FBF66F710613A860B11
8675A8067167FBEF0A26AEFD062073633C7126AD5787F9281F6F4B4A86855063
934C57240DF8F67B12BB484BA96C0D3A378727FEEFDA1E48EC8EECDE8B8CA5B8
400517DBAFCB5718012E0F3F6C528F6A5D715DB8F3C692932FD6EA74C98D4D6C
24DC956BE04FA16980021AAAF5787B986A028EDAB0856CCA3DF52B4D11FAC160
ECC414A478079836762434EB1D5B5E95EF13A51541002A07986298A2213CDD9D
3F3C1DC11E21EC1BD17E0AAFA78790EAB9505C5D56BD96816547877EB1F3A75D
B5C19723DD62E7C363134DA775669445A71FC40E121B4A0343FE3205B4082DC1
A02E92625E32FDAAE3376654A6C0184E6D9FEAB2BE6324D7AE0C60213044485E
27DE3A79E17CF3756F137A2345B8793F48CA8E9FA6A5976D8C1590B3465A5ABE
03C9C0DAD6CB603FAAB9E5ECE5A08EDFF0DCFF480AA0767B6C82F2E8F52B374C
BEED08FCC64C08527EB5C22F2928DDF777EB9AB32CDA858D5580B80C4B193774
D24BF2F6C832E7E0A1624489047D8A12A49AD70A6FCD1A9EDCD1749AE9931196
CF49F2DE4D68F30A6820DFFF594282DEF1BD64342906892912ACE3939E436910
9C495F535D726FD142B1A2B45114244D0019708494E74A11ACA54D221B76C971
58A7C9012C988AFC8209AFC9007825B5017013CFCFE0C602A2F6E4C580ADD685
C4084018D9DC8E89EDB78EF4490460DADD5DED7943C4C29881B54E0DBE1306FC
A31FCE73EFF9E3A63CAFAA5521DB983D8EF5CF20FEB85CA219C07FA4B4D43929
75CF8D244C6109DC8D2C91F3BB659BAF650E7B1EDDDD207C161F74CF2E7E02AB
C3C63FE8A7C65B29FBAD3F9398D68A454F9507CF58CE2989A336A0004F25CA8E
D03837B4CE52B16E08C53CB0DA138A442BD8B84473B3842EDE518B53559A85F8
982A7111E96E941651E32632AA1DE6AF3DD20EB86C80F967777035850291C489
4450AA5E3416BCE3E21FCEEF31A4E7A39AB615F95122B1939A219CEEA8935204
8242AC3154FB38666AB7955B60BC8F2D7B997EF8ABACF7A91F40265B742792BB
8E39E92B6F7C3A4F49CAE9A6F02B5D366B6614096E439D76990019363F75DEF3
5CA42E74B196E901B0EEECD4D817E396C6A4AC7739C68CFA097CCF7B2FC2F7BB
374956D581BA4694B96B46A4357B1351919F4846E1BF724CDF871B388CD929C3
7654177501453CD3FE07B150D25BFB1B293B8FF60859990DB09837DD0C5CF093
E4F4D938E360B080AE93B011B77B6E0088B5786E7BF0C04BA17683B3DA4E8898
D1AE964AC2E842EE215B4FD0106D44FEBCC53DD29286B1BF089BD9EF487733FA
E13B1ACEE58FAB47BB34760D90CB34424570C583273BB54A16ACA135C098FEC0
0439A7362D8D251390472D3D09D9DB48EB4F2B9DEA8E827279E50779C1124C76
14B20E0921297BA0CE276A8B921821A621EF579704D314E2FCDD72756F06AD28
984A91F91DFB578D42DDFB5BB14271E7C33FD375E5C75D84C24BA294765D1897
49B5BF650E5965E3999EE5A42BC4773F93E7972AEEACC0F30A394F09F57F1AA1
FB010E66C054048641097090DDB95380CF8B60E941AC5072AB64F8B3A38F6684
D7361DA53A87793CD6C5C0F7B123089A4516592E36D0A04886B2ADF15A7EB42F
9834799128DF19C5B1D5CCDA05007827D33F516394E52711EC27C8B919F85B14
ACC1C3BBBEF636BF3651DA99E3E29264D1AD18B438A84377451087E1775AEC1E
866D96C05E093E5C52591E70531636F0D07A9E3331E55AD3E6D262F980CD00B5
94A3D6D3FC84206EC083A5444C0799B8DF965187C04AB7DB52E75940C32DCC2D
4CB6D0709C64EF4B18A1CA23D87666285080EB26C8015C34B3A458087051EEAE
04EB142AED252FE3576999AA81B89425BF9F552145CDB98B89609D5C5E1C2153
B8C045927A179E90B7CBC419F03DAFCE599847B993F325AD24664C9C85E9E781
0D16B5026B7772AC32D65F2C2BE666AA649B0B8ACAE4E4A7DD9DB73AEEA11627
318A206241A81D7DC2602DD72AA799F16DCAAA3AB4306792975508AD0EB64340
6E39A7A9E5DBC14952538EDAE9D993E38F6EF802A4B20619F576486910E82BC5
5C7772A8249F27CDC3A117FC67F72EFFC479F8ABA69BF0EDBBCE3104557C4B67
A42FB43B660C1B9C8F9C772CC12FCAF55DF263A042A24517E3FA8C18B01DF36A
DA057A4A437A67CED2D131A6FDD7D9A6D9958383DD28493C2BFE3AC76B49F830
1EF9DAFCA34F24DD78E10AE64F7278D2F354B788F6FF83E5CDDD6F7663A7819D
5B975AB5AED879A966226ED9B7B7EB402739A64984A58026CD1B7901A443AA10
A23CF2B9C920DDF7855234C085D7797ED49F0974956DB4D6424A4488224F83C4
AE55055A2A7B6C9E12FF1D4C120BEDECDC9F3285AA1B08682B55E80C86DCF3A0
568012C5E2FE509C6EE2731E11869C312F73D277F0F536E22C8269776D6AD3CC
E109164B15BE45968780DBB3EA722F64E949749AF14D6088DCD607C5752DB855
A9AA0C6C0F8EB25F5BC008A66C98E71925F84250D5CB460EA2129CD9755AA35A
CBC49A24D859B5E57DB326746874C5B678F167552792B306F6B30C4C2AC649E9
C3A64233BDD77832D74811950A351E0AEE37AC467F95F4B6AD62E4DB890D247E
34570B5FFA2A7CE92E2AE80570E57D2743B0BED5DB25CC762D8FB2F63B3AF472
0D24013A437A1CDD4207648DC184F1FE9DD9916AF5BE4F532CC9207BC8C840F9
F6FB8F555882181EDA9424C10593278E2E068C7625F96EF6E593A8A0446F70C3
B9EA7A6F4DC49597A3F76B80AEFE672E33B7AC27F9BA8734CF7C1323D614E2B0
76B4B14A53192A4B5EF02ED9FC3F67A1F45A9AB4FADB68ED9F075A9D987A1D31
CD917EA599B2ACD72A8EABBCF25A9DA6267985C0DD3D3BD342F158A278B28622
EB67F3DF68A0579C8C5242D0072F6A08183F44A448399718AF6AF7DFA9D16404
49889A37B94D768AC3851A4B56313EFE0437675D0DAE4596EE2A045EF0372CB5
A657F2345657DAC906624BA2EB9EA6050D37F3934B41180BC8642CB7BCB05C4A
A8CC64134354A7369BF0EECE12F55CEB0ED8DD92707FD80A953019BBAC7BA212
7E170E1A9156AC8DEF860993D01B4A00769DE6A8C66E9699D25DC2A217A99066
5B1ADB350A419AD3D951C6F562B37FF58688A8C5664F66B1717EBE66E31BC128
92444BFE74E1A5E41E73816C2C409EADDC28263122F142C14C7DA6A966AA6B09
5979F9481B77188C1D5B23B50A2306D0B79F4F553DF4CB7F8810B67AF11EFC36
160673FDF8BD0E2480DB8FAEC234949CED66EE890B4AE9EA4132FC3FDCE87CC1
F21E2D1DA43D88EC35CEAEAA80A1D221A060DBB0A23C58B473F2546626C680F4
4041D8F618DB4148B72303AC495FCFCFDDE5197961D96E3A6F29F55D2653006F
5E57E0DDD2E7BC2DF29F72C64CB020BAC5C37BA7B264D78EC689E4A84240222E
C89437BD7836A958433854E1CF3849955901ED300860A424F0D7B36410BDFC42
5A4012CAD5037ACDD541D2682D15D685141AD240A70B44BC458C8347AACF2DA4
C53B76C4375301EC04F2AAF36FC9527AB11CFDFAFB70FC66FEBDBE712B4138EB
A25D9D76D780470D9B83B4582FC7B69DAF8A0FF9A64A713E9DFD6CDCB492CD1B
70F850F351D6ABF4D978F008A50D662A91F6E1ECF8B5607E913C1996A8560EC0
4A5A26AF2FB1A86026887ABA3D947174F76538DB77DAE7CB0A9B38E30151707A
7A72A38082B287C06D7A560A891767DD65025DCC0E7A1DD41239B49C1EA4E584
510D3314ED4249BC643F005664E94665607F524AF57C44BA3F1B4405D10108FE
5A593095D4F6D267710117DDED5FFBF8F11037E43D5D74A7E2BB44ACDBCB0325
01203FA682850075D6E17872F84DEACA1975FFC8165DA9B84430072108CA2F51
111ABD537F13844E45B0911944B60E20415F15AED00939779DAAFC98A975F533
3C40F2B0085FB06BEEFF171C048A2964FF61ACAA94028972D5DCFC3639D6561C
B1B64F8EC2B23C1C8FCBF3F5E13E8A6973CF55D0135337
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
%%EndFont 
TeXDict begin 39158274 55380987 1000 600 600 (essai_psframebox.dvi)
@start /Fa 94[49 161[{}1 68.7422 /Fourier-Math-Symbols
rf /Fb 135[35 120[{ TeXBase1Encoding ReEncodeFont }1
68.7422 /Utopia-Italic rf /Fd 138[42 24 30 27 1[42 40
43 4[20 1[36 1[35 41 48[36 36 50[{ TeXBase1Encoding ReEncodeFont }13
68.7422 /Utopia-Regular rf /Fe 152[29 18 102[{
 TeXBase1Encoding ReEncodeFont }2 58.049 /Utopia-Italic
rf /Fg 188[55 67[{}1 83.022 /rsfs10 rf /Fh 204[32 32
32 32 48[{ TeXBase1Encoding ReEncodeFont }4 61.1042 /Utopia-Regular
rf /Fi 94[44 161[{}1 61.1042 /Fourier-Math-Symbols rf
/Fj 58[55 12[55 55 21[55 69[55 41[78 49[{}6 76.3802
/Fourier-Math-Symbols rf /Fl 173[66 82[{}1 83.022 /dsrom10
rf /Fm 22[39 8[40 103[37 2[46 26 33 30 45 46 44 47 70
21 2[22 46 40 24 39 46 38 46 40 3[25 1[25 6[47 1[49 2[58
2[43 2[27 2[44 10[20 20 4[40 40 40 40 40 40 1[20 30 3[27
27 21 39[{ TeXBase1Encoding ReEncodeFont }43 76.3802
/Utopia-Regular rf /Fn 79[30 125[43 43 7[28 41[{
 TeXBase1Encoding ReEncodeFont }4 76.3802 /Utopia-Bold
rf /Fo 135[39 4[30 2[45 2[70 23 4[38 24 35 31[46 10[20
58[{ TeXBase1Encoding ReEncodeFont }10 76.3802 /Utopia-Italic
rf /Fp 182[42 2[65 11[31 7[62 50[{ TeXBase1Encoding ReEncodeFont }4
109.987 /Utopia-Bold rf /Fq 54[55 115[69 55 49 1[68 1[68
65 4[34 71 2[55 1[61 1[57 65[{ TeXBase1Encoding ReEncodeFont }12
87.9899 /Utopia-Bold rf end
%%EndProlog
%%BeginSetup
%%Feature: *Resolution 600dpi
TeXDict begin
%%BeginPaperSize: a4
/setpagedevice where
{ pop << /PageSize [595 842] >> setpagedevice }
{ /a4 where { pop a4 } if }
ifelse
%%EndPaperSize
 end
%%EndSetup
%%Page: 1 1
TeXDict begin 1 0 bop 0 0 a
SDict begin [/Producer (dvips + Distiller)/Title ()/Subject ()/Creator
(LaTeX with hyperref package)/Author ()/Keywords () /DOCINFO pdfmark
end
 0 0 a 0 0 a
SDict begin /product where{pop product(Distiller)search{pop pop pop
version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
grestore}if}{pop}ifelse}{pop}ifelse}if end
 0 0 a 0 TeXcolorgray
-254 -504 a
SDict begin H.S end
 -254 -504 a -254 -504 a
SDict begin H.R end
 -254 -504 a -254
-504 a
SDict begin [/View [/XYZ H.V]/Dest (page.1) cvn /DEST pdfmark end
 -254 -504 a Black 0 TeXcolorgray Black 0 TeXcolorgray
-246 -246 a
 /pssetRGBcolor /setrgbcolor load def /pssetCMYKcolor /setcmykcolor
load def /pssetGraycolor /setgray load def
 -246 -246 a -246 -246 a
tx@Dict begin  gsave STV CP T /ps@rot 0 def grestore  end
 -246 -246 a -246
-246 a
tx@Dict begin  gsave STV CP T /ps@refangle 0.  def grestore  end
 -246 -246 a -246 -246 a
tx@Dict begin  gsave STV CP T /ps@rot 0 def grestore  end
 -246 -246 a -246 -246
a
SDict begin [/PageMode /UseOutlines/Page 1/View [/Fit] /DOCVIEW pdfmark
end
 -246 -246 a -246 -246 a
SDict begin [ {Catalog}<<>> /PUT pdfmark end
 -246 -246 a -246 -246 a
SDict begin H.S end
 -246
-246 a -246 -246 a
SDict begin 12 H.A end
 -246 -246 a -246 -246 a
SDict begin [/View [/XYZ H.V]/Dest (Doc-Start) cvn /DEST pdfmark end
 -246 -246
a 1906 -57 a

 1906 -57 a 1906 -57 a


 pgfo

 save

 0 setgray

 0.3985 pgfw

 save

 save

 /pgfsc{}def/pgffc{}def

 0 0 1 setrgbcolor

 /pgffc{1 setgray}def

 save

 /pgfsc{}def/pgffc{}def

 0 0 1 setrgbcolor

 /pgffc{1 setgray}def

 253.06212 22.41841 moveto

 -253.06212 22.41841 lineto

 -255.8133 22.41841 -258.0435 20.1882 -258.0435 17.43703 curveto

 -258.0435 -17.43703 lineto

 -258.0435 -20.1882 -255.8133 -22.41841 -253.06212 -22.41841 curveto

 253.06212 -22.41841 lineto

 255.8133 -22.41841 258.0435 -20.1882 258.0435 -17.43703 curveto

 258.0435 17.43703 lineto

 258.0435 20.1882 255.8133 22.41841 253.06212 22.41841 curveto

 closepath

 -258.0435 -22.41841 moveto

 gsave pgffc pgffill grestore gsave pgfsc pgfstr grestore

 newpath

 restore

 save

 [1.0 0.0 0.0 1.0 -255.1214 -2.58035 ] concat

 pgfs



 0 0 1 setrgbcolor
 0 TeXcolorgray 0 TeXcolorgray
0 0 1 TeXcolorrgb 3802 -90 a Fp(F)6 b Fq(I)g(C)g(H)g(E)29
b Fp(2)g(:)p 0 TeXcolorgray 0 0 1 TeXcolorrgb 3686 9
a(I)6 b Fq(N)g(\311)g(Q)t(U)r(A)q(T)g(I)g(O)g(N)g(S)p
0 TeXcolorgray 1906 -57 a


 pgfr

 restore

 restore

 restore

 newpath

 restore

 pgfc


 -248 402 a

 -248 402 a -248
402 a


 pgfo

 save

 0 setgray

 0.3985 pgfw

 save

 save

 /pgffc{0 0 0.3 0 setcmykcolor}def

 save

 /pgffc{0 0 0.3 0 setcmykcolor}def

 47.17963 15.05972 moveto

 2.1918 15.05972 lineto

 1.09132 15.05972 0.19925 14.16765 0.19925 13.06717 curveto

 0.19925 2.1918 lineto

 0.19925 1.09132 1.09132 0.19925 2.1918 0.19925 curveto

 47.17963 0.19925 lineto

 48.28009 0.19925 49.17218 1.09132 49.17218 2.1918 curveto

 49.17218 13.06717 lineto

 49.17218 14.16765 48.28009 15.05972 47.17963 15.05972 curveto

 closepath

 0.19925 0.19925 moveto

 gsave pgffc pgffill grestore newpath

 restore

 save

 [1.0 0.0 0.0 1.0 3.12134 5.28822 ] concat

 pgfs



 0 setgray
 -248 402 a Fo(Exemples)17 b(:)-248 402 y


 pgfr

 restore

 restore

 save

 /pgffc{0 0 0.3 0 setcmykcolor}def

 save

 /pgffc{0 0 0.3 0 setcmykcolor}def

 514.2937 -0.19925 moveto

 2.1918 -0.19925 lineto

 1.09132 -0.19925 0.19925 -1.09132 0.19925 -2.1918 curveto

 0.19925 -240.31888 lineto

 0.19925 -241.41934 1.09132 -242.31143 2.1918 -242.31143 curveto

 514.2937 -242.31143 lineto

 515.39417 -242.31143 516.28625 -241.41934 516.28625 -240.31888 curveto

 516.28625 -2.1918 lineto

 516.28625 -1.09132 515.39417 -0.19925 514.2937 -0.19925 curveto

 closepath

 0.19925 -242.31143 moveto

 gsave pgffc pgffill grestore newpath

 restore

 save

 [1.0 0.0 0.0 1.0 3.12134 -123.8357 ] concat

 pgfs



 0 setgray
 -248 -504
a
SDict begin H.S end
 -248 -504 a -248 -504 a
SDict begin 12 H.A end
 -248 -504 a -248 -504 a
SDict begin [/View [/XYZ H.V]/Dest (Item.1) cvn /DEST pdfmark end
 -248
-504 a 0 TeXcolorgray -182 -421 a Fn(1\260\))p 0 TeXcolorgray
41 w Fm(R\351soudr)o(e)h(sur)f Fl(R)25 b Fo(f)19 b Fm(\()r
Fo(x)5 b Fm(\))14 b Fj(\270)g(\241)p Fm(1)p 0 TeXcolorgray
0 TeXcolorgray 816 137 a

 816 137 a 816 137 a


 pgfo

 save

 0 setgray

 0.3985 pgfw

 save

 1 setlinecap

 1 setlinejoin

 save

 /pgfsc{}def/pgffc{}def

 0 setgray

 [ 1.99255 1.99255 ] 0.0 setdash

 -59.52802 -69.44937 moveto

 -59.52802 -69.4491 moveto

 79.37071 -69.4491 lineto

 -59.52802 -55.55927 moveto

 79.37071 -55.55927 lineto

 -59.52802 -41.66945 moveto

 79.37071 -41.66945 lineto

 -59.52802 -27.77963 moveto

 79.37071 -27.77963 lineto

 -59.52802 -13.88982 moveto

 79.37071 -13.88982 lineto

 -59.52802 0.0 moveto

 79.37071 0.0 lineto

 -59.52802 13.88982 moveto

 79.37071 13.88982 lineto

 -59.52802 27.77963 moveto

 79.37071 27.77963 lineto

 -59.52802 41.66945 moveto

 79.37071 41.66945 lineto

 -55.55927 -69.44937 moveto

 -55.55927 49.60667 lineto

 -41.66945 -69.44937 moveto

 -41.66945 49.60667 lineto

 -27.77963 -69.44937 moveto

 -27.77963 49.60667 lineto

 -13.88982 -69.44937 moveto

 -13.88982 49.60667 lineto

 0.0 -69.44937 moveto

 0.0 49.60667 lineto

 13.88982 -69.44937 moveto

 13.88982 49.60667 lineto

 27.77963 -69.44937 moveto

 27.77963 49.60667 lineto

 41.66945 -69.44937 moveto

 41.66945 49.60667 lineto

 55.55927 -69.44937 moveto

 55.55927 49.60667 lineto

 69.4491 -69.44937 moveto

 69.4491 49.60667 lineto

 pgfstr

 restore

 save

 /pgfsc{}def/pgffc{}def

 0 setgray

 -59.52802 0.0 moveto

 78.56177 0.0 lineto

 pgfstr

 save

 [1.0 0.0 0.0 1.0 78.56177 0.0 ] concat

 save [ ] 0.0 setdash 0 setlinejoin -5.20348 2.3356 moveto 0.29886
0.0 lineto -5.20348 -2.3356 lineto closepath gsave pgffc pgffill grestore
gsave pgfsc pgfstr grestore newpath restore

 restore

 restore

 save

 /pgfsc{}def/pgffc{}def

 0 setgray

 -39.68535 1.39478 moveto

 -39.68535 -1.39478 lineto

 pgfstr

 save

 save

 [1.0 0.0 0.0 1.0 -44.26822 -9.42575 ] concat

 pgfs



 0 setgray
 816 137
a Fi(\241)p Fh(2)816 137 y


 pgfr

 restore

 restore

 restore

 save

 /pgfsc{}def/pgffc{}def

 0 setgray

 -19.84267 1.39478 moveto

 -19.84267 -1.39478 lineto

 pgfstr

 save

 save

 [1.0 0.0 0.0 1.0 -24.42552 -9.42575 ] concat

 pgfs



 0 setgray
 816 137 a Fi(\241)p Fh(1)816
137 y


 pgfr

 restore

 restore

 restore

 save

 /pgfsc{}def/pgffc{}def

 0 setgray

 19.84267 1.39478 moveto

 19.84267 -1.39478 lineto

 pgfstr

 save

 save

 [1.0 0.0 0.0 1.0 17.89793 -9.42575 ] concat

 pgfs



 0 setgray
 816 137 a Fh(1)816 137 y


 pgfr

 restore

 restore

 restore

 save

 /pgfsc{}def/pgffc{}def

 0 setgray

 39.68535 1.39478 moveto

 39.68535 -1.39478 lineto

 pgfstr

 save

 save

 [1.0 0.0 0.0 1.0 37.74062 -9.42575 ] concat

 pgfs



 0 setgray
 816 137 a Fh(2)816 137
y


 pgfr

 restore

 restore

 restore

 save

 /pgfsc{}def/pgffc{}def

 0 setgray

 59.52802 1.39478 moveto

 59.52802 -1.39478 lineto

 pgfstr

 save

 save

 [1.0 0.0 0.0 1.0 57.5833 -9.42577 ] concat

 pgfs



 0 setgray
 816 137 a Fh(3)816 137 y


 pgfr

 restore

 restore

 restore

 save

 /pgfsc{}def/pgffc{}def

 0 setgray

 0.0 -69.44937 moveto

 0.0 48.79773 lineto

 pgfstr

 save

 [0.0 1.0 -1.0 0.0 0.0 48.79773 ] concat

 save [ ] 0.0 setdash 0 setlinejoin -5.20348 2.3356 moveto 0.29886
0.0 lineto -5.20348 -2.3356 lineto closepath gsave pgffc pgffill grestore
gsave pgfsc pgfstr grestore newpath restore

 restore

 restore

 save

 /pgfsc{}def/pgffc{}def

 0 setgray

 1.39478 -59.52802 moveto

 -1.39478 -59.52802 lineto

 pgfstr

 save

 save

 [1.0 0.0 0.0 1.0 -13.68185 -61.96292 ] concat

 pgfs



 0 setgray
 816 137 a Fi(\241)p Fh(3)816
137 y


 pgfr

 restore

 restore

 restore

 save

 /pgfsc{}def/pgffc{}def

 0 setgray

 1.39478 -39.68535 moveto

 -1.39478 -39.68535 lineto

 pgfstr

 save

 save

 [1.0 0.0 0.0 1.0 -13.68185 -42.14017 ] concat

 pgfs



 0 setgray
 816 137 a Fi(\241)p Fh(2)816 137 y


 pgfr

 restore

 restore

 restore

 save

 /pgfsc{}def/pgffc{}def

 0 setgray

 1.39478 -19.84267 moveto

 -1.39478 -19.84267 lineto

 pgfstr

 save

 save

 [1.0 0.0 0.0 1.0 -13.68185 -22.29749 ] concat

 pgfs



 0 setgray
 816 137 a Fi(\241)p
Fh(1)816 137 y


 pgfr

 restore

 restore

 restore

 save

 /pgfsc{}def/pgffc{}def

 0 setgray

 1.39478 19.84267 moveto

 -1.39478 19.84267 lineto

 pgfstr

 save

 save

 [1.0 0.0 0.0 1.0 -8.40558 17.38785 ] concat

 pgfs



 0 setgray
 816 137 a Fh(1)816 137 y


 pgfr

 restore

 restore

 restore

 save

 /pgfsc{}def/pgffc{}def

 0 setgray

 1.39478 39.68535 moveto

 -1.39478 39.68535 lineto

 pgfstr

 save

 save

 [1.0 0.0 0.0 1.0 -8.40558 37.23053 ] concat

 pgfs



 0 setgray
 816 137 a Fh(2)816
137 y


 pgfr

 restore

 restore

 restore

 save

 /pgfsc{}def/pgffc{}def

 0 setgray

 0.0 -6.9739 moveto

 pgfstr

 save

 save

 [1.0 0.0 0.0 1.0 3.12134 -9.4088 ] concat

 pgfs



 0 setgray
 816 137 a Fh(0)816 137 y


 pgfr

 restore

 restore

 restore

 -59.52802 -69.44937 moveto

 -59.52802 -67.45682 moveto

 -59.52802 47.61412 lineto

 -59.52802 48.7146 -58.63594 49.60667 -57.53546 49.60667 curveto

 77.37816 49.60667 lineto

 78.47862 49.60667 79.37071 48.7146 79.37071 47.61412 curveto

 79.37071 -67.45682 lineto

 79.37071 -68.55728 78.47862 -69.44937 77.37816 -69.44937 curveto

 -57.53546 -69.44937 lineto

 -58.63594 -69.44937 -59.52802 -68.55728 -59.52802 -67.45682 curveto

 closepath

 79.37071 49.60667 moveto

 clip

 newpath

 -55.95316 -555.02248 moveto

 -55.95316 -555.02248 -54.71739 -522.75705 -54.32169 -512.7793 curveto

 -54.2781 -511.67932 -54.20741 -509.89592 -54.16383 -508.79594 curveto

 -53.76816 -498.81819 -53.007 -480.12056 -52.6155 -470.74612 curveto

 -52.56963 -469.64653 -52.4952 -467.86377 -52.44931 -466.76418 curveto

 -52.05779 -457.38972 -51.29663 -439.64914 -50.90967 -430.86456 curveto

 -50.86127 -429.76497 -50.78276 -427.98221 -50.73436 -426.88261 curveto

 -50.34741 -418.09802 -49.58626 -401.29216 -49.20425 -393.08336 curveto

 -49.1531 -391.98376 -49.07018 -390.201 -49.01903 -389.10141 curveto

 -48.63704 -380.8926 -47.87587 -364.99878 -47.49925 -357.35164 curveto

 -47.44514 -356.25204 -47.35738 -354.46928 -47.30324 -353.36969 curveto

 -46.92665 -345.72255 -46.16551 -330.71825 -45.79475 -323.61761 curveto

 -45.7374 -322.51852 -45.6444 -320.73657 -45.58704 -319.63748 curveto

 -45.21626 -312.53688 -44.45512 -298.39851 -44.09084 -291.83138 curveto

 -44.0299 -290.73228 -43.93109 -288.95033 -43.87016 -287.85124 curveto

 -43.50589 -281.2841 -42.74475 -267.99103 -42.38762 -261.9432 curveto

 -42.32274 -260.84412 -42.21754 -259.06216 -42.15266 -257.96307 curveto

 -41.79552 -251.91525 -41.03438 -239.4426 -40.68504 -233.89876 curveto

 -40.61586 -232.80028 -40.50365 -231.0193 -40.43446 -229.92082 curveto

 -40.08514 -224.377 -39.32399 -212.70357 -38.98343 -207.65086 curveto

 -38.9094 -206.55238 -38.78937 -204.77142 -38.71533 -203.67294 curveto

 -38.37476 -198.62022 -37.6136 -187.72308 -37.28267 -183.14597 curveto

 -37.20332 -182.0482 -37.07468 -180.26842 -36.99535 -179.17064 curveto

 -36.66438 -174.59352 -35.90323 -164.44934 -35.58319 -160.33517 curveto

 -35.49783 -159.2374 -35.3594 -157.45761 -35.27403 -156.35985 curveto

 -34.95401 -152.24567 -34.19286 -142.83337 -33.885 -139.16669 curveto

 -33.79291 -138.06973 -33.6436 -136.29124 -33.55151 -135.19429 curveto

 -33.24364 -131.52762 -32.48248 -122.82379 -32.18831 -119.58998 curveto

 -32.08867 -118.49396 -31.92706 -116.71696 -31.82742 -115.62094 curveto

 -31.53325 -112.38713 -30.77211 -104.36824 -30.49377 -101.55489 curveto

 -30.38538 -100.45885 -30.20961 -98.68185 -30.1012 -97.58583 curveto

 -29.82289 -94.77246 -29.06172 -87.41684 -28.80135 -85.00815 curveto

 -28.68304 -83.91316 -28.4912 -82.13785 -28.3729 -81.04286 curveto

 -28.11249 -78.63417 -27.35135 -71.91957 -27.11179 -69.90126 curveto

 -26.98198 -68.8074 -26.7715 -67.0339 -26.6417 -65.94005 curveto

 -26.40211 -63.92172 -25.64098 -57.82469 -25.42537 -56.17993 curveto

 -25.28233 -55.08867 -25.05038 -53.31937 -24.90736 -52.22809 curveto

 -24.69174 -50.58334 -23.9306 -45.08195 -23.74355 -43.79866 curveto

 -23.58473 -42.70883 -23.32722 -40.94186 -23.1684 -39.85204 curveto

 -22.98137 -38.56874 -22.22023 -33.63911 -22.06685 -32.7001 curveto

 -21.88943 -31.61346 -21.60178 -29.85167 -21.42435 -28.76505 curveto

 -21.27098 -27.82603 -20.50983 -23.4475 -20.39728 -22.83797 curveto

 -20.19733 -21.75491 -19.87312 -19.99898 -19.67317 -18.91592 curveto

 -19.56061 -18.30638 -18.79945 -14.45456 -18.73637 -14.15578 curveto

 -18.5091 -13.0788 -18.14061 -11.3327 -17.91333 -10.25574 curveto

 -17.85023 -9.95695 -17.08908 -6.61017 -17.08818 -6.60658 curveto

 -16.82655 -5.53653 -16.40236 -3.8016 -16.14073 -2.73155 curveto

 -16.13986 -2.72798 -15.37871 0.1368 -15.45683 -0.13452 curveto

 -15.15157 0.92519 -14.65662 2.64328 -14.35135 3.703 curveto

 -14.42949 3.43167 -13.66832 5.83665 -13.84825 5.31802 curveto

 -13.48676 6.35992 -12.90065 8.04913 -12.53915 9.09103 curveto

 -12.71909 8.57239 -11.95796 10.54033 -12.27129 9.81242 curveto

 -11.83612 10.82338 -11.13057 12.46242 -10.69542 13.47337 curveto

 -11.00873 12.74547 -10.24757 14.29988 -10.74641 13.40526 curveto

 -10.20879 14.36949 -9.33713 15.9328 -8.79948 16.89703 curveto

 -9.29834 16.00243 -8.5372 17.16429 -9.28279 16.19962 curveto

 -8.60889 17.07152 -7.51628 18.48515 -6.84236 19.35707 curveto

 -7.58797 18.3924 -6.82683 19.1858 -7.89297 18.30725 curveto

 -7.04204 19.00842 -5.66237 20.14522 -4.81142 20.84634 curveto

 -5.8776 19.96783 -5.11644 20.4146 -6.50443 19.88232 curveto

 -5.47572 20.27678 -3.80792 20.91635 -2.77922 21.31079 curveto

 -4.16722 20.77855 -3.40607 20.90138 -4.92361 20.9427 curveto

 -3.82336 20.91275 -2.03954 20.86417 -0.93929 20.83423 curveto

 -2.45683 20.87552 -1.69568 20.69693 -3.0711 21.25809 curveto

 -2.04936 20.84123 -0.39276 20.16539 0.62897 19.74854 curveto

 -0.74646 20.3097 0.01465 19.85323 -1.10477 20.70313 curveto

 -0.2244 20.03477 1.20294 18.95117 2.08331 18.28285 curveto

 0.96387 19.1327 1.72504 18.41956 0.84232 19.37311 curveto

 1.59195 18.56323 2.80722 17.25021 3.55669 16.44034 curveto

 2.67427 17.39388 3.4354 16.44794 2.73158 17.41368 curveto

 3.38242 16.52061 4.43762 15.07272 5.08844 14.17967 curveto

 4.38464 15.1454 5.14578 13.98854 4.5796 14.91383 curveto

 5.15442 13.97437 6.08638 12.45122 6.66121 11.51175 curveto

 6.09502 12.43706 6.85616 11.09152 6.38754 11.9662 curveto

 6.90848 10.99385 7.75308 9.4174 8.27402 8.44505 curveto

 7.80539 9.31973 8.56653 7.80983 8.17294 8.62418 curveto

 8.65244 7.63208 9.42986 6.02362 9.90935 5.03152 curveto

 9.51576 5.84589 10.27692 4.19235 9.93802 4.95207 curveto

 10.38731 3.9448 11.11574 2.3117 11.56502 1.30444 curveto

 11.22614 2.06416 11.9873 0.29051 11.68892 1.0022 curveto

 12.11581 -0.01599 12.808 -1.6668 13.23492 -2.685 curveto

 12.93652 -1.97333 13.69768 -3.8442 13.43184 -3.17998 curveto

 13.84079 -4.2017 14.5038 -5.85828 14.91272 -6.88002 curveto

 14.6469 -6.21577 15.40805 -8.16228 15.16138 -7.5252 curveto

 15.55974 -8.55392 16.2056 -10.22173 16.60396 -11.25043 curveto

 16.35727 -10.61337 17.11842 -12.61177 16.88411 -11.9941 curveto

 17.27563 -13.02618 17.91045 -14.6995 18.30197 -15.7316 curveto

 18.06767 -15.11394 18.8288 -17.14218 18.6009 -16.53603 curveto

 18.98889 -17.56812 19.61794 -19.24142 20.0059 -20.27351 curveto

 19.77803 -19.66737 20.53918 -21.70273 20.30988 -21.09401 curveto

 20.69864 -22.12611 21.32896 -23.79942 21.71774 -24.83151 curveto

 21.48842 -24.2228 22.24956 -26.24295 22.0131 -25.62361 curveto

 22.4058 -26.65231 23.0425 -28.32013 23.43517 -29.34883 curveto

 23.19879 -28.72949 23.95993 -30.71092 23.70787 -30.06702 curveto

 24.1092 -31.09227 24.7599 -32.75452 25.16121 -33.77975 curveto

 24.90916 -33.13586 25.67032 -35.05736 25.39287 -34.37491 curveto

 25.80821 -35.39664 26.48163 -37.0532 26.89696 -38.07494 curveto

 26.61954 -37.39249 27.38069 -39.22998 27.0687 -38.50133 curveto

 27.50313 -39.51595 28.20747 -41.16092 28.64189 -42.17552 curveto

 28.32991 -41.44688 29.09106 -43.17859 28.73271 -42.39688 curveto

 29.19275 -43.40042 29.9386 -45.02747 30.39864 -46.031 curveto

 30.04028 -45.2493 30.80145 -46.85248 30.38397 -46.01843 curveto

 30.87665 -47.00272 31.67548 -48.59853 32.16817 -49.58281 curveto

 31.75067 -48.74876 32.51183 -50.2008 32.01193 -49.3091 curveto

 32.55016 -50.26926 33.42273 -51.82594 33.96092 -52.7861 curveto

 33.46104 -51.89438 34.2222 -53.17236 33.6076 -52.2254 curveto

 34.20915 -53.15228 35.18446 -54.65506 35.78601 -55.58194 curveto

 35.17143 -54.63496 35.93257 -55.71652 35.16805 -54.74718 curveto

 35.85242 -55.6149 36.96198 -57.02171 37.64633 -57.88943 curveto

 36.88182 -56.92007 37.64294 -57.78273 36.68016 -56.85306 curveto

 37.47403 -57.61957 38.76111 -58.86227 39.55498 -59.62875 curveto

 38.59218 -58.69911 39.35333 -59.3203 38.14207 -58.55359 curveto

 39.07317 -59.14293 40.58272 -60.0984 41.51381 -60.6877 curveto

 40.30257 -59.92104 41.06372 -60.27731 39.61465 -59.88507 curveto

 40.67708 -60.17265 42.39955 -60.63889 43.46198 -60.92647 curveto

 42.01294 -60.53423 42.7741 -60.60403 41.27036 -60.78609 curveto

 42.36298 -60.65382 44.13443 -60.43932 45.22707 -60.30705 curveto

 43.72331 -60.4891 44.48447 -60.24922 43.20584 -60.94344 curveto

 44.17413 -60.41772 45.74403 -59.56541 46.71233 -59.03972 curveto

 45.43369 -59.73393 46.19484 -59.16144 45.25345 -60.09743 curveto

 46.03549 -59.31992 47.30342 -58.05936 48.08546 -57.28186 curveto

 47.14407 -58.21783 47.90521 -57.29118 47.25754 -58.24644 curveto

 47.87737 -57.33221 48.8823 -55.84999 49.5021 -54.93576 curveto

 48.85443 -55.89102 49.6156 -54.58638 49.19272 -55.42607 curveto

 49.68839 -54.44179 50.49203 -52.84598 50.98773 -51.8617 curveto

 50.56483 -52.7014 51.32597 -50.99734 51.06573 -51.65472 curveto

 51.47157 -50.62947 52.1296 -48.96722 52.53543 -47.94197 curveto

 52.2752 -48.59935 53.03635 -46.47203 52.89809 -46.90013 curveto

 53.23657 -45.85204 53.78535 -44.15273 54.12383 -43.10463 curveto

 53.98558 -43.53273 54.74673 -40.96036 54.70099 -41.1297 curveto

 54.98836 -40.06729 55.45433 -38.3448 55.74174 -37.2824 curveto

 55.69597 -37.45174 56.45709 -34.41167 56.48286 -34.30032 curveto

 56.73074 -33.22787 57.13269 -31.48909 57.38057 -30.41664 curveto

 57.40634 -30.30531 58.1675 -26.7743 58.25018 -26.36205 curveto

 58.46663 -25.28296 58.81755 -23.53343 59.034 -22.45435 curveto

 59.11671 -22.0421 59.87787 -17.99837 60.00632 -17.26964 curveto

 60.19748 -16.18474 60.50746 -14.4258 60.69862 -13.3409 curveto

 60.82709 -12.61218 61.58824 -8.03249 61.75465 -6.9687 curveto

 61.92487 -5.8804 62.20084 -4.11597 62.37103 -3.02768 curveto

 62.53746 -1.9639 63.29861 3.17432 63.49658 4.58794 curveto

 63.64937 5.67921 63.8971 7.4485 64.04988 8.53978 curveto

 64.24783 9.95338 65.009 15.6723 65.23384 17.45284 curveto

 65.37178 18.54546 65.59544 20.31693 65.73341 21.40955 curveto

 65.95824 23.19006 66.71938 29.51288 66.96712 31.67467 curveto

 67.09242 32.76852 67.29558 34.54202 67.42087 35.63588 curveto

 67.66861 37.79765 68.42975 44.7467 68.69713 47.304 curveto

 68.81157 48.39899 68.99715 50.1743 69.11159 51.26929 curveto

 69.37898 53.82657 70.14012 61.42432 70.42455 64.39136 curveto

 70.52959 65.4874 70.6999 67.26439 70.80496 68.36041 curveto

 71.08937 71.32747 71.8505 79.59677 72.14984 82.98796 curveto

 72.24663 84.08492 72.40361 85.8634 72.5004 86.96036 curveto

 72.79973 90.35153 73.5609 99.31508 73.87347 103.14613 curveto

 73.96295 104.24309 74.10805 106.02158 74.19753 107.11853 curveto

 74.51012 110.9496 75.27127 120.62971 75.59549 124.91331 curveto

 75.67854 126.01108 75.8132 127.79086 75.89626 128.88863 curveto

 76.22049 133.17223 76.98164 143.5919 77.31631 148.34357 curveto

 77.3936 149.44135 77.51892 151.22113 77.5962 152.3189 curveto

 77.93086 157.07057 78.69202 168.25189 79.03592 173.48442 curveto

 79.1081 174.5829 79.22514 176.36388 79.29733 177.46236 curveto

 79.64124 182.6949 80.40239 194.66101 80.75473 200.38995 curveto

 80.82225 201.48843 80.93176 203.2694 80.9993 204.36787 curveto

 81.35162 210.0968 82.11276 222.87038 82.47264 229.1086 curveto

 82.536 230.20769 82.63876 231.98962 82.70213 233.08871 curveto

 83.062 239.32692 83.82315 252.92987 84.18988 259.69254 curveto

 84.24947 260.79163 84.34605 262.57356 84.40564 263.67265 curveto

 84.77238 270.43533 85.53352 284.89078 85.90654 292.19212 curveto

 85.96265 293.29121 86.05365 295.07317 86.10976 296.17224 curveto

 86.48276 303.4736 87.2439 318.80446 87.62257 326.65764 curveto

 87.67557 327.75723 87.76149 329.54 87.81448 330.63959 curveto

 88.19313 338.49278 88.95428 354.72116 89.33818 363.14116 curveto

 89.38828 364.24075 89.46951 366.02351 89.51962 367.12311 curveto

 89.90352 375.54309 90.66466 392.69168 91.05334 401.69261 curveto

 91.1008 402.7922 91.17775 404.57497 91.22519 405.67456 curveto

 91.61388 414.6755 92.37505 432.76718 92.76813 442.36322 curveto

 92.81314 443.4628 92.88615 445.24557 92.93117 446.34515 curveto

 93.32426 455.9412 94.08542 474.99866 94.48259 485.20311 curveto

 94.52534 486.30307 94.5947 488.08647 94.63747 489.18645 curveto

 95.03464 499.39088 95.79579 519.43596 96.19675 530.26363 curveto

 96.23743 531.36359 96.3034 533.14699 96.34409 534.24696 curveto

 96.74501 545.07462 97.50616 566.13084 97.91061 577.59587 curveto

 97.94937 578.69585 98.0122 580.47925 98.05096 581.57922 curveto

 98.4554 593.04425 99.21654 615.1336 99.62418 627.25012 curveto

 99.66116 628.35008 99.72116 630.13348 99.75815 631.23346 curveto

 100.16579 643.34996 100.92691 666.49567 101.33757 679.2778 curveto

 101.3729 680.37778 101.43018 682.16118 101.4655 683.26115 curveto

 101.87614 696.04329 102.6373 720.26768 103.05077 733.7295 curveto

 103.08453 734.82948 103.13928 736.61288 103.17305 737.71286 curveto

 103.58653 751.17468 104.34769 776.50024 104.76378 790.65533 curveto

 104.7961 791.75557 104.84851 793.5394 104.88083 794.63965 curveto

 105.2969 808.79471 106.05806 835.24405 106.47661 850.10707 curveto

 106.50757 851.20732 106.55779 852.99115 106.58875 854.09138 curveto

 107.00728 868.95439 107.76845 896.5507 108.1893 912.13573 curveto

 108.21896 913.23596 108.26714 915.01979 108.2968 916.12004 curveto

 108.71767 931.70508 109.4788 960.47018 109.90182 976.79128 curveto

 109.93031 977.89151 109.97653 979.67534 110.00502 980.77559 curveto

 110.42804 997.09666 111.1892 1027.05357 111.61424 1044.12486 curveto

 111.6416 1045.2251 111.68599 1047.00894 111.71336 1048.10918 curveto

 112.13841 1065.18047 113.37418 1116.17952 113.37418 1116.17952 curveto

 pgfstr

 save

 1.49442 pgfw

 /pgfsc{}def/pgffc{}def

 1 0 0 setrgbcolor

 -19.84267 0.0 moveto

 19.84267 0.0 lineto

 pgfstr

 restore

 save

 1.49442 pgfw

 /pgfsc{}def/pgffc{}def

 1 0 0 setrgbcolor

 59.52802 0.0 moveto

 59.78024 0.0 lineto

 60.8807 0.0 62.66487 0.0 63.76535 0.0 curveto

 62.02502 0.0 lineto

 63.12549 0.0 64.90965 0.0 66.01013 0.0 curveto

 64.26979 0.0 lineto

 65.37027 0.0 67.15443 0.0 68.2549 0.0 curveto

 66.51457 0.0 lineto

 67.61505 0.0 69.39922 0.0 70.49968 0.0 curveto

 68.75935 0.0 lineto

 69.85982 0.0 71.64398 0.0 72.74446 0.0 curveto

 71.00412 0.0 lineto

 72.10458 0.0 73.88875 0.0 74.98923 0.0 curveto

 73.2489 0.0 lineto

 74.34937 0.0 76.13353 0.0 77.23401 0.0 curveto

 75.49367 0.0 lineto

 76.59415 0.0 78.37831 0.0 79.47878 0.0 curveto

 77.73843 0.0 lineto

 78.83891 0.0 80.62308 0.0 81.72354 0.0 curveto

 79.98323 0.0 lineto

 81.0837 0.0 82.86786 0.0 83.96834 0.0 curveto

 82.22801 0.0 lineto

 83.32848 0.0 85.11264 0.0 86.21312 0.0 curveto

 84.47278 0.0 lineto

 85.57326 0.0 87.35742 0.0 88.45789 0.0 curveto

 86.71754 0.0 lineto

 87.81802 0.0 89.60219 0.0 90.70265 0.0 curveto

 88.96233 0.0 lineto

 90.06279 0.0 91.84695 0.0 92.94743 0.0 curveto

 91.2071 0.0 lineto

 92.30757 0.0 94.09174 0.0 95.19221 0.0 curveto

 93.45189 0.0 lineto

 94.55237 0.0 96.33653 0.0 97.437 0.0 curveto

 95.69666 0.0 lineto

 96.79713 0.0 98.5813 0.0 99.68176 0.0 curveto

 97.94142 0.0 lineto

 99.0419 0.0 100.82607 0.0 101.92653 0.0 curveto

 100.18622 0.0 lineto

 101.28668 0.0 103.07085 0.0 104.17133 0.0 curveto

 102.43098 0.0 lineto

 103.53145 0.0 105.31561 0.0 106.41609 0.0 curveto

 104.67577 0.0 lineto

 105.77625 0.0 107.56041 0.0 108.66087 0.0 curveto

 106.92053 0.0 lineto

 108.02101 0.0 109.80518 0.0 110.90564 0.0 curveto

 109.16531 0.0 lineto

 110.26578 0.0 112.04994 0.0 113.15042 0.0 curveto

 113.40265 0.0 lineto

 pgfstr

 restore

 save

 1.49442 pgfw

 /pgfsc{}def/pgffc{}def

 0 0 1 setrgbcolor

 -55.95316 -19.84267 moveto

 -50.88922 -19.84267 lineto

 -49.78876 -19.84267 -48.0046 -19.84267 -46.90411 -19.84267 curveto

 -43.83275 -19.84267 lineto

 -42.73228 -19.84267 -40.94812 -19.84267 -39.84764 -19.84267 curveto

 -36.77628 -19.84267 lineto

 -35.6758 -19.84267 -33.89163 -19.84267 -32.79117 -19.84267 curveto

 -29.71979 -19.84267 lineto

 -28.61931 -19.84267 -26.83514 -19.84267 -25.73468 -19.84267 curveto

 -22.6633 -19.84267 lineto

 -21.56284 -19.84267 -19.77866 -19.84267 -18.67819 -19.84267 curveto

 -15.60681 -19.84267 lineto

 -14.50635 -19.84267 -12.72218 -19.84267 -11.6217 -19.84267 curveto

 -8.55034 -19.84267 lineto

 -7.44987 -19.84267 -5.66571 -19.84267 -4.56523 -19.84267 curveto

 -1.4939 -19.84267 lineto

 -0.39342 -19.84267 1.39073 -19.84267 2.4912 -19.84267 curveto

 5.56258 -19.84267 lineto

 6.66306 -19.84267 8.44722 -19.84267 9.54768 -19.84267 curveto

 12.61905 -19.84267 lineto

 13.71951 -19.84267 15.50368 -19.84267 16.60416 -19.84267 curveto

 19.67554 -19.84267 lineto

 20.776 -19.84267 22.56017 -19.84267 23.66064 -19.84267 curveto

 26.73203 -19.84267 lineto

 27.83249 -19.84267 29.61665 -19.84267 30.71713 -19.84267 curveto

 33.7885 -19.84267 lineto

 34.88898 -19.84267 36.67314 -19.84267 37.7736 -19.84267 curveto

 40.84499 -19.84267 lineto

 41.94547 -19.84267 43.72963 -19.84267 44.8301 -19.84267 curveto

 47.90146 -19.84267 lineto

 49.00192 -19.84267 50.78609 -19.84267 51.88657 -19.84267 curveto

 54.95795 -19.84267 lineto

 56.05841 -19.84267 57.84258 -19.84267 58.94305 -19.84267 curveto

 62.01442 -19.84267 lineto

 63.1149 -19.84267 64.89906 -19.84267 65.99953 -19.84267 curveto

 69.0709 -19.84267 lineto

 70.17139 -19.84267 71.95555 -19.84267 73.05602 -19.84267 curveto

 76.12738 -19.84267 lineto

 77.22784 -19.84267 79.01202 -19.84267 80.11249 -19.84267 curveto

 83.18387 -19.84267 lineto

 84.28433 -19.84267 86.0685 -19.84267 87.16898 -19.84267 curveto

 90.24034 -19.84267 lineto

 91.3408 -19.84267 93.12497 -19.84267 94.22545 -19.84267 curveto

 97.29681 -19.84267 lineto

 98.3973 -19.84267 100.18146 -19.84267 101.28192 -19.84267 curveto

 104.3533 -19.84267 lineto

 105.45378 -19.84267 107.23795 -19.84267 108.33841 -19.84267 curveto

 113.40233 -19.84267 lineto

 pgfstr

 restore

 49.60667 39.68535 moveto

 pgfstr

 save

 save

 [1.0 0.0 0.0 1.0 52.72803 29.5901 ] concat

 pgfs



 0 setgray
 816 137 a Fg(C)877 151
y Fe(f)816 137 y


 pgfr

 restore

 restore

 save

 1.19553 pgfw

 /pgfsc{}def/pgffc{}def

 0 setgray

 -19.84267 -19.84267 moveto

 -19.47975 -19.47981 lineto

 -20.25792 -20.25795 -20.25792 -20.25795 -19.47975 -19.47981 curveto

 -18.79659 -18.79659 lineto

 -20.88876 -18.79659 moveto

 -18.79659 -20.88876 lineto

 pgfstr

 restore

 save

 1.19553 pgfw

 /pgfsc{}def/pgffc{}def

 0 setgray

 19.84267 -19.84267 moveto

 20.2056 -19.47981 lineto

 19.42741 -20.25795 19.42741 -20.25795 20.2056 -19.47981 curveto

 20.88876 -18.79659 lineto

 18.79659 -18.79659 moveto

 20.88876 -20.88876 lineto

 pgfstr

 restore

 save

 1.19553 pgfw

 /pgfsc{}def/pgffc{}def

 0 setgray

 59.52802 -19.84267 moveto

 59.89095 -19.47981 lineto

 59.11278 -20.25795 59.11278 -20.25795 59.89095 -19.47981 curveto

 60.57411 -18.79659 lineto

 58.48195 -18.79659 moveto

 60.57411 -20.88876 lineto

 pgfstr

 restore

 restore

 newpath

 restore

 pgfc


 -40 933 a Fm(On)20 b(lit)g(les)g(abscisses)g(des)g
(points)h(de)e Fg(C)1166 947 y Fe(f)1222 933 y Fm(d)n('or)o(donn\351e)h
(sup\351-)-40 1033 y(r)q(ieur)o(e)d(ou)h(\351gale)f(\340)g
Fj(\241)p Fm(1)-40 1166 y(L)-10 b('ensemble)37 b(des)e(solutions)i(de)
42 b Fo(f)19 b Fm(\()r Fo(x)5 b Fm(\))32 b Fj(\270)f(\241)p
Fm(1)k(est)1542 1167 y([)1567 1166 y Fj(\241)p Fm(1)8
b(;)g(1)1738 1167 y(])1782 1166 y Fj([)-40 1266 y Fm([)-15
1265 y(3)g(;)g Fj(\3051)194 1266 y Fm([)221 1265 y(.)p
0 TeXcolorgray 0 TeXcolorgray 1920 -504 a
SDict begin H.S end
 1920 -504 a
1920 -504 a
SDict begin 12 H.A end
 1920 -504 a 1920 -504 a
SDict begin [/View [/XYZ H.V]/Dest (Item.2) cvn /DEST pdfmark end
 1920 -504 a 0 TeXcolorgray
1985 -421 a Fn(2\260\))p 0 TeXcolorgray 42 w Fm(R\351soudr)o(e)17
b(sur)h Fl(R)25 b Fo(f)19 b Fm(\()r Fo(x)5 b Fm(\))14
b Fj(\267)i Fo(g)10 b Fm(\()r Fo(x)5 b Fm(\).)p 0 TeXcolorgray
0 TeXcolorgray 2984 137 a

 2984 137 a 2984 137 a


 pgfo

 save

 0 setgray

 0.3985 pgfw

 save

 1 setlinecap

 1 setlinejoin

 save

 /pgfsc{}def/pgffc{}def

 0 setgray

 [ 1.99255 1.99255 ] 0.0 setdash

 -59.52802 -69.44937 moveto

 -59.52802 -69.4491 moveto

 79.37071 -69.4491 lineto

 -59.52802 -55.55927 moveto

 79.37071 -55.55927 lineto

 -59.52802 -41.66945 moveto

 79.37071 -41.66945 lineto

 -59.52802 -27.77963 moveto

 79.37071 -27.77963 lineto

 -59.52802 -13.88982 moveto

 79.37071 -13.88982 lineto

 -59.52802 0.0 moveto

 79.37071 0.0 lineto

 -59.52802 13.88982 moveto

 79.37071 13.88982 lineto

 -59.52802 27.77963 moveto

 79.37071 27.77963 lineto

 -59.52802 41.66945 moveto

 79.37071 41.66945 lineto

 -55.55927 -69.44937 moveto

 -55.55927 49.60667 lineto

 -41.66945 -69.44937 moveto

 -41.66945 49.60667 lineto

 -27.77963 -69.44937 moveto

 -27.77963 49.60667 lineto

 -13.88982 -69.44937 moveto

 -13.88982 49.60667 lineto

 0.0 -69.44937 moveto

 0.0 49.60667 lineto

 13.88982 -69.44937 moveto

 13.88982 49.60667 lineto

 27.77963 -69.44937 moveto

 27.77963 49.60667 lineto

 41.66945 -69.44937 moveto

 41.66945 49.60667 lineto

 55.55927 -69.44937 moveto

 55.55927 49.60667 lineto

 69.4491 -69.44937 moveto

 69.4491 49.60667 lineto

 pgfstr

 restore

 save

 /pgfsc{}def/pgffc{}def

 0 setgray

 -59.52802 0.0 moveto

 78.56177 0.0 lineto

 pgfstr

 save

 [1.0 0.0 0.0 1.0 78.56177 0.0 ] concat

 save [ ] 0.0 setdash 0 setlinejoin -5.20348 2.3356 moveto 0.29886
0.0 lineto -5.20348 -2.3356 lineto closepath gsave pgffc pgffill grestore
gsave pgfsc pgfstr grestore newpath restore

 restore

 restore

 save

 /pgfsc{}def/pgffc{}def

 0 setgray

 -39.68535 1.39478 moveto

 -39.68535 -1.39478 lineto

 pgfstr

 save

 save

 [1.0 0.0 0.0 1.0 -44.26822 -9.42575 ] concat

 pgfs



 0 setgray
 2984
137 a Fi(\241)p Fh(2)2984 137 y


 pgfr

 restore

 restore

 restore

 save

 /pgfsc{}def/pgffc{}def

 0 setgray

 -19.84267 1.39478 moveto

 -19.84267 -1.39478 lineto

 pgfstr

 save

 save

 [1.0 0.0 0.0 1.0 -24.42552 -9.42575 ] concat

 pgfs



 0 setgray
 2984 137 a Fi(\241)p
Fh(1)2984 137 y


 pgfr

 restore

 restore

 restore

 save

 /pgfsc{}def/pgffc{}def

 0 setgray

 19.84267 1.39478 moveto

 19.84267 -1.39478 lineto

 pgfstr

 save

 save

 [1.0 0.0 0.0 1.0 17.89793 -9.42575 ] concat

 pgfs



 0 setgray
 2984 137 a Fh(1)2984 137 y


 pgfr

 restore

 restore

 restore

 save

 /pgfsc{}def/pgffc{}def

 0 setgray

 39.68535 1.39478 moveto

 39.68535 -1.39478 lineto

 pgfstr

 save

 save

 [1.0 0.0 0.0 1.0 37.74062 -9.42575 ] concat

 pgfs



 0 setgray
 2984 137 a
Fh(2)2984 137 y


 pgfr

 restore

 restore

 restore

 save

 /pgfsc{}def/pgffc{}def

 0 setgray

 59.52802 1.39478 moveto

 59.52802 -1.39478 lineto

 pgfstr

 save

 save

 [1.0 0.0 0.0 1.0 57.5833 -9.42577 ] concat

 pgfs



 0 setgray
 2984 137 a Fh(3)2984 137 y


 pgfr

 restore

 restore

 restore

 save

 /pgfsc{}def/pgffc{}def

 0 setgray

 0.0 -69.44937 moveto

 0.0 48.79773 lineto

 pgfstr

 save

 [0.0 1.0 -1.0 0.0 0.0 48.79773 ] concat

 save [ ] 0.0 setdash 0 setlinejoin -5.20348 2.3356 moveto 0.29886
0.0 lineto -5.20348 -2.3356 lineto closepath gsave pgffc pgffill grestore
gsave pgfsc pgfstr grestore newpath restore

 restore

 restore

 save

 /pgfsc{}def/pgffc{}def

 0 setgray

 1.39478 -59.52802 moveto

 -1.39478 -59.52802 lineto

 pgfstr

 save

 save

 [1.0 0.0 0.0 1.0 -13.68185 -61.96292 ] concat

 pgfs



 0 setgray
 2984 137 a
Fi(\241)p Fh(3)2984 137 y


 pgfr

 restore

 restore

 restore

 save

 /pgfsc{}def/pgffc{}def

 0 setgray

 1.39478 -39.68535 moveto

 -1.39478 -39.68535 lineto

 pgfstr

 save

 save

 [1.0 0.0 0.0 1.0 -13.68185 -42.14017 ] concat

 pgfs



 0 setgray
 2984 137 a Fi(\241)p Fh(2)2984
137 y


 pgfr

 restore

 restore

 restore

 save

 /pgfsc{}def/pgffc{}def

 0 setgray

 1.39478 -19.84267 moveto

 -1.39478 -19.84267 lineto

 pgfstr

 save

 save

 [1.0 0.0 0.0 1.0 -13.68185 -22.29749 ] concat

 pgfs



 0 setgray
 2984 137 a Fi(\241)p Fh(1)2984 137 y


 pgfr

 restore

 restore

 restore

 save

 /pgfsc{}def/pgffc{}def

 0 setgray

 1.39478 19.84267 moveto

 -1.39478 19.84267 lineto

 pgfstr

 save

 save

 [1.0 0.0 0.0 1.0 -8.40558 17.38785 ] concat

 pgfs



 0 setgray
 2984 137 a
Fh(1)2984 137 y


 pgfr

 restore

 restore

 restore

 save

 /pgfsc{}def/pgffc{}def

 0 setgray

 1.39478 39.68535 moveto

 -1.39478 39.68535 lineto

 pgfstr

 save

 save

 [1.0 0.0 0.0 1.0 -8.40558 37.23053 ] concat

 pgfs



 0 setgray
 2984 137 a Fh(2)2984 137 y


 pgfr

 restore

 restore

 restore

 save

 /pgfsc{}def/pgffc{}def

 0 setgray

 0.0 -6.9739 moveto

 pgfstr

 save

 save

 [1.0 0.0 0.0 1.0 3.12134 -9.4088 ] concat

 pgfs



 0 setgray
 2984 137 a
Fh(0)2984 137 y


 pgfr

 restore

 restore

 restore

 -59.52802 -69.44937 moveto

 -59.52802 -67.45682 moveto

 -59.52802 47.61412 lineto

 -59.52802 48.7146 -58.63594 49.60667 -57.53546 49.60667 curveto

 77.37816 49.60667 lineto

 78.47862 49.60667 79.37071 48.7146 79.37071 47.61412 curveto

 79.37071 -67.45682 lineto

 79.37071 -68.55728 78.47862 -69.44937 77.37816 -69.44937 curveto

 -57.53546 -69.44937 lineto

 -58.63594 -69.44937 -59.52802 -68.55728 -59.52802 -67.45682 curveto

 closepath

 79.37071 49.60667 moveto

 clip

 newpath

 -55.95316 -555.02248 moveto

 -55.95316 -555.02248 -54.71739 -522.75705 -54.32169 -512.7793 curveto

 -54.2781 -511.67932 -54.20741 -509.89592 -54.16383 -508.79594 curveto

 -53.76816 -498.81819 -53.007 -480.12056 -52.6155 -470.74612 curveto

 -52.56963 -469.64653 -52.4952 -467.86377 -52.44931 -466.76418 curveto

 -52.05779 -457.38972 -51.29663 -439.64914 -50.90967 -430.86456 curveto

 -50.86127 -429.76497 -50.78276 -427.98221 -50.73436 -426.88261 curveto

 -50.34741 -418.09802 -49.58626 -401.29216 -49.20425 -393.08336 curveto

 -49.1531 -391.98376 -49.07018 -390.201 -49.01903 -389.10141 curveto

 -48.63704 -380.8926 -47.87587 -364.99878 -47.49925 -357.35164 curveto

 -47.44514 -356.25204 -47.35738 -354.46928 -47.30324 -353.36969 curveto

 -46.92665 -345.72255 -46.16551 -330.71825 -45.79475 -323.61761 curveto

 -45.7374 -322.51852 -45.6444 -320.73657 -45.58704 -319.63748 curveto

 -45.21626 -312.53688 -44.45512 -298.39851 -44.09084 -291.83138 curveto

 -44.0299 -290.73228 -43.93109 -288.95033 -43.87016 -287.85124 curveto

 -43.50589 -281.2841 -42.74475 -267.99103 -42.38762 -261.9432 curveto

 -42.32274 -260.84412 -42.21754 -259.06216 -42.15266 -257.96307 curveto

 -41.79552 -251.91525 -41.03438 -239.4426 -40.68504 -233.89876 curveto

 -40.61586 -232.80028 -40.50365 -231.0193 -40.43446 -229.92082 curveto

 -40.08514 -224.377 -39.32399 -212.70357 -38.98343 -207.65086 curveto

 -38.9094 -206.55238 -38.78937 -204.77142 -38.71533 -203.67294 curveto

 -38.37476 -198.62022 -37.6136 -187.72308 -37.28267 -183.14597 curveto

 -37.20332 -182.0482 -37.07468 -180.26842 -36.99535 -179.17064 curveto

 -36.66438 -174.59352 -35.90323 -164.44934 -35.58319 -160.33517 curveto

 -35.49783 -159.2374 -35.3594 -157.45761 -35.27403 -156.35985 curveto

 -34.95401 -152.24567 -34.19286 -142.83337 -33.885 -139.16669 curveto

 -33.79291 -138.06973 -33.6436 -136.29124 -33.55151 -135.19429 curveto

 -33.24364 -131.52762 -32.48248 -122.82379 -32.18831 -119.58998 curveto

 -32.08867 -118.49396 -31.92706 -116.71696 -31.82742 -115.62094 curveto

 -31.53325 -112.38713 -30.77211 -104.36824 -30.49377 -101.55489 curveto

 -30.38538 -100.45885 -30.20961 -98.68185 -30.1012 -97.58583 curveto

 -29.82289 -94.77246 -29.06172 -87.41684 -28.80135 -85.00815 curveto

 -28.68304 -83.91316 -28.4912 -82.13785 -28.3729 -81.04286 curveto

 -28.11249 -78.63417 -27.35135 -71.91957 -27.11179 -69.90126 curveto

 -26.98198 -68.8074 -26.7715 -67.0339 -26.6417 -65.94005 curveto

 -26.40211 -63.92172 -25.64098 -57.82469 -25.42537 -56.17993 curveto

 -25.28233 -55.08867 -25.05038 -53.31937 -24.90736 -52.22809 curveto

 -24.69174 -50.58334 -23.9306 -45.08195 -23.74355 -43.79866 curveto

 -23.58473 -42.70883 -23.32722 -40.94186 -23.1684 -39.85204 curveto

 -22.98137 -38.56874 -22.22023 -33.63911 -22.06685 -32.7001 curveto

 -21.88943 -31.61346 -21.60178 -29.85167 -21.42435 -28.76505 curveto

 -21.27098 -27.82603 -20.50983 -23.4475 -20.39728 -22.83797 curveto

 -20.19733 -21.75491 -19.87312 -19.99898 -19.67317 -18.91592 curveto

 -19.56061 -18.30638 -18.79945 -14.45456 -18.73637 -14.15578 curveto

 -18.5091 -13.0788 -18.14061 -11.3327 -17.91333 -10.25574 curveto

 -17.85023 -9.95695 -17.08908 -6.61017 -17.08818 -6.60658 curveto

 -16.82655 -5.53653 -16.40236 -3.8016 -16.14073 -2.73155 curveto

 -16.13986 -2.72798 -15.37871 0.1368 -15.45683 -0.13452 curveto

 -15.15157 0.92519 -14.65662 2.64328 -14.35135 3.703 curveto

 -14.42949 3.43167 -13.66832 5.83665 -13.84825 5.31802 curveto

 -13.48676 6.35992 -12.90065 8.04913 -12.53915 9.09103 curveto

 -12.71909 8.57239 -11.95796 10.54033 -12.27129 9.81242 curveto

 -11.83612 10.82338 -11.13057 12.46242 -10.69542 13.47337 curveto

 -11.00873 12.74547 -10.24757 14.29988 -10.74641 13.40526 curveto

 -10.20879 14.36949 -9.33713 15.9328 -8.79948 16.89703 curveto

 -9.29834 16.00243 -8.5372 17.16429 -9.28279 16.19962 curveto

 -8.60889 17.07152 -7.51628 18.48515 -6.84236 19.35707 curveto

 -7.58797 18.3924 -6.82683 19.1858 -7.89297 18.30725 curveto

 -7.04204 19.00842 -5.66237 20.14522 -4.81142 20.84634 curveto

 -5.8776 19.96783 -5.11644 20.4146 -6.50443 19.88232 curveto

 -5.47572 20.27678 -3.80792 20.91635 -2.77922 21.31079 curveto

 -4.16722 20.77855 -3.40607 20.90138 -4.92361 20.9427 curveto

 -3.82336 20.91275 -2.03954 20.86417 -0.93929 20.83423 curveto

 -2.45683 20.87552 -1.69568 20.69693 -3.0711 21.25809 curveto

 -2.04936 20.84123 -0.39276 20.16539 0.62897 19.74854 curveto

 -0.74646 20.3097 0.01465 19.85323 -1.10477 20.70313 curveto

 -0.2244 20.03477 1.20294 18.95117 2.08331 18.28285 curveto

 0.96387 19.1327 1.72504 18.41956 0.84232 19.37311 curveto

 1.59195 18.56323 2.80722 17.25021 3.55669 16.44034 curveto

 2.67427 17.39388 3.4354 16.44794 2.73158 17.41368 curveto

 3.38242 16.52061 4.43762 15.07272 5.08844 14.17967 curveto

 4.38464 15.1454 5.14578 13.98854 4.5796 14.91383 curveto

 5.15442 13.97437 6.08638 12.45122 6.66121 11.51175 curveto

 6.09502 12.43706 6.85616 11.09152 6.38754 11.9662 curveto

 6.90848 10.99385 7.75308 9.4174 8.27402 8.44505 curveto

 7.80539 9.31973 8.56653 7.80983 8.17294 8.62418 curveto

 8.65244 7.63208 9.42986 6.02362 9.90935 5.03152 curveto

 9.51576 5.84589 10.27692 4.19235 9.93802 4.95207 curveto

 10.38731 3.9448 11.11574 2.3117 11.56502 1.30444 curveto

 11.22614 2.06416 11.9873 0.29051 11.68892 1.0022 curveto

 12.11581 -0.01599 12.808 -1.6668 13.23492 -2.685 curveto

 12.93652 -1.97333 13.69768 -3.8442 13.43184 -3.17998 curveto

 13.84079 -4.2017 14.5038 -5.85828 14.91272 -6.88002 curveto

 14.6469 -6.21577 15.40805 -8.16228 15.16138 -7.5252 curveto

 15.55974 -8.55392 16.2056 -10.22173 16.60396 -11.25043 curveto

 16.35727 -10.61337 17.11842 -12.61177 16.88411 -11.9941 curveto

 17.27563 -13.02618 17.91045 -14.6995 18.30197 -15.7316 curveto

 18.06767 -15.11394 18.8288 -17.14218 18.6009 -16.53603 curveto

 18.98889 -17.56812 19.61794 -19.24142 20.0059 -20.27351 curveto

 19.77803 -19.66737 20.53918 -21.70273 20.30988 -21.09401 curveto

 20.69864 -22.12611 21.32896 -23.79942 21.71774 -24.83151 curveto

 21.48842 -24.2228 22.24956 -26.24295 22.0131 -25.62361 curveto

 22.4058 -26.65231 23.0425 -28.32013 23.43517 -29.34883 curveto

 23.19879 -28.72949 23.95993 -30.71092 23.70787 -30.06702 curveto

 24.1092 -31.09227 24.7599 -32.75452 25.16121 -33.77975 curveto

 24.90916 -33.13586 25.67032 -35.05736 25.39287 -34.37491 curveto

 25.80821 -35.39664 26.48163 -37.0532 26.89696 -38.07494 curveto

 26.61954 -37.39249 27.38069 -39.22998 27.0687 -38.50133 curveto

 27.50313 -39.51595 28.20747 -41.16092 28.64189 -42.17552 curveto

 28.32991 -41.44688 29.09106 -43.17859 28.73271 -42.39688 curveto

 29.19275 -43.40042 29.9386 -45.02747 30.39864 -46.031 curveto

 30.04028 -45.2493 30.80145 -46.85248 30.38397 -46.01843 curveto

 30.87665 -47.00272 31.67548 -48.59853 32.16817 -49.58281 curveto

 31.75067 -48.74876 32.51183 -50.2008 32.01193 -49.3091 curveto

 32.55016 -50.26926 33.42273 -51.82594 33.96092 -52.7861 curveto

 33.46104 -51.89438 34.2222 -53.17236 33.6076 -52.2254 curveto

 34.20915 -53.15228 35.18446 -54.65506 35.78601 -55.58194 curveto

 35.17143 -54.63496 35.93257 -55.71652 35.16805 -54.74718 curveto

 35.85242 -55.6149 36.96198 -57.02171 37.64633 -57.88943 curveto

 36.88182 -56.92007 37.64294 -57.78273 36.68016 -56.85306 curveto

 37.47403 -57.61957 38.76111 -58.86227 39.55498 -59.62875 curveto

 38.59218 -58.69911 39.35333 -59.3203 38.14207 -58.55359 curveto

 39.07317 -59.14293 40.58272 -60.0984 41.51381 -60.6877 curveto

 40.30257 -59.92104 41.06372 -60.27731 39.61465 -59.88507 curveto

 40.67708 -60.17265 42.39955 -60.63889 43.46198 -60.92647 curveto

 42.01294 -60.53423 42.7741 -60.60403 41.27036 -60.78609 curveto

 42.36298 -60.65382 44.13443 -60.43932 45.22707 -60.30705 curveto

 43.72331 -60.4891 44.48447 -60.24922 43.20584 -60.94344 curveto

 44.17413 -60.41772 45.74403 -59.56541 46.71233 -59.03972 curveto

 45.43369 -59.73393 46.19484 -59.16144 45.25345 -60.09743 curveto

 46.03549 -59.31992 47.30342 -58.05936 48.08546 -57.28186 curveto

 47.14407 -58.21783 47.90521 -57.29118 47.25754 -58.24644 curveto

 47.87737 -57.33221 48.8823 -55.84999 49.5021 -54.93576 curveto

 48.85443 -55.89102 49.6156 -54.58638 49.19272 -55.42607 curveto

 49.68839 -54.44179 50.49203 -52.84598 50.98773 -51.8617 curveto

 50.56483 -52.7014 51.32597 -50.99734 51.06573 -51.65472 curveto

 51.47157 -50.62947 52.1296 -48.96722 52.53543 -47.94197 curveto

 52.2752 -48.59935 53.03635 -46.47203 52.89809 -46.90013 curveto

 53.23657 -45.85204 53.78535 -44.15273 54.12383 -43.10463 curveto

 53.98558 -43.53273 54.74673 -40.96036 54.70099 -41.1297 curveto

 54.98836 -40.06729 55.45433 -38.3448 55.74174 -37.2824 curveto

 55.69597 -37.45174 56.45709 -34.41167 56.48286 -34.30032 curveto

 56.73074 -33.22787 57.13269 -31.48909 57.38057 -30.41664 curveto

 57.40634 -30.30531 58.1675 -26.7743 58.25018 -26.36205 curveto

 58.46663 -25.28296 58.81755 -23.53343 59.034 -22.45435 curveto

 59.11671 -22.0421 59.87787 -17.99837 60.00632 -17.26964 curveto

 60.19748 -16.18474 60.50746 -14.4258 60.69862 -13.3409 curveto

 60.82709 -12.61218 61.58824 -8.03249 61.75465 -6.9687 curveto

 61.92487 -5.8804 62.20084 -4.11597 62.37103 -3.02768 curveto

 62.53746 -1.9639 63.29861 3.17432 63.49658 4.58794 curveto

 63.64937 5.67921 63.8971 7.4485 64.04988 8.53978 curveto

 64.24783 9.95338 65.009 15.6723 65.23384 17.45284 curveto

 65.37178 18.54546 65.59544 20.31693 65.73341 21.40955 curveto

 65.95824 23.19006 66.71938 29.51288 66.96712 31.67467 curveto

 67.09242 32.76852 67.29558 34.54202 67.42087 35.63588 curveto

 67.66861 37.79765 68.42975 44.7467 68.69713 47.304 curveto

 68.81157 48.39899 68.99715 50.1743 69.11159 51.26929 curveto

 69.37898 53.82657 70.14012 61.42432 70.42455 64.39136 curveto

 70.52959 65.4874 70.6999 67.26439 70.80496 68.36041 curveto

 71.08937 71.32747 71.8505 79.59677 72.14984 82.98796 curveto

 72.24663 84.08492 72.40361 85.8634 72.5004 86.96036 curveto

 72.79973 90.35153 73.5609 99.31508 73.87347 103.14613 curveto

 73.96295 104.24309 74.10805 106.02158 74.19753 107.11853 curveto

 74.51012 110.9496 75.27127 120.62971 75.59549 124.91331 curveto

 75.67854 126.01108 75.8132 127.79086 75.89626 128.88863 curveto

 76.22049 133.17223 76.98164 143.5919 77.31631 148.34357 curveto

 77.3936 149.44135 77.51892 151.22113 77.5962 152.3189 curveto

 77.93086 157.07057 78.69202 168.25189 79.03592 173.48442 curveto

 79.1081 174.5829 79.22514 176.36388 79.29733 177.46236 curveto

 79.64124 182.6949 80.40239 194.66101 80.75473 200.38995 curveto

 80.82225 201.48843 80.93176 203.2694 80.9993 204.36787 curveto

 81.35162 210.0968 82.11276 222.87038 82.47264 229.1086 curveto

 82.536 230.20769 82.63876 231.98962 82.70213 233.08871 curveto

 83.062 239.32692 83.82315 252.92987 84.18988 259.69254 curveto

 84.24947 260.79163 84.34605 262.57356 84.40564 263.67265 curveto

 84.77238 270.43533 85.53352 284.89078 85.90654 292.19212 curveto

 85.96265 293.29121 86.05365 295.07317 86.10976 296.17224 curveto

 86.48276 303.4736 87.2439 318.80446 87.62257 326.65764 curveto

 87.67557 327.75723 87.76149 329.54 87.81448 330.63959 curveto

 88.19313 338.49278 88.95428 354.72116 89.33818 363.14116 curveto

 89.38828 364.24075 89.46951 366.02351 89.51962 367.12311 curveto

 89.90352 375.54309 90.66466 392.69168 91.05334 401.69261 curveto

 91.1008 402.7922 91.17775 404.57497 91.22519 405.67456 curveto

 91.61388 414.6755 92.37505 432.76718 92.76813 442.36322 curveto

 92.81314 443.4628 92.88615 445.24557 92.93117 446.34515 curveto

 93.32426 455.9412 94.08542 474.99866 94.48259 485.20311 curveto

 94.52534 486.30307 94.5947 488.08647 94.63747 489.18645 curveto

 95.03464 499.39088 95.79579 519.43596 96.19675 530.26363 curveto

 96.23743 531.36359 96.3034 533.14699 96.34409 534.24696 curveto

 96.74501 545.07462 97.50616 566.13084 97.91061 577.59587 curveto

 97.94937 578.69585 98.0122 580.47925 98.05096 581.57922 curveto

 98.4554 593.04425 99.21654 615.1336 99.62418 627.25012 curveto

 99.66116 628.35008 99.72116 630.13348 99.75815 631.23346 curveto

 100.16579 643.34996 100.92691 666.49567 101.33757 679.2778 curveto

 101.3729 680.37778 101.43018 682.16118 101.4655 683.26115 curveto

 101.87614 696.04329 102.6373 720.26768 103.05077 733.7295 curveto

 103.08453 734.82948 103.13928 736.61288 103.17305 737.71286 curveto

 103.58653 751.17468 104.34769 776.50024 104.76378 790.65533 curveto

 104.7961 791.75557 104.84851 793.5394 104.88083 794.63965 curveto

 105.2969 808.79471 106.05806 835.24405 106.47661 850.10707 curveto

 106.50757 851.20732 106.55779 852.99115 106.58875 854.09138 curveto

 107.00728 868.95439 107.76845 896.5507 108.1893 912.13573 curveto

 108.21896 913.23596 108.26714 915.01979 108.2968 916.12004 curveto

 108.71767 931.70508 109.4788 960.47018 109.90182 976.79128 curveto

 109.93031 977.89151 109.97653 979.67534 110.00502 980.77559 curveto

 110.42804 997.09666 111.1892 1027.05357 111.61424 1044.12486 curveto

 111.6416 1045.2251 111.68599 1047.00894 111.71336 1048.10918 curveto

 112.13841 1065.18047 113.37418 1116.17952 113.37418 1116.17952 curveto

 pgfstr

 save

 1.49442 pgfw

 /pgfsc{}def/pgffc{}def

 1 0 0 setrgbcolor

 0.0 0.0 moveto

 59.52802 0.0 lineto

 pgfstr

 restore

 save

 1.49442 pgfw

 /pgfsc{}def/pgffc{}def

 1 0 0 setrgbcolor

 -59.52802 0.0 moveto

 -59.86711 0.0 lineto

 -58.76665 0.0 -56.98248 0.0 -55.882 0.0 curveto

 -58.21367 0.0 lineto

 -57.1132 0.0 -55.32904 0.0 -54.22856 0.0 curveto

 -56.5602 0.0 lineto

 -55.45973 0.0 -53.67557 0.0 -52.57509 0.0 curveto

 -54.90675 0.0 lineto

 -53.80629 0.0 -52.02213 0.0 -50.92165 0.0 curveto

 -53.2533 0.0 lineto

 -52.15283 0.0 -50.36867 0.0 -49.26819 0.0 curveto

 -51.59984 0.0 lineto

 -50.49937 0.0 -48.71521 0.0 -47.61473 0.0 curveto

 -49.94638 0.0 lineto

 -48.84592 0.0 -47.06175 0.0 -45.96127 0.0 curveto

 -48.29292 0.0 lineto

 -47.19246 0.0 -45.40828 0.0 -44.30782 0.0 curveto

 -46.63948 0.0 lineto

 -45.539 0.0 -43.75484 0.0 -42.65437 0.0 curveto

 -44.98602 0.0 lineto

 -43.88554 0.0 -42.10138 0.0 -41.00092 0.0 curveto

 -43.33257 0.0 lineto

 -42.23209 0.0 -40.44792 0.0 -39.34746 0.0 curveto

 -41.67911 0.0 lineto

 -40.57863 0.0 -38.79446 0.0 -37.694 0.0 curveto

 -40.02565 0.0 lineto

 -38.92517 0.0 -37.141 0.0 -36.04054 0.0 curveto

 -38.3722 0.0 lineto

 -37.27171 0.0 -35.48755 0.0 -34.38708 0.0 curveto

 -36.71875 0.0 lineto

 -35.61827 0.0 -33.8341 0.0 -32.73364 0.0 curveto

 -35.06529 0.0 lineto

 -33.96481 0.0 -32.18065 0.0 -31.08018 0.0 curveto

 -33.41183 0.0 lineto

 -32.31136 0.0 -30.52719 0.0 -29.42673 0.0 curveto

 -31.75836 0.0 lineto

 -30.6579 0.0 -28.87373 0.0 -27.77325 0.0 curveto

 -30.1049 0.0 lineto

 -29.00444 0.0 -27.22028 0.0 -26.1198 0.0 curveto

 -28.45146 0.0 lineto

 -27.351 0.0 -25.56683 0.0 -24.46635 0.0 curveto

 -26.79799 0.0 lineto

 -25.69753 0.0 -23.91336 0.0 -22.81288 0.0 curveto

 -25.14455 0.0 lineto

 -24.04408 0.0 -22.25992 0.0 -21.15944 0.0 curveto

 -23.49109 0.0 lineto

 -22.39063 0.0 -20.60646 0.0 -19.50598 0.0 curveto

 -19.84508 0.0 lineto

 pgfstr

 restore

 save

 /pgfsc{}def/pgffc{}def

 0 0 1 setrgbcolor

 -55.95316 -160.28648 moveto

 -55.95316 -160.28648 -54.71739 -154.01724 -54.63403 -153.60126 curveto

 -54.41795 -152.52217 -54.06758 -150.77263 -53.8515 -149.69356 curveto

 -53.76816 -149.27757 -53.007 -145.5213 -52.93298 -145.16017 curveto

 -52.71176 -144.08109 -52.35306 -142.33156 -52.13184 -141.25247 curveto

 -52.05779 -140.89137 -51.29663 -137.2229 -51.23225 -136.91652 curveto

 -51.00569 -135.83743 -50.63835 -134.0879 -50.41177 -133.00882 curveto

 -50.34741 -132.70244 -49.58626 -129.12152 -49.53125 -128.86613 curveto

 -49.2995 -127.78915 -48.92377 -126.04306 -48.69203 -124.9661 curveto

 -48.63704 -124.7107 -47.87587 -121.21808 -47.83075 -121.01358 curveto

 -47.59355 -119.93883 -47.20897 -118.19632 -46.97179 -117.12157 curveto

 -46.92665 -116.91705 -46.16551 -113.51242 -46.13156 -113.36275 curveto

 -45.8882 -112.288 -45.49359 -110.54549 -45.25021 -109.47073 curveto

 -45.21626 -109.32104 -44.45512 -106.00418 -44.4321 -105.90515 curveto

 -44.1827 -104.8327 -43.77832 -103.09393 -43.52892 -102.02147 curveto

 -43.50589 -101.92245 -42.74475 -98.6937 -42.73416 -98.64946 curveto

 -42.47789 -97.57701 -42.0624 -95.83824 -41.80612 -94.76578 curveto

 -41.79552 -94.72154 -41.03438 -91.5803 -41.03587 -91.58653 curveto

 -40.77293 -90.51646 -40.34659 -88.78156 -40.08366 -87.71149 curveto

 -40.08514 -87.71771 -39.32399 -84.66455 -39.3383 -84.72118 curveto

 -39.06828 -83.65358 -38.63046 -81.92268 -38.36046 -80.85507 curveto

 -38.37476 -80.9117 -37.6136 -77.94656 -37.6414 -78.05338 curveto

 -37.36394 -76.98833 -36.91406 -75.26157 -36.63658 -74.19652 curveto

 -36.66438 -74.30333 -35.90323 -71.42598 -35.94664 -71.58762 curveto

 -35.66055 -70.52257 -35.19667 -68.7958 -34.91058 -67.73074 curveto

 -34.95401 -67.8924 -34.19286 -65.1031 -34.25154 -65.31479 curveto

 -33.95702 -64.25237 -33.47949 -62.52989 -33.18497 -61.46747 curveto

 -33.24364 -61.67917 -32.48248 -58.97768 -32.55736 -59.23926 curveto

 -32.25388 -58.17955 -31.76186 -56.46144 -31.45837 -55.40173 curveto

 -31.53325 -55.6633 -30.77211 -53.0496 -30.8643 -53.36093 curveto

 -30.55127 -52.30403 -30.04372 -50.59045 -29.7307 -49.53355 curveto

 -29.82289 -49.8449 -29.06172 -47.31923 -29.17242 -47.68025 curveto

 -28.84917 -46.6262 -28.32504 -44.91727 -28.00179 -43.86322 curveto

 -28.11249 -44.22423 -27.35135 -41.7866 -27.48187 -42.19713 curveto

 -27.14767 -41.14601 -26.60579 -39.44185 -26.27158 -38.39073 curveto

 -26.40211 -38.80125 -25.64098 -36.45137 -25.79094 -36.90569 curveto

 -25.44598 -35.86067 -24.88673 -34.16638 -24.54182 -33.12137 curveto

 -24.69174 -33.57565 -23.9306 -31.31386 -24.10335 -31.81732 curveto

 -23.74583 -30.77542 -23.16614 -29.08621 -22.8086 -28.04431 curveto

 -22.98137 -28.54779 -22.22023 -26.3738 -22.41762 -26.92621 curveto

 -22.04648 -25.88753 -21.44472 -24.20355 -21.07358 -23.16487 curveto

 -21.27098 -23.7173 -20.50983 -21.63112 -20.73175 -22.22644 curveto

 -20.34708 -21.19435 -19.7234 -19.52104 -19.33876 -18.48894 curveto

 -19.56061 -19.08426 -18.79945 -17.08612 -19.05023 -17.73012 curveto

 -18.64961 -16.70142 -18.00008 -15.03362 -17.59944 -14.00491 curveto

 -17.85023 -14.64891 -17.08908 -12.73856 -17.36897 -13.42479 curveto

 -16.95227 -12.40305 -16.27667 -10.74649 -15.85999 -9.72475 curveto

 -16.13986 -10.411 -15.37871 -8.58867 -15.69037 -9.31685 curveto

 -15.25612 -8.30223 -14.55208 -6.65726 -14.11784 -5.64265 curveto

 -14.42949 -6.37082 -13.66832 -4.63655 -14.01186 -5.39948 curveto

 -13.56 -4.39594 -12.82741 -2.76889 -12.37555 -1.76535 curveto

 -12.71909 -2.52826 -11.95796 -0.88158 -12.33975 -1.68552 curveto

 -11.86678 -0.68959 -11.09991 0.92513 -10.62695 1.92105 curveto

 -11.00873 1.11713 -10.24757 2.67581 -10.66861 1.83807 curveto

 -10.17397 2.82236 -9.37195 4.41817 -8.87729 5.40245 curveto

 -9.29834 4.56473 -8.5372 6.03511 -9.0018 5.16418 curveto

 -8.4831 6.13654 -7.64206 7.71297 -7.12332 8.68532 curveto

 -7.58797 7.81438 -6.82683 9.19728 -7.34064 8.29364 curveto

 -6.79472 9.2538 -5.90967 10.81049 -5.3638 11.77065 curveto

 -5.8776 10.86699 -5.11644 12.16182 -5.68155 11.23323 curveto

 -5.10733 12.17686 -4.17635 13.70677 -3.60213 14.65039 curveto

 -4.16722 13.7218 -3.40607 14.92856 -4.02481 13.98314 curveto

 -3.42097 14.9058 -2.44193 16.40175 -1.83809 17.32442 curveto

 -2.45683 16.37897 -1.69568 17.49823 -2.37677 16.53625 curveto

 -1.7385 17.43777 -0.70364 18.89944 -0.06537 19.80096 curveto

 -0.74646 18.839 0.01465 19.86993 -0.72806 18.90672 curveto

 -0.05574 19.77863 1.03427 21.19226 1.70659 22.06418 curveto

 0.96387 21.10098 1.72504 22.04414 0.90814 21.07918 curveto

 1.62141 21.92181 2.7779 23.28795 3.4912 24.13058 curveto

 2.67427 23.16562 3.4354 24.02098 2.54092 23.06781 curveto

 3.29706 23.87364 4.52298 25.18016 5.27911 25.98598 curveto

 4.38464 25.0328 5.14578 25.80011 4.17578 24.87804 curveto

 4.97362 25.63641 6.26717 26.86601 7.065 27.62442 curveto

 6.09502 26.7023 6.85616 27.38177 5.79753 26.49763 curveto

 6.64432 27.20482 8.01721 28.35138 8.86401 29.05856 curveto

 7.80539 28.17441 8.56653 28.76608 7.41646 27.93843 curveto

 8.31375 28.58414 9.76855 29.63101 10.66585 30.27667 curveto

 9.51576 29.44907 10.27692 29.95274 9.04292 29.20741 curveto

 9.98657 29.77734 11.5165 30.7014 12.46014 31.27136 curveto

 11.22614 30.52599 11.9873 30.94164 10.66557 30.296 curveto

 11.65767 30.7806 13.26613 31.56627 14.25822 32.05086 curveto

 12.93652 31.40523 13.69768 31.7331 12.30354 31.21315 curveto

 13.33563 31.59805 15.00896 32.22209 16.04105 32.607 curveto

 14.6469 32.08705 15.40805 32.3268 13.9496 31.9512 curveto

 15.01721 32.22614 16.74811 32.67189 17.8157 32.94681 curveto

 16.35727 32.57121 17.11842 32.72346 15.61974 32.5107 curveto

 16.70956 32.6654 18.47652 32.91628 19.56635 33.07098 curveto

 18.06767 32.85822 18.8288 32.92213 17.31126 32.88213 curveto

 18.4115 32.91113 20.19533 32.95818 21.29558 32.98715 curveto

 19.77803 32.94717 20.53918 32.92337 19.02759 33.0581 curveto

 20.12456 32.96034 21.90303 32.80182 23.0 32.70409 curveto

 21.48842 32.83878 22.24956 32.72688 20.77032 33.02963 curveto

 21.8494 32.80879 23.59894 32.45073 24.67802 32.22989 curveto

 23.19879 32.53264 23.95993 32.333 22.5368 32.78864 curveto

 23.5849 32.45306 25.28421 31.90904 26.3323 31.57352 curveto

 24.90916 32.02911 25.67032 31.74136 24.31442 32.33206 curveto

 25.32538 31.89165 26.96446 31.17764 27.97542 30.73729 curveto

 26.61954 31.32791 27.38069 30.95259 26.10939 31.65314 curveto

 27.07364 31.12181 28.63698 30.26036 29.60123 29.72903 curveto

 28.32991 30.4296 29.09106 29.96622 27.90268 30.7585 curveto

 28.82114 30.14621 30.31023 29.15349 31.22868 28.5412 curveto

 30.04028 29.33348 30.80145 28.78214 29.70493 29.64 curveto

 30.57265 28.9612 31.97946 27.86064 32.84718 27.18187 curveto

 31.75067 28.03966 32.51183 27.40028 31.49802 28.31052 curveto

 32.32005 27.57251 33.65285 26.37593 34.47487 25.63788 curveto

 33.46104 26.54817 34.2222 25.82095 33.29192 26.76324 curveto

 34.06783 25.97728 35.3258 24.70302 36.1017 23.91707 curveto

 35.17143 24.85934 35.93257 24.04463 35.08168 25.00482 curveto

 35.81374 24.17868 37.00066 22.83926 37.73271 22.01312 curveto

 36.88182 22.97331 37.64294 22.06998 36.8669 23.03535 curveto

 37.55763 22.17606 38.67749 20.78287 39.36818 19.92357 curveto

 38.59218 20.88895 39.35333 19.89816 38.64432 20.8622 curveto

 39.29802 19.97339 40.35788 18.53233 41.0116 17.64351 curveto

 40.30257 18.60756 41.06372 17.52866 40.41605 18.48387 curveto

 41.03586 17.56963 42.04079 16.08742 42.66061 15.17317 curveto

 42.01294 16.12839 42.7741 14.96175 42.18396 15.90027 curveto

 42.772 14.96498 43.72539 13.44862 44.3134 12.51334 curveto

 43.72331 13.45184 44.48447 12.19708 43.94879 13.11098 curveto

 44.50676 12.15906 45.41138 10.61566 45.96931 9.66373 curveto

 45.43369 10.57762 46.19484 9.23537 45.70686 10.12405 curveto

 46.2385 9.15576 47.10042 7.58586 47.63205 6.61757 curveto

 47.14407 7.50627 47.90521 6.07565 47.46358 6.93126 curveto

 47.9696 5.95094 48.79004 4.36154 49.29605 3.38123 curveto

 48.85443 4.23683 49.6156 2.7185 49.21506 3.54059 curveto

 49.6984 2.5485 50.48204 0.94003 50.96538 -0.05205 curveto

 50.56483 0.77003 51.32597 -0.83629 50.96567 -0.05516 curveto

 51.42677 -1.05492 52.17441 -2.67584 52.63551 -3.6756 curveto

 52.2752 -2.89449 53.03635 -4.58894 52.70943 -3.8423 curveto

 53.15211 -4.85326 53.86981 -6.4923 54.31248 -7.50325 curveto

 53.98558 -6.75662 54.74673 -8.53836 54.45291 -7.83337 curveto

 54.8773 -8.85158 55.5654 -10.50238 55.9898 -11.52058 curveto

 55.69597 -10.81561 56.45709 -12.68568 56.19348 -12.02283 curveto

 56.6012 -13.04808 57.26224 -14.71033 57.66995 -15.73558 curveto

 57.40634 -15.07272 58.1675 -17.03073 57.93399 -16.41653 curveto

 58.32506 -17.44524 58.95914 -19.11304 59.3502 -20.14175 curveto

 59.11671 -19.52753 59.87787 -21.5736 59.6697 -21.002 curveto

 60.04677 -22.0374 60.65819 -23.71613 61.03528 -24.75154 curveto

 60.82709 -24.17995 61.58824 -26.31357 61.40349 -25.785 curveto

 61.76765 -26.8269 62.35803 -28.51613 62.72214 -29.55801 curveto

 62.53746 -29.02948 63.29861 -31.2512 63.13754 -30.77182 curveto

 63.48862 -31.81683 64.05783 -33.51112 64.40889 -34.55614 curveto

 64.24783 -34.07675 65.009 -36.38625 64.8699 -35.9561 curveto

 65.20885 -37.00421 65.75836 -38.70352 66.0973 -39.75162 curveto

 65.95824 -39.32146 66.71938 -41.71896 66.6007 -41.33824 curveto

 66.92836 -42.38936 67.45963 -44.09352 67.78728 -45.14464 curveto

 67.66861 -44.7639 68.42975 -47.24947 68.3301 -46.91823 curveto

 68.64725 -47.97227 69.16147 -49.68121 69.47862 -50.73526 curveto

 69.37898 -50.40402 70.14012 -52.97739 70.05823 -52.69576 curveto

 70.36559 -53.75266 70.8639 -55.46622 71.17126 -56.52312 curveto

 71.08937 -56.2415 71.8505 -58.90271 71.78526 -58.67079 curveto

 72.0834 -59.73051 72.56683 -61.44861 72.86497 -62.50832 curveto

 72.79973 -62.2764 73.5609 -65.02536 73.51134 -64.84341 curveto

 73.80083 -65.90582 74.27019 -67.62831 74.5597 -68.69072 curveto

 74.51012 -68.50879 75.27127 -71.34604 75.23645 -71.21419 curveto

 75.51779 -72.27924 75.97395 -74.00601 76.2553 -75.07106 curveto

 76.22049 -74.9392 76.98164 -77.86421 76.96071 -77.78252 curveto

 77.23439 -78.85011 77.67813 -80.58101 77.95181 -81.64862 curveto

 77.93086 -81.56691 78.69202 -84.57974 78.68423 -84.5484 curveto

 78.95065 -85.61847 79.38261 -87.35338 79.64905 -88.42345 curveto

 79.64124 -88.39209 80.40239 -91.49295 80.4081 -91.51646 curveto

 80.66705 -92.58653 81.08694 -94.32144 81.3459 -95.39151 curveto

 81.35162 -95.41502 82.11276 -98.60399 82.1302 -98.67793 curveto

 82.38269 -99.75038 82.79208 -101.48917 83.04457 -102.56161 curveto

 83.062 -102.63554 83.82315 -105.91176 83.85167 -106.03636 curveto

 84.09804 -107.11111 84.49748 -108.85362 84.74385 -109.92838 curveto

 84.77238 -110.05296 85.53352 -113.41776 85.57362 -113.59726 curveto

 85.8136 -114.67201 86.2027 -116.41452 86.44269 -117.48927 curveto

 86.48276 -117.66878 87.2439 -121.12128 87.29402 -121.35156 curveto

 87.52847 -122.42853 87.90858 -124.17464 88.14302 -125.2516 curveto

 88.19313 -125.48187 88.95428 -129.02219 89.01486 -129.30728 curveto

 89.24353 -130.38425 89.61427 -132.13034 89.84294 -133.2073 curveto

 89.90352 -133.49242 90.66466 -137.12085 90.73433 -137.4569 curveto

 90.95796 -138.53596 91.32059 -140.2855 91.54422 -141.3646 curveto

 91.61388 -141.70062 92.37505 -145.41656 92.45415 -145.80743 curveto

 92.67258 -146.8865 93.02672 -148.63605 93.24515 -149.71512 curveto

 93.32426 -150.106 94.08542 -153.91026 94.17285 -154.35231 curveto

 94.38667 -155.43343 94.73337 -157.18625 94.94719 -158.26736 curveto

 95.03464 -158.70943 95.79579 -162.60138 95.89188 -163.09827 curveto

 96.10094 -164.17938 96.43988 -165.9322 96.64894 -167.01332 curveto

 96.74501 -167.5102 97.50616 -171.49026 97.60992 -172.03845 curveto

 97.81474 -173.1215 98.14684 -174.87746 98.35165 -175.96051 curveto

 98.4554 -176.5087 99.21654 -180.57652 99.32817 -181.17953 curveto

 99.52864 -182.26259 99.85368 -184.01854 100.05415 -185.1016 curveto

 100.16579 -185.7046 100.92691 -189.86053 101.04614 -190.51834 curveto

 101.24242 -191.6014 101.56065 -193.35735 101.75693 -194.4404 curveto

 101.87614 -195.09819 102.6373 -199.34161 102.76324 -200.0509 curveto

 102.9558 -201.1358 103.26802 -202.89473 103.46059 -203.97963 curveto

 103.58653 -204.68892 104.34769 -209.02069 104.48062 -209.78484 curveto

 104.66933 -210.86974 104.97528 -212.62866 105.16399 -213.71358 curveto

 105.2969 -214.4777 106.05806 -218.89719 106.19777 -219.71616 curveto

 106.38272 -220.80107 106.68263 -222.56 106.86757 -223.6449 curveto

 107.00728 -224.46387 107.76845 -228.97142 107.91405 -229.84204 curveto

 108.09575 -230.92868 108.39035 -232.69048 108.57205 -233.77711 curveto

 108.71767 -234.64772 109.4788 -239.24313 109.63066 -240.16849 curveto

 109.80891 -241.25513 110.09793 -243.01692 110.2762 -244.10356 curveto

 110.42804 -245.02892 111.1892 -249.71187 111.34702 -250.69205 curveto

 111.52196 -251.77869 111.80562 -253.54047 111.98055 -254.6271 curveto

 112.13841 -255.6073 113.37418 -263.38116 113.37418 -263.38116 curveto

 pgfstr

 restore

 49.60667 39.68535 moveto

 pgfstr

 save

 save

 [1.0 0.0 0.0 1.0 52.72803 29.5901 ] concat

 pgfs



 0 setgray
 2984 137 a Fg(C)3045 151 y Fe(f)2984
137 y


 pgfr

 restore

 restore

 save

 /pgfsc{}def/pgffc{}def

 0 0 1 setrgbcolor

 53.57515 -49.60667 moveto

 pgfstr

 save

 save

 [1.0 0.0 0.0 1.0 56.6965 -59.70195 ] concat

 pgfs



 0 0 1 setrgbcolor
 2984 137 a Fg(C)3040 149 y Fe(g)2984 137 y


 pgfr

 restore

 restore

 restore

 save

 1.19553 pgfw

 /pgfsc{}def/pgffc{}def

 0 setgray

 -19.84267 -19.84267 moveto

 -19.47975 -19.47981 lineto

 -20.25792 -20.25795 -20.25792 -20.25795 -19.47975 -19.47981 curveto

 -18.79659 -18.79659 lineto

 -20.88876 -18.79659 moveto

 -18.79659 -20.88876 lineto

 pgfstr

 restore

 save

 1.19553 pgfw

 /pgfsc{}def/pgffc{}def

 0 setgray

 0.0 19.84267 moveto

 0.36293 20.20554 lineto

 -0.41524 19.4274 -0.41524 19.4274 0.36293 20.20554 curveto

 1.04607 20.88876 lineto

 -1.04607 20.88876 moveto

 1.04607 18.79659 lineto

 pgfstr

 restore

 save

 1.19553 pgfw

 /pgfsc{}def/pgffc{}def

 0 setgray

 59.52802 -19.84267 moveto

 59.89095 -19.47981 lineto

 59.11278 -20.25795 59.11278 -20.25795 59.89095 -19.47981 curveto

 60.57411 -18.79659 lineto

 58.48195 -18.79659 moveto

 60.57411 -20.88876 lineto

 pgfstr

 restore

 restore

 newpath

 restore

 pgfc


 2128
933 a Fm(On)20 b(lit)i(les)f(abscisses)h(des)f(points)h(de)f
Fg(C)3343 947 y Fe(f)3401 933 y Fm(situ\351s)h(en)f(dessous)2128
1033 y(ou)c(sur)h(la)f(courbe)g Fg(C)2756 1045 y Fe(g)2128
1166 y Fm(L)-10 b('ensemble)19 b(des)f(solutions)h(de)25
b Fo(f)19 b Fm(\()r Fo(x)5 b Fm(\))14 b Fj(\267)i Fo(g)10
b Fm(\()r Fo(x)5 b Fm(\))17 b(est)3624 1167 y(])3650
1166 y Fj(\2411)8 b Fm(;)g Fj(\241)p Fm(1)3914 1167 y(])3950
1166 y Fj([)2128 1266 y Fm([)2153 1265 y(0)g(;)g(3)2269
1266 y(])2296 1265 y(.)-248 402 y


 pgfr

 restore

 restore

 restore

 newpath

 restore

 pgfc


 -248 2817 a

 -248 2817
a -248 2817 a


 pgfo

 save

 0 setgray

 0.3985 pgfw

 save

 save

 /pgffc{0 0 0.3 0 setcmykcolor}def

 save

 /pgffc{0 0 0.3 0 setcmykcolor}def

 43.61296 15.05972 moveto

 2.1918 15.05972 lineto

 1.09132 15.05972 0.19925 14.16765 0.19925 13.06717 curveto

 0.19925 2.1918 lineto

 0.19925 1.09132 1.09132 0.19925 2.1918 0.19925 curveto

 43.61296 0.19925 lineto

 44.71344 0.19925 45.60551 1.09132 45.60551 2.1918 curveto

 45.60551 13.06717 lineto

 45.60551 14.16765 44.71344 15.05972 43.61296 15.05972 curveto

 closepath

 0.19925 0.19925 moveto

 gsave pgffc pgffill grestore newpath

 restore

 save

 [1.0 0.0 0.0 1.0 3.12134 5.28822 ] concat

 pgfs



 0 setgray
 -248 2817 a Fo(Exemple)17 b(:)-248 2817
y


 pgfr

 restore

 restore

 save

 /pgffc{0 0 0.3 0 setcmykcolor}def

 save

 /pgffc{0 0 0.3 0 setcmykcolor}def

 514.2937 -0.19925 moveto

 2.1918 -0.19925 lineto

 1.09132 -0.19925 0.19925 -1.09132 0.19925 -2.1918 curveto

 0.19925 -103.77528 lineto

 0.19925 -104.87575 1.09132 -105.76784 2.1918 -105.76784 curveto

 514.2937 -105.76784 lineto

 515.39417 -105.76784 516.28625 -104.87575 516.28625 -103.77528 curveto

 516.28625 -2.1918 lineto

 516.28625 -1.09132 515.39417 -0.19925 514.2937 -0.19925 curveto

 closepath

 0.19925 -105.76784 moveto

 gsave pgffc pgffill grestore newpath

 restore

 save

 [1.0 0.0 0.0 1.0 3.12134 -55.56389 ] concat

 pgfs



 0 setgray
 -246 2382 a

 -246 2382 a -246 2382 a


 pgfo

 save

 0 setgray

 0.3985 pgfw

 save

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 save

 [1.0 0.0 0.0 1.0 20.04227 -12.17342 ] concat

 pgfs



 0 setgray
 -78 2382 a Fo(x)-246
2382 y


 pgfr

 restore

 restore

 save

 save

 [1.0 0.0 0.0 1.0 20.04227 -33.81682 ] concat

 pgfs



 0 setgray
 -138 2382 a Fd(signe)-182 2481 y(de)26 b Fb(x)17
b Fa(\241)11 b Fd(2)-246 2382 y


 pgfr

 restore

 restore

 save

 save

 [1.0 0.0 0.0 1.0 20.04227 -59.9267 ] concat

 pgfs



 0 setgray
 -189 2382 a Fd(signe)24
b(de)-157 2481 y Fa(\241)q Fb(x)18 b Fa(\241)11 b Fd(3)-246
2382 y


 pgfr

 restore

 restore

 save

 save

 [1.0 0.0 0.0 1.0 20.04227 -85.72273 ] concat

 pgfs



 0 setgray
 -192 2382 a Fd(signe)24 b(du)-174 2481 y(produit)-246
2382 y


 pgfr

 restore

 restore

 save

 0.3985 pgfw

 39.68607 0.0 moveto

 39.68607 -92.27032 lineto

 pgfstr

 restore

 save

 0.3985 pgfw

 0.0 -14.88226 moveto

 148.82283 -14.88226 lineto

 pgfstr

 restore

 save

 0.3985 pgfw

 0.0 -40.67828 moveto

 148.82283 -40.67828 lineto

 pgfstr

 restore

 save

 0.3985 pgfw

 0.0 -66.4743 moveto

 148.82283 -66.4743 lineto

 pgfstr

 restore

 save

 save

 [1.0 0.0 0.0 1.0 52.7284 -14.697 ] concat

 pgfs



 0 setgray
 -246 2382 a Fj(\2411)-246 2382 y


 pgfr

 restore

 restore

 save

 save

 [1.0 0.0 0.0 1.0 82.49242 -16.69951 ] concat

 pgfs



 0 setgray
 -246 2382 a Fj(\241)p
Fm(3)-246 2382 y


 pgfr

 restore

 restore

 save

 save

 [1.0 0.0 0.0 1.0 112.25647 -16.69951 ] concat

 pgfs



 0 setgray
 -246 2382 a Fm(2)-246 2382 y


 pgfr

 restore

 restore

 save

 save

 [1.0 0.0 0.0 1.0 142.0205 -15.74309 ] concat

 pgfs



 0 setgray
 -246 2382
a Fj(\3051)-246 2382 y


 pgfr

 restore

 restore

 save

 restore

 save

 restore

 save

 save

 [1.0 0.0 0.0 1.0 67.61359 -33.75195 ] concat

 pgfs



 0 setgray
 -246 2382 a Fj(\241)-246 2382
y


 pgfr

 restore

 restore

 save

 restore

 save

 0.3985 pgfw

 [ 0.3985 1.99255 ] 0.0 setdash

 /pgfsc{0 setgray}def

 79.37216 -14.88226 moveto

 79.37216 -40.67828 lineto

 gsave pgfsc pgfstr grestore newpath

 restore

 save

 restore

 save

 save

 [1.0 0.0 0.0 1.0 97.37926 -33.75195 ] concat

 pgfs



 0 setgray
 -246 2382 a Fj(\241)-246 2382 y


 pgfr

 restore

 restore

 save

 restore

 save

 0.3985 pgfw

 [ 0.3985 1.99255 ] 0.0 setdash

 /pgfsc{0 setgray}def

 109.13673 -14.88226 moveto

 109.13673 -40.67828 lineto

 gsave pgfsc pgfstr grestore newpath

 restore

 save

 save

 [1.0 0.0 0.0 1.0 112.26009 -37.03915 ] concat

 pgfs



 0 setgray
 -246 2382 a Fm(0)-246
2382 y


 pgfr

 restore

 restore

 save

 restore

 save

 save

 [1.0 0.0 0.0 1.0 127.14494 -36.08324 ] concat

 pgfs



 0 setgray
 -246 2382 a Fj(\305)-246 2382 y


 pgfr

 restore

 restore

 save

 restore

 save

 restore

 save

 save

 [1.0 0.0 0.0 1.0 67.61359 -61.88022 ] concat

 pgfs



 0 setgray
 -246 2382 a Fj(\305)-246
2382 y


 pgfr

 restore

 restore

 save

 restore

 save

 0.3985 pgfw

 [ 0.3985 1.99255 ] 0.0 setdash

 /pgfsc{0 setgray}def

 79.37216 -40.67828 moveto

 79.37216 -66.4743 lineto

 gsave pgfsc pgfstr grestore newpath

 restore

 save

 save

 [1.0 0.0 0.0 1.0 82.49498 -62.83565 ] concat

 pgfs



 0 setgray
 -246 2382 a Fm(0)-246 2382 y


 pgfr

 restore

 restore

 save

 restore

 save

 save

 [1.0 0.0 0.0 1.0 97.37926 -59.54893 ] concat

 pgfs



 0 setgray
 -246 2382 a Fj(\241)-246
2382 y


 pgfr

 restore

 restore

 save

 restore

 save

 0.3985 pgfw

 [ 0.3985 1.99255 ] 0.0 setdash

 /pgfsc{0 setgray}def

 109.13673 -40.67828 moveto

 109.13673 -66.4743 lineto

 gsave pgfsc pgfstr grestore newpath

 restore

 save

 restore

 save

 save

 [1.0 0.0 0.0 1.0 127.14494 -59.54893 ] concat

 pgfs



 0 setgray
 -246 2382 a Fj(\241)-246 2382 y


 pgfr

 restore

 restore

 save

 restore

 save

 restore

 save

 save

 [1.0 0.0 0.0 1.0 67.61359 -85.34592 ] concat

 pgfs



 0 setgray
 -246 2382 a Fj(\241)-246
2382 y


 pgfr

 restore

 restore

 save

 restore

 save

 0.3985 pgfw

 [ 0.3985 1.99255 ] 0.0 setdash

 /pgfsc{0 setgray}def

 79.37216 -66.4743 moveto

 79.37216 -92.27032 lineto

 gsave pgfsc pgfstr grestore newpath

 restore

 save

 save

 [1.0 0.0 0.0 1.0 82.49498 -88.63216 ] concat

 pgfs



 0 setgray
 -246 2382 a Fm(0)-246 2382 y


 pgfr

 restore

 restore

 save

 restore

 save

 save

 [1.0 0.0 0.0 1.0 97.37926 -87.6772 ] concat

 pgfs



 0 setgray
 -246 2382 a Fj(\305)-246
2382 y


 pgfr

 restore

 restore

 save

 restore

 save

 0.3985 pgfw

 [ 0.3985 1.99255 ] 0.0 setdash

 /pgfsc{0 setgray}def

 109.13673 -66.4743 moveto

 109.13673 -92.27032 lineto

 gsave pgfsc pgfstr grestore newpath

 restore

 save

 save

 [1.0 0.0 0.0 1.0 112.26009 -88.63216 ] concat

 pgfs



 0 setgray
 -246 2382 a Fm(0)-246 2382 y


 pgfr

 restore

 restore

 save

 restore

 save

 save

 [1.0 0.0 0.0 1.0 127.14494 -85.34592 ] concat

 pgfs



 0 setgray
 -246 2382 a Fj(\241)-246
2382 y


 pgfr

 restore

 restore

 restore

 newpath

 restore

 pgfc


 -248 2817 a


 pgfr

 restore

 restore

 restore

 newpath

 restore

 pgfc


 -222 3970 a

 -222 3970 a -222 3970
a


 pgfo

 save

 0 setgray

 0.3985 pgfw

 save

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 save

 [1.0 0.0 0.0 1.0 -2.8345 -9.6404 ] concat

 pgfs



 0 setgray
 -54 3970 a Fo(x)-222 3970 y


 pgfr

 restore

 restore

 save

 save

 [1.0 0.0 0.0 1.0 -2.8345 -24.66081 ] concat

 pgfs



 0 setgray
 -115 3970 a Fd(signe)-158
4070 y(de)i Fb(x)16 b Fa(\241)11 b Fd(2)-222 3970 y


 pgfr

 restore

 restore

 save

 save

 [1.0 0.0 0.0 1.0 -2.8345 -50.61377 ] concat

 pgfs



 0 setgray
 -165
3970 a Fd(signe)24 b(de)-133 4070 y Fa(\241)q Fb(x)18
b Fa(\241)11 b Fd(3)-222 3970 y


 pgfr

 restore

 restore

 save

 save

 [1.0 0.0 0.0 1.0 -2.8345 -75.54677 ] concat

 pgfs



 0 setgray
 -168 3970 a Fd(signe)23
b(du)-150 4070 y(produit)-222 3970 y


 pgfr

 restore

 restore

 save

 0.3985 pgfw

 39.68607 0.0 moveto

 39.68607 -92.27032 lineto

 pgfstr

 restore

 save

 0.3985 pgfw

 0.0 -14.88226 moveto

 148.82283 -14.88226 lineto

 pgfstr

 restore

 save

 0.3985 pgfw

 0.0 -40.67828 moveto

 148.82283 -40.67828 lineto

 pgfstr

 restore

 save

 0.3985 pgfw

 0.0 -66.4743 moveto

 148.82283 -66.4743 lineto

 pgfstr

 restore

 save

 save

 [1.0 0.0 0.0 1.0 41.63185 -9.47353 ] concat

 pgfs



 0 setgray
 -222 3970 a Fj(\2411)-222
3970 y


 pgfr

 restore

 restore

 save

 save

 [1.0 0.0 0.0 1.0 73.6425 -10.48474 ] concat

 pgfs



 0 setgray
 -222 3970 a Fj(\241)p Fm(3)-222 3970 y


 pgfr

 restore

 restore

 save

 save

 [1.0 0.0 0.0 1.0 106.70421 -10.50964 ] concat

 pgfs



 0 setgray
 -222 3970
a Fm(2)-222 3970 y


 pgfr

 restore

 restore

 save

 save

 [1.0 0.0 0.0 1.0 130.92397 -9.99657 ] concat

 pgfs



 0 setgray
 -222 3970 a Fj(\3051)-222 3970 y


 pgfr

 restore

 restore

 save

 restore

 save

 restore

 save

 save

 [1.0 0.0 0.0 1.0 61.19456 -29.20595 ] concat

 pgfs



 0 setgray
 -222
3970 a Fj(\241)-222 3970 y


 pgfr

 restore

 restore

 save

 restore

 save

 0.3985 pgfw

 [ 0.3985 1.99255 ] 0.0 setdash

 /pgfsc{0 setgray}def

 79.37216 -14.88226 moveto

 79.37216 -40.67828 lineto

 gsave pgfsc pgfstr grestore newpath

 restore

 save

 restore

 save

 save

 [1.0 0.0 0.0 1.0 90.96024 -29.20595 ] concat

 pgfs



 0 setgray
 -222 3970 a Fj(\241)-222 3970
y


 pgfr

 restore

 restore

 save

 restore

 save

 0.3985 pgfw

 [ 0.3985 1.99255 ] 0.0 setdash

 /pgfsc{0 setgray}def

 109.13673 -14.88226 moveto

 109.13673 -40.67828 lineto

 gsave pgfsc pgfstr grestore newpath

 restore

 save

 save

 [1.0 0.0 0.0 1.0 106.70782 -30.82439 ] concat

 pgfs



 0 setgray
 -222 3970 a Fm(0)-222 3970 y


 pgfr

 restore

 restore

 save

 restore

 save

 save

 [1.0 0.0 0.0 1.0 120.72592 -30.33673 ] concat

 pgfs



 0 setgray
 -222 3970 a Fj(\305)-222
3970 y


 pgfr

 restore

 restore

 save

 restore

 save

 restore

 save

 save

 [1.0 0.0 0.0 1.0 61.19456 -56.13371 ] concat

 pgfs



 0 setgray
 -222 3970 a Fj(\305)-222 3970 y


 pgfr

 restore

 restore

 save

 restore

 save

 0.3985 pgfw

 [ 0.3985 1.99255 ] 0.0 setdash

 /pgfsc{0 setgray}def

 79.37216 -40.67828 moveto

 79.37216 -66.4743 lineto

 gsave pgfsc pgfstr grestore newpath

 restore

 save

 save

 [1.0 0.0 0.0 1.0 76.94272 -56.62088 ] concat

 pgfs



 0 setgray
 -222 3970 a Fm(0)-222
3970 y


 pgfr

 restore

 restore

 save

 restore

 save

 save

 [1.0 0.0 0.0 1.0 90.96024 -55.00293 ] concat

 pgfs



 0 setgray
 -222 3970 a Fj(\241)-222 3970 y


 pgfr

 restore

 restore

 save

 restore

 save

 0.3985 pgfw

 [ 0.3985 1.99255 ] 0.0 setdash

 /pgfsc{0 setgray}def

 109.13673 -40.67828 moveto

 109.13673 -66.4743 lineto

 gsave pgfsc pgfstr grestore newpath

 restore

 save

 restore

 save

 save

 [1.0 0.0 0.0 1.0 120.72592 -55.00293 ] concat

 pgfs



 0 setgray
 -222 3970 a Fj(\241)-222
3970 y


 pgfr

 restore

 restore

 save

 restore

 save

 restore

 save

 save

 [1.0 0.0 0.0 1.0 61.19456 -80.79991 ] concat

 pgfs



 0 setgray
 -222 3970 a Fj(\241)-222 3970 y


 pgfr

 restore

 restore

 save

 restore

 save

 0.3985 pgfw

 [ 0.3985 1.99255 ] 0.0 setdash

 /pgfsc{0 setgray}def

 79.37216 -66.4743 moveto

 79.37216 -92.27032 lineto

 gsave pgfsc pgfstr grestore newpath

 restore

 save

 save

 [1.0 0.0 0.0 1.0 76.94272 -82.4174 ] concat

 pgfs



 0 setgray
 -222 3970 a Fm(0)-222
3970 y


 pgfr

 restore

 restore

 save

 restore

 save

 save

 [1.0 0.0 0.0 1.0 90.96024 -81.9307 ] concat

 pgfs



 0 setgray
 -222 3970 a Fj(\305)-222 3970 y


 pgfr

 restore

 restore

 save

 restore

 save

 0.3985 pgfw

 [ 0.3985 1.99255 ] 0.0 setdash

 /pgfsc{0 setgray}def

 109.13673 -66.4743 moveto

 109.13673 -92.27032 lineto

 gsave pgfsc pgfstr grestore newpath

 restore

 save

 save

 [1.0 0.0 0.0 1.0 106.70782 -82.4174 ] concat

 pgfs



 0 setgray
 -222 3970 a Fm(0)-222
3970 y


 pgfr

 restore

 restore

 save

 restore

 save

 save

 [1.0 0.0 0.0 1.0 120.72592 -80.79991 ] concat

 pgfs



 0 setgray
 -222 3970 a Fj(\241)-222 3970 y


 pgfr

 restore

 restore

 restore

 newpath

 restore

 pgfc


 -217 4878 a @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.4 SLW 0 0 0.3 0  setcmykcolor  0.05 true 3.4
neg 5.57498 neg 47.24992 10.275 .5 Frame  gsave 0 0 0.3 0  setcmykcolor
 1. .setopacityalpha  fill  grestore gsave 0.4 SLW 0 0 0.3 0  setcmykcolor
 1. .setopacityalpha   0  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial 17 w Fo(Exemple)16 b(:)-217
5545 y @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.4 SLW 0 0 0.3 0  setcmykcolor  0.05 true 3.4
neg 67.16275 neg 519.6896 72.34274 .5 Frame  gsave 0 0 0.3 0  setcmykcolor
 1. .setopacityalpha  fill  grestore gsave 0.4 SLW 0 0 0.3 0  setcmykcolor
 1. .setopacityalpha   0  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial -199 4975
a

 -199 4975 a -199 4975 a


 pgfo

 save

 0 setgray

 0.3985 pgfw

 save

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 save

 [1.0 0.0 0.0 1.0 5.66927 -12.82932 ] concat

 pgfs



 0 setgray
 -31 4975 a Fo(x)-199 4975 y


 pgfr

 restore

 restore

 save

 save

 [1.0 0.0 0.0 1.0 5.66927 -36.56618 ] concat

 pgfs



 0 setgray

-91 4975 a Fd(signe)-135 5074 y(de)26 b Fb(x)17 b Fa(\241)11
b Fd(2)-199 4975 y


 pgfr

 restore

 restore

 save

 save

 [1.0 0.0 0.0 1.0 5.66927 -73.57404 ] concat

 pgfs



 0 setgray
 -142 4975 a Fd(signe)24 b(de)-110
5074 y Fa(\241)q Fb(x)18 b Fa(\241)11 b Fd(3)-199 4975
y


 pgfr

 restore

 restore

 save

 save

 [1.0 0.0 0.0 1.0 5.66927 -109.56195 ] concat

 pgfs



 0 setgray
 -145 4975 a Fd(signe)24 b(du)-127 5074 y(produit)-199
4975 y


 pgfr

 restore

 restore

 save

 0.3985 pgfw

 56.69362 0.0 moveto

 56.69362 -131.81291 lineto

 pgfstr

 restore

 save

 0.3985 pgfw

 0.0 -21.2601 moveto

 212.60106 -21.2601 lineto

 pgfstr

 restore

 save

 0.3985 pgfw

 0.0 -58.11102 moveto

 212.60106 -58.11102 lineto

 pgfstr

 restore

 save

 0.3985 pgfw

 0.0 -94.96198 moveto

 212.60106 -94.96198 lineto

 pgfstr

 restore

 save

 save

 [1.0 0.0 0.0 1.0 62.89185 -12.66245 ] concat

 pgfs



 0 setgray
 -199 4975 a Fj(\2411)-199 4975 y


 pgfr

 restore

 restore

 save

 save

 [1.0 0.0 0.0 1.0 107.65869 -13.67366 ] concat

 pgfs



 0 setgray
 -199 4975 a Fj(\241)p
Fm(3)-199 4975 y


 pgfr

 restore

 restore

 save

 save

 [1.0 0.0 0.0 1.0 153.4766 -13.69856 ] concat

 pgfs



 0 setgray
 -199 4975 a Fm(2)-199 4975 y


 pgfr

 restore

 restore

 save

 save

 [1.0 0.0 0.0 1.0 190.45253 -13.18549 ] concat

 pgfs



 0 setgray
 -199 4975
a Fj(\3051)-199 4975 y


 pgfr

 restore

 restore

 save

 restore

 save

 restore

 save

 save

 [1.0 0.0 0.0 1.0 88.82944 -41.11023 ] concat

 pgfs



 0 setgray
 -199 4975 a Fj(\241)-199 4975
y


 pgfr

 restore

 restore

 save

 restore

 save

 0.3985 pgfw

 [ 0.3985 1.99255 ] 0.0 setdash

 /pgfsc{0 setgray}def

 113.38724 -21.2601 moveto

 113.38724 -58.11102 lineto

 gsave pgfsc pgfstr grestore newpath

 restore

 save

 restore

 save

 save

 [1.0 0.0 0.0 1.0 131.34966 -41.11023 ] concat

 pgfs



 0 setgray
 -199 4975 a Fj(\241)-199 4975 y


 pgfr

 restore

 restore

 save

 restore

 save

 0.3985 pgfw

 [ 0.3985 1.99255 ] 0.0 setdash

 /pgfsc{0 setgray}def

 155.90744 -21.2601 moveto

 155.90744 -58.11102 lineto

 gsave pgfsc pgfstr grestore newpath

 restore

 save

 save

 [1.0 0.0 0.0 1.0 153.47653 -42.72919 ] concat

 pgfs



 0 setgray
 -199 4975 a Fm(0)-199
4975 y


 pgfr

 restore

 restore

 save

 restore

 save

 save

 [1.0 0.0 0.0 1.0 173.86987 -42.24101 ] concat

 pgfs



 0 setgray
 -199 4975 a Fj(\305)-199 4975 y


 pgfr

 restore

 restore

 save

 restore

 save

 restore

 save

 save

 [1.0 0.0 0.0 1.0 88.82944 -79.09195 ] concat

 pgfs



 0 setgray
 -199 4975 a Fj(\305)-199
4975 y


 pgfr

 restore

 restore

 save

 restore

 save

 0.3985 pgfw

 [ 0.3985 1.99255 ] 0.0 setdash

 /pgfsc{0 setgray}def

 113.38724 -58.11102 moveto

 113.38724 -94.96198 lineto

 gsave pgfsc pgfstr grestore newpath

 restore

 save

 save

 [1.0 0.0 0.0 1.0 110.95633 -79.58011 ] concat

 pgfs



 0 setgray
 -199 4975 a Fm(0)-199 4975 y


 pgfr

 restore

 restore

 save

 restore

 save

 save

 [1.0 0.0 0.0 1.0 131.34966 -77.96117 ] concat

 pgfs



 0 setgray
 -199 4975 a Fj(\241)-199
4975 y


 pgfr

 restore

 restore

 save

 restore

 save

 0.3985 pgfw

 [ 0.3985 1.99255 ] 0.0 setdash

 /pgfsc{0 setgray}def

 155.90744 -58.11102 moveto

 155.90744 -94.96198 lineto

 gsave pgfsc pgfstr grestore newpath

 restore

 save

 restore

 save

 save

 [1.0 0.0 0.0 1.0 173.86987 -77.96117 ] concat

 pgfs



 0 setgray
 -199 4975 a Fj(\241)-199 4975 y


 pgfr

 restore

 restore

 save

 restore

 save

 restore

 save

 save

 [1.0 0.0 0.0 1.0 88.82944 -114.81212 ] concat

 pgfs



 0 setgray
 -199 4975 a Fj(\241)-199
4975 y


 pgfr

 restore

 restore

 save

 restore

 save

 0.3985 pgfw

 [ 0.3985 1.99255 ] 0.0 setdash

 /pgfsc{0 setgray}def

 113.38724 -94.96198 moveto

 113.38724 -131.81291 lineto

 gsave pgfsc pgfstr grestore newpath

 restore

 save

 save

 [1.0 0.0 0.0 1.0 110.95633 -116.43106 ] concat

 pgfs



 0 setgray
 -199 4975 a Fm(0)-199 4975 y


 pgfr

 restore

 restore

 save

 restore

 save

 save

 [1.0 0.0 0.0 1.0 131.34966 -115.9429 ] concat

 pgfs



 0 setgray
 -199 4975 a Fj(\305)-199
4975 y


 pgfr

 restore

 restore

 save

 restore

 save

 0.3985 pgfw

 [ 0.3985 1.99255 ] 0.0 setdash

 /pgfsc{0 setgray}def

 155.90744 -94.96198 moveto

 155.90744 -131.81291 lineto

 gsave pgfsc pgfstr grestore newpath

 restore

 save

 save

 [1.0 0.0 0.0 1.0 153.47653 -116.43106 ] concat

 pgfs



 0 setgray
 -199 4975 a Fm(0)-199 4975 y


 pgfr

 restore

 restore

 save

 restore

 save

 save

 [1.0 0.0 0.0 1.0 173.86987 -114.81212 ] concat

 pgfs



 0 setgray
 -199 4975 a Fj(\241)-199
4975 y


 pgfr

 restore

 restore

 restore

 newpath

 restore

 pgfc


 0 TeXcolorgray -246 6172 4252 5 v -246 6271 a
Fm(2014-2015)e(-)17 b(2nde)1174 b(F)o(iche)19 b(2)e(:)22
b(I)o(n\351quations)1726 b(1)p 0 TeXcolorgray eop end
%%Page: 2 2
TeXDict begin 2 1 bop 0 TeXcolorgray 0 0 a
SDict begin /product where{pop product(Distiller)search{pop pop pop
version(.)search{exch pop exch pop(3011)eq{gsave newpath 0 0 moveto
closepath clip/Courier findfont 10 scalefont setfont 72 72 moveto(.)show
grestore}if}{pop}ifelse}{pop}ifelse}if end
 0 0 a 0 TeXcolorgray
-254 -504 a
SDict begin H.S end
 -254 -504 a -254 -504 a
SDict begin H.R end
 -254 -504 a -254
-504 a
SDict begin [/View [/XYZ H.V]/Dest (page.2) cvn /DEST pdfmark end
 -254 -504 a 0 TeXcolorgray 0 TeXcolorgray 0 TeXcolorgray
-217 397 a @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.4 SLW 0 0 0.3 0  setcmykcolor  0. true 3.4
neg 72.18774 neg 519.6896 77.36774 .5 Frame  gsave 0 0 0.3 0  setcmykcolor
 1. .setopacityalpha  fill  grestore gsave 0.4 SLW 0 0 0.3 0  setcmykcolor
 1. .setopacityalpha   0  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial -200
-160 a Fo(Exemple)16 b(:)-199 -132 y

 -199 -132 a -199
-132 a


 pgfo

 save

 0 setgray

 0.3985 pgfw

 save

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 restore

 save

 save

 [1.0 0.0 0.0 1.0 5.66927 -12.82932 ] concat

 pgfs



 0 setgray
 -31 -132 a Fo(x)-199 -132 y


 pgfr

 restore

 restore

 save

 save

 [1.0 0.0 0.0 1.0 5.66927 -36.56618 ] concat

 pgfs



 0 setgray
 -91 -132 a Fd(signe)-135
-33 y(de)26 b Fb(x)17 b Fa(\241)11 b Fd(2)-199 -132 y


 pgfr

 restore

 restore

 save

 save

 [1.0 0.0 0.0 1.0 5.66927 -73.57404 ] concat

 pgfs



 0 setgray

-142 -132 a Fd(signe)24 b(de)-110 -33 y Fa(\241)q Fb(x)18
b Fa(\241)11 b Fd(3)-199 -132 y


 pgfr

 restore

 restore

 save

 save

 [1.0 0.0 0.0 1.0 5.66927 -109.56195 ] concat

 pgfs



 0 setgray
 -145 -132 a Fd(signe)24
b(du)-127 -33 y(produit)-199 -132 y


 pgfr

 restore

 restore

 save

 0.3985 pgfw

 56.69362 0.0 moveto

 56.69362 -131.81291 lineto

 pgfstr

 restore

 save

 0.3985 pgfw

 0.0 -21.2601 moveto

 212.60106 -21.2601 lineto

 pgfstr

 restore

 save

 0.3985 pgfw

 0.0 -58.11102 moveto

 212.60106 -58.11102 lineto

 pgfstr

 restore

 save

 0.3985 pgfw

 0.0 -94.96198 moveto

 212.60106 -94.96198 lineto

 pgfstr

 restore

 save

 save

 [1.0 0.0 0.0 1.0 62.89185 -12.66245 ] concat

 pgfs



 0 setgray
 -199 -132 a Fj(\2411)-199
-132 y


 pgfr

 restore

 restore

 save

 save

 [1.0 0.0 0.0 1.0 107.65869 -13.67366 ] concat

 pgfs



 0 setgray
 -199 -132 a Fj(\241)p Fm(3)-199 -132 y


 pgfr

 restore

 restore

 save

 save

 [1.0 0.0 0.0 1.0 153.4766 -13.69856 ] concat

 pgfs



 0 setgray
 -199 -132
a Fm(2)-199 -132 y


 pgfr

 restore

 restore

 save

 save

 [1.0 0.0 0.0 1.0 190.45253 -13.18549 ] concat

 pgfs



 0 setgray
 -199 -132 a Fj(\3051)-199 -132 y


 pgfr

 restore

 restore

 save

 restore

 save

 restore

 save

 save

 [1.0 0.0 0.0 1.0 88.82944 -41.11023 ] concat

 pgfs



 0 setgray
 -199
-132 a Fj(\241)-199 -132 y


 pgfr

 restore

 restore

 save

 restore

 save

 0.3985 pgfw

 [ 0.3985 1.99255 ] 0.0 setdash

 /pgfsc{0 setgray}def

 113.38724 -21.2601 moveto

 113.38724 -58.11102 lineto

 gsave pgfsc pgfstr grestore newpath

 restore

 save

 restore

 save

 save

 [1.0 0.0 0.0 1.0 131.34966 -41.11023 ] concat

 pgfs



 0 setgray
 -199 -132 a Fj(\241)-199 -132
y


 pgfr

 restore

 restore

 save

 restore

 save

 0.3985 pgfw

 [ 0.3985 1.99255 ] 0.0 setdash

 /pgfsc{0 setgray}def

 155.90744 -21.2601 moveto

 155.90744 -58.11102 lineto

 gsave pgfsc pgfstr grestore newpath

 restore

 save

 save

 [1.0 0.0 0.0 1.0 153.47653 -42.72919 ] concat

 pgfs



 0 setgray
 -199 -132 a Fm(0)-199 -132 y


 pgfr

 restore

 restore

 save

 restore

 save

 save

 [1.0 0.0 0.0 1.0 173.86987 -42.24101 ] concat

 pgfs



 0 setgray
 -199 -132 a Fj(\305)-199
-132 y


 pgfr

 restore

 restore

 save

 restore

 save

 restore

 save

 save

 [1.0 0.0 0.0 1.0 88.82944 -79.09195 ] concat

 pgfs



 0 setgray
 -199 -132 a Fj(\305)-199 -132 y


 pgfr

 restore

 restore

 save

 restore

 save

 0.3985 pgfw

 [ 0.3985 1.99255 ] 0.0 setdash

 /pgfsc{0 setgray}def

 113.38724 -58.11102 moveto

 113.38724 -94.96198 lineto

 gsave pgfsc pgfstr grestore newpath

 restore

 save

 save

 [1.0 0.0 0.0 1.0 110.95633 -79.58011 ] concat

 pgfs



 0 setgray
 -199 -132 a Fm(0)-199
-132 y


 pgfr

 restore

 restore

 save

 restore

 save

 save

 [1.0 0.0 0.0 1.0 131.34966 -77.96117 ] concat

 pgfs



 0 setgray
 -199 -132 a Fj(\241)-199 -132 y


 pgfr

 restore

 restore

 save

 restore

 save

 0.3985 pgfw

 [ 0.3985 1.99255 ] 0.0 setdash

 /pgfsc{0 setgray}def

 155.90744 -58.11102 moveto

 155.90744 -94.96198 lineto

 gsave pgfsc pgfstr grestore newpath

 restore

 save

 restore

 save

 save

 [1.0 0.0 0.0 1.0 173.86987 -77.96117 ] concat

 pgfs



 0 setgray
 -199 -132 a Fj(\241)-199
-132 y


 pgfr

 restore

 restore

 save

 restore

 save

 restore

 save

 save

 [1.0 0.0 0.0 1.0 88.82944 -114.81212 ] concat

 pgfs



 0 setgray
 -199 -132 a Fj(\241)-199 -132 y


 pgfr

 restore

 restore

 save

 restore

 save

 0.3985 pgfw

 [ 0.3985 1.99255 ] 0.0 setdash

 /pgfsc{0 setgray}def

 113.38724 -94.96198 moveto

 113.38724 -131.81291 lineto

 gsave pgfsc pgfstr grestore newpath

 restore

 save

 save

 [1.0 0.0 0.0 1.0 110.95633 -116.43106 ] concat

 pgfs



 0 setgray
 -199 -132 a Fm(0)-199
-132 y


 pgfr

 restore

 restore

 save

 restore

 save

 save

 [1.0 0.0 0.0 1.0 131.34966 -115.9429 ] concat

 pgfs



 0 setgray
 -199 -132 a Fj(\305)-199 -132 y


 pgfr

 restore

 restore

 save

 restore

 save

 0.3985 pgfw

 [ 0.3985 1.99255 ] 0.0 setdash

 /pgfsc{0 setgray}def

 155.90744 -94.96198 moveto

 155.90744 -131.81291 lineto

 gsave pgfsc pgfstr grestore newpath

 restore

 save

 save

 [1.0 0.0 0.0 1.0 153.47653 -116.43106 ] concat

 pgfs



 0 setgray
 -199 -132 a Fm(0)-199
-132 y


 pgfr

 restore

 restore

 save

 restore

 save

 save

 [1.0 0.0 0.0 1.0 173.86987 -114.81212 ] concat

 pgfs



 0 setgray
 -199 -132 a Fj(\241)-199 -132 y


 pgfr

 restore

 restore

 restore

 newpath

 restore

 pgfc


 -217 1291 a @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
/ArrowInside { } def  0.4 SLW 0 0 0.3 0  setcmykcolor  0.05 true 3.4
neg 29.37999 neg 519.6896 34.55998 .5 Frame  gsave 0 0 0.3 0  setcmykcolor
 1. .setopacityalpha  fill  grestore gsave 0.4 SLW 0 0 0.3 0  setcmykcolor
 1. .setopacityalpha   0  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial -200 1090 a Fo(Exemple)16 b(:)-200
1189 y Fm(T)-8 b(est)23 b(arrondi)e(en)i(fct)f(de)g(la)h(longueur)g(du)
f(texte)o(.T)-8 b(est)24 b(arrondi)d(en)i(fct)f(de)g(la)h(longueur)g
(du)f(texte)o(.T)-8 b(est)24 b(arrondi)d(en)i(fct)f(de)g(la)h(longueur)
g(du)-200 1289 y(texte)o(.T)-8 b(est)21 b(arrondi)d(en)h(fct)g(de)g(la)
g(longueur)g(du)g(texte)o(.T)-8 b(est)21 b(arrondi)d(en)h(fct)h(de)e
(la)h(longueur)h(du)f(texte)o(.T)-8 b(est)21 b(arrondi)d(en)h(fct)g(de)
g(la)g(longueur)-200 1388 y(du)14 b(texte)o(.T)-8 b(est)16
b(arrondi)d(en)h(fct)h(de)f(la)g(longueur)h(du)f(texte)o(.T)-8
b(est)16 b(arrondi)d(en)h(fct)h(de)f(la)g(longueur)h(du)f(texte)o(.T)-8
b(est)16 b(arrondi)d(en)h(fct)h(de)f(la)g(longueur)-200
1488 y(du)j(texte)o(.T)-8 b(est)20 b(arrondi)c(en)i(fct)f(de)g(la)h
(longueur)g(du)f(texte)o(.)p 0 TeXcolorgray -246 6172
4252 5 v -246 6271 a(2014-2015)22 b(-)17 b(2nde)1174
b(F)o(iche)19 b(2)e(:)22 b(I)o(n\351quations)1726 b(2)p
0 TeXcolorgray eop end
%%Trailer

userdict /end-hook known{end-hook}if
%%EOF
